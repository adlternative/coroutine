



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="C++ 20 Coroutines in Action.">
      
      
        <link rel="canonical" href="https://luncliff.github.io/coroutine/articles/exploring-msvc-coroutine/">
      
      
        <meta name="author" content="Park DongHa">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-4.6.3">
    
    
      
        <title>Exploring MSVC Coroutine - luncliff/coroutine</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.adb8469c.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="">
      
    
    
      <script src="../../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="white" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#exploring-msvc-coroutine" tabindex="0" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://luncliff.github.io/coroutine" title="luncliff/coroutine" aria-label="luncliff/coroutine" class="md-header-nav__button md-logo">
          
            <i class="md-icon">call_split</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              luncliff/coroutine
            </span>
            <span class="md-header-nav__topic">
              
                Exploring MSVC Coroutine
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="http://github.com/luncliff/coroutine/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    luncliff/coroutine
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://luncliff.github.io/coroutine" title="luncliff/coroutine" class="md-nav__button md-logo">
      
        <i class="md-icon">call_split</i>
      
    </a>
    luncliff/coroutine
  </label>
  
    <div class="md-nav__source">
      


  

<a href="http://github.com/luncliff/coroutine/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    luncliff/coroutine
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      PPT
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        PPT
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../ppt/Exploring-the-Cpp-Coroutine/" title="C++ Korea 5th Seminar" class="md-nav__link">
      C++ Korea 5th Seminar
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      Articles
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Articles
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Exploring MSVC Coroutine
      </label>
    
    <a href="./" title="Exploring MSVC Coroutine" class="md-nav__link md-nav__link--active">
      Exploring MSVC Coroutine
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#reference" class="md-nav__link">
    Reference
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#proposal" class="md-nav__link">
    Proposal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#visual-c-team-blog" class="md-nav__link">
    Visual C++ Team Blog
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#video" class="md-nav__link">
    Video
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#github" class="md-nav__link">
    GitHub
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#caution" class="md-nav__link">
    Caution
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#definition" class="md-nav__link">
    Definition
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#old-fashion-the-machine-level" class="md-nav__link">
    Old Fashion : The Machine Level
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concept-relation" class="md-nav__link">
    Concept : Relation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#subroutine-caller-callee" class="md-nav__link">
    Subroutine : Caller-Callee
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coroutine-activator-activator" class="md-nav__link">
    Coroutine : Activator-Activator
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#difference" class="md-nav__link">
    Difference?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example" class="md-nav__link">
    Example
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#motivation-programming-model" class="md-nav__link">
    Motivation : Programming Model
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#its-a-stack" class="md-nav__link">
    It's a stack!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blocking" class="md-nav__link">
    Blocking
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#persistence" class="md-nav__link">
    Persistence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#approach" class="md-nav__link">
    Approach
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stackful-stackless" class="md-nav__link">
    Stackful? Stackless!
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stackful-or-segmented-stack" class="md-nav__link">
    Stackful or Segmented Stack
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stackless-function-frame" class="md-nav__link">
    Stackless - Function Frame
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-c-coroutine-resumable-function" class="md-nav__link">
    The C++ Coroutine : Resumable Function
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#invoke" class="md-nav__link">
    Invoke
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#finalize" class="md-nav__link">
    Finalize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#suspend" class="md-nav__link">
    Suspend
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#activate" class="md-nav__link">
    Activate
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#code" class="md-nav__link">
    Code
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#promise-compilers-requirement" class="md-nav__link">
    Promise : Compiler's Requirement
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#resumable-promise-requirement" class="md-nav__link">
    Resumable Promise Requirement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generator" class="md-nav__link">
    Generator
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#concept" class="md-nav__link">
    Concept
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_1" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#detail" class="md-nav__link">
    Detail
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compilers-view" class="md-nav__link">
    Compiler's View
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resumable-function" class="md-nav__link">
    Resumable Function
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#concept_1" class="md-nav__link">
    Concept
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resumable-frame" class="md-nav__link">
    Resumable Frame
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coroutine-traits" class="md-nav__link">
    Coroutine Traits
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#section-summary" class="md-nav__link">
    Section Summary
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-awaitable-concept" class="md-nav__link">
    The Awaitable Concept
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example_2" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#awaitable-interface" class="md-nav__link">
    Awaitable Interface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compilers-view_1" class="md-nav__link">
    Compiler's View
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#co_await-tricks" class="md-nav__link">
    co_await Tricks
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#async-generator" class="md-nav__link">
    Async Generator
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#concept_2" class="md-nav__link">
    Concept
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_3" class="md-nav__link">
    Example
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    Conclusion
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../awaitable-event/" title="Awaitable event using the coroutine, epoll and eventfd" class="md-nav__link">
      Awaitable event using the coroutine, epoll and eventfd
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../designing-the-channel/" title="Designing the coroutine channel" class="md-nav__link">
      Designing the coroutine channel
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../combining-coroutines-and-pthread_create/" title="Combining C++ coroutines and `pthread_create`" class="md-nav__link">
      Combining C++ coroutines and `pthread_create`
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../russian-roulette/" title="Russian Roulette and C++ Coroutines" class="md-nav__link">
      Russian Roulette and C++ Coroutines
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Code
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Code
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../modules/" title="Groups" class="md-nav__link">
      Groups
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../namespaces/" title="Namespaces" class="md-nav__link">
      Namespaces
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../functions/" title="Functions" class="md-nav__link">
      Functions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../classes/" title="Classes" class="md-nav__link">
      Classes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../files/" title="Files" class="md-nav__link">
      Files
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#reference" class="md-nav__link">
    Reference
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#proposal" class="md-nav__link">
    Proposal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#visual-c-team-blog" class="md-nav__link">
    Visual C++ Team Blog
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#video" class="md-nav__link">
    Video
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#github" class="md-nav__link">
    GitHub
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#caution" class="md-nav__link">
    Caution
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#definition" class="md-nav__link">
    Definition
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#old-fashion-the-machine-level" class="md-nav__link">
    Old Fashion : The Machine Level
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concept-relation" class="md-nav__link">
    Concept : Relation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#subroutine-caller-callee" class="md-nav__link">
    Subroutine : Caller-Callee
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coroutine-activator-activator" class="md-nav__link">
    Coroutine : Activator-Activator
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#difference" class="md-nav__link">
    Difference?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example" class="md-nav__link">
    Example
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#motivation-programming-model" class="md-nav__link">
    Motivation : Programming Model
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#its-a-stack" class="md-nav__link">
    It's a stack!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blocking" class="md-nav__link">
    Blocking
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#persistence" class="md-nav__link">
    Persistence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#approach" class="md-nav__link">
    Approach
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stackful-stackless" class="md-nav__link">
    Stackful? Stackless!
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stackful-or-segmented-stack" class="md-nav__link">
    Stackful or Segmented Stack
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stackless-function-frame" class="md-nav__link">
    Stackless - Function Frame
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-c-coroutine-resumable-function" class="md-nav__link">
    The C++ Coroutine : Resumable Function
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#invoke" class="md-nav__link">
    Invoke
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#finalize" class="md-nav__link">
    Finalize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#suspend" class="md-nav__link">
    Suspend
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#activate" class="md-nav__link">
    Activate
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#code" class="md-nav__link">
    Code
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#promise-compilers-requirement" class="md-nav__link">
    Promise : Compiler's Requirement
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#resumable-promise-requirement" class="md-nav__link">
    Resumable Promise Requirement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generator" class="md-nav__link">
    Generator
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#concept" class="md-nav__link">
    Concept
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_1" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#detail" class="md-nav__link">
    Detail
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compilers-view" class="md-nav__link">
    Compiler's View
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resumable-function" class="md-nav__link">
    Resumable Function
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#concept_1" class="md-nav__link">
    Concept
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resumable-frame" class="md-nav__link">
    Resumable Frame
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coroutine-traits" class="md-nav__link">
    Coroutine Traits
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#section-summary" class="md-nav__link">
    Section Summary
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-awaitable-concept" class="md-nav__link">
    The Awaitable Concept
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example_2" class="md-nav__link">
    Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#awaitable-interface" class="md-nav__link">
    Awaitable Interface
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compilers-view_1" class="md-nav__link">
    Compiler's View
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#co_await-tricks" class="md-nav__link">
    co_await Tricks
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#async-generator" class="md-nav__link">
    Async Generator
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#concept_2" class="md-nav__link">
    Concept
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example_3" class="md-nav__link">
    Example
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    Conclusion
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="http://github.com/luncliff/coroutine/edit/master/docs/articles/exploring-msvc-coroutine.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="exploring-msvc-coroutine">Exploring MSVC Coroutine<a class="headerlink" href="#exploring-msvc-coroutine" title="Permanent link">&para;</a></h1>
<blockquote>
<p>Written in 2017/02/17</p>
</blockquote>
<p><a href="./">한국어</a></p>
<h3 id="reference">Reference<a class="headerlink" href="#reference" title="Permanent link">&para;</a></h3>
<h4 id="proposal">Proposal<a class="headerlink" href="#proposal" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="https://isocpp.org/files/papers/N3858.pdf">N3858</a></li>
<li><a href="https://isocpp.org/files/papers/N3977.pdf">N3977</a></li>
<li><a href="https://isocpp.org/files/papers/N4134.pdf">N4134</a></li>
<li><a href="https://isocpp.org/files/papers/N4402.pdf">N4402</a></li>
</ul>
<h4 id="visual-c-team-blog">Visual C++ Team Blog<a class="headerlink" href="#visual-c-team-blog" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="https://blogs.msdn.microsoft.com/vcblog/2015/11/30/coroutines-in-visual-studio-2015-update-1/">Coroutines in Visual Studio 2015– Update 1</a></li>
<li><a href="https://blogs.msdn.microsoft.com/vcblog/2015/04/29/more-about-resumable-functions-in-c/">More about resumable functions in C++</a></li>
</ul>
<h4 id="video">Video<a class="headerlink" href="#video" title="Permanent link">&para;</a></h4>
<ul>
<li>CppCon 2016 : <a href="https://channel9.msdn.com/events/CPP/CppCon-2016/CppCon-2016-Gor-Nishanov-C-Coroutines-Under-the-covers">Gor Nishanov "C++ Coroutines: Under the covers"</a></li>
<li>CppCon 2016 : <a href="https://channel9.msdn.com/events/CPP/CppCon-2016/CppCon-2016-James-McNellis-Introduction-to-C-Coroutines">James McNellis "Introduction to C++ Coroutines"</a></li>
<li>CppCon 2016 : <a href="https://channel9.msdn.com/events/CPP/CppCon-2016/CppCon-2016-Kenny-Kerr--James-McNellis-Putting-Coroutines-to-Work-with-the-Windows-Runtime">Kenny Kerr &amp; James McNellis "Putting Coroutines to Work with the Windows Runtime"</a></li>
<li>CppCon 2016 : <a href="https://www.youtube.com/watch?v=N3CkQu39j5I&amp;t=1257s">John Bandela “Channels - An alternative to callbacks and futures"</a></li>
<li>CppCon 2015 : <a href="https://channel9.msdn.com/events/CPP/CppCon-2015/CPPConD03V008">Gor Nishanov "C++ Coroutines - a negative overhead abstraction"</a></li>
<li>Meeting C++ 2015 : <a href="https://www.youtube.com/watch?v=YYtzQ355_Co&amp;t=2890s">James McNellis "An Introduction to C++ Coroutines"</a></li>
<li>Meeting C++ 2015 : <a href="https://www.youtube.com/watch?v=SbaLI2ZcyY0&amp;t=2180s">Grigory Demchenko "Asynchrony and Coroutines"</a></li>
<li>CppCon 2014 : <a href="https://channel9.msdn.com/events/CPP/C-PP-Con-2014/0006-await-20-Stackless-Resumable-Functions">Gor Nishanov "await 2.0: Stackless Resumable Functions"</a></li>
</ul>
<h4 id="github">GitHub<a class="headerlink" href="#github" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="https://github.com/kirkshoop/await">kirkshoop/<strong>await</strong></a></li>
</ul>
<h3 id="caution">Caution<a class="headerlink" href="#caution" title="Permanent link">&para;</a></h3>
<p>To try this feature, you need 3 things.</p>
<ul>
<li>Visual Studio 2015 Up3 or later.</li>
<li><code>/await</code> Compiler option</li>
<li><code>&lt;experimental/*&gt;</code> header files to include.</li>
</ul>
<p><img alt="Fig: Command line option" src="https://cqldba.bn1304.livefilestore.com/y4mxWo9KNVrGutUuX0-nCTZefQXnqsDaRe8UNOQ89xEjUO2BrVrUuHz0c5cBAiZilYehHoPUZaJDruvP-6h-Q5hmmnSbwyNzTa2XcCNXa3mLaCCiUZxZIn7t3XBhRbvJXIAh2PSqJ2ZVKx_w6ytO_khp85PfSBYluHbSAUdzVW98b-5E-frvtigKcY3FmDqFBO-KfIGMFdBX2G_ibX9hwyB5Q?width=1024&amp;height=730&amp;cropmode=none" /></p>
<h2 id="definition">Definition<a class="headerlink" href="#definition" title="Permanent link">&para;</a></h2>
<p>So, what is coroutine?</p>
<h3 id="old-fashion-the-machine-level">Old Fashion : The Machine Level<a class="headerlink" href="#old-fashion-the-machine-level" title="Permanent link">&para;</a></h3>
<p>For me, the story starts from <strong>The Art of Computer Programming</strong>, written by Donald Knuth.</p>
<p>Basically, the procedure call is <code>goto</code>. But, <code>goto</code> where? As you know, program can be thought as a sequence of states. And program's state, which is defined by programmer, is composition of machine environment and memory. It can be finite, or infinite.</p>
<ul>
<li><em>Program State = Environment X Memory (Cartesian Product)</em></li>
</ul>
<p>Here, instructions are transition between states. And routine is a ordered group of instructions.</p>
<ul>
<li><em>Instruction : Transition between states</em></li>
<li><em>Routine : Ordered group of instructions</em></li>
</ul>
<p>Now, let's go to subroutine &amp; coroutine.</p>
<h3 id="concept-relation">Concept : Relation<a class="headerlink" href="#concept-relation" title="Permanent link">&para;</a></h3>
<p>All programmers have their own mental model for codes. Lets start from the point. Mental model for subroutine and coroutine.</p>
<h4 id="subroutine-caller-callee">Subroutine : Caller-Callee<a class="headerlink" href="#subroutine-caller-callee" title="Permanent link">&para;</a></h4>
<p>Caller expects some states (Pre-condition). And it knows which routine is required.
Callee, with specified (in other words, well-defined) codes, do its work without consideration of its caller. It can be impure with side-effect. But it's about work, not the relation.</p>
<p><img alt="Fig: Relation of Subroutine" src="https://caiska.bn1304.livefilestore.com/y4mpAqgE-2ZtAMBzq_B4eBn8S35AG_sqM-mrzhBzQ-qZsc-8-UqnF-6q5QBBqI0mI_e-hWEhFwBVpu3kSSToMa0qIclnvogKeRTJA-i7eqm9ZvnF2TGgziVlsD8YRj9rZogyizLpBaxaHZ3P_RqwdE2AKu7ThSdJZsGKJk1LQnb3afhPDsBz6ClDhrMRpBS86eSxMD3fva5BM2VJiLfo9PE-g?width=660&amp;height=425&amp;cropmode=none" /></p>
<h4 id="coroutine-activator-activator">Coroutine : Activator-Activator<a class="headerlink" href="#coroutine-activator-activator" title="Permanent link">&para;</a></h4>
<p>Coroutine is cooperative routine. In other worlds, it is aware of the other routines.</p>
<p><img alt="Fig: Relation of Coroutine" src="https://cairka.bn1304.livefilestore.com/y4mJI5CB46xuv-xi1oajDyVT-EwddQKm-1RINOP34GvInKfxXZMS_hMk2lITYLcPhDRSOA3e3LIDx4WU20SJ_0ns1k7cu8rV6j4XAtj690i9x2yj_UEJ85Hq2yw-ylxpztnHQ2eBOGnl3p0XFJ8O06Jn-Klc04LcZHiHqzZ7ONPO4mvSAmLDXvrwUmbAbSDwpXiqssEeSzAEftW7_qlK_VFfQ?width=828&amp;height=374&amp;cropmode=none" /></p>
<p>Notice that both are activated and activating by each other. Coroutine is activated by Invoker and Resuming routine. And by suspending or returning, coroutine activates its peer. In real, these <strong>activations</strong> are equal to jump(<code>goto</code>/<code>jmp</code>) instruction. So some suspension can be considered as invocation. Or there might not be significant difference between suspension and finalization.</p>
<p>If the point is entry(prologue) of routine, it is <strong>invocation</strong>(<code>call</code>).<br />
If the flow goes to the middle of procedure, then it's <strong>activation</strong>(<code>resume</code>).   </p>
<ul>
<li><em>Invocation: Jump to start the routine</em></li>
<li><em>Activation: Jump into a point of the routine</em></li>
</ul>
<p>Like subroutine, coroutines has specification for its pre-condition and post-condition. Therefore it must be designed with consideration of modification on program state.
But after its work, it preserves the state and <code>goto</code> another point. This is <strong>suspension</strong>(<code>yield</code>). Of course, this can be return. In that case, it just finalizes and then <code>return</code> to its caller. (Since they have activation records)</p>
<ul>
<li><em>Suspension: Jump to another point without finalization</em></li>
<li><em>Finalization: Destroy(cleanup) all function resources</em></li>
</ul>
<h4 id="difference">Difference?<a class="headerlink" href="#difference" title="Permanent link">&para;</a></h4>
<p>So, the major difference of coroutine/subroutine is that coroutine supports more operations. This is why Knuth summarized in his book.</p>
<blockquote>
<p>"Subroutines are special cases of ... coroutines"  - Donald Knuth</p>
</blockquote>
<p>Let's see that in table form.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th align="center">Subroutine</th>
<th align="center">Coroutine</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Invoke</td>
<td align="center">o</td>
<td align="center">o</td>
<td>General procedure start</td>
</tr>
<tr>
<td>Activate</td>
<td align="center">x</td>
<td align="center">o</td>
<td><code>goto</code> a specific point of procedure</td>
</tr>
<tr>
<td>Suspend</td>
<td align="center">x</td>
<td align="center">o</td>
<td>Yield current control flow</td>
</tr>
<tr>
<td>Finalize</td>
<td align="center">o</td>
<td align="center">o</td>
<td>Cleanup and <code>return</code></td>
</tr>
</tbody>
</table>
<p>Clearly, subroutine is limited but easy and simple in relationship. However, coroutine have more operations, but might be complex because it suspension and activation should be managed.</p>
<ul>
<li><em>Routine: Group of instructions that modify the program state to another with defined statements</em></li>
<li><em>Subroutine: Routine that supports 2 operations</em><ol>
<li>Invoke</li>
<li>Finalize</li>
</ol>
</li>
<li><em>Coroutine: Routine that supports 4 operations</em><ol>
<li>Invoke</li>
<li>Activate</li>
<li>Suspend</li>
<li>Finalize</li>
</ol>
</li>
</ul>
<h4 id="example">Example<a class="headerlink" href="#example" title="Permanent link">&para;</a></h4>
<p>Knuth wrote how this is expressed in code. You don't have to understand all MIX instructions. Unlike theseday's subroutine, operations are usually <code>JMP</code> without abstraction.</p>
<p>What I want to explain is that there is a gap between High-level and Assembly languages.
The key point is <strong>coroutine has multiple points for entry and exit</strong>. Also, they have some implicit states.</p>
<div class="codehilite"><pre><span></span><code>// MIX example, modified
// The Art of Computer Programming 1.4.2.
// For detail, read the book. :D

// Subroutine for character input
READER  EQU     16
INPUT   ORIG    *+16
NETCHAR STJ     9F
        JXNZ    3F          // ---&gt; (3H)
1H      J6N     2F          // ---&gt; (2H)
        IN      INPUT(READER)
        JBUS    *(READER)
        ENN6    16
2H      LDX     INPUT+16,6  // &lt;--- (1H) J6N 2F
        INC6    1
3H      ENTA    0           // &lt;--- JXNZ 3F
        SLAX    1
9H      JANZ    *
        JMP     NEXTCHAR+1

// First coroutine
2H      INCA    30          // &lt;--- JGE 2B
        JMP     OUT         // ---&gt; OUT1
IN1     JMP     NEXTCHAR    // ---&gt; NETCHAR
                            //  &lt;--
        DECA    30
        JAN     2B          // ---&gt; (2H)
        CMPA    =10=
        JGE     2B          // ---&gt; (2H)
        STA     *,1(0:2)
        ENT5    *
        JMP     NEXTCHAR    // ---&gt; NETCHAR
                            //  &lt;--
        JMP     OUT         // ---&gt; OUT1
                            // &lt;--- J5NN *-2
        DEC5    1
        J5NN    *-2         // ---&gt; JMP OUT
        JMP     IN1         // ---&gt; (IN1)

// Second coroutine
        ALF
OUTPUT  ORIG    *+16
PUNCH   EQU     17
OUT1    ENT4    -16         // &lt;--- JMP  OUT
        MOVE    -1,1(16)
1H      JMP     IN          // ---&gt; IN1
        STA     OUTPUT+16,4(1:1)
        CMPA    PERIOD
        JE      9F          // ---&gt; (9H)
        JMP     IN          // ---&gt; IN1
        STA     OUTPUT+16,4(2:2)
        CMPA    PERIOD
        JE      9F          // ---&gt; (9H)
        JMP     IN          // ---&gt; IN1
        STA     OUTPUT+16,4(2:2)
        CMPA    PERIOD
        JE      9F          // ---&gt; (9H)
        INC4    1
        J4N     1B          // ---&gt; (1H)
9H      OUT     OUTPUT(PUNCH)
        JBUS    *(PUNCH)
        JNE     OUT1        // ---&gt; OUT1
        HLT
PERIOD  ALF     .
</code></pre></div>


<h2 id="motivation-programming-model">Motivation : Programming Model<a class="headerlink" href="#motivation-programming-model" title="Permanent link">&para;</a></h2>
<h3 id="its-a-stack">It's a stack!<a class="headerlink" href="#its-a-stack" title="Permanent link">&para;</a></h3>
<blockquote>
<p>"It's A Trap!" - Admiral Ackbar</p>
</blockquote>
<p>These days, we are familiar with high-level languages with runtime stack. It's fancy, well-defined, and automated.
Think of structured, stack-ful program's model. <strong>In the model, the program is basically a mathematical expression tree</strong> that flows in depth-first order. For instance, <code>main</code> function finished at some time point and then it returns a value. Like figure, functions in this model embeds a sequence of statements when it is written.</p>
<p><img alt="Fig: Expression tree and Runtime stack" src="https://cgivka.bn1304.livefilestore.com/y4mgGPMais5Nox_bo2a89cnv97CkD-aEUbF-vczXI3Z2ZCnwcFq4okkX1OZwAnymFxJqYun9_D7T1E8OTGI5CCsg49c3dnoUL6orCbrfGIhIcWBlw4Ni9mk3YHi4wvIjp4vePNyxVnNG56A7Y44GrVImH1qZgNBRt-kbNoPn3hOnikh2JWgpxkaBmpXjX3dWwah-dbQAOuy6otLqa62emMDOA?width=1024&amp;height=681&amp;cropmode=none" /></p>
<p>To reach the statement B, we have to finish the traversal for statement A. Then, the program state is affected by statement A. Memory locations will containing result values. Environments like registers will be set as defined.</p>
<h3 id="blocking">Blocking<a class="headerlink" href="#blocking" title="Permanent link">&para;</a></h3>
<p>But the dependency became a problem.</p>
<p>Remind that tree model follows mathematics. If we have all values in the expression, the calculation can be processed without blocking. Since we don't have infinite resource, we can't prepare all values when the flow starts.</p>
<p>So, we need some In/Out operations. which is extremely slow. Waiting its result blocks our control flow.</p>
<p><img alt="Fig: Expression tree blocks" src="https://cwitka.bn1304.livefilestore.com/y4mU5R4khMBvmHhDnCCaAaX2FsvwsiDoJPtzrxGTXiYI8S9C-eKPFYSp8A7joRShjatPM9ymqZ4jQGnO7KHyO_hbbEjvO0sWFsPYtn_TcMFVF2DcS-mkjI-qedbz4ddNzEI0KShV9ZGm2DyBQF3uxkXrTH0iLk8nUMbcR_l0ZHD6vqCwkR_cJn3gRDmDPkziNNw6jmZ6QuEJhxKvVBDw9vzDw?width=1024&amp;height=693&amp;cropmode=none" /></p>
<p>We don't want to stop our program. We want responsiveness. That's why we started to use non-blocking operations and to apply some asynchronous programming models. We generalized the program tree to a graph form. Which is another notation for state machine.</p>
<p>Now, <strong>the program is graph of states</strong>. And our processors traverse over it.</p>
<p><img alt="Fig: Graph of states" src="https://cgivka.bn1304.livefilestore.com/y4mgGPMais5Nox_bo2a89cnv97CkD-aEUbF-vczXI3Z2ZCnwcFq4okkX1OZwAnymFxJqYun9_D7T1E8OTGI5CCsg49c3dnoUL6orCbrfGIhIcWBlw4Ni9mk3YHi4wvIjp4vePNyxVnNG56A7Y44GrVImH1qZgNBRt-kbNoPn3hOnikh2JWgpxkaBmpXjX3dWwah-dbQAOuy6otLqa62emMDOA?width=1024&amp;height=681&amp;cropmode=none" /></p>
<blockquote>
<p>Processor can be OS Process, OS Thread, or some language supported abstraction such as Goroutine and Erlang process.
But, Let me skip them, we are thinking about coroutine now.</p>
</blockquote>
<h3 id="persistence">Persistence<a class="headerlink" href="#persistence" title="Permanent link">&para;</a></h3>
<p>The point is, we have to deliver some <strong>context</strong> between vertices of the graph.
But subroutine can't do this. Because it always destroyes(finalizes) itself.</p>
<p>Subroutine is lack of persistence. It returns to caller. That's how runtime stack works. But it disabled us to pass contexts between states. Think of <strong>callback hell</strong> to enable that context forwarding.</p>
<blockquote>
<p>"James. This code has a bug. Can you fix it?" - Gor Nishanov, CppCon2015</p>
</blockquote>
<div class="codehilite"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">tcp_reader</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">total</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">reader_state</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">4096</span><span class="o">&gt;</span> <span class="n">_buffer</span><span class="p">;</span>
        <span class="kt">int64_t</span>                <span class="n">_total</span><span class="p">;</span>
        <span class="n">tcp</span><span class="o">::</span><span class="n">connection</span>        <span class="n">_connection</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">reader_state</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">total</span><span class="p">)</span> <span class="o">:</span>
            <span class="n">_total</span><span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="n">state</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">reader_state</span><span class="o">&gt;</span><span class="p">(</span><span class="n">total</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">tcp</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">1337</span><span class="p">).</span><span class="n">then</span><span class="p">(</span>
        <span class="p">[</span><span class="n">state</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">::</span><span class="n">connection</span><span class="o">&gt;</span> <span class="n">the_connection</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">the_connection</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
            <span class="k">return</span> <span class="nf">do_while</span><span class="p">([</span><span class="n">state</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_total</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_ready_future</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_buffer</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
                                        <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_buffer</span><span class="p">)).</span><span class="n">then</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">state</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">bytes_read_future</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kt">int64_t</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">bytes_read_future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">bytes_read</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_ready_future</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
                        <span class="p">}</span>
                        <span class="n">state</span><span class="o">-&gt;</span><span class="n">_total</span> <span class="o">-=</span> <span class="n">bytes_read</span><span class="p">;</span>
                        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_ready_future</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
                    <span class="p">});</span>
           <span class="p">});</span>
        <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>


<h2 id="approach">Approach<a class="headerlink" href="#approach" title="Permanent link">&para;</a></h2>
<p>We need some persistent function. Reminding coroutine suspend/yield its control without finalization, the answer is crystal clear. Coroutine can take the role. But how can we migrate that assembly concept into our stack world?</p>
<p>Let's change the question.</p>
<ol>
<li>What should be persistent?: <strong>Context</strong></li>
<li>What is context?: <strong>The routine's state</strong></li>
<li>What makes the state?: <strong>Environment &amp; Memory</strong></li>
<li>Where are they?: <strong>Function Frame</strong></li>
</ol>
<p>Henceforce, our migration starts from <strong>how to make those frames persistent</strong>. If you can't get what it is, visit <a href="http://duartes.org/gustavo/blog/post/journey-to-the-stack/">this page</a>.</p>
<h3 id="stackful-stackless">Stackful? Stackless!<a class="headerlink" href="#stackful-stackless" title="Permanent link">&para;</a></h3>
<blockquote>
<p>"Why do you rob banks?"
"That's where the money is."  - Bank robber</p>
</blockquote>
<h4 id="stackful-or-segmented-stack">Stackful or Segmented Stack<a class="headerlink" href="#stackful-or-segmented-stack" title="Permanent link">&para;</a></h4>
<p>It differes upon language, but C++ places function frames in runtime stack. To preserve some frame, we have to dump it and store it in some location. Or we can make a smaller chunk of space and use it as a side(alternantive) stack for function.</p>
<p>But let's bypass them. Our focus, MSVC coroutine is stackless.</p>
<h4 id="stackless-function-frame">Stackless - Function Frame<a class="headerlink" href="#stackless-function-frame" title="Permanent link">&para;</a></h4>
<p>N3858 wrote about resumable function's implementability. It suggested heap-allocated activation frames.</p>
<p>But frame is just a structure. Remind that we need 4 operations for coroutine. Those are declared as compiler intrinsic.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Header File : &lt;experimental/resumable&gt;</span>

<span class="c1">// ...</span>
<span class="c1">// intrinsics used in implementation of coroutine_handle</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">size_t</span> <span class="n">_coro_resume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span>   <span class="n">_coro_destroy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">size_t</span> <span class="n">_coro_done</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#pragma intrinsic(_coro_resume)</span>
<span class="cp">#pragma intrinsic(_coro_destroy)</span>
<span class="cp">#pragma intrinsic(_coro_done)</span>

<span class="c1">// ...</span>
<span class="c1">// resumable functions support intrinsics</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">size_t</span> <span class="n">_coro_frame_size</span><span class="p">();</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_coro_frame_ptr</span><span class="p">();</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span>   <span class="n">_coro_init_block</span><span class="p">();</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_coro_resume_addr</span><span class="p">();</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span>   <span class="n">_coro_init_frame</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span>   <span class="n">_coro_save</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span>   <span class="n">_coro_suspend</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span>   <span class="n">_coro_cancel</span><span class="p">();</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span>   <span class="n">_coro_resume_block</span><span class="p">();</span>

<span class="cp">#pragma intrinsic(_coro_frame_size)</span>
<span class="cp">#pragma intrinsic(_coro_frame_ptr)</span>
<span class="cp">#pragma intrinsic(_coro_init_block)</span>
<span class="cp">#pragma intrinsic(_coro_resume_addr)</span>
<span class="cp">#pragma intrinsic(_coro_init_frame)</span>
<span class="cp">#pragma intrinsic(_coro_save)</span>
<span class="cp">#pragma intrinsic(_coro_suspend)</span>
<span class="cp">#pragma intrinsic(_coro_cancel)</span>
<span class="cp">#pragma intrinsic(_coro_resume_block)</span>
<span class="c1">// ...</span>
</code></pre></div>


<p>So there is nothing we can touch.(Unless you are in MSVC team... right?) But if you want more detail, follow the references above and watch CppCon talks.</p>
<p>you may noticed there are 2 kinds of concept. Frame and Block.</p>
<ul>
<li>Coroutine<ol>
<li><code>_coro_resume</code></li>
<li><code>_coro_destroy</code></li>
<li><code>_coro_done</code></li>
<li><code>_coro_save</code></li>
<li><code>_coro_suspend</code></li>
<li><code>_coro_cancel</code></li>
<li><code>_coro_resume_addr</code></li>
</ol>
</li>
<li>Frame<ol>
<li><code>_coro_frame_ptr</code></li>
<li><code>_coro_frame_size</code></li>
<li><code>_coro_init_frame</code></li>
</ol>
</li>
<li>Block<ol>
<li><code>_coro_init_block</code></li>
<li><code>_coro_resume_block</code></li>
</ol>
</li>
</ul>
<blockquote>
<p>It is not clear for me now. Let me update this section later.
In my opinion,
the frame is activation record for the function (In the case, resumable function).
And block is space for function code. Therefore, it will contain local/captured arguments, And it's size will depends on maximum stack size of the function.
... Probably.</p>
</blockquote>
<h2 id="the-c-coroutine-resumable-function">The C++ Coroutine : Resumable Function<a class="headerlink" href="#the-c-coroutine-resumable-function" title="Permanent link">&para;</a></h2>
<p>At this point, we have to define 2 terms.</p>
<ul>
<li><em>Coroutine : <strong>Concept</strong>. Routine that supports 4 operations</em></li>
<li><em>Resumable Function : <strong>Implementation</strong> of coroutine concept in C++ world</em></li>
</ul>
<p>And the following table is about how to use its operations</p>
<table>
<thead>
<tr>
<th align="left">Operation</th>
<th align="center">Subroutine</th>
<th align="center">Coroutine</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Invoke</td>
<td align="center"><code>func(args)</code></td>
<td align="center"><code>func(args)</code></td>
</tr>
<tr>
<td align="left">Activate</td>
<td align="center">x</td>
<td align="center"><code>resume()</code></td>
</tr>
<tr>
<td align="left">Suspend</td>
<td align="center">x</td>
<td align="center"><code>co_yield</code>/<code>co_await</code></td>
</tr>
<tr>
<td align="left">Finalize</td>
<td align="center"><code>return</code></td>
<td align="center"><code>co_return</code></td>
</tr>
</tbody>
</table>
<h3 id="invoke">Invoke<a class="headerlink" href="#invoke" title="Permanent link">&para;</a></h3>
<p><strong>For function call, there is no change.</strong> But the resumable function returns <code>std::future&lt;T&gt;</code>.</p>
<h3 id="finalize">Finalize<a class="headerlink" href="#finalize" title="Permanent link">&para;</a></h3>
<p>Cleanup and return point can be specified the well-known keyword, <code>return</code>. For same purpose, in resumable function, <code>co_return</code> statement is used.</p>
<h3 id="suspend">Suspend<a class="headerlink" href="#suspend" title="Permanent link">&para;</a></h3>
<p>When you wan to suspend funtion and yield its control, <code>co_yield</code> expression and <code>co_await</code> operator can do that. By adding 1 of them, the suspend/resume point is specified and MSVC will treat the function as coroutine. (Also, <code>co_return</code> statement can be used)</p>
<h3 id="activate">Activate<a class="headerlink" href="#activate" title="Permanent link">&para;</a></h3>
<p>When we have to activate suspended function, we will use <code>coroutine_handle</code> and its memeber function, <code>.resume()</code>. This is an interface to compiler intrinsic <code>_coro_resume</code> above.</p>
<h2 id="code">Code<a class="headerlink" href="#code" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Example codes are inspired by <a href="https://github.com/kirkshoop/await">kirkshoop's repository</a>.</p>
</blockquote>
<p>In short, if we follows MSVC's requirement, we can use C++ coroutine. But notice that the title of proposal is <strong>resumable</strong>(therefore, persistent) function.
However, its category differs to which meaning you want to carry with. Before that, let's start with compiler's requirement.</p>
<h3 id="promise-compilers-requirement">Promise : Compiler's Requirement<a class="headerlink" href="#promise-compilers-requirement" title="Permanent link">&para;</a></h3>
<p>You may already know about <code>std::future&lt;T&gt;</code> and <code>std::promise&lt;T&gt;</code>, and relation of the pair. Usually, <code>future&lt;T&gt;</code> is something like "I will return value or exception <strong>later</strong>" (See <code>std::async()</code>). And the value/exception is transferred via <code>promise&lt;T&gt;</code>. It is, "I kept the <strong>promise</strong> for the value".</p>
<p>And I already explained that resumable returns <code>future&lt;T&gt;</code>. Literally, This is not weird because coroutine can suspends itself and therefore its activator can't sure that it has returned. However, with the signature, programmer can still explicitly specify for return type just like conventional subroutine.</p>
<p>But here, the promise is for resumable function. See <a href="https://isocpp.org/files/papers/N4402.pdf">N4402</a>. You may ask why this is necessary. The answer is that resumable function is <strong>abstraction</strong>.</p>
<p>Because of stack, we had migrated the coroutine concept but not assembly-like flat code. Our resumable function lives in heap and to pass value from heap space(from function frame) to stack space(to <code>future</code> or awaitable), there must be some <strong>interface</strong>. For both compiler and programmer.</p>
<h4 id="resumable-promise-requirement">Resumable Promise Requirement<a class="headerlink" href="#resumable-promise-requirement" title="Permanent link">&para;</a></h4>
<p>I will explain how this interface is used soon.
According to N4402, the promise type for resumable function should support operations in the table below. I summarized note column. For detail, please read the document.</p>
<table>
<thead>
<tr>
<th align="left">Expression</th>
<th align="left">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>P{}</code></td>
<td align="left">Promise must be <a href="http://en.cppreference.com/w/cpp/concept/DefaultConstructible">default constructible</a></td>
</tr>
<tr>
<td align="left"><code>p.get_return_object()</code></td>
<td align="left">The return value of funtion. It can be <code>future&lt;T&gt;</code>, or some user-defined type.</td>
</tr>
<tr>
<td align="left"><code>p.return_value(v)</code></td>
<td align="left"><code>co_return</code> statement. Pass the value <code>v</code> and the value will be consumed later.</td>
</tr>
<tr>
<td align="left"><code>p.return_value()</code></td>
<td align="left"><code>co_return</code> statement. Pass <code>void</code>. Can be invoked when the coroutine returns. And calling this can be thought as "No more value".</td>
</tr>
<tr>
<td align="left"><code>p.set_exception(e)</code></td>
<td align="left">Pass the exception. It will throw when the resumer activates the function with this context.</td>
</tr>
<tr>
<td align="left"><code>p.yield_value(v)</code></td>
<td align="left"><code>co_yield</code> expression. Similar to <code>return_value(v)</code>.</td>
</tr>
<tr>
<td align="left"><code>p.initial_suspend()</code></td>
<td align="left">If return <code>true</code>, suspends at initial suspend point.</td>
</tr>
<tr>
<td align="left"><code>p.final_suspend()</code></td>
<td align="left">If return <code>true</code>, suspends at final suspend point.</td>
</tr>
</tbody>
</table>
<p>Some operations are related to <code>coroutine_traits&lt;T&gt;</code>. Later section will describe its flexibility. It is pretty abstract for now, but we are in progress. Lets move our focus to usecases of C++ coroutine.</p>
<h3 id="generator">Generator<a class="headerlink" href="#generator" title="Permanent link">&para;</a></h3>
<h4 id="concept">Concept<a class="headerlink" href="#concept" title="Permanent link">&para;</a></h4>
<ul>
<li><em>Generator = Iterator + Resumable Function</em></li>
</ul>
<p>See? There is an iterator. <code>generator&lt;T&gt;</code> is abstraction for sequence of values, which are generated by resumable function. The function is persistent, and contains some unique context in its frame.</p>
<h4 id="example_1">Example<a class="headerlink" href="#example_1" title="Permanent link">&para;</a></h4>
<p>The following code is simple generator for fibonacci numbers.</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;experimental/generator&gt;</span><span class="cp"></span>

<span class="c1">// Make a generator for `N` fibonacci numbers</span>
<span class="k">auto</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Set the value and suspend</span>
        <span class="k">co_yield</span> <span class="n">f1</span><span class="p">;</span>

        <span class="c1">// Calculate next fibo and shift</span>
        <span class="kt">int</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span><span class="p">;</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span><span class="p">;</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">f3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">co_return</span><span class="p">;</span>  <span class="c1">// No more value</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usecase</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// A sequence of 10 fibo numbers</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">fibo</span> <span class="p">:</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// 0, 1, 1, 2, 3, 5, 8 ... 34</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<p>How this can be possible? Well, lets see the definition of <code>generator&lt;T&gt;</code>.</p>
<h4 id="detail">Detail<a class="headerlink" href="#detail" title="Permanent link">&para;</a></h4>
<p>Here is a skeleton of <code>generator&lt;T&gt;</code>. We can see that it supports <code>iterator</code> and <code>promise_type</code>. and <code>begin()</code>/<code>end()</code> function to support <a href="http://en.cppreference.com/w/cpp/language/range-for">Range-based for loop</a></p>
<div class="codehilite"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span>
<span class="k">struct</span> <span class="n">generator</span>
<span class="p">{</span>
    <span class="c1">// Resumable Promise Requirement</span>
    <span class="k">struct</span> <span class="n">promise_type</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// Handle for Resumable Funtion</span>
    <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">_Coro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">struct</span> <span class="n">promise_type</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
    <span class="k">struct</span> <span class="n">iterator</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>

    <span class="n">iterator</span> <span class="nf">begin</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// If we have handle, we can resume it to get the value.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_Coro</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_Coro</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
            <span class="c1">// The function returned?</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_Coro</span><span class="p">.</span><span class="n">done</span><span class="p">())</span>
                <span class="k">return</span> <span class="p">{</span><span class="k">nullptr</span><span class="p">};</span> <span class="c1">// return end();</span>
        <span class="p">}</span>
        <span class="c1">// The function is not finished.</span>
        <span class="c1">// Will be reused later...</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">_Coro</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">end</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// No handle, No more value.</span>
        <span class="k">return</span> <span class="p">{</span><span class="k">nullptr</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">generator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// RAII : Destroy function frame</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_Coro</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_Coro</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">};</span>
</code></pre></div>


<p>So, the actual usecase function will be like this.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">usecase</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// A generator for 10 fibo numbers</span>
    <span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gen</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">// We cannot use `iter++` because it is deleted.</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">gen</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
         <span class="n">iter</span> <span class="o">!=</span> <span class="n">gen</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
         <span class="o">++</span><span class="n">iter</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fibo</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
        <span class="c1">// 0, 1, 1, 2, 3, 5, 8 ... 34</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<p>Pretty simple with the iterator! Let's hack the iterator then...</p>
<div class="codehilite"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span>
<span class="k">struct</span> <span class="n">generator</span>
<span class="p">{</span>
    <span class="c1">// Iterator interface</span>
    <span class="k">struct</span> <span class="nl">iterator</span> <span class="p">:</span> <span class="n">_STD</span> <span class="n">iterator</span><span class="o">&lt;</span><span class="n">input_iterator_tag</span><span class="p">,</span> <span class="n">_Ty</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="c1">// Resumable function handle</span>
        <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">_Coro</span><span class="p">;</span>

        <span class="n">iterator</span><span class="p">(</span><span class="n">nullptr_t</span><span class="p">);</span>
        <span class="n">iterator</span><span class="p">(</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">_CoroArg</span><span class="p">);</span>

        <span class="c1">// When we move next...</span>
        <span class="n">iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="c1">// Make the function yield next value</span>
            <span class="n">_Coro</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>

            <span class="c1">// If done, just release.</span>
            <span class="c1">// Generator will destroy it later...</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_Coro</span><span class="p">.</span><span class="n">done</span><span class="p">())</span>
                <span class="n">_Coro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// This is MSVC comment....</span>
        <span class="c1">// In short, post increment can overlap the handle in iterator.</span>
        <span class="c1">// And it can leak the last value in coroutine frame.</span>
        <span class="c1">// ---- ---- ---- ---- ----</span>
        <span class="c1">// generator iterator current_value</span>
        <span class="c1">// is a reference to a temporary on the coroutine frame</span>
        <span class="c1">// implementing post increment will require storing a copy</span>
        <span class="c1">// of the value in the iterator.</span>
        <span class="n">iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="c1">//{</span>
        <span class="c1">//      auto _Result = *this;</span>
        <span class="c1">//      ++(*this);</span>
        <span class="c1">//      return _Result;</span>
        <span class="c1">//}</span>

        <span class="c1">// We use `promise` to get the value.</span>
        <span class="c1">// It is pointing the value in function frame</span>
        <span class="n">_Ty</span> <span class="k">const</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">_Coro</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">_CurrentValue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">_Ty</span> <span class="k">const</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">_Right</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">_Right</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>


<p>At this point, we can understand that iterator is resuming the function repetitively. And acquiring value from <code>generator&lt;T&gt;</code>'s <code>promise_type</code>. So in this case, <code>usecase</code> function is <strong>both invoker and resumer for the generator</strong>.</p>
<p><img alt="Fig: Generator Invoke and Resume" src="https://cgiska.bn1304.livefilestore.com/y4myyjBEM4mTFN8yloP0iVkJc-b8wQ_OzKXH-Y03gXYlJqaxpsg7db3xWQAxUujyjQamngJ9mw7cnHmFt3_W2qxviWYpMzdRR6iub1Msi_bZOHuB76FbOOdfrhDo5yen6OAzJH48zRRfbbiiboTzymHRLN5xOosm6PyywXhQO9lYo80KY_lPRhaUMu-dcPkbu3wiL0OtjtiyJE8iGt1-d4vbw?width=1024&amp;height=607&amp;cropmode=none" /></p>
<h4 id="compilers-view">Compiler's View<a class="headerlink" href="#compilers-view" title="Permanent link">&para;</a></h4>
<p>Now, the keystone <code>promise_type</code> is on the stage. It has more codes but I will skip them for simplicity.</p>
<div class="codehilite"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span>
<span class="k">struct</span> <span class="n">generator</span>
<span class="p">{</span>
    <span class="c1">// Resumable Promise Requirement for `generator`</span>
    <span class="k">struct</span> <span class="n">promise_type</span>
    <span class="p">{</span>
        <span class="c1">// it knows where the value is... in frame.</span>
        <span class="n">_Ty</span> <span class="k">const</span> <span class="o">*</span><span class="n">_CurrentValue</span><span class="p">;</span>

        <span class="c1">// It returns `promise_type`.</span>
        <span class="c1">// The reason will be explained in next section.</span>
        <span class="n">promise_type</span> <span class="o">&amp;</span><span class="n">get_return_object</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If return `true`, suspends at initial suspend point.</span>
        <span class="c1">// So we suspends at *some* point</span>
        <span class="kt">bool</span> <span class="n">initial_suspend</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// If return `true`, suspends at final suspend point.</span>
        <span class="c1">// So we suspends at *some* point</span>
        <span class="kt">bool</span> <span class="n">final_suspend</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Support `co_yield` expression</span>
        <span class="kt">void</span> <span class="n">yield_value</span><span class="p">(</span><span class="n">_Ty</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">_Value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// point the value</span>
            <span class="n">_CurrentValue</span> <span class="o">=</span> <span class="n">_STD</span> <span class="n">addressof</span><span class="p">(</span><span class="n">_Value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>


<p>The <code>promise_type</code> supports 4 functions in requirement. <code>get_return_object</code>, <code>initial_suspend</code>, <code>final_suspend</code>, and <code>yield_value</code>.</p>
<p>In short, <code>co_yield</code> is equal to "Set the value and suspend". Compiler will change the expression like following.</p>
<ul>
<li><code>co_yield</code> : <code>co_await</code> + <code>p.yield_value(x)</code></li>
</ul>
<p>Therefore, <code>co_yield</code> with empty expression is <strong>impossible</strong>. Because <code>x</code> can't be <code>void</code>. Since generator is abstraction of sequence, this is natural constraint.</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;experimental/generator&gt;</span><span class="cp"></span>

<span class="k">auto</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// Compiler changes the expression to...</span>
        <span class="c1">// co_yield f1;</span>
        <span class="n">p</span><span class="p">.</span><span class="n">yield_value</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span>  <span class="c1">// Set the value pointer</span>
        <span class="k">co_await</span> <span class="n">suspend_always</span><span class="p">{};</span> <span class="c1">// And suspend.</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="k">co_return</span><span class="p">;</span>  <span class="c1">// No more value</span>
<span class="p">}</span>
</code></pre></div>


<p>Notice that there is no <code>promise_type p{}</code> or something else. Its secret will be covered in next section.</p>
<h3 id="resumable-function">Resumable Function<a class="headerlink" href="#resumable-function" title="Permanent link">&para;</a></h3>
<p>This section starts from detail. The example code will be seen after explanation of awaitable concept.</p>
<h4 id="concept_1">Concept<a class="headerlink" href="#concept_1" title="Permanent link">&para;</a></h4>
<ul>
<li><em>Resumable Function : Heap Allocated Frame + Operation</em></li>
<li><em>Operation : <code>call</code> | <code>co_await</code> | <code>co_return</code> | <code>resume()</code></em></li>
</ul>
<p><code>generator&lt;T&gt;</code> was simple example. And you may remember that it contains <code>coroutine_handle</code>. Let's cover the type. <code>coroutine_handle</code> was <code>resumable_handle</code>.</p>
<p>Remembering that resumable function is C++ implementation of coroutine concept, it is alias of resumable function handle. If you have an experience of Windows API, you probably know what <em>handle</em> means. It is <code>void *</code>.</p>
<p>We already talked about how stackless coroutine can be implemented. MSVC uses heap allocated function frame and supports several intrinsics. <strong>With the pointer to frame in heap, <code>coroutine_handle</code> adds some operation over it.</strong></p>
<h4 id="resumable-frame">Resumable Frame<a class="headerlink" href="#resumable-frame" title="Permanent link">&para;</a></h4>
<p>Then, how does the frame look like?
As I commented above, the frame of resumable function. It has head and body.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// TEMPLATE CLASS coroutine_handle</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_PromiseT</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">coroutine_handle</span><span class="p">;</span>

<span class="c1">// TEMPLATE CLASS coroutine_handle&lt;void&gt; - no promise access</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="c1">// ---- ---- ---- ---- ----</span>
    <span class="c1">// Head of function frame</span>
    <span class="c1">//  - Fn    : Instruction address for resume operation</span>
    <span class="c1">//  - cdecl : Caller manages the frame. Callee won&#39;t touch it.</span>
    <span class="c1">//  - Index : Index to resumption point.</span>
    <span class="c1">//            0 is special value for `done()`</span>
    <span class="c1">//  - Flag  : ???</span>
    <span class="k">struct</span> <span class="n">_Resumable_frame_prefix</span>
    <span class="p">{</span>
        <span class="k">typedef</span> <span class="kt">void</span><span class="p">(</span><span class="kr">__cdecl</span> <span class="o">*</span><span class="n">_Resume_fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
        <span class="n">_Resume_fn</span> <span class="n">_Fn</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">_Index</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">_Flags</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="c1">// ---- ---- ---- ---- ----</span>
    <span class="c1">// Coroutine Frame will include...</span>
    <span class="c1">//  - Promise</span>
    <span class="c1">//  - Captured arguments</span>
    <span class="c1">//  - Function body</span>
    <span class="c1">//      - Local Variables and Temporaries</span>
    <span class="c1">//  - Platform context</span>
    <span class="c1">//      - Registers</span>
    <span class="c1">// ---- ---- ---- ---- ----</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="n">_Resumable_frame_prefix</span> <span class="o">*</span><span class="n">_Ptr</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">coroutine_handle</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">coroutine_handle</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">coroutine_handle</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">nullptr_t</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="c1">// Import : the pointer to resumable handle</span>
    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_Addr</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="n">coroutine_handle</span> <span class="n">_Result</span><span class="p">;</span>
        <span class="n">_Result</span><span class="p">.</span><span class="n">_Ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">_Resumable_frame_prefix</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">_Addr</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">_Result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Export : return the frame address</span>
    <span class="kt">void</span> <span class="o">*</span><span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_Ptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">resume</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">();</span>

    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="c1">// REVISIT: should return _coro_done() == 0; when intrinsic is</span>
        <span class="c1">// hooked up</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_Ptr</span><span class="o">-&gt;</span><span class="n">_Index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div>


<p><strong>Head</strong> : Like its name, <code>_Resumable_frame_prefix</code> is head of coroutine frame. MSVC uses fixed size of <code>sizeof(void *) * 2</code>(16 bytes in x64) for this struct.</p>
<ul>
<li><code>Fn</code> :  Note that this is declared as <code>cdecl</code> convention. Since <code>cdecl</code> specifies stack cleanup (in the case, frame destruction) is up to caller, the call of <code>Fn</code> won't destroy the frame.</li>
<li><code>Index</code> : Resumable function can have multiple resumption point. This is a index for the point.</li>
<li><code>Flag</code> : ??? Who are you ???</li>
</ul>
<p><strong>Body</strong> : N4402 describes what frame includes. Based on James McNellis's PPT, the compiler-generated frame body will be like the following code.</p>
<ul>
<li>Promise</li>
<li>Captured arguments</li>
<li>Function body<ul>
<li>Local Variables and Temporaries</li>
</ul>
</li>
<li>Platform context<ul>
<li>Registers</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="c1">// Possible frame for fibonacci function</span>
<span class="k">struct</span> <span class="n">__frame_fibonacci</span>
<span class="p">{</span>
    <span class="c1">// `_Resumable_frame_prefix`</span>
    <span class="n">Frame_Prefix</span>  <span class="n">_prefix</span><span class="p">;</span>

    <span class="c1">// Resumable Promise Requirement</span>
    <span class="c1">//   fibonacci returns `generator&lt;int&gt;`</span>
    <span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">promise_type</span>  <span class="n">_p</span><span class="p">;</span>

    <span class="c1">// Captured arguments</span>
    <span class="kt">int</span>   <span class="n">_n</span><span class="p">;</span> <span class="c1">// fibonacci(n);</span>

    <span class="kt">int</span>   <span class="n">_f1</span><span class="p">,</span> <span class="n">_f2</span><span class="p">;</span>     <span class="c1">// Local variable</span>
    <span class="kt">int</span>   <span class="n">_i</span><span class="p">,</span>  <span class="n">_f3</span><span class="p">;</span>     <span class="c1">// Temporaries</span>

    <span class="c1">// Platform dependent storage</span>
    <span class="c1">//  for registers, etc.</span>
<span class="p">};</span>
</code></pre></div>


<h4 id="coroutine-traits">Coroutine Traits<a class="headerlink" href="#coroutine-traits" title="Permanent link">&para;</a></h4>
<p>We didn't cover <code>p.get_return_object()</code> yet. This is the section for the topic. Let me explain <code>coroutine_traits</code> first...</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// &lt;experimental/resumable&gt;</span>

<span class="c1">// TEMPLATE CLASS coroutine_traits</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ret</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">_Ts</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">coroutine_traits</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">_Ret</span><span class="o">::</span><span class="n">promise_type</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>


<p>It's pretty simple. <code>coroutine_traits</code> requires <code>promise_type</code> to be implemented at compile time. And it must follow <strong>Resumable Promise Requirement</strong>.</p>
<p>I explaind that resumable function returns <code>future&lt;T&gt;</code>, but that was not correct. If there is a type that fulfills the <code>coroutine_traits</code>, it can be return type of Resumable function.</p>
<p>Let't go to <strong>template specialization</strong> of <code>coroutine_traits</code>for <code>std::future&lt;T&gt;</code>. Previous example, <code>generator&lt;T&gt;</code> implemented promise type in itself, but with the specialization trick, we can reuse some old types or try some custom type.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// &lt;future&gt;</span>
<span class="cp">#ifdef _RESUMABLE_FUNCTIONS_SUPPORTED</span>

<span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
<span class="p">{</span>

<span class="c1">// Template Specialization for `std::future&lt;T&gt;`</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty</span><span class="p">,</span> <span class="n">class</span><span class="p">...</span> <span class="n">_ArgTypes</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">future</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_ArgTypes</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="c1">// defines resumable traits for functions returning future&lt;_Ty&gt;</span>
    <span class="k">struct</span> <span class="n">promise_type</span>
    <span class="p">{</span>
        <span class="c1">// `std::promise&lt;T&gt;`</span>
        <span class="n">promise</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span> <span class="n">_MyPromise</span><span class="p">;</span>

        <span class="c1">// Resumable function can return `std::future&lt;T&gt;`...</span>
        <span class="n">future</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span> <span class="n">get_return_object</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">_MyPromise</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// if `false`, we skip the initial suspend point.</span>
        <span class="kt">bool</span> <span class="n">initial_suspend</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// if `false`, we skip the final suspend point.</span>
        <span class="kt">bool</span> <span class="n">final_suspend</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Pass the value through `std::promise&lt;T&gt;`</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ut</span><span class="o">&gt;</span>
        <span class="kt">void</span> <span class="n">return_value</span><span class="p">(</span><span class="n">_Ut</span><span class="o">&amp;&amp;</span> <span class="n">_Value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_MyPromise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">_STD</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">_Ut</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_Value</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// Pass the exception through `std::promise&lt;T&gt;`</span>
        <span class="kt">void</span> <span class="n">set_exception</span><span class="p">(</span><span class="n">exception_ptr</span> <span class="n">_Exc</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_MyPromise</span><span class="p">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">_STD</span> <span class="n">move</span><span class="p">(</span><span class="n">_Exc</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">};</span><span class="c1">// struct promise_type</span>
<span class="p">};</span><span class="c1">// coroutine_traits&lt;T, Args...&gt;</span>

<span class="c1">// ...</span>
<span class="p">}</span><span class="c1">// namespace std::experimental</span>

<span class="cp">#endif</span>
</code></pre></div>


<p>When MSVC meets <code>co_await</code>/<code>co_yield</code>/<code>co_return</code>, it applies <code>coroutine_traits</code> to enable compile-time check. Let's see the fibonacci example again. It will show what MSVC does.</p>
<blockquote>
<p>The code might be wrong. I will update it as I find correct mechanism.</p>
</blockquote>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;experimental/generator&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="p">;</span>

<span class="c1">// Make a generator for `N` fibonacci numbers</span>
<span class="k">auto</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="c1">// At this point, compiler will generate code</span>
    <span class="c1">//  and check `return_type` fulfills promise requirement.</span>
    <span class="k">using</span> <span class="n">traits</span> <span class="o">=</span> <span class="n">coroutine_traite</span><span class="o">&lt;</span><span class="n">return_type</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c1">// Requirement : OK.</span>
    <span class="c1">// We can generate unique frame type for this function.</span>
    <span class="c1">// Possible frame for fibonacci function</span>
    <span class="k">struct</span> <span class="n">__frame</span>
    <span class="p">{</span>
        <span class="c1">// `_Resumable_frame_prefix`</span>
        <span class="n">Frame_Prefix</span>  <span class="n">_prefix</span><span class="p">;</span>

        <span class="c1">// Resumable Promise Requirement</span>
        <span class="c1">//   fibonacci returns `generator&lt;int&gt;`</span>
        <span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">promise_type</span>  <span class="n">_promise</span><span class="p">;</span>

        <span class="c1">// Captured arguments</span>
        <span class="kt">int</span>   <span class="n">_n</span><span class="p">;</span> <span class="c1">// fibonacci(n);</span>

        <span class="kt">int</span>   <span class="n">_f1</span><span class="p">,</span> <span class="n">_f2</span><span class="p">;</span>     <span class="c1">// Local variable</span>
        <span class="kt">int</span>   <span class="n">_i</span><span class="p">,</span>  <span class="n">_f3</span><span class="p">;</span>     <span class="c1">// Temporaries</span>

        <span class="c1">// Platform dependent storage</span>
        <span class="c1">//  for registers, etc.</span>
    <span class="p">};</span>

    <span class="c1">// We are forwarding arguments to frame!</span>
    <span class="c1">// Let&#39;s call it context(ctx)</span>
    <span class="n">__frame</span><span class="o">*</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">__frame</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">n</span><span class="p">)};</span>
    <span class="c1">// Generate return objet</span>
    <span class="c1">// In this case, `generator&lt;int&gt;`</span>
    <span class="n">return_type</span> <span class="n">__return</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>

    <span class="c1">// if true, suspend.</span>
    <span class="c1">// if false, keep move...</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">()</span> <span class="p">){</span> <span class="c1">// always true</span>
        <span class="c1">// suspend...</span>
    <span class="nl">__initial_suspend_point</span><span class="p">:</span>
    <span class="p">}</span>

    <span class="c1">// User code : use variables in frame(ctx)...</span>
    <span class="c1">// ---- ---- ---- ---- ----</span>
    <span class="p">{</span>
        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
             <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_i</span> <span class="o">&lt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_n</span><span class="p">;</span>
             <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Pass value through promise</span>
            <span class="c1">// co_yield f1;</span>
            <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_promise</span><span class="p">.</span><span class="n">yield_value</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f1</span><span class="p">);</span>

            <span class="c1">// instructions for suspension with `ctx-&gt;_prefix`...</span>
            <span class="c1">// co_await suspend_always{};</span>
        <span class="nl">__suspend_resume_point_1</span><span class="p">:</span>

            <span class="c1">// Calculate next fibo and shift</span>
            <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f3</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f1</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f2</span><span class="p">;</span>
            <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f1</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f2</span><span class="p">;</span>
            <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f2</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_f3</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// co_return;</span>
        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_promise</span><span class="p">.</span><span class="n">set_result</span><span class="p">();</span>
        <span class="k">goto</span> <span class="n">__final_suspend_point</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ---- ---- ---- ---- ----</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">_promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">()</span> <span class="p">){</span> <span class="c1">// always true</span>
        <span class="c1">// suspend...</span>
    <span class="nl">__final_suspend_point</span><span class="p">:</span>
    <span class="p">}</span>

    <span class="c1">// Instructions for clean up...</span>
<span class="p">}</span>
</code></pre></div>


<p>So we could find out that compiler do <strong>a lot of job</strong> instead of us. And using frame pointer <code>ctx</code> is not that different from <code>this</code> pointer for memeber functions. Therefore, the cost for frame-based code will be negligible.</p>
<ul>
<li><code>co_yield</code>  : <code>co_await</code> + <code>p.yield_value(x)</code></li>
<li><code>co_return</code> : <code>p.set_result(x)</code> + <code>goto final_suspend;</code></li>
</ul>
<h4 id="section-summary">Section Summary<a class="headerlink" href="#section-summary" title="Permanent link">&para;</a></h4>
<p>We covered <code>co_return</code> and <code>co_yield</code> with <code>generator&lt;T&gt;</code> example. Generator was a combination of iterator and resumable function.</p>
<p>Resumable functions use <code>coroutine_handle</code>, which is basically raw pointer to function frame and some operations that rely on compiler intrinsics. The mechanism for frame-based approach was pretty similar to <code>this</code> pointer approach.</p>
<p>For compile-time(static) assertion, <code>coroutine_traits&lt;T&gt;</code> is used. It enforce the return type to support <code>promise_type</code> that fulfills resumable promise requirement. And there was a specialization especially for <code>std::future&lt;T&gt;</code>.</p>
<h3 id="the-awaitable-concept">The Awaitable Concept<a class="headerlink" href="#the-awaitable-concept" title="Permanent link">&para;</a></h3>
<ul>
<li><em><code>operator co_await</code> = Syntactic Sugar + Resumable Function</em></li>
</ul>
<p>The last core of resumable function is <code>co_await</code>. It is unary operator.</p>
<p>In this semantics, <strong>await is synonym of suspend</strong>. And because of suspension, its return value becomes <strong>asynchronous</strong>.</p>
<p>This is the important point for our mental model. You may thought <code>async</code> &amp; <code>await</code> of C# language, The difference in C++ world is that we can manage them <strong>manually</strong>, with our code and compiler support.</p>
<h4 id="example_2">Example<a class="headerlink" href="#example_2" title="Permanent link">&para;</a></h4>
<p>The code is sample from MSVC blog.</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;    // Windows Threadpool API</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>

<span class="c1">// operator overload.</span>
<span class="c1">// co_await can&#39;t use primitive type parameter.</span>
<span class="k">auto</span> <span class="k">operator</span> <span class="nf">co_await</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">duration</span> <span class="n">duration</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="p">;</span>

    <span class="c1">// Awaitable must implements 3 function.</span>
    <span class="c1">//  - bool await_ready();</span>
    <span class="c1">//  - auto await_suspend();</span>
    <span class="c1">//  - T    await_resume();</span>
    <span class="k">class</span> <span class="nc">awaiter</span>
    <span class="p">{</span>
        <span class="k">static</span>
        <span class="kt">void</span> <span class="n">CALLBACK</span> <span class="n">TimerCallback</span><span class="p">(</span><span class="n">PTP_CALLBACK_INSTANCE</span><span class="p">,</span>
                                    <span class="kt">void</span> <span class="o">*</span><span class="n">Context</span><span class="p">,</span>
                                    <span class="n">PTP_TIMER</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Callback Thread will resume the function</span>
            <span class="n">coroutine_handle</span><span class="o">&lt;&gt;::</span><span class="n">from_address</span><span class="p">(</span><span class="n">Context</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">PTP_TIMER</span> <span class="n">timer</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">duration</span> <span class="n">duration</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>

        <span class="k">explicit</span>
        <span class="n">awaiter</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">duration</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">duration</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="p">{}</span>
        <span class="o">~</span><span class="n">awaiter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="n">CloseThreadpoolTimer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// If not ready (`false`), invoke `await_suspend`</span>
        <span class="c1">// If ready (`true`), go to `await_resume` directly.</span>
        <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Return might be ignored.</span>
        <span class="kt">bool</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">resume_cb</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int64_t</span> <span class="n">relative_count</span> <span class="o">=</span> <span class="o">-</span><span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>
            <span class="n">timer</span> <span class="o">=</span> <span class="n">CreateThreadpoolTimer</span><span class="p">(</span><span class="n">TimerCallback</span><span class="p">,</span>
                                          <span class="n">resume_cb</span><span class="p">.</span><span class="n">address</span><span class="p">(),</span>
                                          <span class="k">nullptr</span><span class="p">);</span>
            <span class="c1">// Set the timer and then suspend...</span>
            <span class="n">SetThreadpoolTimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="p">(</span><span class="n">PFILETIME</span><span class="p">)</span><span class="o">&amp;</span><span class="n">relative_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">timer</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Return T type&#39;s value after resumed.</span>
        <span class="c1">// T can be `void`.</span>
        <span class="kt">void</span> <span class="n">await_resume</span><span class="p">()</span> <span class="p">{}</span>

    <span class="p">};</span>
    <span class="k">return</span> <span class="n">awaiter</span><span class="p">{</span> <span class="n">duration</span> <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// Resumable Function</span>
<span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: sleeping…</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="c1">// await for 1 millisecond...</span>
    <span class="k">co_await</span> <span class="mi">1</span><span class="n">ms</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: woke up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This is normal subroutine</span>
<span class="kt">void</span> <span class="n">usecase</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">test</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: back in main</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>It's flow is like the figure.</p>
<p><img alt="Fig: Invoker and Resumer for co_await" src="https://bqivka.bn1304.livefilestore.com/y4mfcDYFCH6SMe0hrR74BNJzFaua5hK_tksI8vp8pdRykhjrX1yuUOQoHrhFVFu9ci5icB6lOrMGLwaC74PxZthzgw8u-O4yNDAgEnkT5EMTPv7CcAVmOX6DHF_Ofi44GE33IJgYheftmKUrKX46k9SubyycOFSpsjxd_2Vj5bKAwzML-6geswyforIr-YIeBH1_B82cMEKrJnsOf5kJDOfbQ?width=1024&amp;height=692&amp;cropmode=none" /></p>
<h4 id="awaitable-interface">Awaitable Interface<a class="headerlink" href="#awaitable-interface" title="Permanent link">&para;</a></h4>
<p><code>co_await</code> requires some interface for its operation. As we can see in code above, Awaitable interface should implement at least 3 functions.</p>
<ul>
<li><code>await_ready</code></li>
<li><code>await_suspend</code></li>
<li><code>await_resume</code></li>
</ul>
<p>It can be both member and normal function. <code>future&lt;T&gt;</code> also implements this interface. so <code>future</code> can be an argument for <code>co_await</code>. But just like the code <code>await_suspend</code>, it can be inefficient.
For user-defined type, simple overload is enough.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// &lt;future&gt;</span>
<span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">await_ready</span><span class="p">(</span><span class="n">future</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;&amp;</span> <span class="n">_Fut</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">_Fut</span><span class="p">.</span><span class="n">_Is_ready</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">future</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;&amp;</span> <span class="n">_Fut</span><span class="p">,</span>
                   <span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">_ResumeCb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// change to .then when future gets .then</span>
    <span class="kr">thread</span> <span class="n">_WaitingThread</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">_Fut</span><span class="p">,</span> <span class="n">_ResumeCb</span><span class="p">]{</span>
            <span class="n">_Fut</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
            <span class="n">_ResumeCb</span><span class="p">();</span>
        <span class="p">});</span>
    <span class="n">_WaitingThread</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">await_resume</span><span class="p">(</span><span class="n">future</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;&amp;</span> <span class="n">_Fut</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">_Fut</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="p">}</span>

<span class="p">}</span><span class="c1">// namespace std</span>
</code></pre></div>


<p>How about compiler's view? How does it change our code?</p>
<h4 id="compilers-view_1">Compiler's View<a class="headerlink" href="#compilers-view_1" title="Permanent link">&para;</a></h4>
<ul>
<li><em><code>operator co_await</code> = Syntactic Sugar + Resumable Function</em></li>
</ul>
<p>I explained that <code>co_await</code> is syntatic sugar. If operator's argument type implements awaitable concept appropriately, the code will be modified by compiler. Revisiting previous example, <code>test</code> function which awaits for 1 millisecond, let's see how it works...</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Before...</span>
<span class="c1">// ---- ---- ---- ---- ----</span>
<span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">co_await</span> <span class="mi">1</span><span class="n">ms</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// After...</span>
<span class="c1">// ---- ---- ---- ---- ----</span>
<span class="c1">// With `co_await` keyword in function body,</span>
<span class="c1">// compiler will make this function to resumable.</span>
<span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Compiler-generated coroutine frame...</span>
    <span class="n">__frame</span><span class="o">*</span> <span class="n">context</span><span class="p">;</span>
    <span class="c1">// ...</span>

    <span class="c1">// Awaitable type implements awaitable interface.</span>
    <span class="c1">// Precisely, this will be temporary variable in frame.</span>
    <span class="n">awaiter</span> <span class="n">aw</span> <span class="o">=</span> <span class="k">operator</span> <span class="k">co_await</span><span class="p">(</span><span class="mi">1</span><span class="n">ms</span><span class="p">);</span>

    <span class="c1">// Do we have expected value now?</span>
    <span class="c1">// If not, suspend.</span>
    <span class="c1">// If ready, skip the suspend and resume directly.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">aw</span><span class="p">.</span><span class="n">await_ready</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="c1">// await_ready(aw);</span>
    <span class="p">{</span>
        <span class="c1">// Wrap the function frame to `coroutine_handle` type</span>
        <span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">resume_cb</span> <span class="o">=</span>
                <span class="n">coroutine_handle</span><span class="o">&lt;&gt;::</span><span class="n">from_address</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

        <span class="n">aw</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">resume_cb</span><span class="p">);</span>

        <span class="c1">// some instructions....</span>
    <span class="nl">__suspend_resume_point_1</span><span class="p">:</span>
        <span class="c1">// Since resume point is in this scope,</span>
        <span class="c1">// there won&#39;t be suspension if ready()==true.</span>
    <span class="p">}</span>

    <span class="c1">// If await_resume has return type...</span>
    <span class="c1">// auto value = aw.await_resume();</span>
    <span class="n">aw</span><span class="p">.</span><span class="n">await_resume</span><span class="p">();</span> <span class="c1">// await_resume(aw);</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>


<p>So there are some points for each of interface functions.</p>
<ul>
<li><em><code>await_ready</code> : "Do we have return value now?"</em></li>
</ul>
<p><code>await_ready</code> makes the branch. It asks value for <code>await_resume</code> is ready.
If not, the control flows into the scope of <code>if</code> statement.
If it's ready, <code>await_ready</code> returns <code>true</code> and <code>await_resume</code> will be invoked directly.
Compiler can optimize the code if it returns <code>false</code> always. In the case, we don't need suspension and therefore frame wrapping becomes unnecessary. The coroutine will become normal subroutine after optimization steps.</p>
<p>In suspension scope, we must ready for suspension. Since <code>coroutine_handle&lt;&gt;</code> is just a raw pointer to frame, we can wrap it easily with static function  <code>coroutine_handle&lt;&gt;::from_address</code>.</p>
<ul>
<li><em><code>await_suspend</code> : "The routine will suspend soon. Do what you have to do!"</em></li>
</ul>
<p><code>await_suspend</code> receives <code>coroutine_handle&lt;&gt;</code> for its argument. With this function, we can interleave our code for suspension handling.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// The example code set the Windows Thread Pool Timer</span>
<span class="c1">//  and forward frame&#39;s address as callback argument.</span>
<span class="k">class</span> <span class="nc">awaiter</span>
<span class="p">{</span>
    <span class="c1">// Return might be ignored.</span>
    <span class="kt">bool</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">resume_cb</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int64_t</span> <span class="n">relative_count</span> <span class="o">=</span> <span class="o">-</span><span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>
        <span class="n">timer</span> <span class="o">=</span> <span class="n">CreateThreadpoolTimer</span><span class="p">(</span><span class="n">TimerCallback</span><span class="p">,</span>
                                    <span class="c1">// Unwrap the handle</span>
                                    <span class="n">resume_cb</span><span class="p">.</span><span class="n">address</span><span class="p">(),</span>
                                    <span class="k">nullptr</span><span class="p">);</span>
        <span class="n">SetThreadpoolTimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="p">(</span><span class="n">PFILETIME</span><span class="p">)</span><span class="o">&amp;</span><span class="n">relative_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">timer</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// A thread in Windows Thread Pool will invoke this callback.</span>
    <span class="c1">//  And it will be resumer for the function.</span>
    <span class="k">static</span>
    <span class="kt">void</span> <span class="n">CALLBACK</span> <span class="n">TimerCallback</span><span class="p">(</span><span class="n">PTP_CALLBACK_INSTANCE</span><span class="p">,</span>
                                <span class="kt">void</span> <span class="o">*</span><span class="n">Context</span><span class="p">,</span>
                                <span class="n">PTP_TIMER</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Wrap the frame to handle again. And resume.</span>
        <span class="n">coroutine_handle</span><span class="o">&lt;&gt;::</span><span class="n">from_address</span><span class="p">(</span><span class="n">Context</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<ul>
<li><em><code>await_resume</code> : "Now, here is the return value and control flow"</em></li>
</ul>
<p>Suspend/resume point is created for resume operation. When the coroutine handle's <code>.resume()</code> is invoked, the function will set the context(frame pointer) and jump to it. The flow then exits the scope and call <code>await_resume</code>.</p>
<p>Notice that we did suspend because the value wasn't ready(<code>await_ready</code>). When the function is resumed, there should be return value. If <code>await_resume</code>'s return type is void, it means control flow is back.</p>
<p><img alt="Fig: Awaiting Windows Threapool Timer" src="https://cgiuka.bn1304.livefilestore.com/y4mpoQFynRK0frHDJppknT-r10zBKbxf8AgNbV_lVSDl8WHEcPl7hGHltVblWdKQSeStvaegIMlhqTGiSZ0AF57wx5XOGV_T_8asbwKQsxOzs2X473nkhVGpS-AkoZJJfG2_dCA46XtuWEw6IHIk7_OePD1bV_BF1WcAGLqyTVTFps5Bl9UetnzIBKVyxrPb_NC_s0qqvHNR-DLF6KqZRiQBg?width=645&amp;height=660&amp;cropmode=none" /></p>
<h4 id="co_await-tricks"><code>co_await</code> Tricks<a class="headerlink" href="#co_await-tricks" title="Permanent link">&para;</a></h4>
<p>Kenny Kerr and James Mcnellis introduced several tricks with this mechanism. I strongly recommend you to watch the video.</p>
<p>CppCon 2016 : <a href="https://channel9.msdn.com/events/CPP/CppCon-2016/CppCon-2016-Kenny-Kerr--James-McNellis-Putting-Coroutines-to-Work-with-the-Windows-Runtime">Kenny Kerr &amp; James McNellis "Putting Coroutines to Work with the Windows Runtime"</a></p>
<h3 id="async-generator">Async Generator<a class="headerlink" href="#async-generator" title="Permanent link">&para;</a></h3>
<h4 id="concept_2">Concept<a class="headerlink" href="#concept_2" title="Permanent link">&para;</a></h4>
<ul>
<li><em>Async Generator = Awaitable iterator + Resumable function</em></li>
</ul>
<p>This is similar to Generator's concept, but it has <strong>awaitable iterator</strong>. In other words, we can use <code>for co_await</code> statement for it. Kirkshoop will give you <a href="https://github.com/kirkshoop/await#async_generatort---each-value-arrives-later">clear explanation</a> for this.</p>
<h4 id="example_3">Example<a class="headerlink" href="#example_3" title="Permanent link">&para;</a></h4>
<p>I won't write hard example since I hadn't try this feature. But previous examples and explanations will help your understanding.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Infinite sequence of interger.</span>
<span class="n">async_generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">infinite</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">co_yield</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">usecase</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// for co_await statement</span>
    <span class="k">for</span> <span class="k">co_await</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">infinite</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// do something with `v`...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<p>I sad <code>iterator</code> is awaitable. So real code of <code>usecase</code> will be like following.</p>
<div class="codehilite"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">usecase</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// generator with awaitable(async) iterator</span>
    <span class="n">async_generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gen</span> <span class="o">=</span> <span class="n">infinite</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">gen</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  <span class="c1">// `co_await` + `begin()` </span>
         <span class="n">iter</span> <span class="o">!=</span> <span class="n">gen</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>     <span class="c1">// `end()` has nullptr</span>
         <span class="k">co_await</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="c1">// `co_await` + `operator++()` </span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<p>The only difference form <code>generator&lt;T&gt;</code> example is that the function is awaiting iterator at 2 points. <code>begin()</code> and <code>operator++()</code>. These are points for resume operation.</p>
<p>Here, value type is primitive type <code>int</code>. So there won't be complex code here. The following code shows how to make awaitable iterator. The other code for generator body and <code>promise_type</code> is exactly same with <code>std::experimental::generator&lt;T&gt;</code></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Actually, generator is not async. Its iterator is async(awaitable).</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">async_generator</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">promise_type</span><span class="p">;</span>    <span class="c1">// Same with experimental generator</span>

    <span class="c1">// We will implement awaitable interface...</span>
    <span class="k">struct</span> <span class="nl">iterator</span> <span class="p">:</span>
            <span class="n">std</span><span class="o">::</span><span class="n">iterator</span><span class="o">&lt;</span><span class="n">input_iterator_tag</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">chp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

        <span class="c1">// ...</span>
        <span class="n">iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">iterator</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">();</span>
        <span class="c1">// ...</span>
        <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="c1">// promise_type has constant pointer to value</span>
            <span class="k">const</span> <span class="n">promise_type</span><span class="o">&amp;</span> <span class="n">prom</span> <span class="o">=</span> <span class="n">chp</span><span class="p">.</span><span class="n">promise</span><span class="p">();</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">prom</span><span class="p">.</span><span class="n">pvalue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>

        <span class="c1">// Since this is syntactic example, there is no suspension.</span>
        <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// With no suspension, there is nothing to do with handle.</span>
        <span class="kt">void</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">hcoro</span><span class="p">)</span> <span class="p">{}</span>

        <span class="c1">// Return awaitable iterator at resume point</span>
        <span class="n">iterator</span> <span class="n">await_resume</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span><span class="c1">// iterator</span>

<span class="p">};</span><span class="c1">// async_generator</span>
</code></pre></div>


<p>By adding 3 member functions for <code>iterator</code>, we could make it awaitable and became available to use <code>for co_await</code> statement. But as I mentioned at <strong>Awaitable Interface</strong> section, you don't have to add member function.</p>
<div class="codehilite"><pre><span></span><code><span class="k">using</span> <span class="n">iter_type</span> <span class="o">=</span> <span class="n">async_generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">(</span><span class="n">iter_type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">iter_type</span> <span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
                   <span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">hcoro</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// do for suspension...</span>
<span class="p">}</span>

<span class="n">iter_type</span><span class="o">&amp;</span> <span class="n">await_resume</span><span class="p">(</span><span class="n">iter_type</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">it</span><span class="p">;</span>    <span class="c1">// forward the reference</span>
<span class="p">}</span>
</code></pre></div>


<p>Adding these helper functions for old types will work fine.</p>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>So, we have traveled MSVC coroutine from concept to code. That's all.
I wish I made helpful description.</p>
<p>I'd like to add disassembly experience about this feature, but I can't make it because I'm a beginner for that ability. I will try that topic later.</p>
<p>I couldn't make this article in more detail. Maybe there could be a chance to update this...! :D</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../../ppt/Exploring-the-Cpp-Coroutine/" title="C++ Korea 5th Seminar" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                C++ Korea 5th Seminar
              </span>
            </div>
          </a>
        
        
          <a href="../awaitable-event/" title="Awaitable event using the coroutine, epoll and eventfd" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Awaitable event using the coroutine, epoll and eventfd
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            CC-BY-4.0 https://creativecommons.org/licenses/by/4.0/deed
          </div>
        
        powered by
        <a href="https://www.mkdocs.org" target="_blank" rel="noopener">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/luncliff" target="_blank" rel="noopener" title="github" class="md-footer-social__link fa fa-github"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.c33a9706.js"></script>
      
      <script>app.initialize({version:"1.1",url:{base:"../.."}})</script>
      
    
  </body>
</html>