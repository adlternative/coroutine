{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Home/","text":"The document follows master branch Welcome to the luncliff/coroutine wiki! Please explore the pages with this link(GitHub Pages) If you have opinion for the docs, please create an issue and suggest your idea. Let me hear you and write more helpful contents. :D First with the C++ 20 Coroutines? \u00b6 If you're longing for the good references , visit the MattPD's collection ! If you want to run it now , there is a little example(Compiler Explorer) Developer Note \u00b6 This example project started with the post in 2017.02 . Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here! Articles Awaitable event using coroutine, epoll , and eventfd Designing the coroutine channel Combining C++ coroutines and pthread_create Russian Roulette and C++ Coroutines Windows DLL linking issues(WIP) Library Features \u00b6 Please check the navigation tab to explore the features. You can run them using the test codes in this repo. Clone the master branch and start your dive! :)","title":"Home"},{"location":"Home/#first-with-the-c-20-coroutines","text":"If you're longing for the good references , visit the MattPD's collection ! If you want to run it now , there is a little example(Compiler Explorer)","title":"First with the C++ 20 Coroutines?"},{"location":"Home/#developer-note","text":"This example project started with the post in 2017.02 . Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here! Articles Awaitable event using coroutine, epoll , and eventfd Designing the coroutine channel Combining C++ coroutines and pthread_create Russian Roulette and C++ Coroutines Windows DLL linking issues(WIP)","title":"Developer Note"},{"location":"Home/#library-features","text":"Please check the navigation tab to explore the features. You can run them using the test codes in this repo. Clone the master branch and start your dive! :)","title":"Library Features"},{"location":"_Footer/","text":"This work is licensed under a Creative Commons Attribution 4.0 International License .","title":" Footer"},{"location":"annotated/","text":"Class List \u00b6 Here are the classes, structs, unions and interfaces with brief descriptions: struct clang_frame_prefix namespace coro struct bypass_lock class channel class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class enumerable class iterator class promise_type class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type namespace internal class list class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class kqueue_owner RAII wrapping for kqueue file descriptor. class peeker class promise_aa class promise_an class promise_na class promise_nn class pthread_detacher_t Special return type that wraps pthread_detach __ class promise_type class pthread_joiner_t Special return type that wraps pthread_join __ class promise_type class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class reader class section Standard lockable with win32 criticial section. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. class writer struct gcc_frame_prefix namespace gsl struct msvc_frame_prefix namespace std namespace experimental class coroutine_handle class coroutine_handle< noop_coroutine_promise > class coroutine_handle< void > union prefix_t struct coroutine_traits struct noop_coroutine_promise class suspend_always class suspend_never namespace chrono","title":"Class List"},{"location":"annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: struct clang_frame_prefix namespace coro struct bypass_lock class channel class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class enumerable class iterator class promise_type class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type namespace internal class list class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class kqueue_owner RAII wrapping for kqueue file descriptor. class peeker class promise_aa class promise_an class promise_na class promise_nn class pthread_detacher_t Special return type that wraps pthread_detach __ class promise_type class pthread_joiner_t Special return type that wraps pthread_join __ class promise_type class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class reader class section Standard lockable with win32 criticial section. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. class writer struct gcc_frame_prefix namespace gsl struct msvc_frame_prefix namespace std namespace experimental class coroutine_handle class coroutine_handle< noop_coroutine_promise > class coroutine_handle< void > union prefix_t struct coroutine_traits struct noop_coroutine_promise class suspend_always class suspend_never namespace chrono","title":"Class List"},{"location":"channel_8hpp/","text":"File channel.hpp \u00b6 File List > interface > internal > channel.hpp Go to the source code of this file. #include <mutex> #include <tuple> Namespaces \u00b6 Type Name namespace coro namespace internal Classes \u00b6 Type Name struct bypass_lock class channel <T, M> class channel <T, M> class list <T> class peeker <typename T, typename M> class peeker <typename T, typename M> class reader <typename T, typename M> class reader <typename T, typename M> class writer <typename T, typename M> class writer <typename T, typename M> Macros \u00b6 Type Name define LUNCLIFF_COROUTINE_CHANNEL_HPP Macro Definition Documentation \u00b6 define LUNCLIFF_COROUTINE_CHANNEL_HPP \u00b6 #define LUNCLIFF_COROUTINE_CHANNEL_HPP The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"File channel.hpp"},{"location":"channel_8hpp/#file-channelhpp","text":"File List > interface > internal > channel.hpp Go to the source code of this file. #include <mutex> #include <tuple>","title":"File channel.hpp"},{"location":"channel_8hpp/#namespaces","text":"Type Name namespace coro namespace internal","title":"Namespaces"},{"location":"channel_8hpp/#classes","text":"Type Name struct bypass_lock class channel <T, M> class channel <T, M> class list <T> class peeker <typename T, typename M> class peeker <typename T, typename M> class reader <typename T, typename M> class reader <typename T, typename M> class writer <typename T, typename M> class writer <typename T, typename M>","title":"Classes"},{"location":"channel_8hpp/#macros","text":"Type Name define LUNCLIFF_COROUTINE_CHANNEL_HPP","title":"Macros"},{"location":"channel_8hpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"channel_8hpp/#define-luncliff95coroutine95channel95hpp","text":"#define LUNCLIFF_COROUTINE_CHANNEL_HPP The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"define LUNCLIFF_COROUTINE_CHANNEL_HPP"},{"location":"channel_8hpp_source/","text":"File channel.hpp \u00b6 File List > interface > internal > channel.hpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // Note // Coroutine based channel // This is a simplified form of channel in The Go Language // #pragma once #ifndef LUNCLIFF_COROUTINE_CHANNEL_HPP #define LUNCLIFF_COROUTINE_CHANNEL_HPP #if __has_include(<coroutine>) // C++ 20 #include <coroutine> #elif __has_include(<coroutine/frame.h>) #include <coroutine/frame.h> #elif __has_include(<experimental/coroutine>) // C++ 17 #include <experimental/coroutine> #else #error \"expect header <experimental/coroutine> or <coroutine/frame.h>\" #endif #include <mutex> #include <tuple> namespace coro { using namespace std ; using namespace std :: experimental ; // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } }; namespace internal { // A non-null address that leads access violation static inline void * poison () noexcept ( false ) { return reinterpret_cast < void *> ( 0xFADE ' 03 8 C ' BCFA ' 9E64 ); } // Linked list without allocation template < typename T > class list { using node_type = T ; node_type * head {}; node_type * tail {}; public : list () noexcept = default ; public : bool is_empty () const noexcept ( false ) { return head == nullptr ; } void push ( node_type * node ) noexcept ( false ) { if ( tail ) { tail -> next = node ; tail = node ; } else head = tail = node ; } auto pop () noexcept ( false ) -> node_type * { node_type * node = head ; if ( head == tail ) // empty or 1 head = tail = nullptr ; else // 2 or more head = head -> next ; return node ; // this can be nullptr } }; } // namespace internal template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class peeker ; // Awaitable for channel's read operation template < typename T , typename M > class reader { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader_list = typename channel_type :: reader_list ; using writer = typename channel_type :: writer ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend writer ; friend peeker ; friend reader_list ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ) : ptr {}, frame { nullptr }, chan { addressof ( ch )} { } reader ( const reader & ) noexcept = delete ; reader & operator = ( const reader & ) noexcept = delete ; reader ( reader && ) noexcept = delete ; reader & operator = ( reader && ) noexcept = delete ; public : ~ reader () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> writer_list :: is_empty ()) // await_suspend will unlock in the case return false ; writer * w = chan -> writer_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . reader_list :: push ( this ); // push to channel ch . mtx . unlock (); } auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; // Awaitable for channel's write operation template < typename T , typename M > class writer final { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader = typename channel_type :: reader ; using reader_list = typename channel_type :: reader_list ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend reader ; friend peeker ; friend writer_list ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ) : ptr { pv }, frame { nullptr }, chan { addressof ( ch )} { } writer ( const writer & ) noexcept = delete ; writer & operator = ( const writer & ) noexcept = delete ; writer ( writer && ) noexcept = delete ; writer & operator = ( writer && ) noexcept = delete ; public : ~ writer () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> reader_list :: is_empty ()) // await_suspend will unlock in the case return false ; reader * r = chan -> reader_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , r -> ptr ); swap ( this -> frame , r -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . writer_list :: push ( this ); // push to channel ch . mtx . unlock (); } bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); public : using value_type = T ; using pointer = value_type * ; using reference = value_type & ; using mutex_type = M ; private : using reader = reader < value_type , mutex_type > ; using reader_list = internal :: list < reader > ; using writer = writer < value_type , mutex_type > ; using writer_list = internal :: list < writer > ; using peeker = peeker < value_type , mutex_type > ; friend reader ; friend writer ; friend peeker ; private : mutex_type mtx {}; private : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; public : channel () noexcept ( false ) : reader_list {}, writer_list {}, mtx {} { // initialized 2 linked list and given mutex } ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; // // If the channel is raced hardly, some coroutines can be // enqueued into list just after this destructor unlocks mutex. // // Unfortunately, this can't be detected at once since // we have 2 list (readers/writers) in the channel. // // Current implementation allows checking repeatedly to reduce the // probability of such interleaving. // Increase the repeat count below if the situation occurs. // But notice that it is NOT zero. // size_t repeat = 1 ; // author experienced 5'000+ for hazard usage while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); coro . resume (); } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); } } } public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; using reader = typename channel_type :: reader ; using writer = typename channel_type :: writer ; private : peeker ( const peeker & ) noexcept ( false ) = delete ; peeker ( peeker && ) noexcept ( false ) = delete ; peeker & operator = ( const peeker & ) noexcept ( false ) = delete ; peeker & operator = ( peeker && ) noexcept ( false ) = delete ; public : explicit peeker ( channel_type & ch ) noexcept ( false ) : reader { ch } { } ~ peeker () noexcept = default ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { select ( ch , forward < FuncType &&> ( fn )); // evaluate return select ( forward < Args &&> ( args )...); // try next pair } } // namespace coro #endif // LUNCLIFF_COROUTINE_CHANNEL_HPP","title":"File channel.hpp"},{"location":"channel_8hpp_source/#file-channelhpp","text":"File List > interface > internal > channel.hpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // Note // Coroutine based channel // This is a simplified form of channel in The Go Language // #pragma once #ifndef LUNCLIFF_COROUTINE_CHANNEL_HPP #define LUNCLIFF_COROUTINE_CHANNEL_HPP #if __has_include(<coroutine>) // C++ 20 #include <coroutine> #elif __has_include(<coroutine/frame.h>) #include <coroutine/frame.h> #elif __has_include(<experimental/coroutine>) // C++ 17 #include <experimental/coroutine> #else #error \"expect header <experimental/coroutine> or <coroutine/frame.h>\" #endif #include <mutex> #include <tuple> namespace coro { using namespace std ; using namespace std :: experimental ; // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } }; namespace internal { // A non-null address that leads access violation static inline void * poison () noexcept ( false ) { return reinterpret_cast < void *> ( 0xFADE ' 03 8 C ' BCFA ' 9E64 ); } // Linked list without allocation template < typename T > class list { using node_type = T ; node_type * head {}; node_type * tail {}; public : list () noexcept = default ; public : bool is_empty () const noexcept ( false ) { return head == nullptr ; } void push ( node_type * node ) noexcept ( false ) { if ( tail ) { tail -> next = node ; tail = node ; } else head = tail = node ; } auto pop () noexcept ( false ) -> node_type * { node_type * node = head ; if ( head == tail ) // empty or 1 head = tail = nullptr ; else // 2 or more head = head -> next ; return node ; // this can be nullptr } }; } // namespace internal template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class peeker ; // Awaitable for channel's read operation template < typename T , typename M > class reader { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader_list = typename channel_type :: reader_list ; using writer = typename channel_type :: writer ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend writer ; friend peeker ; friend reader_list ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ) : ptr {}, frame { nullptr }, chan { addressof ( ch )} { } reader ( const reader & ) noexcept = delete ; reader & operator = ( const reader & ) noexcept = delete ; reader ( reader && ) noexcept = delete ; reader & operator = ( reader && ) noexcept = delete ; public : ~ reader () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> writer_list :: is_empty ()) // await_suspend will unlock in the case return false ; writer * w = chan -> writer_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . reader_list :: push ( this ); // push to channel ch . mtx . unlock (); } auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; // Awaitable for channel's write operation template < typename T , typename M > class writer final { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader = typename channel_type :: reader ; using reader_list = typename channel_type :: reader_list ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend reader ; friend peeker ; friend writer_list ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ) : ptr { pv }, frame { nullptr }, chan { addressof ( ch )} { } writer ( const writer & ) noexcept = delete ; writer & operator = ( const writer & ) noexcept = delete ; writer ( writer && ) noexcept = delete ; writer & operator = ( writer && ) noexcept = delete ; public : ~ writer () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> reader_list :: is_empty ()) // await_suspend will unlock in the case return false ; reader * r = chan -> reader_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , r -> ptr ); swap ( this -> frame , r -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . writer_list :: push ( this ); // push to channel ch . mtx . unlock (); } bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); public : using value_type = T ; using pointer = value_type * ; using reference = value_type & ; using mutex_type = M ; private : using reader = reader < value_type , mutex_type > ; using reader_list = internal :: list < reader > ; using writer = writer < value_type , mutex_type > ; using writer_list = internal :: list < writer > ; using peeker = peeker < value_type , mutex_type > ; friend reader ; friend writer ; friend peeker ; private : mutex_type mtx {}; private : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; public : channel () noexcept ( false ) : reader_list {}, writer_list {}, mtx {} { // initialized 2 linked list and given mutex } ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; // // If the channel is raced hardly, some coroutines can be // enqueued into list just after this destructor unlocks mutex. // // Unfortunately, this can't be detected at once since // we have 2 list (readers/writers) in the channel. // // Current implementation allows checking repeatedly to reduce the // probability of such interleaving. // Increase the repeat count below if the situation occurs. // But notice that it is NOT zero. // size_t repeat = 1 ; // author experienced 5'000+ for hazard usage while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); coro . resume (); } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); } } } public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; using reader = typename channel_type :: reader ; using writer = typename channel_type :: writer ; private : peeker ( const peeker & ) noexcept ( false ) = delete ; peeker ( peeker && ) noexcept ( false ) = delete ; peeker & operator = ( const peeker & ) noexcept ( false ) = delete ; peeker & operator = ( peeker && ) noexcept ( false ) = delete ; public : explicit peeker ( channel_type & ch ) noexcept ( false ) : reader { ch } { } ~ peeker () noexcept = default ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { select ( ch , forward < FuncType &&> ( fn )); // evaluate return select ( forward < Args &&> ( args )...); // try next pair } } // namespace coro #endif // LUNCLIFF_COROUTINE_CHANNEL_HPP","title":"File channel.hpp"},{"location":"class_member_enums/","text":"Class Member Enums \u00b6","title":"Class Member Enums"},{"location":"class_member_enums/#class-member-enums","text":"","title":"Class Member Enums"},{"location":"class_member_functions/","text":"Class Member Functions \u00b6 a \u00b6 await_ready ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) acquire ( coro::peeker ) await_transform ( coro::pthread_spawn_promise ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) b \u00b6 begin ( coro::enumerable ) c \u00b6 channel ( coro::channel ) continue_on_apc ( coro::continue_on_apc ) create_and_submit_work ( coro::continue_on_thread_pool ) change ( coro::kqueue_owner ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) d \u00b6 destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) e \u00b6 end ( coro::enumerable ) enumerable ( coro::enumerable ) epoll_owner ( coro::epoll_owner ) event ( coro::event ) error ( coro::io_work_t ) events ( coro::kqueue_owner ) f \u00b6 fd ( coro::event ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle ) g \u00b6 get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) i \u00b6 iterator ( coro::enumerable::iterator ) is_set ( coro::event ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_spawn_promise ) k \u00b6 kqueue_owner ( coro::kqueue_owner ) l \u00b6 lock ( coro::bypass_lock , coro::section ) list ( coro::internal::list ) o \u00b6 operator= ( coro::channel , coro::enumerable , coro::epoll_owner , coro::event , coro::kqueue_owner , coro::peeker , coro::reader , coro::section , coro::set_or_cancel , coro::writer , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator!= ( coro::enumerable::iterator ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator pthread_t ( coro::pthread_knower_t ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > ) p \u00b6 pop ( coro::internal::list ) push ( coro::internal::list ) peek ( coro::peeker ) peeker ( coro::peeker ) pthread_detacher_t ( coro::pthread_detacher_t ) pthread_joiner_t ( coro::pthread_joiner_t ) pthread_knower_t ( coro::pthread_knower_t ) pthread_resume ( coro::pthread_spawner_t ) pthread_spawner_t ( coro::pthread_spawner_t ) promise ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > ) q \u00b6 queue_user_apc ( coro::continue_on_apc ) r \u00b6 read ( coro::channel ) resume_on_apc ( coro::continue_on_apc ) resume_on_thread_pool ( coro::continue_on_thread_pool ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) remove ( coro::epoll_owner ) reset ( coro::event ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) resume_on_pthread ( coro::pthread_spawner_t ) reader ( coro::reader ) s \u00b6 submit ( coro::epoll_owner , coro::kqueue_owner ) set ( coro::event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::set_or_cancel ) section ( coro::section ) set_or_cancel ( coro::set_or_cancel ) t \u00b6 try_lock ( coro::bypass_lock , coro::section ) try_add ( coro::epoll_owner ) try_detach ( coro::pthread_detacher_t ) try_join ( coro::pthread_joiner_t ) u \u00b6 unlock ( coro::bypass_lock , coro::section ) unhandled_exception ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_spawn_promise ) unregister ( coro::set_or_cancel ) w \u00b6 write ( coro::channel ) wait ( coro::epoll_owner ) writer ( coro::writer ) y \u00b6 yield_value ( coro::enumerable::promise_type ) ~ \u00b6 ~channel ( coro::channel ) ~enumerable ( coro::enumerable ) ~epoll_owner ( coro::epoll_owner ) ~event ( coro::event ) ~kqueue_owner ( coro::kqueue_owner ) ~peeker ( coro::peeker ) ~pthread_detacher_t ( coro::pthread_detacher_t ) ~pthread_joiner_t ( coro::pthread_joiner_t ) ~pthread_spawner_t ( coro::pthread_spawner_t ) ~reader ( coro::reader ) ~section ( coro::section ) ~set_or_cancel ( coro::set_or_cancel ) ~writer ( coro::writer ) ~coroutine_handle ( std::experimental::coroutine_handle< void > )","title":"Class Member Functions"},{"location":"class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"class_member_functions/#a","text":"await_ready ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) acquire ( coro::peeker ) await_transform ( coro::pthread_spawn_promise ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"a"},{"location":"class_member_functions/#b","text":"begin ( coro::enumerable )","title":"b"},{"location":"class_member_functions/#c","text":"channel ( coro::channel ) continue_on_apc ( coro::continue_on_apc ) create_and_submit_work ( coro::continue_on_thread_pool ) change ( coro::kqueue_owner ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"c"},{"location":"class_member_functions/#d","text":"destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"d"},{"location":"class_member_functions/#e","text":"end ( coro::enumerable ) enumerable ( coro::enumerable ) epoll_owner ( coro::epoll_owner ) event ( coro::event ) error ( coro::io_work_t ) events ( coro::kqueue_owner )","title":"e"},{"location":"class_member_functions/#f","text":"fd ( coro::event ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle )","title":"f"},{"location":"class_member_functions/#g","text":"get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type )","title":"g"},{"location":"class_member_functions/#i","text":"iterator ( coro::enumerable::iterator ) is_set ( coro::event ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_spawn_promise )","title":"i"},{"location":"class_member_functions/#k","text":"kqueue_owner ( coro::kqueue_owner )","title":"k"},{"location":"class_member_functions/#l","text":"lock ( coro::bypass_lock , coro::section ) list ( coro::internal::list )","title":"l"},{"location":"class_member_functions/#o","text":"operator= ( coro::channel , coro::enumerable , coro::epoll_owner , coro::event , coro::kqueue_owner , coro::peeker , coro::reader , coro::section , coro::set_or_cancel , coro::writer , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator!= ( coro::enumerable::iterator ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator pthread_t ( coro::pthread_knower_t ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"o"},{"location":"class_member_functions/#p","text":"pop ( coro::internal::list ) push ( coro::internal::list ) peek ( coro::peeker ) peeker ( coro::peeker ) pthread_detacher_t ( coro::pthread_detacher_t ) pthread_joiner_t ( coro::pthread_joiner_t ) pthread_knower_t ( coro::pthread_knower_t ) pthread_resume ( coro::pthread_spawner_t ) pthread_spawner_t ( coro::pthread_spawner_t ) promise ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"p"},{"location":"class_member_functions/#q","text":"queue_user_apc ( coro::continue_on_apc )","title":"q"},{"location":"class_member_functions/#r","text":"read ( coro::channel ) resume_on_apc ( coro::continue_on_apc ) resume_on_thread_pool ( coro::continue_on_thread_pool ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) remove ( coro::epoll_owner ) reset ( coro::event ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) resume_on_pthread ( coro::pthread_spawner_t ) reader ( coro::reader )","title":"r"},{"location":"class_member_functions/#s","text":"submit ( coro::epoll_owner , coro::kqueue_owner ) set ( coro::event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::set_or_cancel ) section ( coro::section ) set_or_cancel ( coro::set_or_cancel )","title":"s"},{"location":"class_member_functions/#t","text":"try_lock ( coro::bypass_lock , coro::section ) try_add ( coro::epoll_owner ) try_detach ( coro::pthread_detacher_t ) try_join ( coro::pthread_joiner_t )","title":"t"},{"location":"class_member_functions/#u","text":"unlock ( coro::bypass_lock , coro::section ) unhandled_exception ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_spawn_promise ) unregister ( coro::set_or_cancel )","title":"u"},{"location":"class_member_functions/#w","text":"write ( coro::channel ) wait ( coro::epoll_owner ) writer ( coro::writer )","title":"w"},{"location":"class_member_functions/#y","text":"yield_value ( coro::enumerable::promise_type )","title":"y"},{"location":"class_member_functions/#_1","text":"~channel ( coro::channel ) ~enumerable ( coro::enumerable ) ~epoll_owner ( coro::epoll_owner ) ~event ( coro::event ) ~kqueue_owner ( coro::kqueue_owner ) ~peeker ( coro::peeker ) ~pthread_detacher_t ( coro::pthread_detacher_t ) ~pthread_joiner_t ( coro::pthread_joiner_t ) ~pthread_spawner_t ( coro::pthread_spawner_t ) ~reader ( coro::reader ) ~section ( coro::section ) ~set_or_cancel ( coro::set_or_cancel ) ~writer ( coro::writer ) ~coroutine_handle ( std::experimental::coroutine_handle< void > )","title":"~"},{"location":"class_member_typedefs/","text":"Class Member Typedefs \u00b6 c \u00b6 channel_type ( coro::peeker , coro::reader , coro::writer ) d \u00b6 difference_type ( coro::enumerable::iterator ) i \u00b6 iterator_category ( coro::enumerable::iterator ) m \u00b6 mutex_type ( coro::channel ) n \u00b6 node_type ( coro::internal::list ) p \u00b6 peeker ( coro::channel , coro::reader , coro::writer ) pointer ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits ) r \u00b6 reader ( coro::channel , coro::peeker , coro::writer ) reader_list ( coro::channel , coro::reader , coro::writer ) reference ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) v \u00b6 value_type ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::peeker , coro::reader , coro::writer ) w \u00b6 writer ( coro::channel , coro::peeker , coro::reader ) writer_list ( coro::channel , coro::reader , coro::writer )","title":"Class Member Typedefs"},{"location":"class_member_typedefs/#class-member-typedefs","text":"","title":"Class Member Typedefs"},{"location":"class_member_typedefs/#c","text":"channel_type ( coro::peeker , coro::reader , coro::writer )","title":"c"},{"location":"class_member_typedefs/#d","text":"difference_type ( coro::enumerable::iterator )","title":"d"},{"location":"class_member_typedefs/#i","text":"iterator_category ( coro::enumerable::iterator )","title":"i"},{"location":"class_member_typedefs/#m","text":"mutex_type ( coro::channel )","title":"m"},{"location":"class_member_typedefs/#n","text":"node_type ( coro::internal::list )","title":"n"},{"location":"class_member_typedefs/#p","text":"peeker ( coro::channel , coro::reader , coro::writer ) pointer ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits )","title":"p"},{"location":"class_member_typedefs/#r","text":"reader ( coro::channel , coro::peeker , coro::writer ) reader_list ( coro::channel , coro::reader , coro::writer ) reference ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer )","title":"r"},{"location":"class_member_typedefs/#v","text":"value_type ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::peeker , coro::reader , coro::writer )","title":"v"},{"location":"class_member_typedefs/#w","text":"writer ( coro::channel , coro::peeker , coro::reader ) writer_list ( coro::channel , coro::reader , coro::writer )","title":"w"},{"location":"class_member_variables/","text":"Class Member Variables \u00b6 a \u00b6 attr ( coro::pthread_spawner_t ) b \u00b6 buffer ( coro::io_work_t ) c \u00b6 coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) chan ( coro::reader , coro::writer ) channel_type ( coro::reader , coro::writer ) e \u00b6 epfd ( coro::epoll_owner ) f \u00b6 factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) frame ( coro::reader , coro::writer ) flag ( msvc_frame_prefix ) h \u00b6 head ( coro::internal::list ) hobject ( coro::set_or_cancel ) i \u00b6 index ( msvc_frame_prefix ) k \u00b6 kqfd ( coro::kqueue_owner ) m \u00b6 mtx ( coro::channel ) n \u00b6 next ( coro::reader , coro::writer ) p \u00b6 peeker ( coro::channel , coro::reader , coro::writer ) promise ( coro::pthread_knower_t ) ptr ( coro::reader , coro::writer ) prefix ( std::experimental::coroutine_handle< void > ) r \u00b6 reader ( coro::channel , coro::writer ) reader_list ( coro::reader ) rwlock ( coro::section ) s \u00b6 state ( coro::event ) t \u00b6 thread ( coro::continue_on_apc ) tail ( coro::internal::list ) task ( coro::io_work_t ) tid ( coro::pthread_spawn_promise , coro::pthread_spawner_t ) v \u00b6 v ( std::experimental::coroutine_handle< noop_coroutine_promise > ) w \u00b6 writer ( coro::channel , coro::reader ) writer_list ( coro::writer ) _ \u00b6 _unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix ) @ \u00b6 @1 ( coro::reader ) @3 ( coro::writer )","title":"Class Member Variables"},{"location":"class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"class_member_variables/#a","text":"attr ( coro::pthread_spawner_t )","title":"a"},{"location":"class_member_variables/#b","text":"buffer ( coro::io_work_t )","title":"b"},{"location":"class_member_variables/#c","text":"coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) chan ( coro::reader , coro::writer ) channel_type ( coro::reader , coro::writer )","title":"c"},{"location":"class_member_variables/#e","text":"epfd ( coro::epoll_owner )","title":"e"},{"location":"class_member_variables/#f","text":"factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) frame ( coro::reader , coro::writer ) flag ( msvc_frame_prefix )","title":"f"},{"location":"class_member_variables/#h","text":"head ( coro::internal::list ) hobject ( coro::set_or_cancel )","title":"h"},{"location":"class_member_variables/#i","text":"index ( msvc_frame_prefix )","title":"i"},{"location":"class_member_variables/#k","text":"kqfd ( coro::kqueue_owner )","title":"k"},{"location":"class_member_variables/#m","text":"mtx ( coro::channel )","title":"m"},{"location":"class_member_variables/#n","text":"next ( coro::reader , coro::writer )","title":"n"},{"location":"class_member_variables/#p","text":"peeker ( coro::channel , coro::reader , coro::writer ) promise ( coro::pthread_knower_t ) ptr ( coro::reader , coro::writer ) prefix ( std::experimental::coroutine_handle< void > )","title":"p"},{"location":"class_member_variables/#r","text":"reader ( coro::channel , coro::writer ) reader_list ( coro::reader ) rwlock ( coro::section )","title":"r"},{"location":"class_member_variables/#s","text":"state ( coro::event )","title":"s"},{"location":"class_member_variables/#t","text":"thread ( coro::continue_on_apc ) tail ( coro::internal::list ) task ( coro::io_work_t ) tid ( coro::pthread_spawn_promise , coro::pthread_spawner_t )","title":"t"},{"location":"class_member_variables/#v","text":"v ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"v"},{"location":"class_member_variables/#w","text":"writer ( coro::channel , coro::reader ) writer_list ( coro::writer )","title":"w"},{"location":"class_member_variables/#_","text":"_unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix )","title":"_"},{"location":"class_member_variables/#_1","text":"@1 ( coro::reader ) @3 ( coro::writer )","title":"@"},{"location":"class_members/","text":"Class Members \u00b6 a \u00b6 await_ready ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) acquire ( coro::peeker ) await_transform ( coro::pthread_spawn_promise ) attr ( coro::pthread_spawner_t ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) b \u00b6 begin ( coro::enumerable ) buffer ( coro::io_work_t ) c \u00b6 channel ( coro::channel ) continue_on_apc ( coro::continue_on_apc ) create_and_submit_work ( coro::continue_on_thread_pool ) coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) change ( coro::kqueue_owner ) channel_type ( coro::peeker , coro::reader , coro::writer ) chan ( coro::reader , coro::writer ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) d \u00b6 difference_type ( coro::enumerable::iterator ) destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) e \u00b6 end ( coro::enumerable ) enumerable ( coro::enumerable ) epfd ( coro::epoll_owner ) epoll_owner ( coro::epoll_owner ) event ( coro::event ) error ( coro::io_work_t ) events ( coro::kqueue_owner ) f \u00b6 factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) fd ( coro::event ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) frame ( coro::reader , coro::writer ) flag ( msvc_frame_prefix ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle ) g \u00b6 get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) h \u00b6 head ( coro::internal::list ) hobject ( coro::set_or_cancel ) i \u00b6 iterator ( coro::enumerable::iterator ) iterator_category ( coro::enumerable::iterator ) is_set ( coro::event ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_spawn_promise ) index ( msvc_frame_prefix ) k \u00b6 kqfd ( coro::kqueue_owner ) kqueue_owner ( coro::kqueue_owner ) l \u00b6 lock ( coro::bypass_lock , coro::section ) list ( coro::internal::list ) m \u00b6 mtx ( coro::channel ) mutex_type ( coro::channel ) n \u00b6 node_type ( coro::internal::list ) next ( coro::reader , coro::writer ) o \u00b6 operator= ( coro::channel , coro::enumerable , coro::epoll_owner , coro::event , coro::kqueue_owner , coro::peeker , coro::reader , coro::section , coro::set_or_cancel , coro::writer , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator!= ( coro::enumerable::iterator ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator pthread_t ( coro::pthread_knower_t ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > ) p \u00b6 peeker ( coro::channel , coro::peeker , coro::reader , coro::writer ) pointer ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) pop ( coro::internal::list ) push ( coro::internal::list ) peek ( coro::peeker ) pthread_detacher_t ( coro::pthread_detacher_t ) pthread_joiner_t ( coro::pthread_joiner_t ) promise ( coro::pthread_knower_t , std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > ) pthread_knower_t ( coro::pthread_knower_t ) pthread_resume ( coro::pthread_spawner_t ) pthread_spawner_t ( coro::pthread_spawner_t ) ptr ( coro::reader , coro::writer ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits ) prefix ( std::experimental::coroutine_handle< void > ) q \u00b6 queue_user_apc ( coro::continue_on_apc ) r \u00b6 read ( coro::channel ) reader ( coro::channel , coro::peeker , coro::reader , coro::writer ) reader_list ( coro::channel , coro::reader , coro::writer ) reference ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) resume_on_apc ( coro::continue_on_apc ) resume_on_thread_pool ( coro::continue_on_thread_pool ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) remove ( coro::epoll_owner ) reset ( coro::event ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) resume_on_pthread ( coro::pthread_spawner_t ) rwlock ( coro::section ) s \u00b6 submit ( coro::epoll_owner , coro::kqueue_owner ) set ( coro::event ) state ( coro::event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::set_or_cancel ) section ( coro::section ) set_or_cancel ( coro::set_or_cancel ) t \u00b6 try_lock ( coro::bypass_lock , coro::section ) thread ( coro::continue_on_apc ) try_add ( coro::epoll_owner ) tail ( coro::internal::list ) task ( coro::io_work_t ) try_detach ( coro::pthread_detacher_t ) try_join ( coro::pthread_joiner_t ) tid ( coro::pthread_spawn_promise , coro::pthread_spawner_t ) u \u00b6 unlock ( coro::bypass_lock , coro::section ) unhandled_exception ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_spawn_promise ) unregister ( coro::set_or_cancel ) v \u00b6 value_type ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::peeker , coro::reader , coro::writer ) v ( std::experimental::coroutine_handle< noop_coroutine_promise > ) w \u00b6 write ( coro::channel ) writer ( coro::channel , coro::peeker , coro::reader , coro::writer ) writer_list ( coro::channel , coro::reader , coro::writer ) wait ( coro::epoll_owner ) y \u00b6 yield_value ( coro::enumerable::promise_type ) ~ \u00b6 ~channel ( coro::channel ) ~enumerable ( coro::enumerable ) ~epoll_owner ( coro::epoll_owner ) ~event ( coro::event ) ~kqueue_owner ( coro::kqueue_owner ) ~peeker ( coro::peeker ) ~pthread_detacher_t ( coro::pthread_detacher_t ) ~pthread_joiner_t ( coro::pthread_joiner_t ) ~pthread_spawner_t ( coro::pthread_spawner_t ) ~reader ( coro::reader ) ~section ( coro::section ) ~set_or_cancel ( coro::set_or_cancel ) ~writer ( coro::writer ) ~coroutine_handle ( std::experimental::coroutine_handle< void > ) _ \u00b6 _unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix ) @ \u00b6 @1 ( coro::reader ) @3 ( coro::writer )","title":"Class Members"},{"location":"class_members/#class-members","text":"","title":"Class Members"},{"location":"class_members/#a","text":"await_ready ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::reader , coro::set_or_cancel , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) acquire ( coro::peeker ) await_transform ( coro::pthread_spawn_promise ) attr ( coro::pthread_spawner_t ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"a"},{"location":"class_members/#b","text":"begin ( coro::enumerable ) buffer ( coro::io_work_t )","title":"b"},{"location":"class_members/#c","text":"channel ( coro::channel ) continue_on_apc ( coro::continue_on_apc ) create_and_submit_work ( coro::continue_on_thread_pool ) coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) change ( coro::kqueue_owner ) channel_type ( coro::peeker , coro::reader , coro::writer ) chan ( coro::reader , coro::writer ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"c"},{"location":"class_members/#d","text":"difference_type ( coro::enumerable::iterator ) destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"d"},{"location":"class_members/#e","text":"end ( coro::enumerable ) enumerable ( coro::enumerable ) epfd ( coro::epoll_owner ) epoll_owner ( coro::epoll_owner ) event ( coro::event ) error ( coro::io_work_t ) events ( coro::kqueue_owner )","title":"e"},{"location":"class_members/#f","text":"factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) fd ( coro::event ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) frame ( coro::reader , coro::writer ) flag ( msvc_frame_prefix ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle )","title":"f"},{"location":"class_members/#g","text":"get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type )","title":"g"},{"location":"class_members/#h","text":"head ( coro::internal::list ) hobject ( coro::set_or_cancel )","title":"h"},{"location":"class_members/#i","text":"iterator ( coro::enumerable::iterator ) iterator_category ( coro::enumerable::iterator ) is_set ( coro::event ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_spawn_promise ) index ( msvc_frame_prefix )","title":"i"},{"location":"class_members/#k","text":"kqfd ( coro::kqueue_owner ) kqueue_owner ( coro::kqueue_owner )","title":"k"},{"location":"class_members/#l","text":"lock ( coro::bypass_lock , coro::section ) list ( coro::internal::list )","title":"l"},{"location":"class_members/#m","text":"mtx ( coro::channel ) mutex_type ( coro::channel )","title":"m"},{"location":"class_members/#n","text":"node_type ( coro::internal::list ) next ( coro::reader , coro::writer )","title":"n"},{"location":"class_members/#o","text":"operator= ( coro::channel , coro::enumerable , coro::epoll_owner , coro::event , coro::kqueue_owner , coro::peeker , coro::reader , coro::section , coro::set_or_cancel , coro::writer , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator!= ( coro::enumerable::iterator ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator pthread_t ( coro::pthread_knower_t ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"o"},{"location":"class_members/#p","text":"peeker ( coro::channel , coro::peeker , coro::reader , coro::writer ) pointer ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) pop ( coro::internal::list ) push ( coro::internal::list ) peek ( coro::peeker ) pthread_detacher_t ( coro::pthread_detacher_t ) pthread_joiner_t ( coro::pthread_joiner_t ) promise ( coro::pthread_knower_t , std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > ) pthread_knower_t ( coro::pthread_knower_t ) pthread_resume ( coro::pthread_spawner_t ) pthread_spawner_t ( coro::pthread_spawner_t ) ptr ( coro::reader , coro::writer ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits ) prefix ( std::experimental::coroutine_handle< void > )","title":"p"},{"location":"class_members/#q","text":"queue_user_apc ( coro::continue_on_apc )","title":"q"},{"location":"class_members/#r","text":"read ( coro::channel ) reader ( coro::channel , coro::peeker , coro::reader , coro::writer ) reader_list ( coro::channel , coro::reader , coro::writer ) reference ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) resume_on_apc ( coro::continue_on_apc ) resume_on_thread_pool ( coro::continue_on_thread_pool ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type ) remove ( coro::epoll_owner ) reset ( coro::event ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) resume_on_pthread ( coro::pthread_spawner_t ) rwlock ( coro::section )","title":"r"},{"location":"class_members/#s","text":"submit ( coro::epoll_owner , coro::kqueue_owner ) set ( coro::event ) state ( coro::event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::set_or_cancel ) section ( coro::section ) set_or_cancel ( coro::set_or_cancel )","title":"s"},{"location":"class_members/#t","text":"try_lock ( coro::bypass_lock , coro::section ) thread ( coro::continue_on_apc ) try_add ( coro::epoll_owner ) tail ( coro::internal::list ) task ( coro::io_work_t ) try_detach ( coro::pthread_detacher_t ) try_join ( coro::pthread_joiner_t ) tid ( coro::pthread_spawn_promise , coro::pthread_spawner_t )","title":"t"},{"location":"class_members/#u","text":"unlock ( coro::bypass_lock , coro::section ) unhandled_exception ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_spawn_promise ) unregister ( coro::set_or_cancel )","title":"u"},{"location":"class_members/#v","text":"value_type ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::peeker , coro::reader , coro::writer ) v ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"v"},{"location":"class_members/#w","text":"write ( coro::channel ) writer ( coro::channel , coro::peeker , coro::reader , coro::writer ) writer_list ( coro::channel , coro::reader , coro::writer ) wait ( coro::epoll_owner )","title":"w"},{"location":"class_members/#y","text":"yield_value ( coro::enumerable::promise_type )","title":"y"},{"location":"class_members/#_1","text":"~channel ( coro::channel ) ~enumerable ( coro::enumerable ) ~epoll_owner ( coro::epoll_owner ) ~event ( coro::event ) ~kqueue_owner ( coro::kqueue_owner ) ~peeker ( coro::peeker ) ~pthread_detacher_t ( coro::pthread_detacher_t ) ~pthread_joiner_t ( coro::pthread_joiner_t ) ~pthread_spawner_t ( coro::pthread_spawner_t ) ~reader ( coro::reader ) ~section ( coro::section ) ~set_or_cancel ( coro::set_or_cancel ) ~writer ( coro::writer ) ~coroutine_handle ( std::experimental::coroutine_handle< void > )","title":"~"},{"location":"class_members/#_","text":"_unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix )","title":"_"},{"location":"class_members/#_2","text":"@1 ( coro::reader ) @3 ( coro::writer )","title":"@"},{"location":"classcoro_1_1channel/","text":"Class coro::channel \u00b6 template <typename T, typename M> Class List > coro > channel #include <channel.hpp> Inherits the following classes: coro::internal::list , coro::internal::list Public Types \u00b6 Type Name typedef M mutex_type typedef value_type * pointer typedef value_type & reference typedef T value_type Public Functions \u00b6 Type Name channel () noexcept decltype(auto) read () noexcept decltype(auto) write ( reference ref) noexcept ~channel () noexcept Public Functions inherited from coro::internal::list \u00b6 See coro::internal::list Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept Public Functions inherited from coro::internal::list \u00b6 See coro::internal::list Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept Public Types Documentation \u00b6 typedef mutex_type \u00b6 using coro :: channel < T , M >:: mutex_type = M ; typedef pointer \u00b6 using coro :: channel < T , M >:: pointer = value_type * ; typedef reference \u00b6 using coro :: channel < T , M >:: reference = value_type & ; typedef value_type \u00b6 using coro :: channel < T , M >:: value_type = T ; Public Functions Documentation \u00b6 function channel [3/3] \u00b6 inline coro :: channel :: channel () noexcept function read \u00b6 inline decltype ( auto ) coro :: channel :: read () noexcept function write \u00b6 inline decltype ( auto ) coro :: channel :: write ( reference ref ) noexcept function ~channel \u00b6 inline coro :: channel ::~ channel () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"Class coro::channel"},{"location":"classcoro_1_1channel/#class-corochannel","text":"template <typename T, typename M> Class List > coro > channel #include <channel.hpp> Inherits the following classes: coro::internal::list , coro::internal::list","title":"Class coro::channel"},{"location":"classcoro_1_1channel/#public-types","text":"Type Name typedef M mutex_type typedef value_type * pointer typedef value_type & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1channel/#public-functions","text":"Type Name channel () noexcept decltype(auto) read () noexcept decltype(auto) write ( reference ref) noexcept ~channel () noexcept","title":"Public Functions"},{"location":"classcoro_1_1channel/#public-functions-inherited-from-corointernallist","text":"See coro::internal::list Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept","title":"Public Functions inherited from coro::internal::list"},{"location":"classcoro_1_1channel/#public-functions-inherited-from-corointernallist_1","text":"See coro::internal::list Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept","title":"Public Functions inherited from coro::internal::list"},{"location":"classcoro_1_1channel/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1channel/#typedef-mutex95type","text":"using coro :: channel < T , M >:: mutex_type = M ;","title":"typedef mutex_type"},{"location":"classcoro_1_1channel/#typedef-pointer","text":"using coro :: channel < T , M >:: pointer = value_type * ;","title":"typedef pointer"},{"location":"classcoro_1_1channel/#typedef-reference","text":"using coro :: channel < T , M >:: reference = value_type & ;","title":"typedef reference"},{"location":"classcoro_1_1channel/#typedef-value95type","text":"using coro :: channel < T , M >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1channel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1channel/#function-channel-33","text":"inline coro :: channel :: channel () noexcept","title":"function channel [3/3]"},{"location":"classcoro_1_1channel/#function-read","text":"inline decltype ( auto ) coro :: channel :: read () noexcept","title":"function read"},{"location":"classcoro_1_1channel/#function-write","text":"inline decltype ( auto ) coro :: channel :: write ( reference ref ) noexcept","title":"function write"},{"location":"classcoro_1_1channel/#function-channel","text":"inline coro :: channel ::~ channel () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"function ~channel"},{"location":"classcoro_1_1continue__on__apc/","text":"Class coro::continue_on_apc \u00b6 Class List > coro > continue_on_apc Move into the designated thread's APC queue and continue the routine. More... #include <windows.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept Try to submit the coroutine to the thread's APC queue. continue_on_apc (HANDLE hThread) noexcept Detailed Description \u00b6 See also: QueueUserAPC See also: OpenThread Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool coro :: continue_on_apc :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void coro :: continue_on_apc :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: continue_on_apc :: await_suspend ( coroutine_handle < void > coro ) noexcept Parameters: coro Exception: system_error function continue_on_apc \u00b6 inline explicit coro :: continue_on_apc :: continue_on_apc ( HANDLE hThread ) noexcept Parameters: hThread Target thread's handle See also: OpenThread The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"Class coro::continue\\_on\\_apc"},{"location":"classcoro_1_1continue__on__apc/#class-corocontinue95on95apc","text":"Class List > coro > continue_on_apc Move into the designated thread's APC queue and continue the routine. More... #include <windows.h>","title":"Class coro::continue_on_apc"},{"location":"classcoro_1_1continue__on__apc/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept Try to submit the coroutine to the thread's APC queue. continue_on_apc (HANDLE hThread) noexcept","title":"Public Functions"},{"location":"classcoro_1_1continue__on__apc/#detailed-description","text":"See also: QueueUserAPC See also: OpenThread","title":"Detailed Description"},{"location":"classcoro_1_1continue__on__apc/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1continue__on__apc/#function-await95ready","text":"inline constexpr bool coro :: continue_on_apc :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1continue__on__apc/#function-await95resume","text":"inline constexpr void coro :: continue_on_apc :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1continue__on__apc/#function-await95suspend","text":"inline void coro :: continue_on_apc :: await_suspend ( coroutine_handle < void > coro ) noexcept Parameters: coro Exception: system_error","title":"function await_suspend"},{"location":"classcoro_1_1continue__on__apc/#function-continue95on95apc","text":"inline explicit coro :: continue_on_apc :: continue_on_apc ( HANDLE hThread ) noexcept Parameters: hThread Target thread's handle See also: OpenThread The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"function continue_on_apc"},{"location":"classcoro_1_1continue__on__thread__pool/","text":"Class coro::continue_on_thread_pool \u00b6 Class List > coro > continue_on_thread_pool Move into the win32 thread pool and continue the routine. More... #include <windows.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept Try to submit the coroutine to thread pool. Detailed Description \u00b6 See also: CreateThreadpoolWork See also: SubmitThreadpoolWork See also: CloseThreadpoolWork Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool coro :: continue_on_thread_pool :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void coro :: continue_on_thread_pool :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: continue_on_thread_pool :: await_suspend ( coroutine_handle < void > coro ) noexcept Parameters: coro Exception: system_error The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"Class coro::continue\\_on\\_thread\\_pool"},{"location":"classcoro_1_1continue__on__thread__pool/#class-corocontinue95on95thread95pool","text":"Class List > coro > continue_on_thread_pool Move into the win32 thread pool and continue the routine. More... #include <windows.h>","title":"Class coro::continue_on_thread_pool"},{"location":"classcoro_1_1continue__on__thread__pool/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept Try to submit the coroutine to thread pool.","title":"Public Functions"},{"location":"classcoro_1_1continue__on__thread__pool/#detailed-description","text":"See also: CreateThreadpoolWork See also: SubmitThreadpoolWork See also: CloseThreadpoolWork","title":"Detailed Description"},{"location":"classcoro_1_1continue__on__thread__pool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1continue__on__thread__pool/#function-await95ready","text":"inline constexpr bool coro :: continue_on_thread_pool :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1continue__on__thread__pool/#function-await95resume","text":"inline constexpr void coro :: continue_on_thread_pool :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1continue__on__thread__pool/#function-await95suspend","text":"inline void coro :: continue_on_thread_pool :: await_suspend ( coroutine_handle < void > coro ) noexcept Parameters: coro Exception: system_error The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"function await_suspend"},{"location":"classcoro_1_1enumerable/","text":"Class coro::enumerable \u00b6 template <typename T typename T> Class List > coro > enumerable #include <yield.hpp> Classes \u00b6 Type Name class iterator class promise_type Public Types \u00b6 Type Name typedef value_type * pointer typedef value_type & reference typedef T value_type Public Functions \u00b6 Type Name iterator begin () noexcept iterator end () noexcept enumerable (const enumerable &) = delete enumerable ( enumerable && rhs) noexcept enumerable () noexcept enumerable ( promise_type * ptr) noexcept enumerable & operator= (const enumerable &) = delete enumerable & operator= ( enumerable && rhs) noexcept ~enumerable () noexcept Public Types Documentation \u00b6 typedef pointer \u00b6 using coro :: enumerable < T >:: pointer = value_type * ; typedef reference \u00b6 using coro :: enumerable < T >:: reference = value_type & ; typedef value_type \u00b6 using coro :: enumerable < T >:: value_type = T ; Public Functions Documentation \u00b6 function begin \u00b6 inline iterator coro :: enumerable :: begin () noexcept function end \u00b6 inline iterator coro :: enumerable :: end () noexcept function enumerable [1/4] \u00b6 coro :: enumerable :: enumerable ( const enumerable & ) = delete function enumerable [2/4] \u00b6 inline coro :: enumerable :: enumerable ( enumerable && rhs ) noexcept function enumerable [3/4] \u00b6 coro :: enumerable :: enumerable () noexcept function enumerable [4/4] \u00b6 inline coro :: enumerable :: enumerable ( promise_type * ptr ) noexcept function operator= \u00b6 enumerable & coro :: enumerable :: operator = ( const enumerable & ) = delete function operator= \u00b6 inline enumerable & coro :: enumerable :: operator = ( enumerable && rhs ) noexcept function ~enumerable \u00b6 inline coro :: enumerable ::~ enumerable () noexcept The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"Class coro::enumerable"},{"location":"classcoro_1_1enumerable/#class-coroenumerable","text":"template <typename T typename T> Class List > coro > enumerable #include <yield.hpp>","title":"Class coro::enumerable"},{"location":"classcoro_1_1enumerable/#classes","text":"Type Name class iterator class promise_type","title":"Classes"},{"location":"classcoro_1_1enumerable/#public-types","text":"Type Name typedef value_type * pointer typedef value_type & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1enumerable/#public-functions","text":"Type Name iterator begin () noexcept iterator end () noexcept enumerable (const enumerable &) = delete enumerable ( enumerable && rhs) noexcept enumerable () noexcept enumerable ( promise_type * ptr) noexcept enumerable & operator= (const enumerable &) = delete enumerable & operator= ( enumerable && rhs) noexcept ~enumerable () noexcept","title":"Public Functions"},{"location":"classcoro_1_1enumerable/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1enumerable/#typedef-pointer","text":"using coro :: enumerable < T >:: pointer = value_type * ;","title":"typedef pointer"},{"location":"classcoro_1_1enumerable/#typedef-reference","text":"using coro :: enumerable < T >:: reference = value_type & ;","title":"typedef reference"},{"location":"classcoro_1_1enumerable/#typedef-value95type","text":"using coro :: enumerable < T >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1enumerable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1enumerable/#function-begin","text":"inline iterator coro :: enumerable :: begin () noexcept","title":"function begin"},{"location":"classcoro_1_1enumerable/#function-end","text":"inline iterator coro :: enumerable :: end () noexcept","title":"function end"},{"location":"classcoro_1_1enumerable/#function-enumerable-14","text":"coro :: enumerable :: enumerable ( const enumerable & ) = delete","title":"function enumerable [1/4]"},{"location":"classcoro_1_1enumerable/#function-enumerable-24","text":"inline coro :: enumerable :: enumerable ( enumerable && rhs ) noexcept","title":"function enumerable [2/4]"},{"location":"classcoro_1_1enumerable/#function-enumerable-34","text":"coro :: enumerable :: enumerable () noexcept","title":"function enumerable [3/4]"},{"location":"classcoro_1_1enumerable/#function-enumerable-44","text":"inline coro :: enumerable :: enumerable ( promise_type * ptr ) noexcept","title":"function enumerable [4/4]"},{"location":"classcoro_1_1enumerable/#function-operator","text":"enumerable & coro :: enumerable :: operator = ( const enumerable & ) = delete","title":"function operator="},{"location":"classcoro_1_1enumerable/#function-operator_1","text":"inline enumerable & coro :: enumerable :: operator = ( enumerable && rhs ) noexcept","title":"function operator="},{"location":"classcoro_1_1enumerable/#function-enumerable","text":"inline coro :: enumerable ::~ enumerable () noexcept The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"function ~enumerable"},{"location":"classcoro_1_1enumerable_1_1iterator/","text":"Class coro::enumerable::iterator \u00b6 Class List > coro > enumerable > iterator #include <yield.hpp> Public Types \u00b6 Type Name typedef ptrdiff_t difference_type typedef std::forward_iterator_tag iterator_category typedef value_type * pointer typedef value_type & reference typedef T value_type Public Attributes \u00b6 Type Name coroutine_handle < promise_type > coro Public Functions \u00b6 Type Name iterator (std::nullptr_t) noexcept iterator ( coroutine_handle < promise_type > handle) noexcept bool operator!= (const iterator & rhs) noexcept const reference operator* () noexcept iterator & operator++ (int) = delete iterator & operator++ () noexcept pointer operator-> () noexcept bool operator== (const iterator & rhs) noexcept const Public Types Documentation \u00b6 typedef difference_type \u00b6 using coro :: enumerable < T >:: iterator :: difference_type = ptrdiff_t ; typedef iterator_category \u00b6 using coro :: enumerable < T >:: iterator :: iterator_category = std :: forward_iterator_tag ; typedef pointer \u00b6 using coro :: enumerable < T >:: iterator :: pointer = value_type * ; typedef reference \u00b6 using coro :: enumerable < T >:: iterator :: reference = value_type & ; typedef value_type \u00b6 using coro :: enumerable < T >:: iterator :: value_type = T ; Public Attributes Documentation \u00b6 variable coro \u00b6 coroutine_handle < promise_type > coro :: enumerable < T >:: iterator :: coro ; Public Functions Documentation \u00b6 function iterator [1/2] \u00b6 inline explicit coro :: enumerable :: iterator :: iterator ( std :: nullptr_t ) noexcept function iterator [2/2] \u00b6 inline explicit coro :: enumerable :: iterator :: iterator ( coroutine_handle < promise_type > handle ) noexcept function operator!= \u00b6 inline bool coro :: enumerable :: iterator :: operator != ( const iterator & rhs ) noexcept const function operator* \u00b6 inline reference coro :: enumerable :: iterator :: operator * () noexcept function operator++ \u00b6 iterator & coro :: enumerable :: iterator :: operator ++ ( int ) = delete function operator++ \u00b6 inline iterator & coro :: enumerable :: iterator :: operator ++ () noexcept function operator-> \u00b6 inline pointer coro :: enumerable :: iterator :: operator -> () noexcept function operator== \u00b6 inline bool coro :: enumerable :: iterator :: operator == ( const iterator & rhs ) noexcept const The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"Class coro::enumerable::iterator"},{"location":"classcoro_1_1enumerable_1_1iterator/#class-coroenumerableiterator","text":"Class List > coro > enumerable > iterator #include <yield.hpp>","title":"Class coro::enumerable::iterator"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-types","text":"Type Name typedef ptrdiff_t difference_type typedef std::forward_iterator_tag iterator_category typedef value_type * pointer typedef value_type & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-attributes","text":"Type Name coroutine_handle < promise_type > coro","title":"Public Attributes"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-functions","text":"Type Name iterator (std::nullptr_t) noexcept iterator ( coroutine_handle < promise_type > handle) noexcept bool operator!= (const iterator & rhs) noexcept const reference operator* () noexcept iterator & operator++ (int) = delete iterator & operator++ () noexcept pointer operator-> () noexcept bool operator== (const iterator & rhs) noexcept const","title":"Public Functions"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-difference95type","text":"using coro :: enumerable < T >:: iterator :: difference_type = ptrdiff_t ;","title":"typedef difference_type"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-iterator95category","text":"using coro :: enumerable < T >:: iterator :: iterator_category = std :: forward_iterator_tag ;","title":"typedef iterator_category"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-pointer","text":"using coro :: enumerable < T >:: iterator :: pointer = value_type * ;","title":"typedef pointer"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-reference","text":"using coro :: enumerable < T >:: iterator :: reference = value_type & ;","title":"typedef reference"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-value95type","text":"using coro :: enumerable < T >:: iterator :: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1enumerable_1_1iterator/#variable-coro","text":"coroutine_handle < promise_type > coro :: enumerable < T >:: iterator :: coro ;","title":"variable coro"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-iterator-12","text":"inline explicit coro :: enumerable :: iterator :: iterator ( std :: nullptr_t ) noexcept","title":"function iterator [1/2]"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-iterator-22","text":"inline explicit coro :: enumerable :: iterator :: iterator ( coroutine_handle < promise_type > handle ) noexcept","title":"function iterator [2/2]"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator","text":"inline bool coro :: enumerable :: iterator :: operator != ( const iterator & rhs ) noexcept const","title":"function operator!="},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator42","text":"inline reference coro :: enumerable :: iterator :: operator * () noexcept","title":"function operator*"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_1","text":"iterator & coro :: enumerable :: iterator :: operator ++ ( int ) = delete","title":"function operator++"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_2","text":"inline iterator & coro :: enumerable :: iterator :: operator ++ () noexcept","title":"function operator++"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator-","text":"inline pointer coro :: enumerable :: iterator :: operator -> () noexcept","title":"function operator-&gt;"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_3","text":"inline bool coro :: enumerable :: iterator :: operator == ( const iterator & rhs ) noexcept const The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"function operator=="},{"location":"classcoro_1_1enumerable_1_1promise__type/","text":"Class coro::enumerable::promise_type \u00b6 Class List > coro > enumerable > promise_type #include <yield.hpp> Inherits the following classes: coro::promise_aa Public Functions \u00b6 Type Name promise_type * get_return_object () noexcept void return_void () noexcept void unhandled_exception () noexcept auto yield_value ( reference ref) noexcept auto yield_value ( value_type && v) noexcept Public Functions inherited from coro::promise_aa \u00b6 See coro::promise_aa Type Name suspend_always final_suspend () noexcept suspend after return suspend_always initial_suspend () noexcept suspend after invoke Public Functions Documentation \u00b6 function get_return_object \u00b6 inline promise_type * coro :: enumerable :: promise_type :: get_return_object () noexcept function return_void \u00b6 inline void coro :: enumerable :: promise_type :: return_void () noexcept function unhandled_exception \u00b6 inline void coro :: enumerable :: promise_type :: unhandled_exception () noexcept function yield_value [1/2] \u00b6 inline auto coro :: enumerable :: promise_type :: yield_value ( reference ref ) noexcept function yield_value [2/2] \u00b6 inline auto coro :: enumerable :: promise_type :: yield_value ( value_type && v ) noexcept The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"Class coro::enumerable::promise\\_type"},{"location":"classcoro_1_1enumerable_1_1promise__type/#class-coroenumerablepromise95type","text":"Class List > coro > enumerable > promise_type #include <yield.hpp> Inherits the following classes: coro::promise_aa","title":"Class coro::enumerable::promise_type"},{"location":"classcoro_1_1enumerable_1_1promise__type/#public-functions","text":"Type Name promise_type * get_return_object () noexcept void return_void () noexcept void unhandled_exception () noexcept auto yield_value ( reference ref) noexcept auto yield_value ( value_type && v) noexcept","title":"Public Functions"},{"location":"classcoro_1_1enumerable_1_1promise__type/#public-functions-inherited-from-coropromise_aa","text":"See coro::promise_aa Type Name suspend_always final_suspend () noexcept suspend after return suspend_always initial_suspend () noexcept suspend after invoke","title":"Public Functions inherited from coro::promise_aa"},{"location":"classcoro_1_1enumerable_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-get95return95object","text":"inline promise_type * coro :: enumerable :: promise_type :: get_return_object () noexcept","title":"function get_return_object"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-return95void","text":"inline void coro :: enumerable :: promise_type :: return_void () noexcept","title":"function return_void"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-unhandled95exception","text":"inline void coro :: enumerable :: promise_type :: unhandled_exception () noexcept","title":"function unhandled_exception"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-yield95value-12","text":"inline auto coro :: enumerable :: promise_type :: yield_value ( reference ref ) noexcept","title":"function yield_value [1/2]"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-yield95value-22","text":"inline auto coro :: enumerable :: promise_type :: yield_value ( value_type && v ) noexcept The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"function yield_value [2/2]"},{"location":"classcoro_1_1epoll__owner/","text":"Class coro::epoll_owner \u00b6 Class List > coro > epoll_owner RAII wrapping for epoll file descriptor. #include <linux.h> Public Functions \u00b6 Type Name epoll_owner () noexcept create a fd with epoll . Throw if the function fails. epoll_owner (const epoll_owner &) = delete epoll_owner ( epoll_owner &&) = delete epoll_owner & operator= (const epoll_owner &) = delete epoll_owner & operator= ( epoll_owner &&) = delete void remove (uint64_t fd) unbind the fd to epoll auto submit (int64_t fd, epoll_event & req) noexcept return temporary awaitable object for given event void try_add (uint64_t fd, epoll_event & req) noexcept bind the fd to epoll ptrdiff_t wait (uint32_t wait_ms, gsl::span< epoll_event > list) noexcept fetch all events for the given kqeueue descriptor ~epoll_owner () noexcept close the current epoll file descriptor Public Functions Documentation \u00b6 function epoll_owner [1/3] \u00b6 coro :: epoll_owner :: epoll_owner () noexcept See also: kqeueue Exception: system_error function epoll_owner [2/3] \u00b6 coro :: epoll_owner :: epoll_owner ( const epoll_owner & ) = delete function epoll_owner [3/3] \u00b6 coro :: epoll_owner :: epoll_owner ( epoll_owner && ) = delete function operator= \u00b6 epoll_owner & coro :: epoll_owner :: operator = ( const epoll_owner & ) = delete function operator= \u00b6 epoll_owner & coro :: epoll_owner :: operator = ( epoll_owner && ) = delete function remove \u00b6 void coro :: epoll_owner :: remove ( uint64_t fd ) Parameters: fd See also: epoll_ctl function submit \u00b6 inline auto coro :: epoll_owner :: submit ( int64_t fd , epoll_event & req ) noexcept Parameters: req input for change operation See also: change There is no guarantee of reusage of returned awaiter object When it is awaited, and req.udata is null(0), the value is set to coroutine_handle<void> auto edge_in_async ( epoll_owner & ep , int64_t fd ) -> frame_t { epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = nullptr ; co_await ep . submit ( fd , req ); } function try_add \u00b6 void coro :: epoll_owner :: try_add ( uint64_t fd , epoll_event & req ) noexcept Parameters: fd req See also: epoll_ctl Exception: system_error function wait \u00b6 ptrdiff_t coro :: epoll_owner :: wait ( uint32_t wait_ms , gsl :: span < epoll_event > list ) noexcept Parameters: wait_ms millisecond to wait list Returns: ptrdiff_t See also: epoll_wait Exception: system_error Timeout is not an error for this function function ~epoll_owner \u00b6 coro :: epoll_owner ::~ epoll_owner () noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"Class coro::epoll\\_owner"},{"location":"classcoro_1_1epoll__owner/#class-coroepoll95owner","text":"Class List > coro > epoll_owner RAII wrapping for epoll file descriptor. #include <linux.h>","title":"Class coro::epoll_owner"},{"location":"classcoro_1_1epoll__owner/#public-functions","text":"Type Name epoll_owner () noexcept create a fd with epoll . Throw if the function fails. epoll_owner (const epoll_owner &) = delete epoll_owner ( epoll_owner &&) = delete epoll_owner & operator= (const epoll_owner &) = delete epoll_owner & operator= ( epoll_owner &&) = delete void remove (uint64_t fd) unbind the fd to epoll auto submit (int64_t fd, epoll_event & req) noexcept return temporary awaitable object for given event void try_add (uint64_t fd, epoll_event & req) noexcept bind the fd to epoll ptrdiff_t wait (uint32_t wait_ms, gsl::span< epoll_event > list) noexcept fetch all events for the given kqeueue descriptor ~epoll_owner () noexcept close the current epoll file descriptor","title":"Public Functions"},{"location":"classcoro_1_1epoll__owner/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1epoll__owner/#function-epoll95owner-13","text":"coro :: epoll_owner :: epoll_owner () noexcept See also: kqeueue Exception: system_error","title":"function epoll_owner [1/3]"},{"location":"classcoro_1_1epoll__owner/#function-epoll95owner-23","text":"coro :: epoll_owner :: epoll_owner ( const epoll_owner & ) = delete","title":"function epoll_owner [2/3]"},{"location":"classcoro_1_1epoll__owner/#function-epoll95owner-33","text":"coro :: epoll_owner :: epoll_owner ( epoll_owner && ) = delete","title":"function epoll_owner [3/3]"},{"location":"classcoro_1_1epoll__owner/#function-operator","text":"epoll_owner & coro :: epoll_owner :: operator = ( const epoll_owner & ) = delete","title":"function operator="},{"location":"classcoro_1_1epoll__owner/#function-operator_1","text":"epoll_owner & coro :: epoll_owner :: operator = ( epoll_owner && ) = delete","title":"function operator="},{"location":"classcoro_1_1epoll__owner/#function-remove","text":"void coro :: epoll_owner :: remove ( uint64_t fd ) Parameters: fd See also: epoll_ctl","title":"function remove"},{"location":"classcoro_1_1epoll__owner/#function-submit","text":"inline auto coro :: epoll_owner :: submit ( int64_t fd , epoll_event & req ) noexcept Parameters: req input for change operation See also: change There is no guarantee of reusage of returned awaiter object When it is awaited, and req.udata is null(0), the value is set to coroutine_handle<void> auto edge_in_async ( epoll_owner & ep , int64_t fd ) -> frame_t { epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = nullptr ; co_await ep . submit ( fd , req ); }","title":"function submit"},{"location":"classcoro_1_1epoll__owner/#function-try95add","text":"void coro :: epoll_owner :: try_add ( uint64_t fd , epoll_event & req ) noexcept Parameters: fd req See also: epoll_ctl Exception: system_error","title":"function try_add"},{"location":"classcoro_1_1epoll__owner/#function-wait","text":"ptrdiff_t coro :: epoll_owner :: wait ( uint32_t wait_ms , gsl :: span < epoll_event > list ) noexcept Parameters: wait_ms millisecond to wait list Returns: ptrdiff_t See also: epoll_wait Exception: system_error Timeout is not an error for this function","title":"function wait"},{"location":"classcoro_1_1epoll__owner/#function-epoll95owner","text":"coro :: epoll_owner ::~ epoll_owner () noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"function ~epoll_owner"},{"location":"classcoro_1_1event/","text":"Class coro::event \u00b6 Class List > coro > event RAII + stateful eventfd __ More... #include <linux.h> Public Functions \u00b6 Type Name event () noexcept event (const event &) = delete event ( event &&) = delete uint64_t fd () noexcept const bool is_set () noexcept const event & operator= (const event &) = delete event & operator= ( event &&) = delete void reset () noexcept void set () noexcept ~event () noexcept Detailed Description \u00b6 See also: https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/is_epollexclusive_available.cc If the object is signaled( set ), the bound epoll_owner will yield suspended coroutine through epoll_event 's user data. Its object can be co_await ed multiple times Public Functions Documentation \u00b6 function event [1/3] \u00b6 coro :: event :: event () noexcept function event [2/3] \u00b6 coro :: event :: event ( const event & ) = delete function event [3/3] \u00b6 coro :: event :: event ( event && ) = delete function fd \u00b6 uint64_t coro :: event :: fd () noexcept const function is_set \u00b6 bool coro :: event :: is_set () noexcept const function operator= \u00b6 event & coro :: event :: operator = ( const event & ) = delete function operator= \u00b6 event & coro :: event :: operator = ( event && ) = delete function reset \u00b6 void coro :: event :: reset () noexcept function set \u00b6 void coro :: event :: set () noexcept function ~event \u00b6 coro :: event ::~ event () noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"Class coro::event"},{"location":"classcoro_1_1event/#class-coroevent","text":"Class List > coro > event RAII + stateful eventfd __ More... #include <linux.h>","title":"Class coro::event"},{"location":"classcoro_1_1event/#public-functions","text":"Type Name event () noexcept event (const event &) = delete event ( event &&) = delete uint64_t fd () noexcept const bool is_set () noexcept const event & operator= (const event &) = delete event & operator= ( event &&) = delete void reset () noexcept void set () noexcept ~event () noexcept","title":"Public Functions"},{"location":"classcoro_1_1event/#detailed-description","text":"See also: https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/is_epollexclusive_available.cc If the object is signaled( set ), the bound epoll_owner will yield suspended coroutine through epoll_event 's user data. Its object can be co_await ed multiple times","title":"Detailed Description"},{"location":"classcoro_1_1event/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1event/#function-event-13","text":"coro :: event :: event () noexcept","title":"function event [1/3]"},{"location":"classcoro_1_1event/#function-event-23","text":"coro :: event :: event ( const event & ) = delete","title":"function event [2/3]"},{"location":"classcoro_1_1event/#function-event-33","text":"coro :: event :: event ( event && ) = delete","title":"function event [3/3]"},{"location":"classcoro_1_1event/#function-fd","text":"uint64_t coro :: event :: fd () noexcept const","title":"function fd"},{"location":"classcoro_1_1event/#function-is95set","text":"bool coro :: event :: is_set () noexcept const","title":"function is_set"},{"location":"classcoro_1_1event/#function-operator","text":"event & coro :: event :: operator = ( const event & ) = delete","title":"function operator="},{"location":"classcoro_1_1event/#function-operator_1","text":"event & coro :: event :: operator = ( event && ) = delete","title":"function operator="},{"location":"classcoro_1_1event/#function-reset","text":"void coro :: event :: reset () noexcept","title":"function reset"},{"location":"classcoro_1_1event/#function-set","text":"void coro :: event :: set () noexcept","title":"function set"},{"location":"classcoro_1_1event/#function-event","text":"coro :: event ::~ event () noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"function ~event"},{"location":"classcoro_1_1frame__t/","text":"Class coro::frame_t \u00b6 Class List > coro > frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. More... #include <return.h> Inherits the following classes: std::experimental::coroutine_handle< void > Classes \u00b6 Type Name class promise_type Public Types inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name union prefix_t Public Attributes inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name prefix_t prefix Public Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept Public Static Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept Detailed Description \u00b6 See also: coroutine_handle<void> The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::frame\\_t"},{"location":"classcoro_1_1frame__t/#class-coroframe95t","text":"Class List > coro > frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. More... #include <return.h> Inherits the following classes: std::experimental::coroutine_handle< void >","title":"Class coro::frame_t"},{"location":"classcoro_1_1frame__t/#classes","text":"Type Name class promise_type","title":"Classes"},{"location":"classcoro_1_1frame__t/#public-types-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name union prefix_t","title":"Public Types inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#public-attributes-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name prefix_t prefix","title":"Public Attributes inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#public-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept","title":"Public Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#public-static-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept","title":"Public Static Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#detailed-description","text":"See also: coroutine_handle<void> The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Detailed Description"},{"location":"classcoro_1_1frame__t_1_1promise__type/","text":"Class coro::frame_t::promise_type \u00b6 Class List > coro > frame_t > promise_type #include <return.h> Inherits the following classes: coro::promise_na Public Functions \u00b6 Type Name frame_t get_return_object () noexcept Acquire coroutine_handle<void> from current promise and return it. void return_void () noexcept this is a void return for the coroutines void unhandled_exception () noexcept The frame_t will do nothing for exception handling. Public Functions inherited from coro::promise_na \u00b6 See coro::promise_na Type Name suspend_always final_suspend () noexcept suspend after return suspend_never initial_suspend () noexcept no suspend after invoke Public Functions Documentation \u00b6 function get_return_object \u00b6 inline frame_t coro :: frame_t :: promise_type :: get_return_object () noexcept Returns: frame_t function return_void \u00b6 inline void coro :: frame_t :: promise_type :: return_void () noexcept function unhandled_exception \u00b6 inline void coro :: frame_t :: promise_type :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::frame\\_t::promise\\_type"},{"location":"classcoro_1_1frame__t_1_1promise__type/#class-coroframe95tpromise95type","text":"Class List > coro > frame_t > promise_type #include <return.h> Inherits the following classes: coro::promise_na","title":"Class coro::frame_t::promise_type"},{"location":"classcoro_1_1frame__t_1_1promise__type/#public-functions","text":"Type Name frame_t get_return_object () noexcept Acquire coroutine_handle<void> from current promise and return it. void return_void () noexcept this is a void return for the coroutines void unhandled_exception () noexcept The frame_t will do nothing for exception handling.","title":"Public Functions"},{"location":"classcoro_1_1frame__t_1_1promise__type/#public-functions-inherited-from-coropromise_na","text":"See coro::promise_na Type Name suspend_always final_suspend () noexcept suspend after return suspend_never initial_suspend () noexcept no suspend after invoke","title":"Public Functions inherited from coro::promise_na"},{"location":"classcoro_1_1frame__t_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1frame__t_1_1promise__type/#function-get95return95object","text":"inline frame_t coro :: frame_t :: promise_type :: get_return_object () noexcept Returns: frame_t","title":"function get_return_object"},{"location":"classcoro_1_1frame__t_1_1promise__type/#function-return95void","text":"inline void coro :: frame_t :: promise_type :: return_void () noexcept","title":"function return_void"},{"location":"classcoro_1_1frame__t_1_1promise__type/#function-unhandled95exception","text":"inline void coro :: frame_t :: promise_type :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function unhandled_exception"},{"location":"classcoro_1_1internal_1_1list/","text":"Class coro::internal::list \u00b6 template <typename T> Class List > coro > internal > list #include <channel.hpp> Public Functions \u00b6 Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept Public Functions Documentation \u00b6 function is_empty \u00b6 inline bool coro :: internal :: list :: is_empty () noexcept const function list \u00b6 coro :: internal :: list :: list () noexcept function pop \u00b6 inline auto coro :: internal :: list :: pop () noexcept function push \u00b6 inline void coro :: internal :: list :: push ( node_type * node ) noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"Class coro::internal::list"},{"location":"classcoro_1_1internal_1_1list/#class-corointernallist","text":"template <typename T> Class List > coro > internal > list #include <channel.hpp>","title":"Class coro::internal::list"},{"location":"classcoro_1_1internal_1_1list/#public-functions","text":"Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept","title":"Public Functions"},{"location":"classcoro_1_1internal_1_1list/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1internal_1_1list/#function-is95empty","text":"inline bool coro :: internal :: list :: is_empty () noexcept const","title":"function is_empty"},{"location":"classcoro_1_1internal_1_1list/#function-list","text":"coro :: internal :: list :: list () noexcept","title":"function list"},{"location":"classcoro_1_1internal_1_1list/#function-pop","text":"inline auto coro :: internal :: list :: pop () noexcept","title":"function pop"},{"location":"classcoro_1_1internal_1_1list/#function-push","text":"inline void coro :: internal :: list :: push ( node_type * node ) noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"function push"},{"location":"classcoro_1_1io__recv/","text":"Class coro::io_recv \u00b6 Class List > coro > io_recv Awaitable type to perform recv I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name bool ready () noexcept const Detailed Description \u00b6 See also: recv See also: WSARecv Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_recv :: await_ready () noexcept const function await_resume \u00b6 inline int64_t coro :: io_recv :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_recv :: await_suspend ( coroutine_handle < void > t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_recv"},{"location":"classcoro_1_1io__recv/#class-coroio95recv","text":"Class List > coro > io_recv Awaitable type to perform recv I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t","title":"Class coro::io_recv"},{"location":"classcoro_1_1io__recv/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv/#public-functions","text":"Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__recv/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv/#detailed-description","text":"See also: recv See also: WSARecv","title":"Detailed Description"},{"location":"classcoro_1_1io__recv/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__recv/#function-await95ready","text":"inline bool coro :: io_recv :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__recv/#function-await95resume","text":"inline int64_t coro :: io_recv :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__recv/#function-await95suspend","text":"inline void coro :: io_recv :: await_suspend ( coroutine_handle < void > t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__recv__from/","text":"Class coro::io_recv_from \u00b6 Class List > coro > io_recv_from Awaitable type to perform recvfrom I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name bool ready () noexcept const Detailed Description \u00b6 See also: recvfrom See also: WSARecvFrom Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_recv_from :: await_ready () noexcept const function await_resume \u00b6 inline int64_t coro :: io_recv_from :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_recv_from :: await_suspend ( coroutine_handle < void > t ) noexcept Exception: std::system_error The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_recv\\_from"},{"location":"classcoro_1_1io__recv__from/#class-coroio95recv95from","text":"Class List > coro > io_recv_from Awaitable type to perform recvfrom I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t","title":"Class coro::io_recv_from"},{"location":"classcoro_1_1io__recv__from/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv__from/#public-functions","text":"Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__recv__from/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv__from/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv__from/#detailed-description","text":"See also: recvfrom See also: WSARecvFrom","title":"Detailed Description"},{"location":"classcoro_1_1io__recv__from/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__recv__from/#function-await95ready","text":"inline bool coro :: io_recv_from :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__recv__from/#function-await95resume","text":"inline int64_t coro :: io_recv_from :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__recv__from/#function-await95suspend","text":"inline void coro :: io_recv_from :: await_suspend ( coroutine_handle < void > t ) noexcept Exception: std::system_error The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__send/","text":"Class coro::io_send \u00b6 Class List > coro > io_send Awaitable type to perform send I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name bool ready () noexcept const Detailed Description \u00b6 See also: send See also: WSASend Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_send :: await_ready () noexcept const function await_resume \u00b6 inline int64_t coro :: io_send :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_send :: await_suspend ( coroutine_handle < void > t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_send"},{"location":"classcoro_1_1io__send/#class-coroio95send","text":"Class List > coro > io_send Awaitable type to perform send I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t","title":"Class coro::io_send"},{"location":"classcoro_1_1io__send/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send/#public-functions","text":"Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__send/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send/#detailed-description","text":"See also: send See also: WSASend","title":"Detailed Description"},{"location":"classcoro_1_1io__send/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__send/#function-await95ready","text":"inline bool coro :: io_send :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__send/#function-await95resume","text":"inline int64_t coro :: io_send :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__send/#function-await95suspend","text":"inline void coro :: io_send :: await_suspend ( coroutine_handle < void > t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__send__to/","text":"Class coro::io_send_to \u00b6 Class List > coro > io_send_to Awaitable type to perform sendto I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name bool ready () noexcept const Detailed Description \u00b6 See also: sendto See also: WSASendTo Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_send_to :: await_ready () noexcept const function await_resume \u00b6 inline int64_t coro :: io_send_to :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_send_to :: await_suspend ( coroutine_handle < void > t ) noexcept Exception: std::system_error The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_send\\_to"},{"location":"classcoro_1_1io__send__to/#class-coroio95send95to","text":"Class List > coro > io_send_to Awaitable type to perform sendto I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t","title":"Class coro::io_send_to"},{"location":"classcoro_1_1io__send__to/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send__to/#public-functions","text":"Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__send__to/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send__to/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send__to/#detailed-description","text":"See also: sendto See also: WSASendTo","title":"Detailed Description"},{"location":"classcoro_1_1io__send__to/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__send__to/#function-await95ready","text":"inline bool coro :: io_send_to :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__send__to/#function-await95resume","text":"inline int64_t coro :: io_send_to :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__send__to/#function-await95suspend","text":"inline void coro :: io_send_to :: await_suspend ( coroutine_handle < void > t ) noexcept Exception: std::system_error The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__work__t/","text":"Class coro::io_work_t \u00b6 Class List > coro > io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. #include <net.h> Inherits the following classes: io_control_block Inherited by the following classes: coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to Public Attributes \u00b6 Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions \u00b6 Type Name bool ready () noexcept const Public Attributes Documentation \u00b6 variable buffer \u00b6 io_buffer_t coro :: io_work_t :: buffer ; variable task \u00b6 coroutine_handle < void > coro :: io_work_t :: task ; Public Functions Documentation \u00b6 function error \u00b6 uint32_t coro :: io_work_t :: error () noexcept const Returns: uint32_t error code from the system Protected Functions Documentation \u00b6 function ready \u00b6 bool coro :: io_work_t :: ready () noexcept const See also: await_ready Returns: true The given socket can be use for non-blocking operations Returns: false For Windows, the return is always false The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_work\\_t"},{"location":"classcoro_1_1io__work__t/#class-coroio95work95t","text":"Class List > coro > io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. #include <net.h> Inherits the following classes: io_control_block Inherited by the following classes: coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to","title":"Class coro::io_work_t"},{"location":"classcoro_1_1io__work__t/#public-attributes","text":"Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes"},{"location":"classcoro_1_1io__work__t/#public-functions","text":"Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions"},{"location":"classcoro_1_1io__work__t/#protected-functions","text":"Type Name bool ready () noexcept const","title":"Protected Functions"},{"location":"classcoro_1_1io__work__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1io__work__t/#variable-buffer","text":"io_buffer_t coro :: io_work_t :: buffer ;","title":"variable buffer"},{"location":"classcoro_1_1io__work__t/#variable-task","text":"coroutine_handle < void > coro :: io_work_t :: task ;","title":"variable task"},{"location":"classcoro_1_1io__work__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__work__t/#function-error","text":"uint32_t coro :: io_work_t :: error () noexcept const Returns: uint32_t error code from the system","title":"function error"},{"location":"classcoro_1_1io__work__t/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"classcoro_1_1io__work__t/#function-ready","text":"bool coro :: io_work_t :: ready () noexcept const See also: await_ready Returns: true The given socket can be use for non-blocking operations Returns: false For Windows, the return is always false The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function ready"},{"location":"classcoro_1_1kqueue__owner/","text":"Class coro::kqueue_owner \u00b6 Class List > coro > kqueue_owner RAII wrapping for kqueue file descriptor. #include <unix.h> Public Functions \u00b6 Type Name void change (kevent64_s & req) noexcept bind the event to kqueue ptrdiff_t events (const timespec & wait_time, gsl::span< kevent64_s > list) noexcept fetch all events for the given kqeueue descriptor kqueue_owner () noexcept create a fd with kqueue . Throw if the function fails. kqueue_owner (const kqueue_owner &) = delete kqueue_owner ( kqueue_owner &&) = delete kqueue_owner & operator= (const kqueue_owner &) = delete kqueue_owner & operator= ( kqueue_owner &&) = delete auto submit (kevent64_s & req) noexcept return temporary awaitable object for given event ~kqueue_owner () noexcept close the current kqueue file descriptor Public Functions Documentation \u00b6 function change \u00b6 void coro :: kqueue_owner :: change ( kevent64_s & req ) noexcept Parameters: req See also: kevent64 Exception: system_error The function is named change because the given argument is used for 'change list' fo kqueue64 function events \u00b6 ptrdiff_t coro :: kqueue_owner :: events ( const timespec & wait_time , gsl :: span < kevent64_s > list ) noexcept Parameters: wait_time list Returns: ptrdiff_t See also: kevent64 Exception: system_error The function is named events because the given argument is used for 'event list' fo kqueue64 Timeout is not an error for this function function kqueue_owner [1/3] \u00b6 coro :: kqueue_owner :: kqueue_owner () noexcept See also: kqeueue Exception: system_error function kqueue_owner [2/3] \u00b6 coro :: kqueue_owner :: kqueue_owner ( const kqueue_owner & ) = delete function kqueue_owner [3/3] \u00b6 coro :: kqueue_owner :: kqueue_owner ( kqueue_owner && ) = delete function operator= \u00b6 kqueue_owner & coro :: kqueue_owner :: operator = ( const kqueue_owner & ) = delete function operator= \u00b6 kqueue_owner & coro :: kqueue_owner :: operator = ( kqueue_owner && ) = delete function submit \u00b6 inline auto coro :: kqueue_owner :: submit ( kevent64_s & req ) noexcept Parameters: req input for change operation See also: change There is no guarantee of reusage of returned awaiter object When it is awaited, and req.udata is null(0), the value is set to coroutine_handle<void> auto read_async ( kqueue_owner & kq , uint64_t fd ) -> frame_t { kevent64_s req {. ident = fd , . filter = EVFILT_READ , . flags = EV_ADD | EV_ENABLE | EV_ONESHOT }; co_await kq . submit ( req ); // ... co_await kq . submit ( req ); // ... } function ~kqueue_owner \u00b6 coro :: kqueue_owner ::~ kqueue_owner () noexcept The documentation for this class was generated from the following file interface/coroutine/unix.h","title":"Class coro::kqueue\\_owner"},{"location":"classcoro_1_1kqueue__owner/#class-corokqueue95owner","text":"Class List > coro > kqueue_owner RAII wrapping for kqueue file descriptor. #include <unix.h>","title":"Class coro::kqueue_owner"},{"location":"classcoro_1_1kqueue__owner/#public-functions","text":"Type Name void change (kevent64_s & req) noexcept bind the event to kqueue ptrdiff_t events (const timespec & wait_time, gsl::span< kevent64_s > list) noexcept fetch all events for the given kqeueue descriptor kqueue_owner () noexcept create a fd with kqueue . Throw if the function fails. kqueue_owner (const kqueue_owner &) = delete kqueue_owner ( kqueue_owner &&) = delete kqueue_owner & operator= (const kqueue_owner &) = delete kqueue_owner & operator= ( kqueue_owner &&) = delete auto submit (kevent64_s & req) noexcept return temporary awaitable object for given event ~kqueue_owner () noexcept close the current kqueue file descriptor","title":"Public Functions"},{"location":"classcoro_1_1kqueue__owner/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1kqueue__owner/#function-change","text":"void coro :: kqueue_owner :: change ( kevent64_s & req ) noexcept Parameters: req See also: kevent64 Exception: system_error The function is named change because the given argument is used for 'change list' fo kqueue64","title":"function change"},{"location":"classcoro_1_1kqueue__owner/#function-events","text":"ptrdiff_t coro :: kqueue_owner :: events ( const timespec & wait_time , gsl :: span < kevent64_s > list ) noexcept Parameters: wait_time list Returns: ptrdiff_t See also: kevent64 Exception: system_error The function is named events because the given argument is used for 'event list' fo kqueue64 Timeout is not an error for this function","title":"function events"},{"location":"classcoro_1_1kqueue__owner/#function-kqueue95owner-13","text":"coro :: kqueue_owner :: kqueue_owner () noexcept See also: kqeueue Exception: system_error","title":"function kqueue_owner [1/3]"},{"location":"classcoro_1_1kqueue__owner/#function-kqueue95owner-23","text":"coro :: kqueue_owner :: kqueue_owner ( const kqueue_owner & ) = delete","title":"function kqueue_owner [2/3]"},{"location":"classcoro_1_1kqueue__owner/#function-kqueue95owner-33","text":"coro :: kqueue_owner :: kqueue_owner ( kqueue_owner && ) = delete","title":"function kqueue_owner [3/3]"},{"location":"classcoro_1_1kqueue__owner/#function-operator","text":"kqueue_owner & coro :: kqueue_owner :: operator = ( const kqueue_owner & ) = delete","title":"function operator="},{"location":"classcoro_1_1kqueue__owner/#function-operator_1","text":"kqueue_owner & coro :: kqueue_owner :: operator = ( kqueue_owner && ) = delete","title":"function operator="},{"location":"classcoro_1_1kqueue__owner/#function-submit","text":"inline auto coro :: kqueue_owner :: submit ( kevent64_s & req ) noexcept Parameters: req input for change operation See also: change There is no guarantee of reusage of returned awaiter object When it is awaited, and req.udata is null(0), the value is set to coroutine_handle<void> auto read_async ( kqueue_owner & kq , uint64_t fd ) -> frame_t { kevent64_s req {. ident = fd , . filter = EVFILT_READ , . flags = EV_ADD | EV_ENABLE | EV_ONESHOT }; co_await kq . submit ( req ); // ... co_await kq . submit ( req ); // ... }","title":"function submit"},{"location":"classcoro_1_1kqueue__owner/#function-kqueue95owner","text":"coro :: kqueue_owner ::~ kqueue_owner () noexcept The documentation for this class was generated from the following file interface/coroutine/unix.h","title":"function ~kqueue_owner"},{"location":"classcoro_1_1peeker/","text":"Class coro::peeker \u00b6 template <typename T typename T, typename M typename M> Class List > coro > peeker #include <channel.hpp> Inherits the following classes: coro::reader Public Types inherited from coro::reader \u00b6 See coro::reader Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type Public Attributes inherited from coro::reader \u00b6 See coro::reader Type Name channel_type * chan reader * next = = nullptr Public Functions \u00b6 Type Name bool acquire ( value_type & storage) noexcept void peek () noexcept const peeker ( channel_type & ch) noexcept ~peeker () noexcept Public Functions inherited from coro::reader \u00b6 See coro::reader Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~reader () noexcept Protected Attributes inherited from coro::reader \u00b6 See coro::reader Type Name union coro::reader::@0 @1 void * frame pointer ptr Public Functions Documentation \u00b6 function acquire \u00b6 inline bool coro :: peeker :: acquire ( value_type & storage ) noexcept function peek \u00b6 inline void coro :: peeker :: peek () noexcept const function peeker [3/3] \u00b6 inline explicit coro :: peeker :: peeker ( channel_type & ch ) noexcept function ~peeker \u00b6 coro :: peeker ::~ peeker () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"Class coro::peeker"},{"location":"classcoro_1_1peeker/#class-coropeeker","text":"template <typename T typename T, typename M typename M> Class List > coro > peeker #include <channel.hpp> Inherits the following classes: coro::reader","title":"Class coro::peeker"},{"location":"classcoro_1_1peeker/#public-types-inherited-from-cororeader","text":"See coro::reader Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type","title":"Public Types inherited from coro::reader"},{"location":"classcoro_1_1peeker/#public-attributes-inherited-from-cororeader","text":"See coro::reader Type Name channel_type * chan reader * next = = nullptr","title":"Public Attributes inherited from coro::reader"},{"location":"classcoro_1_1peeker/#public-functions","text":"Type Name bool acquire ( value_type & storage) noexcept void peek () noexcept const peeker ( channel_type & ch) noexcept ~peeker () noexcept","title":"Public Functions"},{"location":"classcoro_1_1peeker/#public-functions-inherited-from-cororeader","text":"See coro::reader Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~reader () noexcept","title":"Public Functions inherited from coro::reader"},{"location":"classcoro_1_1peeker/#protected-attributes-inherited-from-cororeader","text":"See coro::reader Type Name union coro::reader::@0 @1 void * frame pointer ptr","title":"Protected Attributes inherited from coro::reader"},{"location":"classcoro_1_1peeker/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1peeker/#function-acquire","text":"inline bool coro :: peeker :: acquire ( value_type & storage ) noexcept","title":"function acquire"},{"location":"classcoro_1_1peeker/#function-peek","text":"inline void coro :: peeker :: peek () noexcept const","title":"function peek"},{"location":"classcoro_1_1peeker/#function-peeker-33","text":"inline explicit coro :: peeker :: peeker ( channel_type & ch ) noexcept","title":"function peeker [3/3]"},{"location":"classcoro_1_1peeker/#function-peeker","text":"coro :: peeker ::~ peeker () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"function ~peeker"},{"location":"classcoro_1_1promise__aa/","text":"Class coro::promise_aa \u00b6 Class List > coro > promise_aa #include <return.h> Inherited by the following classes: coro::enumerable::promise_type Public Functions \u00b6 Type Name suspend_always final_suspend () noexcept suspend after return suspend_always initial_suspend () noexcept suspend after invoke Public Functions Documentation \u00b6 function final_suspend \u00b6 inline suspend_always coro :: promise_aa :: final_suspend () noexcept Returns: suspend_always function initial_suspend \u00b6 inline suspend_always coro :: promise_aa :: initial_suspend () noexcept Returns: suspend_always The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_aa"},{"location":"classcoro_1_1promise__aa/#class-coropromise95aa","text":"Class List > coro > promise_aa #include <return.h> Inherited by the following classes: coro::enumerable::promise_type","title":"Class coro::promise_aa"},{"location":"classcoro_1_1promise__aa/#public-functions","text":"Type Name suspend_always final_suspend () noexcept suspend after return suspend_always initial_suspend () noexcept suspend after invoke","title":"Public Functions"},{"location":"classcoro_1_1promise__aa/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__aa/#function-final95suspend","text":"inline suspend_always coro :: promise_aa :: final_suspend () noexcept Returns: suspend_always","title":"function final_suspend"},{"location":"classcoro_1_1promise__aa/#function-initial95suspend","text":"inline suspend_always coro :: promise_aa :: initial_suspend () noexcept Returns: suspend_always The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1promise__an/","text":"Class coro::promise_an \u00b6 Class List > coro > promise_an #include <return.h> Public Functions \u00b6 Type Name suspend_never final_suspend () noexcept destroy coroutine frame after return suspend_always initial_suspend () noexcept suspend after invoke Public Functions Documentation \u00b6 function final_suspend \u00b6 inline suspend_never coro :: promise_an :: final_suspend () noexcept Returns: suspend_never function initial_suspend \u00b6 inline suspend_always coro :: promise_an :: initial_suspend () noexcept Returns: suspend_always The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_an"},{"location":"classcoro_1_1promise__an/#class-coropromise95an","text":"Class List > coro > promise_an #include <return.h>","title":"Class coro::promise_an"},{"location":"classcoro_1_1promise__an/#public-functions","text":"Type Name suspend_never final_suspend () noexcept destroy coroutine frame after return suspend_always initial_suspend () noexcept suspend after invoke","title":"Public Functions"},{"location":"classcoro_1_1promise__an/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__an/#function-final95suspend","text":"inline suspend_never coro :: promise_an :: final_suspend () noexcept Returns: suspend_never","title":"function final_suspend"},{"location":"classcoro_1_1promise__an/#function-initial95suspend","text":"inline suspend_always coro :: promise_an :: initial_suspend () noexcept Returns: suspend_always The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1promise__na/","text":"Class coro::promise_na \u00b6 Class List > coro > promise_na #include <return.h> Inherited by the following classes: coro::frame_t::promise_type Public Functions \u00b6 Type Name suspend_always final_suspend () noexcept suspend after return suspend_never initial_suspend () noexcept no suspend after invoke Public Functions Documentation \u00b6 function final_suspend \u00b6 inline suspend_always coro :: promise_na :: final_suspend () noexcept Returns: suspend_always function initial_suspend \u00b6 inline suspend_never coro :: promise_na :: initial_suspend () noexcept Returns: suspend_never The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_na"},{"location":"classcoro_1_1promise__na/#class-coropromise95na","text":"Class List > coro > promise_na #include <return.h> Inherited by the following classes: coro::frame_t::promise_type","title":"Class coro::promise_na"},{"location":"classcoro_1_1promise__na/#public-functions","text":"Type Name suspend_always final_suspend () noexcept suspend after return suspend_never initial_suspend () noexcept no suspend after invoke","title":"Public Functions"},{"location":"classcoro_1_1promise__na/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__na/#function-final95suspend","text":"inline suspend_always coro :: promise_na :: final_suspend () noexcept Returns: suspend_always","title":"function final_suspend"},{"location":"classcoro_1_1promise__na/#function-initial95suspend","text":"inline suspend_never coro :: promise_na :: initial_suspend () noexcept Returns: suspend_never The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1promise__nn/","text":"Class coro::promise_nn \u00b6 Class List > coro > promise_nn #include <return.h> Public Functions \u00b6 Type Name suspend_never final_suspend () noexcept destroy coroutine frame after return suspend_never initial_suspend () noexcept no suspend after invoke Public Functions Documentation \u00b6 function final_suspend \u00b6 inline suspend_never coro :: promise_nn :: final_suspend () noexcept Returns: suspend_never function initial_suspend \u00b6 inline suspend_never coro :: promise_nn :: initial_suspend () noexcept Returns: suspend_never The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_nn"},{"location":"classcoro_1_1promise__nn/#class-coropromise95nn","text":"Class List > coro > promise_nn #include <return.h>","title":"Class coro::promise_nn"},{"location":"classcoro_1_1promise__nn/#public-functions","text":"Type Name suspend_never final_suspend () noexcept destroy coroutine frame after return suspend_never initial_suspend () noexcept no suspend after invoke","title":"Public Functions"},{"location":"classcoro_1_1promise__nn/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__nn/#function-final95suspend","text":"inline suspend_never coro :: promise_nn :: final_suspend () noexcept Returns: suspend_never","title":"function final_suspend"},{"location":"classcoro_1_1promise__nn/#function-initial95suspend","text":"inline suspend_never coro :: promise_nn :: initial_suspend () noexcept Returns: suspend_never The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1pthread__detacher__t/","text":"Class coro::pthread_detacher_t \u00b6 Class List > coro > pthread_detacher_t Special return type that wraps pthread_detach __ #include <pthread.h> Inherits the following classes: coro::pthread_knower_t Classes \u00b6 Type Name class promise_type Public Functions \u00b6 Type Name pthread_detacher_t ( promise_type * p) noexcept ~pthread_detacher_t () noexcept Public Functions inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name operator pthread_t () noexcept const allow access to the tid __ Protected Attributes inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name pthread_spawn_promise * promise Protected Functions inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept Public Functions Documentation \u00b6 function pthread_detacher_t \u00b6 coro :: pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept Exception: invalid_argument function ~pthread_detacher_t \u00b6 inline coro :: pthread_detacher_t ::~ pthread_detacher_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_detacher\\_t"},{"location":"classcoro_1_1pthread__detacher__t/#class-coropthread95detacher95t","text":"Class List > coro > pthread_detacher_t Special return type that wraps pthread_detach __ #include <pthread.h> Inherits the following classes: coro::pthread_knower_t","title":"Class coro::pthread_detacher_t"},{"location":"classcoro_1_1pthread__detacher__t/#classes","text":"Type Name class promise_type","title":"Classes"},{"location":"classcoro_1_1pthread__detacher__t/#public-functions","text":"Type Name pthread_detacher_t ( promise_type * p) noexcept ~pthread_detacher_t () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__detacher__t/#public-functions-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name operator pthread_t () noexcept const allow access to the tid __","title":"Public Functions inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__detacher__t/#protected-attributes-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name pthread_spawn_promise * promise","title":"Protected Attributes inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__detacher__t/#protected-functions-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept","title":"Protected Functions inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__detacher__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__detacher__t/#function-pthread95detacher95t","text":"coro :: pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept Exception: invalid_argument","title":"function pthread_detacher_t"},{"location":"classcoro_1_1pthread__detacher__t/#function-pthread95detacher95t_1","text":"inline coro :: pthread_detacher_t ::~ pthread_detacher_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function ~pthread_detacher_t"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/","text":"Class coro::pthread_detacher_t::promise_type \u00b6 Class List > coro > pthread_detacher_t > promise_type #include <pthread.h> Inherits the following classes: coro::pthread_spawn_promise Public Attributes inherited from coro::pthread_spawn_promise \u00b6 See coro::pthread_spawn_promise Type Name pthread_t tid = {} Public Functions \u00b6 Type Name auto final_suspend () noexcept auto get_return_object () noexcept void return_void () noexcept Public Functions inherited from coro::pthread_spawn_promise \u00b6 See coro::pthread_spawn_promise Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling Public Functions Documentation \u00b6 function final_suspend \u00b6 inline auto coro :: pthread_detacher_t :: promise_type :: final_suspend () noexcept function get_return_object \u00b6 inline auto coro :: pthread_detacher_t :: promise_type :: get_return_object () noexcept function return_void \u00b6 inline void coro :: pthread_detacher_t :: promise_type :: return_void () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_detacher\\_t::promise\\_type"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#class-coropthread95detacher95tpromise95type","text":"Class List > coro > pthread_detacher_t > promise_type #include <pthread.h> Inherits the following classes: coro::pthread_spawn_promise","title":"Class coro::pthread_detacher_t::promise_type"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#public-attributes-inherited-from-coropthread_spawn_promise","text":"See coro::pthread_spawn_promise Type Name pthread_t tid = {}","title":"Public Attributes inherited from coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#public-functions","text":"Type Name auto final_suspend () noexcept auto get_return_object () noexcept void return_void () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#public-functions-inherited-from-coropthread_spawn_promise","text":"See coro::pthread_spawn_promise Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling","title":"Public Functions inherited from coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#function-final95suspend","text":"inline auto coro :: pthread_detacher_t :: promise_type :: final_suspend () noexcept","title":"function final_suspend"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#function-get95return95object","text":"inline auto coro :: pthread_detacher_t :: promise_type :: get_return_object () noexcept","title":"function get_return_object"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#function-return95void","text":"inline void coro :: pthread_detacher_t :: promise_type :: return_void () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function return_void"},{"location":"classcoro_1_1pthread__joiner__t/","text":"Class coro::pthread_joiner_t \u00b6 Class List > coro > pthread_joiner_t Special return type that wraps pthread_join __ More... #include <pthread.h> Inherits the following classes: coro::pthread_knower_t Classes \u00b6 Type Name class promise_type Public Functions \u00b6 Type Name pthread_joiner_t ( promise_type * p) noexcept ~pthread_joiner_t () noexcept Public Functions inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name operator pthread_t () noexcept const allow access to the tid __ Protected Attributes inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name pthread_spawn_promise * promise Protected Functions inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept Detailed Description \u00b6 See also: pthread_join Public Functions Documentation \u00b6 function pthread_joiner_t \u00b6 coro :: pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept Exception: invalid_argument function ~pthread_joiner_t \u00b6 inline coro :: pthread_joiner_t ::~ pthread_joiner_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_joiner\\_t"},{"location":"classcoro_1_1pthread__joiner__t/#class-coropthread95joiner95t","text":"Class List > coro > pthread_joiner_t Special return type that wraps pthread_join __ More... #include <pthread.h> Inherits the following classes: coro::pthread_knower_t","title":"Class coro::pthread_joiner_t"},{"location":"classcoro_1_1pthread__joiner__t/#classes","text":"Type Name class promise_type","title":"Classes"},{"location":"classcoro_1_1pthread__joiner__t/#public-functions","text":"Type Name pthread_joiner_t ( promise_type * p) noexcept ~pthread_joiner_t () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__joiner__t/#public-functions-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name operator pthread_t () noexcept const allow access to the tid __","title":"Public Functions inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__joiner__t/#protected-attributes-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name pthread_spawn_promise * promise","title":"Protected Attributes inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__joiner__t/#protected-functions-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept","title":"Protected Functions inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__joiner__t/#detailed-description","text":"See also: pthread_join","title":"Detailed Description"},{"location":"classcoro_1_1pthread__joiner__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__joiner__t/#function-pthread95joiner95t","text":"coro :: pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept Exception: invalid_argument","title":"function pthread_joiner_t"},{"location":"classcoro_1_1pthread__joiner__t/#function-pthread95joiner95t_1","text":"inline coro :: pthread_joiner_t ::~ pthread_joiner_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function ~pthread_joiner_t"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/","text":"Class coro::pthread_joiner_t::promise_type \u00b6 Class List > coro > pthread_joiner_t > promise_type #include <pthread.h> Inherits the following classes: coro::pthread_spawn_promise Public Attributes inherited from coro::pthread_spawn_promise \u00b6 See coro::pthread_spawn_promise Type Name pthread_t tid = {} Public Functions \u00b6 Type Name auto final_suspend () noexcept auto get_return_object () noexcept void return_void () noexcept Public Functions inherited from coro::pthread_spawn_promise \u00b6 See coro::pthread_spawn_promise Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling Public Functions Documentation \u00b6 function final_suspend \u00b6 inline auto coro :: pthread_joiner_t :: promise_type :: final_suspend () noexcept function get_return_object \u00b6 inline auto coro :: pthread_joiner_t :: promise_type :: get_return_object () noexcept function return_void \u00b6 inline void coro :: pthread_joiner_t :: promise_type :: return_void () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_joiner\\_t::promise\\_type"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#class-coropthread95joiner95tpromise95type","text":"Class List > coro > pthread_joiner_t > promise_type #include <pthread.h> Inherits the following classes: coro::pthread_spawn_promise","title":"Class coro::pthread_joiner_t::promise_type"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#public-attributes-inherited-from-coropthread_spawn_promise","text":"See coro::pthread_spawn_promise Type Name pthread_t tid = {}","title":"Public Attributes inherited from coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#public-functions","text":"Type Name auto final_suspend () noexcept auto get_return_object () noexcept void return_void () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#public-functions-inherited-from-coropthread_spawn_promise","text":"See coro::pthread_spawn_promise Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling","title":"Public Functions inherited from coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#function-final95suspend","text":"inline auto coro :: pthread_joiner_t :: promise_type :: final_suspend () noexcept","title":"function final_suspend"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#function-get95return95object","text":"inline auto coro :: pthread_joiner_t :: promise_type :: get_return_object () noexcept","title":"function get_return_object"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#function-return95void","text":"inline void coro :: pthread_joiner_t :: promise_type :: return_void () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function return_void"},{"location":"classcoro_1_1pthread__knower__t/","text":"Class coro::pthread_knower_t \u00b6 Class List > coro > pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. #include <pthread.h> Inherited by the following classes: coro::pthread_detacher_t , coro::pthread_joiner_t Public Functions \u00b6 Type Name operator pthread_t () noexcept const allow access to the tid __ Protected Attributes \u00b6 Type Name pthread_spawn_promise * promise Protected Functions \u00b6 Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept Public Functions Documentation \u00b6 function operator pthread_t \u00b6 inline coro :: pthread_knower_t :: operator pthread_t () noexcept const Returns: pthread_t Protected Attributes Documentation \u00b6 variable promise \u00b6 pthread_spawn_promise * coro :: pthread_knower_t :: promise ; Protected Functions Documentation \u00b6 function pthread_knower_t \u00b6 inline explicit coro :: pthread_knower_t :: pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_knower\\_t"},{"location":"classcoro_1_1pthread__knower__t/#class-coropthread95knower95t","text":"Class List > coro > pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. #include <pthread.h> Inherited by the following classes: coro::pthread_detacher_t , coro::pthread_joiner_t","title":"Class coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__knower__t/#public-functions","text":"Type Name operator pthread_t () noexcept const allow access to the tid __","title":"Public Functions"},{"location":"classcoro_1_1pthread__knower__t/#protected-attributes","text":"Type Name pthread_spawn_promise * promise","title":"Protected Attributes"},{"location":"classcoro_1_1pthread__knower__t/#protected-functions","text":"Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept","title":"Protected Functions"},{"location":"classcoro_1_1pthread__knower__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__knower__t/#function-operator-pthread95t","text":"inline coro :: pthread_knower_t :: operator pthread_t () noexcept const Returns: pthread_t","title":"function operator pthread_t"},{"location":"classcoro_1_1pthread__knower__t/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"classcoro_1_1pthread__knower__t/#variable-promise","text":"pthread_spawn_promise * coro :: pthread_knower_t :: promise ;","title":"variable promise"},{"location":"classcoro_1_1pthread__knower__t/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"classcoro_1_1pthread__knower__t/#function-pthread95knower95t","text":"inline explicit coro :: pthread_knower_t :: pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function pthread_knower_t"},{"location":"classcoro_1_1pthread__spawn__promise/","text":"Class coro::pthread_spawn_promise \u00b6 Class List > coro > pthread_spawn_promise allows pthread_attr_t* for co_await operator More... #include <pthread.h> Inherited by the following classes: coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type Public Attributes \u00b6 Type Name pthread_t tid = {} Public Functions \u00b6 Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling Detailed Description \u00b6 See also: pthread_create See also: pthread_attr_t The type wraps pthread_create function. After spawn, it contains thread id of the brand-new thread. Public Attributes Documentation \u00b6 variable tid \u00b6 pthread_t coro :: pthread_spawn_promise :: tid ; Public Functions Documentation \u00b6 function await_transform [1/3] \u00b6 inline auto coro :: pthread_spawn_promise :: await_transform ( const pthread_attr_t * attr ) noexcept function await_transform [2/3] \u00b6 inline auto coro :: pthread_spawn_promise :: await_transform ( pthread_attr_t * attr ) noexcept function await_transform [3/3] \u00b6 template < typename Awaitable typename Awaitable > inline decltype ( auto ) coro :: pthread_spawn_promise :: await_transform ( Awaitable && a ) noexcept function initial_suspend \u00b6 inline auto coro :: pthread_spawn_promise :: initial_suspend () noexcept function unhandled_exception \u00b6 inline void coro :: pthread_spawn_promise :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_spawn\\_promise"},{"location":"classcoro_1_1pthread__spawn__promise/#class-coropthread95spawn95promise","text":"Class List > coro > pthread_spawn_promise allows pthread_attr_t* for co_await operator More... #include <pthread.h> Inherited by the following classes: coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type","title":"Class coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__spawn__promise/#public-attributes","text":"Type Name pthread_t tid = {}","title":"Public Attributes"},{"location":"classcoro_1_1pthread__spawn__promise/#public-functions","text":"Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling","title":"Public Functions"},{"location":"classcoro_1_1pthread__spawn__promise/#detailed-description","text":"See also: pthread_create See also: pthread_attr_t The type wraps pthread_create function. After spawn, it contains thread id of the brand-new thread.","title":"Detailed Description"},{"location":"classcoro_1_1pthread__spawn__promise/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1pthread__spawn__promise/#variable-tid","text":"pthread_t coro :: pthread_spawn_promise :: tid ;","title":"variable tid"},{"location":"classcoro_1_1pthread__spawn__promise/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__spawn__promise/#function-await95transform-13","text":"inline auto coro :: pthread_spawn_promise :: await_transform ( const pthread_attr_t * attr ) noexcept","title":"function await_transform [1/3]"},{"location":"classcoro_1_1pthread__spawn__promise/#function-await95transform-23","text":"inline auto coro :: pthread_spawn_promise :: await_transform ( pthread_attr_t * attr ) noexcept","title":"function await_transform [2/3]"},{"location":"classcoro_1_1pthread__spawn__promise/#function-await95transform-33","text":"template < typename Awaitable typename Awaitable > inline decltype ( auto ) coro :: pthread_spawn_promise :: await_transform ( Awaitable && a ) noexcept","title":"function await_transform [3/3]"},{"location":"classcoro_1_1pthread__spawn__promise/#function-initial95suspend","text":"inline auto coro :: pthread_spawn_promise :: initial_suspend () noexcept","title":"function initial_suspend"},{"location":"classcoro_1_1pthread__spawn__promise/#function-unhandled95exception","text":"inline void coro :: pthread_spawn_promise :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function unhandled_exception"},{"location":"classcoro_1_1pthread__spawner__t/","text":"Class coro::pthread_spawner_t \u00b6 Class List > coro > pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. #include <pthread.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept pthread_spawner_t (pthread_t * _tid, const pthread_attr_t * _attr) ~pthread_spawner_t () noexcept Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool coro :: pthread_spawner_t :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void coro :: pthread_spawner_t :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: pthread_spawner_t :: await_suspend ( coroutine_handle < void > coro ) noexcept function pthread_spawner_t \u00b6 inline coro :: pthread_spawner_t :: pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) function ~pthread_spawner_t \u00b6 coro :: pthread_spawner_t ::~ pthread_spawner_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_spawner\\_t"},{"location":"classcoro_1_1pthread__spawner__t/#class-coropthread95spawner95t","text":"Class List > coro > pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. #include <pthread.h>","title":"Class coro::pthread_spawner_t"},{"location":"classcoro_1_1pthread__spawner__t/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept pthread_spawner_t (pthread_t * _tid, const pthread_attr_t * _attr) ~pthread_spawner_t () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__spawner__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__spawner__t/#function-await95ready","text":"inline constexpr bool coro :: pthread_spawner_t :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1pthread__spawner__t/#function-await95resume","text":"inline constexpr void coro :: pthread_spawner_t :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1pthread__spawner__t/#function-await95suspend","text":"inline void coro :: pthread_spawner_t :: await_suspend ( coroutine_handle < void > coro ) noexcept","title":"function await_suspend"},{"location":"classcoro_1_1pthread__spawner__t/#function-pthread95spawner95t","text":"inline coro :: pthread_spawner_t :: pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr )","title":"function pthread_spawner_t"},{"location":"classcoro_1_1pthread__spawner__t/#function-pthread95spawner95t_1","text":"coro :: pthread_spawner_t ::~ pthread_spawner_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function ~pthread_spawner_t"},{"location":"classcoro_1_1reader/","text":"Class coro::reader \u00b6 template <typename T typename T, typename M typename M> Class List > coro > reader #include <channel.hpp> Inherited by the following classes: coro::peeker Public Types \u00b6 Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type Public Attributes \u00b6 Type Name channel_type * chan reader * next = = nullptr Public Functions \u00b6 Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~reader () noexcept Protected Attributes \u00b6 Type Name union coro::reader::@0 @1 void * frame pointer ptr Public Types Documentation \u00b6 typedef channel_type [1/2] \u00b6 using coro :: reader < T , M >:: channel_type = channel < T , M > ; typedef pointer \u00b6 using coro :: reader < T , M >:: pointer = T * ; typedef reference \u00b6 using coro :: reader < T , M >:: reference = T & ; typedef value_type \u00b6 using coro :: reader < T , M >:: value_type = T ; Public Attributes Documentation \u00b6 variable chan \u00b6 channel_type * coro :: reader < T , M >:: chan ; variable next \u00b6 reader * coro :: reader < T , M >:: next ; Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: reader :: await_ready () noexcept const function await_resume \u00b6 inline auto coro :: reader :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: reader :: await_suspend ( coroutine_handle < void > coro ) noexcept function ~reader \u00b6 coro :: reader ::~ reader () noexcept Protected Attributes Documentation \u00b6 variable @1 \u00b6 union coro :: reader :: @ 0 coro :: reader < T , M >:: @ 1 ; variable frame \u00b6 void * coro :: reader < T , M >:: frame ; variable ptr \u00b6 pointer coro :: reader < T , M >:: ptr ; The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"Class coro::reader"},{"location":"classcoro_1_1reader/#class-cororeader","text":"template <typename T typename T, typename M typename M> Class List > coro > reader #include <channel.hpp> Inherited by the following classes: coro::peeker","title":"Class coro::reader"},{"location":"classcoro_1_1reader/#public-types","text":"Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1reader/#public-attributes","text":"Type Name channel_type * chan reader * next = = nullptr","title":"Public Attributes"},{"location":"classcoro_1_1reader/#public-functions","text":"Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~reader () noexcept","title":"Public Functions"},{"location":"classcoro_1_1reader/#protected-attributes","text":"Type Name union coro::reader::@0 @1 void * frame pointer ptr","title":"Protected Attributes"},{"location":"classcoro_1_1reader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1reader/#typedef-channel95type-12","text":"using coro :: reader < T , M >:: channel_type = channel < T , M > ;","title":"typedef channel_type [1/2]"},{"location":"classcoro_1_1reader/#typedef-pointer","text":"using coro :: reader < T , M >:: pointer = T * ;","title":"typedef pointer"},{"location":"classcoro_1_1reader/#typedef-reference","text":"using coro :: reader < T , M >:: reference = T & ;","title":"typedef reference"},{"location":"classcoro_1_1reader/#typedef-value95type","text":"using coro :: reader < T , M >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1reader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1reader/#variable-chan","text":"channel_type * coro :: reader < T , M >:: chan ;","title":"variable chan"},{"location":"classcoro_1_1reader/#variable-next","text":"reader * coro :: reader < T , M >:: next ;","title":"variable next"},{"location":"classcoro_1_1reader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1reader/#function-await95ready","text":"inline bool coro :: reader :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1reader/#function-await95resume","text":"inline auto coro :: reader :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1reader/#function-await95suspend","text":"inline void coro :: reader :: await_suspend ( coroutine_handle < void > coro ) noexcept","title":"function await_suspend"},{"location":"classcoro_1_1reader/#function-reader","text":"coro :: reader ::~ reader () noexcept","title":"function ~reader"},{"location":"classcoro_1_1reader/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"classcoro_1_1reader/#variable-1","text":"union coro :: reader :: @ 0 coro :: reader < T , M >:: @ 1 ;","title":"variable @1"},{"location":"classcoro_1_1reader/#variable-frame","text":"void * coro :: reader < T , M >:: frame ;","title":"variable frame"},{"location":"classcoro_1_1reader/#variable-ptr","text":"pointer coro :: reader < T , M >:: ptr ; The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"variable ptr"},{"location":"classcoro_1_1section/","text":"Class coro::section \u00b6 Class List > coro > section Standard lockable with win32 criticial section. Inherits the following classes: CRITICAL_SECTION Public Functions \u00b6 Type Name void lock () noexcept void lock () noexcept section & operator= (const section &) = delete section & operator= ( section &&) = delete section () noexcept section (const section &) = delete section ( section &&) = delete section () noexcept bool try_lock () noexcept bool try_lock () noexcept void unlock () noexcept void unlock () noexcept ~section () noexcept ~section () noexcept Public Functions Documentation \u00b6 function lock [1/2] \u00b6 void coro :: section :: lock () noexcept Note: pthread_mutex_ returned EINVAL for lock operation. replaced to rwlock See also: pthread_rwlock_wrlock function lock [1/2] \u00b6 void coro :: section :: lock () noexcept function operator= \u00b6 section & coro :: section :: operator = ( const section & ) = delete function operator= \u00b6 section & coro :: section :: operator = ( section && ) = delete function section [1/6] \u00b6 coro :: section :: section () noexcept See also: pthread_rwlock_init function section [2/6] \u00b6 coro :: section :: section ( const section & ) = delete function section [3/6] \u00b6 coro :: section :: section ( section && ) = delete function section [1/6] \u00b6 coro :: section :: section () noexcept function try_lock [1/2] \u00b6 bool coro :: section :: try_lock () noexcept possible errors are ... * EBUSY * EINVAL * EDEADLK See also: pthread_rwlock_trywrlock Returns: true Returns: false failed. check errno function try_lock [1/2] \u00b6 bool coro :: section :: try_lock () noexcept function unlock [1/2] \u00b6 void coro :: section :: unlock () noexcept See also: pthread_rwlock_unlock function unlock [1/2] \u00b6 void coro :: section :: unlock () noexcept function ~section [1/2] \u00b6 coro :: section ::~ section () noexcept See also: pthread_rwlock_destroy function ~section [1/2] \u00b6 coro :: section ::~ section () noexcept The documentation for this class was generated from the following file modules/system/pthread.cpp","title":"Class coro::section"},{"location":"classcoro_1_1section/#class-corosection","text":"Class List > coro > section Standard lockable with win32 criticial section. Inherits the following classes: CRITICAL_SECTION","title":"Class coro::section"},{"location":"classcoro_1_1section/#public-functions","text":"Type Name void lock () noexcept void lock () noexcept section & operator= (const section &) = delete section & operator= ( section &&) = delete section () noexcept section (const section &) = delete section ( section &&) = delete section () noexcept bool try_lock () noexcept bool try_lock () noexcept void unlock () noexcept void unlock () noexcept ~section () noexcept ~section () noexcept","title":"Public Functions"},{"location":"classcoro_1_1section/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1section/#function-lock-12","text":"void coro :: section :: lock () noexcept Note: pthread_mutex_ returned EINVAL for lock operation. replaced to rwlock See also: pthread_rwlock_wrlock","title":"function lock [1/2]"},{"location":"classcoro_1_1section/#function-lock-12_1","text":"void coro :: section :: lock () noexcept","title":"function lock [1/2]"},{"location":"classcoro_1_1section/#function-operator","text":"section & coro :: section :: operator = ( const section & ) = delete","title":"function operator="},{"location":"classcoro_1_1section/#function-operator_1","text":"section & coro :: section :: operator = ( section && ) = delete","title":"function operator="},{"location":"classcoro_1_1section/#function-section-16","text":"coro :: section :: section () noexcept See also: pthread_rwlock_init","title":"function section [1/6]"},{"location":"classcoro_1_1section/#function-section-26","text":"coro :: section :: section ( const section & ) = delete","title":"function section [2/6]"},{"location":"classcoro_1_1section/#function-section-36","text":"coro :: section :: section ( section && ) = delete","title":"function section [3/6]"},{"location":"classcoro_1_1section/#function-section-16_1","text":"coro :: section :: section () noexcept","title":"function section [1/6]"},{"location":"classcoro_1_1section/#function-try95lock-12","text":"bool coro :: section :: try_lock () noexcept possible errors are ... * EBUSY * EINVAL * EDEADLK See also: pthread_rwlock_trywrlock Returns: true Returns: false failed. check errno","title":"function try_lock [1/2]"},{"location":"classcoro_1_1section/#function-try95lock-12_1","text":"bool coro :: section :: try_lock () noexcept","title":"function try_lock [1/2]"},{"location":"classcoro_1_1section/#function-unlock-12","text":"void coro :: section :: unlock () noexcept See also: pthread_rwlock_unlock","title":"function unlock [1/2]"},{"location":"classcoro_1_1section/#function-unlock-12_1","text":"void coro :: section :: unlock () noexcept","title":"function unlock [1/2]"},{"location":"classcoro_1_1section/#function-section-12","text":"coro :: section ::~ section () noexcept See also: pthread_rwlock_destroy","title":"function ~section [1/2]"},{"location":"classcoro_1_1section/#function-section-12_1","text":"coro :: section ::~ section () noexcept The documentation for this class was generated from the following file modules/system/pthread.cpp","title":"function ~section [1/2]"},{"location":"classcoro_1_1set__or__cancel/","text":"Class coro::set_or_cancel \u00b6 Class List > coro > set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. More... #include <windows.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const uint32_t await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept set_or_cancel (void * target) noexcept uint32_t unregister () noexcept cancel the event waiting ~set_or_cancel () noexcept Detailed Description \u00b6 It uses INFINITE wait. So its user must sure one of SetEvent(hEvent) or sc.unregister() happens after co_await . Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool coro :: set_or_cancel :: await_ready () noexcept const function await_resume \u00b6 inline uint32_t coro :: set_or_cancel :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: set_or_cancel :: await_suspend ( coroutine_handle < void > coro ) noexcept function set_or_cancel [3/3] \u00b6 explicit coro :: set_or_cancel :: set_or_cancel ( void * target ) noexcept function unregister \u00b6 uint32_t coro :: set_or_cancel :: unregister () noexcept Returns: uint32_t See also: https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-unregisterwait function ~set_or_cancel \u00b6 coro :: set_or_cancel ::~ set_or_cancel () noexcept The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"Class coro::set\\_or\\_cancel"},{"location":"classcoro_1_1set__or__cancel/#class-coroset95or95cancel","text":"Class List > coro > set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. More... #include <windows.h>","title":"Class coro::set_or_cancel"},{"location":"classcoro_1_1set__or__cancel/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const uint32_t await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept set_or_cancel (void * target) noexcept uint32_t unregister () noexcept cancel the event waiting ~set_or_cancel () noexcept","title":"Public Functions"},{"location":"classcoro_1_1set__or__cancel/#detailed-description","text":"It uses INFINITE wait. So its user must sure one of SetEvent(hEvent) or sc.unregister() happens after co_await .","title":"Detailed Description"},{"location":"classcoro_1_1set__or__cancel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1set__or__cancel/#function-await95ready","text":"inline constexpr bool coro :: set_or_cancel :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1set__or__cancel/#function-await95resume","text":"inline uint32_t coro :: set_or_cancel :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1set__or__cancel/#function-await95suspend","text":"inline void coro :: set_or_cancel :: await_suspend ( coroutine_handle < void > coro ) noexcept","title":"function await_suspend"},{"location":"classcoro_1_1set__or__cancel/#function-set95or95cancel-33","text":"explicit coro :: set_or_cancel :: set_or_cancel ( void * target ) noexcept","title":"function set_or_cancel [3/3]"},{"location":"classcoro_1_1set__or__cancel/#function-unregister","text":"uint32_t coro :: set_or_cancel :: unregister () noexcept Returns: uint32_t See also: https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-unregisterwait","title":"function unregister"},{"location":"classcoro_1_1set__or__cancel/#function-set95or95cancel","text":"coro :: set_or_cancel ::~ set_or_cancel () noexcept The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"function ~set_or_cancel"},{"location":"classcoro_1_1writer/","text":"Class coro::writer \u00b6 template <typename T typename T, typename M typename M> Class List > coro > writer #include <channel.hpp> Public Types \u00b6 Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type Public Attributes \u00b6 Type Name channel_type * chan writer * next = = nullptr Public Functions \u00b6 Type Name bool await_ready () noexcept const bool await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~writer () noexcept Public Types Documentation \u00b6 typedef channel_type [1/2] \u00b6 using coro :: writer < T , M >:: channel_type = channel < T , M > ; typedef pointer \u00b6 using coro :: writer < T , M >:: pointer = T * ; typedef reference \u00b6 using coro :: writer < T , M >:: reference = T & ; typedef value_type \u00b6 using coro :: writer < T , M >:: value_type = T ; Public Attributes Documentation \u00b6 variable chan \u00b6 channel_type * coro :: writer < T , M >:: chan ; variable next \u00b6 writer * coro :: writer < T , M >:: next ; Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: writer :: await_ready () noexcept const function await_resume \u00b6 inline bool coro :: writer :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: writer :: await_suspend ( coroutine_handle < void > coro ) noexcept function ~writer \u00b6 coro :: writer ::~ writer () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"Class coro::writer"},{"location":"classcoro_1_1writer/#class-corowriter","text":"template <typename T typename T, typename M typename M> Class List > coro > writer #include <channel.hpp>","title":"Class coro::writer"},{"location":"classcoro_1_1writer/#public-types","text":"Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1writer/#public-attributes","text":"Type Name channel_type * chan writer * next = = nullptr","title":"Public Attributes"},{"location":"classcoro_1_1writer/#public-functions","text":"Type Name bool await_ready () noexcept const bool await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~writer () noexcept","title":"Public Functions"},{"location":"classcoro_1_1writer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1writer/#typedef-channel95type-12","text":"using coro :: writer < T , M >:: channel_type = channel < T , M > ;","title":"typedef channel_type [1/2]"},{"location":"classcoro_1_1writer/#typedef-pointer","text":"using coro :: writer < T , M >:: pointer = T * ;","title":"typedef pointer"},{"location":"classcoro_1_1writer/#typedef-reference","text":"using coro :: writer < T , M >:: reference = T & ;","title":"typedef reference"},{"location":"classcoro_1_1writer/#typedef-value95type","text":"using coro :: writer < T , M >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1writer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1writer/#variable-chan","text":"channel_type * coro :: writer < T , M >:: chan ;","title":"variable chan"},{"location":"classcoro_1_1writer/#variable-next","text":"writer * coro :: writer < T , M >:: next ;","title":"variable next"},{"location":"classcoro_1_1writer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1writer/#function-await95ready","text":"inline bool coro :: writer :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1writer/#function-await95resume","text":"inline bool coro :: writer :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1writer/#function-await95suspend","text":"inline void coro :: writer :: await_suspend ( coroutine_handle < void > coro ) noexcept","title":"function await_suspend"},{"location":"classcoro_1_1writer/#function-writer","text":"coro :: writer ::~ writer () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"function ~writer"},{"location":"classes/","text":"Class Index \u00b6 b \u00b6 bypass_lock ( coro ) c \u00b6 channel ( coro ) continue_on_apc ( coro ) continue_on_thread_pool ( coro ) coroutine_handle ( std::experimental ) coroutine_handle< noop_coroutine_promise > ( std::experimental ) coroutine_handle< void > ( std::experimental ) clang_frame_prefix coroutine_traits ( std::experimental ) e \u00b6 enumerable ( coro ) epoll_owner ( coro ) event ( coro ) f \u00b6 frame_t ( coro ) g \u00b6 gcc_frame_prefix i \u00b6 iterator ( coro::enumerable ) io_recv ( coro ) io_recv_from ( coro ) io_send ( coro ) io_send_to ( coro ) io_work_t ( coro ) k \u00b6 kqueue_owner ( coro ) l \u00b6 list ( coro::internal ) m \u00b6 msvc_frame_prefix n \u00b6 noop_coroutine_promise ( std::experimental ) p \u00b6 promise_type ( coro::enumerable ) promise_type ( coro::frame_t ) peeker ( coro ) promise_aa ( coro ) promise_an ( coro ) promise_na ( coro ) promise_nn ( coro ) pthread_detacher_t ( coro ) promise_type ( coro::pthread_detacher_t ) pthread_joiner_t ( coro ) promise_type ( coro::pthread_joiner_t ) pthread_knower_t ( coro ) pthread_spawn_promise ( coro ) pthread_spawner_t ( coro ) r \u00b6 reader ( coro ) s \u00b6 section ( coro ) set_or_cancel ( coro ) suspend_always ( std::experimental ) suspend_never ( std::experimental ) w \u00b6 writer ( coro )","title":"Classes"},{"location":"classes/#class-index","text":"","title":"Class Index"},{"location":"classes/#b","text":"bypass_lock ( coro )","title":"b"},{"location":"classes/#c","text":"channel ( coro ) continue_on_apc ( coro ) continue_on_thread_pool ( coro ) coroutine_handle ( std::experimental ) coroutine_handle< noop_coroutine_promise > ( std::experimental ) coroutine_handle< void > ( std::experimental ) clang_frame_prefix coroutine_traits ( std::experimental )","title":"c"},{"location":"classes/#e","text":"enumerable ( coro ) epoll_owner ( coro ) event ( coro )","title":"e"},{"location":"classes/#f","text":"frame_t ( coro )","title":"f"},{"location":"classes/#g","text":"gcc_frame_prefix","title":"g"},{"location":"classes/#i","text":"iterator ( coro::enumerable ) io_recv ( coro ) io_recv_from ( coro ) io_send ( coro ) io_send_to ( coro ) io_work_t ( coro )","title":"i"},{"location":"classes/#k","text":"kqueue_owner ( coro )","title":"k"},{"location":"classes/#l","text":"list ( coro::internal )","title":"l"},{"location":"classes/#m","text":"msvc_frame_prefix","title":"m"},{"location":"classes/#n","text":"noop_coroutine_promise ( std::experimental )","title":"n"},{"location":"classes/#p","text":"promise_type ( coro::enumerable ) promise_type ( coro::frame_t ) peeker ( coro ) promise_aa ( coro ) promise_an ( coro ) promise_na ( coro ) promise_nn ( coro ) pthread_detacher_t ( coro ) promise_type ( coro::pthread_detacher_t ) pthread_joiner_t ( coro ) promise_type ( coro::pthread_joiner_t ) pthread_knower_t ( coro ) pthread_spawn_promise ( coro ) pthread_spawner_t ( coro )","title":"p"},{"location":"classes/#r","text":"reader ( coro )","title":"r"},{"location":"classes/#s","text":"section ( coro ) set_or_cancel ( coro ) suspend_always ( std::experimental ) suspend_never ( std::experimental )","title":"s"},{"location":"classes/#w","text":"writer ( coro )","title":"w"},{"location":"classstd_1_1experimental_1_1coroutine__handle/","text":"Class std::experimental::coroutine_handle \u00b6 template <typename PromiseType> Class List > std > experimental > coroutine_handle #include <frame.h> Public Types \u00b6 Type Name typedef PromiseType promise_type Public Functions \u00b6 Type Name coroutine_handle & operator= (nullptr_t) noexcept auto promise () noexcept const auto promise () noexcept Public Static Functions \u00b6 Type Name coroutine_handle from_address (void * addr) noexcept coroutine_handle from_promise ( promise_type & prom) noexcept Public Types Documentation \u00b6 typedef promise_type \u00b6 using std :: experimental :: coroutine_handle < PromiseType >:: promise_type = PromiseType ; Public Functions Documentation \u00b6 function operator= \u00b6 inline coroutine_handle & std :: experimental :: coroutine_handle :: operator = ( nullptr_t ) noexcept function promise [1/2] \u00b6 inline auto std :: experimental :: coroutine_handle :: promise () noexcept const function promise [2/2] \u00b6 inline auto std :: experimental :: coroutine_handle :: promise () noexcept Public Static Functions Documentation \u00b6 function from_address \u00b6 static inline coroutine_handle std :: experimental :: coroutine_handle :: from_address ( void * addr ) noexcept function from_promise \u00b6 static inline coroutine_handle std :: experimental :: coroutine_handle :: from_promise ( promise_type & prom ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::coroutine\\_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#class-stdexperimentalcoroutine95handle","text":"template <typename PromiseType> Class List > std > experimental > coroutine_handle #include <frame.h>","title":"Class std::experimental::coroutine_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-types","text":"Type Name typedef PromiseType promise_type","title":"Public Types"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-functions","text":"Type Name coroutine_handle & operator= (nullptr_t) noexcept auto promise () noexcept const auto promise () noexcept","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-static-functions","text":"Type Name coroutine_handle from_address (void * addr) noexcept coroutine_handle from_promise ( promise_type & prom) noexcept","title":"Public Static Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#typedef-promise95type","text":"using std :: experimental :: coroutine_handle < PromiseType >:: promise_type = PromiseType ;","title":"typedef promise_type"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-operator","text":"inline coroutine_handle & std :: experimental :: coroutine_handle :: operator = ( nullptr_t ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-promise-12","text":"inline auto std :: experimental :: coroutine_handle :: promise () noexcept const","title":"function promise [1/2]"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-promise-22","text":"inline auto std :: experimental :: coroutine_handle :: promise () noexcept","title":"function promise [2/2]"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-from95address","text":"static inline coroutine_handle std :: experimental :: coroutine_handle :: from_address ( void * addr ) noexcept","title":"function from_address"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-from95promise","text":"static inline coroutine_handle std :: experimental :: coroutine_handle :: from_promise ( promise_type & prom ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function from_promise"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/","text":"Class std::experimental::coroutine_handle< noop_coroutine_promise > \u00b6 template <> Class List > std > experimental > coroutine_handle< noop_coroutine_promise > #include <frame.h> Inherits the following classes: std::experimental::coroutine_handle< void > Public Types inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name union prefix_t Public Attributes \u00b6 Type Name this prefix v = = &p Public Attributes inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name prefix_t prefix Public Functions \u00b6 Type Name constexpr void * address () noexcept const coroutine_handle () noexcept constexpr void destroy () noexcept const constexpr bool done () noexcept const constexpr operator bool () noexcept const constexpr void operator() () noexcept const noop_coroutine_promise & promise () noexcept const constexpr void resume () noexcept const Public Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept Public Static Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept Public Attributes Documentation \u00b6 variable v \u00b6 this prefix std :: experimental :: coroutine_handle < noop_coroutine_promise >:: v ; Public Functions Documentation \u00b6 function address \u00b6 inline constexpr void * std :: experimental :: coroutine_handle < noop_coroutine_promise >:: address () noexcept const function coroutine_handle \u00b6 inline std :: experimental :: coroutine_handle < noop_coroutine_promise >:: coroutine_handle () noexcept function destroy \u00b6 inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: destroy () noexcept const function done \u00b6 inline constexpr bool std :: experimental :: coroutine_handle < noop_coroutine_promise >:: done () noexcept const function operator bool \u00b6 inline explicit constexpr std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator bool () noexcept const function operator() \u00b6 inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator () () noexcept const function promise \u00b6 inline noop_coroutine_promise & std :: experimental :: coroutine_handle < noop_coroutine_promise >:: promise () noexcept const function resume \u00b6 inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: resume () noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::coroutine\\_handle&lt; noop\\_coroutine\\_promise &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#class-stdexperimentalcoroutine95handle-noop95coroutine95promise","text":"template <> Class List > std > experimental > coroutine_handle< noop_coroutine_promise > #include <frame.h> Inherits the following classes: std::experimental::coroutine_handle< void >","title":"Class std::experimental::coroutine_handle&lt; noop_coroutine_promise &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-types-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name union prefix_t","title":"Public Types inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-attributes","text":"Type Name this prefix v = = &p","title":"Public Attributes"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-attributes-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name prefix_t prefix","title":"Public Attributes inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-functions","text":"Type Name constexpr void * address () noexcept const coroutine_handle () noexcept constexpr void destroy () noexcept const constexpr bool done () noexcept const constexpr operator bool () noexcept const constexpr void operator() () noexcept const noop_coroutine_promise & promise () noexcept const constexpr void resume () noexcept const","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept","title":"Public Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-static-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept","title":"Public Static Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#variable-v","text":"this prefix std :: experimental :: coroutine_handle < noop_coroutine_promise >:: v ;","title":"variable v"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-address","text":"inline constexpr void * std :: experimental :: coroutine_handle < noop_coroutine_promise >:: address () noexcept const","title":"function address"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-coroutine95handle","text":"inline std :: experimental :: coroutine_handle < noop_coroutine_promise >:: coroutine_handle () noexcept","title":"function coroutine_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-destroy","text":"inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: destroy () noexcept const","title":"function destroy"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-done","text":"inline constexpr bool std :: experimental :: coroutine_handle < noop_coroutine_promise >:: done () noexcept const","title":"function done"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-operator-bool","text":"inline explicit constexpr std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator bool () noexcept const","title":"function operator bool"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-operator","text":"inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator () () noexcept const","title":"function operator()"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-promise","text":"inline noop_coroutine_promise & std :: experimental :: coroutine_handle < noop_coroutine_promise >:: promise () noexcept const","title":"function promise"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-resume","text":"inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: resume () noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function resume"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/","text":"Class std::experimental::coroutine_handle< void > \u00b6 template <> Class List > std > experimental > coroutine_handle< void > #include <frame.h> Inherited by the following classes: coro::frame_t , std::experimental::coroutine_handle< noop_coroutine_promise > Public Types \u00b6 Type Name union prefix_t Public Attributes \u00b6 Type Name prefix_t prefix Public Functions \u00b6 Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept Public Static Functions \u00b6 Type Name coroutine_handle from_address (void * addr) noexcept Public Types Documentation \u00b6 union prefix_t \u00b6 Public Attributes Documentation \u00b6 variable prefix \u00b6 prefix_t std :: experimental :: coroutine_handle < void >:: prefix ; Public Functions Documentation \u00b6 function address \u00b6 inline constexpr void * std :: experimental :: coroutine_handle < void >:: address () noexcept const function coroutine_handle [1/4] \u00b6 std :: experimental :: coroutine_handle < void >:: coroutine_handle () noexcept function coroutine_handle [2/4] \u00b6 std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle const & ) noexcept function coroutine_handle [3/4] \u00b6 std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle && rhs ) noexcept function coroutine_handle [4/4] \u00b6 inline std :: experimental :: coroutine_handle < void >:: coroutine_handle ( std :: nullptr_t ) noexcept function destroy \u00b6 inline void std :: experimental :: coroutine_handle < void >:: destroy () noexcept function done \u00b6 inline bool std :: experimental :: coroutine_handle < void >:: done () noexcept const function operator bool \u00b6 inline explicit std :: experimental :: coroutine_handle < void >:: operator bool () noexcept const function operator= \u00b6 coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle const & ) noexcept function operator= \u00b6 coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle && rhs ) noexcept function operator= \u00b6 inline coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( nullptr_t ) noexcept function resume \u00b6 inline void std :: experimental :: coroutine_handle < void >:: resume () noexcept function ~coroutine_handle \u00b6 std :: experimental :: coroutine_handle < void >::~ coroutine_handle () noexcept Public Static Functions Documentation \u00b6 function from_address \u00b6 static inline coroutine_handle std :: experimental :: coroutine_handle < void >:: from_address ( void * addr ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::coroutine\\_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#class-stdexperimentalcoroutine95handle-void","text":"template <> Class List > std > experimental > coroutine_handle< void > #include <frame.h> Inherited by the following classes: coro::frame_t , std::experimental::coroutine_handle< noop_coroutine_promise >","title":"Class std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-types","text":"Type Name union prefix_t","title":"Public Types"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-attributes","text":"Type Name prefix_t prefix","title":"Public Attributes"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-functions","text":"Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-static-functions","text":"Type Name coroutine_handle from_address (void * addr) noexcept","title":"Public Static Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#union-prefix95t","text":"","title":"union prefix_t"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#variable-prefix","text":"prefix_t std :: experimental :: coroutine_handle < void >:: prefix ;","title":"variable prefix"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-address","text":"inline constexpr void * std :: experimental :: coroutine_handle < void >:: address () noexcept const","title":"function address"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle-14","text":"std :: experimental :: coroutine_handle < void >:: coroutine_handle () noexcept","title":"function coroutine_handle [1/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle-24","text":"std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle const & ) noexcept","title":"function coroutine_handle [2/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle-34","text":"std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle && rhs ) noexcept","title":"function coroutine_handle [3/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle-44","text":"inline std :: experimental :: coroutine_handle < void >:: coroutine_handle ( std :: nullptr_t ) noexcept","title":"function coroutine_handle [4/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-destroy","text":"inline void std :: experimental :: coroutine_handle < void >:: destroy () noexcept","title":"function destroy"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-done","text":"inline bool std :: experimental :: coroutine_handle < void >:: done () noexcept const","title":"function done"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator-bool","text":"inline explicit std :: experimental :: coroutine_handle < void >:: operator bool () noexcept const","title":"function operator bool"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator","text":"coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle const & ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator_1","text":"coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle && rhs ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator_2","text":"inline coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( nullptr_t ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-resume","text":"inline void std :: experimental :: coroutine_handle < void >:: resume () noexcept","title":"function resume"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle","text":"std :: experimental :: coroutine_handle < void >::~ coroutine_handle () noexcept","title":"function ~coroutine_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-from95address","text":"static inline coroutine_handle std :: experimental :: coroutine_handle < void >:: from_address ( void * addr ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function from_address"},{"location":"classstd_1_1experimental_1_1suspend__always/","text":"Class std::experimental::suspend_always \u00b6 Class List > std > experimental > suspend_always #include <frame.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool std :: experimental :: suspend_always :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void std :: experimental :: suspend_always :: await_resume () noexcept const function await_suspend \u00b6 inline void std :: experimental :: suspend_always :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::suspend\\_always"},{"location":"classstd_1_1experimental_1_1suspend__always/#class-stdexperimentalsuspend95always","text":"Class List > std > experimental > suspend_always #include <frame.h>","title":"Class std::experimental::suspend_always"},{"location":"classstd_1_1experimental_1_1suspend__always/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1suspend__always/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1suspend__always/#function-await95ready","text":"inline constexpr bool std :: experimental :: suspend_always :: await_ready () noexcept const","title":"function await_ready"},{"location":"classstd_1_1experimental_1_1suspend__always/#function-await95resume","text":"inline constexpr void std :: experimental :: suspend_always :: await_resume () noexcept const","title":"function await_resume"},{"location":"classstd_1_1experimental_1_1suspend__always/#function-await95suspend","text":"inline void std :: experimental :: suspend_always :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function await_suspend"},{"location":"classstd_1_1experimental_1_1suspend__never/","text":"Class std::experimental::suspend_never \u00b6 Class List > std > experimental > suspend_never #include <frame.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool std :: experimental :: suspend_never :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void std :: experimental :: suspend_never :: await_resume () noexcept const function await_suspend \u00b6 inline void std :: experimental :: suspend_never :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::suspend\\_never"},{"location":"classstd_1_1experimental_1_1suspend__never/#class-stdexperimentalsuspend95never","text":"Class List > std > experimental > suspend_never #include <frame.h>","title":"Class std::experimental::suspend_never"},{"location":"classstd_1_1experimental_1_1suspend__never/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1suspend__never/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1suspend__never/#function-await95ready","text":"inline constexpr bool std :: experimental :: suspend_never :: await_ready () noexcept const","title":"function await_ready"},{"location":"classstd_1_1experimental_1_1suspend__never/#function-await95resume","text":"inline constexpr void std :: experimental :: suspend_never :: await_resume () noexcept const","title":"function await_resume"},{"location":"classstd_1_1experimental_1_1suspend__never/#function-await95suspend","text":"inline void std :: experimental :: suspend_never :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function await_suspend"},{"location":"darwin_8cpp/","text":"File darwin.cpp \u00b6 File List > modules > system > darwin.cpp Go to the source code of this file. #include <coroutine/frame.h> #include <coroutine/unix.h> #include <coroutine/return.h> #include \"internal/yield.hpp\" The documentation for this class was generated from the following file modules/system/darwin.cpp","title":"File darwin.cpp"},{"location":"darwin_8cpp/#file-darwincpp","text":"File List > modules > system > darwin.cpp Go to the source code of this file. #include <coroutine/frame.h> #include <coroutine/unix.h> #include <coroutine/return.h> #include \"internal/yield.hpp\" The documentation for this class was generated from the following file modules/system/darwin.cpp","title":"File darwin.cpp"},{"location":"darwin_8cpp_source/","text":"File darwin.cpp \u00b6 File List > modules > system > darwin.cpp Go to the documentation of this file. // expect the following headers are available // clang-format off #include <coroutine/frame.h> #include <coroutine/unix.h> #include <coroutine/return.h> #include \"internal/yield.hpp\" // clang-format on #if defined(__clang__) #else // we must error for the compilation. // however, this section will be left blank // to allow possible a clang-compatible one #endif // in-use functions static_assert ( __has_builtin ( __builtin_coro_done )); static_assert ( __has_builtin ( __builtin_coro_resume )); static_assert ( __has_builtin ( __builtin_coro_destroy )); static_assert ( __has_builtin ( __builtin_coro_promise )); // known functions static_assert ( __has_builtin ( __builtin_coro_size )); static_assert ( __has_builtin ( __builtin_coro_frame )); static_assert ( __has_builtin ( __builtin_coro_free )); static_assert ( __has_builtin ( __builtin_coro_id )); static_assert ( __has_builtin ( __builtin_coro_begin )); static_assert ( __has_builtin ( __builtin_coro_end )); static_assert ( __has_builtin ( __builtin_coro_suspend )); static_assert ( __has_builtin ( __builtin_coro_param ));","title":"File darwin.cpp"},{"location":"darwin_8cpp_source/#file-darwincpp","text":"File List > modules > system > darwin.cpp Go to the documentation of this file. // expect the following headers are available // clang-format off #include <coroutine/frame.h> #include <coroutine/unix.h> #include <coroutine/return.h> #include \"internal/yield.hpp\" // clang-format on #if defined(__clang__) #else // we must error for the compilation. // however, this section will be left blank // to allow possible a clang-compatible one #endif // in-use functions static_assert ( __has_builtin ( __builtin_coro_done )); static_assert ( __has_builtin ( __builtin_coro_resume )); static_assert ( __has_builtin ( __builtin_coro_destroy )); static_assert ( __has_builtin ( __builtin_coro_promise )); // known functions static_assert ( __has_builtin ( __builtin_coro_size )); static_assert ( __has_builtin ( __builtin_coro_frame )); static_assert ( __has_builtin ( __builtin_coro_free )); static_assert ( __has_builtin ( __builtin_coro_id )); static_assert ( __has_builtin ( __builtin_coro_begin )); static_assert ( __has_builtin ( __builtin_coro_end )); static_assert ( __has_builtin ( __builtin_coro_suspend )); static_assert ( __has_builtin ( __builtin_coro_param ));","title":"File darwin.cpp"},{"location":"dir_1a14cfa05288f960dad150e6e316c4bb/","text":"Dir interface/internal \u00b6 File List > interface > internal Files \u00b6 Type Name file channel.hpp file yield.hpp enumerable is simply a copy of generator in VC++ The documentation for this class was generated from the following file interface/internal/","title":"Dir interface/internal"},{"location":"dir_1a14cfa05288f960dad150e6e316c4bb/#dir-interfaceinternal","text":"File List > interface > internal","title":"Dir interface/internal"},{"location":"dir_1a14cfa05288f960dad150e6e316c4bb/#files","text":"Type Name file channel.hpp file yield.hpp enumerable is simply a copy of generator in VC++ The documentation for this class was generated from the following file interface/internal/","title":"Files"},{"location":"dir_826aeabe2439c2b66ff3bb7c0dad7853/","text":"Dir modules/system \u00b6 File List > modules > system Files \u00b6 Type Name file darwin.cpp file kqueue.cpp file libmain.cpp file linux.cpp file pthread.cpp file windows.cpp The documentation for this class was generated from the following file modules/system/","title":"Dir modules/system"},{"location":"dir_826aeabe2439c2b66ff3bb7c0dad7853/#dir-modulessystem","text":"File List > modules > system","title":"Dir modules/system"},{"location":"dir_826aeabe2439c2b66ff3bb7c0dad7853/#files","text":"Type Name file darwin.cpp file kqueue.cpp file libmain.cpp file linux.cpp file pthread.cpp file windows.cpp The documentation for this class was generated from the following file modules/system/","title":"Files"},{"location":"dir_923c80758d00fd62f29a99e232049d19/","text":"Dir modules/net \u00b6 File List > modules > net Files \u00b6 Type Name file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp The documentation for this class was generated from the following file modules/net/","title":"Dir modules/net"},{"location":"dir_923c80758d00fd62f29a99e232049d19/#dir-modulesnet","text":"File List > modules > net","title":"Dir modules/net"},{"location":"dir_923c80758d00fd62f29a99e232049d19/#files","text":"Type Name file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp The documentation for this class was generated from the following file modules/net/","title":"Files"},{"location":"dir_9b61234ab8cba81e3caae75634773f62/","text":"Dir interface/coroutine \u00b6 File List > coroutine Files \u00b6 Type Name file frame.h file linux.h file net.h Async I/O operation support with system socket functions. file pthread.h file return.h Utility to define return types for coroutine. file unix.h file windows.h The documentation for this class was generated from the following file interface/coroutine/","title":"Dir interface/coroutine"},{"location":"dir_9b61234ab8cba81e3caae75634773f62/#dir-interfacecoroutine","text":"File List > coroutine","title":"Dir interface/coroutine"},{"location":"dir_9b61234ab8cba81e3caae75634773f62/#files","text":"Type Name file frame.h file linux.h file net.h Async I/O operation support with system socket functions. file pthread.h file return.h Utility to define return types for coroutine. file unix.h file windows.h The documentation for this class was generated from the following file interface/coroutine/","title":"Files"},{"location":"dir_b31d54d5631803016a26f28213a41162/","text":"Dir interface \u00b6 File List > interface Directories \u00b6 Type Name dir coroutine dir internal The documentation for this class was generated from the following file interface/","title":"Dir interface"},{"location":"dir_b31d54d5631803016a26f28213a41162/#dir-interface","text":"File List > interface","title":"Dir interface"},{"location":"dir_b31d54d5631803016a26f28213a41162/#directories","text":"Type Name dir coroutine dir internal The documentation for this class was generated from the following file interface/","title":"Directories"},{"location":"dir_e05d7e2b1ecd646af5bb94391405f3b5/","text":"Dir modules \u00b6 File List > modules Directories \u00b6 Type Name dir net dir system The documentation for this class was generated from the following file modules/","title":"Dir modules"},{"location":"dir_e05d7e2b1ecd646af5bb94391405f3b5/#dir-modules","text":"File List > modules","title":"Dir modules"},{"location":"dir_e05d7e2b1ecd646af5bb94391405f3b5/#directories","text":"Type Name dir net dir system The documentation for this class was generated from the following file modules/","title":"Directories"},{"location":"files/","text":"File List \u00b6 Here is a list of all files with brief descriptions: dir interface dir coroutine file frame.h file linux.h file net.h Async I/O operation support with system socket functions. file pthread.h file return.h Utility to define return types for coroutine. file unix.h file windows.h dir internal file channel.hpp file yield.hpp enumerable is simply a copy of generator in VC++ dir modules dir net file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp dir system file darwin.cpp file kqueue.cpp file libmain.cpp file linux.cpp file pthread.cpp file windows.cpp","title":"Files"},{"location":"files/#file-list","text":"Here is a list of all files with brief descriptions: dir interface dir coroutine file frame.h file linux.h file net.h Async I/O operation support with system socket functions. file pthread.h file return.h Utility to define return types for coroutine. file unix.h file windows.h dir internal file channel.hpp file yield.hpp enumerable is simply a copy of generator in VC++ dir modules dir net file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp dir system file darwin.cpp file kqueue.cpp file libmain.cpp file linux.cpp file pthread.cpp file windows.cpp","title":"File List"},{"location":"frame_8h/","text":"File frame.h \u00b6 File List > coroutine > frame.h Go to the source code of this file. #include <cstddef> #include <cstdint> #include <type_traits> Namespaces \u00b6 Type Name namespace std namespace experimental Classes \u00b6 Type Name struct clang_frame_prefix struct gcc_frame_prefix struct msvc_frame_prefix class coroutine_handle <PromiseType> class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never Public Types \u00b6 Type Name union prefix_t Public Attributes \u00b6 Type Name constexpr auto aligned_size_v = = ((sizeof(T) + 16u - 1u) & ~(16u - 1u)) Public Functions \u00b6 Type Name void __builtin_coro_destroy (void *) bool __builtin_coro_done (void *) void __builtin_coro_resume (void *) void _coro_destroy (void *) size_t _coro_done (void *) bool _coro_finished (const msvc_frame_prefix *) noexcept size_t _coro_resume (void *) Macros \u00b6 Type Name define COROUTINE_PORTABLE_FRAME_H Public Types Documentation \u00b6 union prefix_t \u00b6 Public Attributes Documentation \u00b6 variable aligned_size_v \u00b6 constexpr auto aligned_size_v ; Public Functions Documentation \u00b6 function __builtin_coro_destroy \u00b6 void __builtin_coro_destroy ( void * ) function __builtin_coro_done \u00b6 bool __builtin_coro_done ( void * ) function __builtin_coro_resume \u00b6 void __builtin_coro_resume ( void * ) function _coro_destroy \u00b6 void _coro_destroy ( void * ) function _coro_done \u00b6 size_t _coro_done ( void * ) function _coro_finished \u00b6 bool _coro_finished ( const msvc_frame_prefix * ) noexcept function _coro_resume \u00b6 size_t _coro_resume ( void * ) Macro Definition Documentation \u00b6 define COROUTINE_PORTABLE_FRAME_H \u00b6 #define COROUTINE_PORTABLE_FRAME_H The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"File frame.h"},{"location":"frame_8h/#file-frameh","text":"File List > coroutine > frame.h Go to the source code of this file. #include <cstddef> #include <cstdint> #include <type_traits>","title":"File frame.h"},{"location":"frame_8h/#namespaces","text":"Type Name namespace std namespace experimental","title":"Namespaces"},{"location":"frame_8h/#classes","text":"Type Name struct clang_frame_prefix struct gcc_frame_prefix struct msvc_frame_prefix class coroutine_handle <PromiseType> class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never","title":"Classes"},{"location":"frame_8h/#public-types","text":"Type Name union prefix_t","title":"Public Types"},{"location":"frame_8h/#public-attributes","text":"Type Name constexpr auto aligned_size_v = = ((sizeof(T) + 16u - 1u) & ~(16u - 1u))","title":"Public Attributes"},{"location":"frame_8h/#public-functions","text":"Type Name void __builtin_coro_destroy (void *) bool __builtin_coro_done (void *) void __builtin_coro_resume (void *) void _coro_destroy (void *) size_t _coro_done (void *) bool _coro_finished (const msvc_frame_prefix *) noexcept size_t _coro_resume (void *)","title":"Public Functions"},{"location":"frame_8h/#macros","text":"Type Name define COROUTINE_PORTABLE_FRAME_H","title":"Macros"},{"location":"frame_8h/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"frame_8h/#union-prefix95t","text":"","title":"union prefix_t"},{"location":"frame_8h/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"frame_8h/#variable-aligned95size95v","text":"constexpr auto aligned_size_v ;","title":"variable aligned_size_v"},{"location":"frame_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"frame_8h/#function-9595builtin95coro95destroy","text":"void __builtin_coro_destroy ( void * )","title":"function __builtin_coro_destroy"},{"location":"frame_8h/#function-9595builtin95coro95done","text":"bool __builtin_coro_done ( void * )","title":"function __builtin_coro_done"},{"location":"frame_8h/#function-9595builtin95coro95resume","text":"void __builtin_coro_resume ( void * )","title":"function __builtin_coro_resume"},{"location":"frame_8h/#function-95coro95destroy","text":"void _coro_destroy ( void * )","title":"function _coro_destroy"},{"location":"frame_8h/#function-95coro95done","text":"size_t _coro_done ( void * )","title":"function _coro_done"},{"location":"frame_8h/#function-95coro95finished","text":"bool _coro_finished ( const msvc_frame_prefix * ) noexcept","title":"function _coro_finished"},{"location":"frame_8h/#function-95coro95resume","text":"size_t _coro_resume ( void * )","title":"function _coro_resume"},{"location":"frame_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"frame_8h/#define-coroutine95portable95frame95h","text":"#define COROUTINE_PORTABLE_FRAME_H The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"define COROUTINE_PORTABLE_FRAME_H"},{"location":"frame_8h_source/","text":"File frame.h \u00b6 File List > coroutine > frame.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // Header to adjust the difference of coroutine frame between compilers // // Reference // <experimental/resumable> from Microsoft VC++ (since 2017 Feb.) // <experimental/coroutine> from LLVM libcxx (since 6.0) // https://github.com/iains/gcc-cxx-coroutines // #pragma once #include <cstddef> #include <cstdint> #if defined(__clang__) && defined(_MSC_VER) // use this header // // case: clang-cl, VC++ // In this case, override <experimental/resumable>. // Since msvc and clang++ uses differnet frame layout, // VC++ won't fit clang-cl's code generation. // see the implementation below // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #elif defined(USE_PORTABLE_COROUTINE_HANDLE) // use this header // // case: clang-cl, VC++ // case: msvc, VC++ // case: clang, libc++ // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #else // use default header // // case: msvc, VC++ // case: clang, libc++ // It is safe to use vendor's header. // by defining macro variable, user can prevent template redefinition // #if __has_include(<coroutine>) // C++ 20 standard #include <coroutine> #elif __has_include(<experimental/coroutine>) // C++ 17 experimetal #include <experimental/coroutine> // We don't need to use this portable one. // Disable the implementation below and use the default #define COROUTINE_PORTABLE_FRAME_H #endif #endif // <coroutine> header #if defined(__clang__) static constexpr auto is_clang = true ; static constexpr auto is_msvc = ! is_clang ; static constexpr auto is_gcc = ! is_clang ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(_MSC_VER) static constexpr auto is_msvc = true ; static constexpr auto is_clang = ! is_msvc ; static constexpr auto is_gcc = ! is_msvc ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(__GNUC__) static constexpr auto is_gcc = true ; static constexpr auto is_msvc = ! is_gcc ; static constexpr auto is_clang = ! is_gcc ; // gcc-10 failes when __cdecl is used. declare it without convention using procedure_t = void ( * )( void * ); #else #error \"unexpected compiler. please contact the author\" #endif template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16u - 1u ) & ~ ( 16u - 1u )); // - Note // MSVC coroutine frame's prefix // Reference <experimental/resumable> for the detail // - Layout // +------------+------------------+--------------------+ // | Promise(?) | Frame Prefix(16) | Local variables(?) | // +------------+------------------+--------------------+ struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); // - Note // Clang coroutine frame's prefix // - Layout // +------------------+------------+---+--------------------+ // | Frame Prefix(16) | Promise(?) | ? | Local variables(?) | // +------------------+------------+---+--------------------+ struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 ); // - Note // GCC coroutine frame's prefix // - Layout // Unknown struct gcc_frame_prefix final { void * _unknown1 ; void * _unknown2 ; }; static_assert ( aligned_size_v < gcc_frame_prefix > == 16 ); #ifndef COROUTINE_PORTABLE_FRAME_H #define COROUTINE_PORTABLE_FRAME_H #pragma warning(push, 4) #pragma warning(disable : 4455 4494 4577 4619 4643 4702 4984 4988) #pragma warning(disable : 26490 26481 26476 26429 26409) #include <type_traits> // Alternative of `_coro_done` of msvc for this library. // It is renamed to avoid redefinition bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; // // intrinsic: MSVC // extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // // intrinsic: Clang/GCC // extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); // void* __builtin_coro_promise(void* ptr, int align, bool p); namespace std { namespace experimental { // template <typename R, class = void> // struct coroutine_traits_sfinae {}; // // template <typename R> // struct coroutine_traits_sfinae<R, void_t<typename R::promise_type>> { // using promise_type = typename R::promise_type; // }; // traits to enforce `promise_type`, without sfinae consideration. template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; template < typename PromiseType = void > class coroutine_handle ; template <> class coroutine_handle < void > { public : // This type is exposed // to provide more information for the frame and // to prepare for future adaptation. (especially for gcc family) union prefix_t { void * v {}; msvc_frame_prefix * m ; clang_frame_prefix * c ; gcc_frame_prefix * g ; }; static_assert ( sizeof ( prefix_t ) == sizeof ( void * )); prefix_t prefix ; public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept : prefix { nullptr } { } coroutine_handle & operator = ( nullptr_t ) noexcept { prefix . v = nullptr ; return * this ; } explicit operator bool () const noexcept { return prefix . v != nullptr ; } void resume () noexcept ( false ) { if constexpr ( is_msvc ) { _coro_resume ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_resume ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_resume ( prefix . g ); } } void destroy () noexcept { if constexpr ( is_msvc ) { _coro_destroy ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_destroy ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_destroy ( prefix . g ); } } bool done () const noexcept { if constexpr ( is_msvc ) { return _coro_finished ( prefix . m ); } else if constexpr ( is_clang ) { return __builtin_coro_done ( prefix . c ); } else if constexpr ( is_gcc ) { return __builtin_coro_done ( prefix . g ); } else { return false ; } } public : constexpr void * address () const noexcept { return prefix . v ; } static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } }; template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; private : static promise_type * from_frame ( prefix_t addr ) noexcept { if constexpr ( is_clang ) { // calculate the location of the frame's prefix auto * prefix = addr . c ; // for clang, promise is placed just after frame prefix // so this line works like `__builtin_coro_promise`, auto * promise = reinterpret_cast < promise_type *> ( prefix + 1 ); return promise ; } else if constexpr ( is_msvc ) { auto * ptr = reinterpret_cast < char *> ( addr . m ); // for msvc, promise is placed before frame prefix auto * promise = reinterpret_cast < promise_type *> ( ptr - aligned_size_v < promise_type > ); return promise ; } else if constexpr ( is_gcc ) { void * ptr = __builtin_coro_promise ( addr . g , __alignof ( promise_type ), false ); return reinterpret_cast < promise_type *> ( ptr ); } // !!! crash !!! return nullptr ; } public : using coroutine_handle < void >:: coroutine_handle ; coroutine_handle & operator = ( nullptr_t ) noexcept { this -> prefix . v = nullptr ; return * this ; } auto promise () const noexcept -> const promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } auto promise () noexcept -> promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } public : static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } static coroutine_handle from_promise ( promise_type & prom ) noexcept { promise_type * promise = & prom ; // calculate the location of the coroutine frame prefix if constexpr ( is_clang ) { void * prefix = reinterpret_cast < char *> ( promise ) - sizeof ( clang_frame_prefix ); return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_msvc ) { void * prefix = reinterpret_cast < char *> ( promise ) + aligned_size_v < promise_type > ; return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_gcc ) { void * prefix = __builtin_coro_promise ( reinterpret_cast < char *> ( & prom ), __alignof ( promise_type ), true ); return coroutine_handle :: from_address ( prefix ); } return coroutine_handle {}; } }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); inline bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () == rhs . address (); } inline bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs == rhs ); } inline bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () < rhs . address (); } inline bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } inline bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs > rhs ); } inline bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } struct noop_coroutine_promise {}; using noop_coroutine_handle = coroutine_handle < noop_coroutine_promise > ; template <> class coroutine_handle < noop_coroutine_promise > : public coroutine_handle < void > { public : coroutine_handle () noexcept : coroutine_handle < void > {} { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) this -> prefix . v = __builtin_coro_noop (); #else auto & p = this -> promise (); this -> prefix . v = & p ; #endif } public : constexpr explicit operator bool () const noexcept { return true ; } constexpr bool done () const noexcept { return false ; } constexpr void operator ()() const noexcept { return ; } constexpr void resume () const noexcept { return ; } constexpr void destroy () const noexcept { return ; } noop_coroutine_promise & promise () const noexcept { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) return * static_cast < noop_coroutine_promise *> ( __builtin_coro_promise ( this -> prefix . v , __alignof ( noop_coroutine_promise ), false )); #else static noop_coroutine_promise p {}; return p ; #endif } constexpr void * address () const noexcept { return this -> prefix . v ; } }; inline noop_coroutine_handle noop_coroutine () noexcept { return {}; } class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function won't be invoked } }; class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function will ignore the given handle } }; } // namespace experimental } // namespace std #if defined(__clang__) // // Note // VC++ header expects msvc intrinsics. Redirect them to Clang intrinsics. // If the project uses libc++ header files, this code won't be a problem // because they wont't be used // Reference // https://clang.llvm.org/docs/LanguageExtensions.html#c-coroutines-support-builtins // https://llvm.org/docs/Coroutines.html#example // inline bool _coro_finished ( msvc_frame_prefix * m ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed auto * c = reinterpret_cast < clang_frame_prefix *> ( m ); return __builtin_coro_done ( c ) ? 1 : 0 ; } inline size_t _coro_resume ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_resume ( c ); return 0 ; } inline void _coro_destroy ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_destroy ( c ); } #elif defined(_MSC_VER) inline bool _coro_finished ( const msvc_frame_prefix * prefix ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed return prefix -> index == 0 ; } namespace std :: experimental { // Helper traits for MSVC's coroutine compilation. // The original code is in <experimental/resumable> template < typename _Ret , typename ... _Ts > struct _Resumable_helper_traits { using promise_type = typename coroutine_traits < _Ret , _Ts ... >:: promise_type ; using handle_type = coroutine_handle < promise_type > ; static promise_type * _Promise_from_frame ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); return & prom ; } static handle_type _Handle_from_frame ( void * _Addr ) noexcept { auto * p = _Promise_from_frame ( _Addr ); return handle_type :: from_promise ( * p ); } static void _Set_exception ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); prom -> set_exception ( std :: current_exception ()); } static void _ConstructPromise ( void * addr , void * func , int _HeapElision ) noexcept ( false ) { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); prefix -> factivate = static_cast < procedure_t > ( func ); uint32_t * ptr = reinterpret_cast < uint32_t *> ( reinterpret_cast < uintptr_t > ( prefix ) + sizeof ( void * )); * ptr = 2 + ( _HeapElision ? 0 : 0x10000 ); auto * prom = _Promise_from_frame ( prefix ); :: new ( prom ) promise_type (); } static void _DestructPromise ( void * addr ) noexcept { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); _Promise_from_frame ( prefix ) ->~ promise_type (); } }; } // namespace std::experimental #elif defined(__GNUC__) inline bool is_suspended ( gcc_frame_prefix * g ) noexcept { return __builtin_coro_is_suspended ( g ); } #endif // __clang__ || _MSC_VER || __GNUC__ #pragma warning(pop) #endif // COROUTINE_PORTABLE_FRAME_H","title":"File frame.h"},{"location":"frame_8h_source/#file-frameh","text":"File List > coroutine > frame.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // Header to adjust the difference of coroutine frame between compilers // // Reference // <experimental/resumable> from Microsoft VC++ (since 2017 Feb.) // <experimental/coroutine> from LLVM libcxx (since 6.0) // https://github.com/iains/gcc-cxx-coroutines // #pragma once #include <cstddef> #include <cstdint> #if defined(__clang__) && defined(_MSC_VER) // use this header // // case: clang-cl, VC++ // In this case, override <experimental/resumable>. // Since msvc and clang++ uses differnet frame layout, // VC++ won't fit clang-cl's code generation. // see the implementation below // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #elif defined(USE_PORTABLE_COROUTINE_HANDLE) // use this header // // case: clang-cl, VC++ // case: msvc, VC++ // case: clang, libc++ // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #else // use default header // // case: msvc, VC++ // case: clang, libc++ // It is safe to use vendor's header. // by defining macro variable, user can prevent template redefinition // #if __has_include(<coroutine>) // C++ 20 standard #include <coroutine> #elif __has_include(<experimental/coroutine>) // C++ 17 experimetal #include <experimental/coroutine> // We don't need to use this portable one. // Disable the implementation below and use the default #define COROUTINE_PORTABLE_FRAME_H #endif #endif // <coroutine> header #if defined(__clang__) static constexpr auto is_clang = true ; static constexpr auto is_msvc = ! is_clang ; static constexpr auto is_gcc = ! is_clang ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(_MSC_VER) static constexpr auto is_msvc = true ; static constexpr auto is_clang = ! is_msvc ; static constexpr auto is_gcc = ! is_msvc ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(__GNUC__) static constexpr auto is_gcc = true ; static constexpr auto is_msvc = ! is_gcc ; static constexpr auto is_clang = ! is_gcc ; // gcc-10 failes when __cdecl is used. declare it without convention using procedure_t = void ( * )( void * ); #else #error \"unexpected compiler. please contact the author\" #endif template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16u - 1u ) & ~ ( 16u - 1u )); // - Note // MSVC coroutine frame's prefix // Reference <experimental/resumable> for the detail // - Layout // +------------+------------------+--------------------+ // | Promise(?) | Frame Prefix(16) | Local variables(?) | // +------------+------------------+--------------------+ struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); // - Note // Clang coroutine frame's prefix // - Layout // +------------------+------------+---+--------------------+ // | Frame Prefix(16) | Promise(?) | ? | Local variables(?) | // +------------------+------------+---+--------------------+ struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 ); // - Note // GCC coroutine frame's prefix // - Layout // Unknown struct gcc_frame_prefix final { void * _unknown1 ; void * _unknown2 ; }; static_assert ( aligned_size_v < gcc_frame_prefix > == 16 ); #ifndef COROUTINE_PORTABLE_FRAME_H #define COROUTINE_PORTABLE_FRAME_H #pragma warning(push, 4) #pragma warning(disable : 4455 4494 4577 4619 4643 4702 4984 4988) #pragma warning(disable : 26490 26481 26476 26429 26409) #include <type_traits> // Alternative of `_coro_done` of msvc for this library. // It is renamed to avoid redefinition bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; // // intrinsic: MSVC // extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // // intrinsic: Clang/GCC // extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); // void* __builtin_coro_promise(void* ptr, int align, bool p); namespace std { namespace experimental { // template <typename R, class = void> // struct coroutine_traits_sfinae {}; // // template <typename R> // struct coroutine_traits_sfinae<R, void_t<typename R::promise_type>> { // using promise_type = typename R::promise_type; // }; // traits to enforce `promise_type`, without sfinae consideration. template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; template < typename PromiseType = void > class coroutine_handle ; template <> class coroutine_handle < void > { public : // This type is exposed // to provide more information for the frame and // to prepare for future adaptation. (especially for gcc family) union prefix_t { void * v {}; msvc_frame_prefix * m ; clang_frame_prefix * c ; gcc_frame_prefix * g ; }; static_assert ( sizeof ( prefix_t ) == sizeof ( void * )); prefix_t prefix ; public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept : prefix { nullptr } { } coroutine_handle & operator = ( nullptr_t ) noexcept { prefix . v = nullptr ; return * this ; } explicit operator bool () const noexcept { return prefix . v != nullptr ; } void resume () noexcept ( false ) { if constexpr ( is_msvc ) { _coro_resume ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_resume ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_resume ( prefix . g ); } } void destroy () noexcept { if constexpr ( is_msvc ) { _coro_destroy ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_destroy ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_destroy ( prefix . g ); } } bool done () const noexcept { if constexpr ( is_msvc ) { return _coro_finished ( prefix . m ); } else if constexpr ( is_clang ) { return __builtin_coro_done ( prefix . c ); } else if constexpr ( is_gcc ) { return __builtin_coro_done ( prefix . g ); } else { return false ; } } public : constexpr void * address () const noexcept { return prefix . v ; } static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } }; template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; private : static promise_type * from_frame ( prefix_t addr ) noexcept { if constexpr ( is_clang ) { // calculate the location of the frame's prefix auto * prefix = addr . c ; // for clang, promise is placed just after frame prefix // so this line works like `__builtin_coro_promise`, auto * promise = reinterpret_cast < promise_type *> ( prefix + 1 ); return promise ; } else if constexpr ( is_msvc ) { auto * ptr = reinterpret_cast < char *> ( addr . m ); // for msvc, promise is placed before frame prefix auto * promise = reinterpret_cast < promise_type *> ( ptr - aligned_size_v < promise_type > ); return promise ; } else if constexpr ( is_gcc ) { void * ptr = __builtin_coro_promise ( addr . g , __alignof ( promise_type ), false ); return reinterpret_cast < promise_type *> ( ptr ); } // !!! crash !!! return nullptr ; } public : using coroutine_handle < void >:: coroutine_handle ; coroutine_handle & operator = ( nullptr_t ) noexcept { this -> prefix . v = nullptr ; return * this ; } auto promise () const noexcept -> const promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } auto promise () noexcept -> promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } public : static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } static coroutine_handle from_promise ( promise_type & prom ) noexcept { promise_type * promise = & prom ; // calculate the location of the coroutine frame prefix if constexpr ( is_clang ) { void * prefix = reinterpret_cast < char *> ( promise ) - sizeof ( clang_frame_prefix ); return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_msvc ) { void * prefix = reinterpret_cast < char *> ( promise ) + aligned_size_v < promise_type > ; return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_gcc ) { void * prefix = __builtin_coro_promise ( reinterpret_cast < char *> ( & prom ), __alignof ( promise_type ), true ); return coroutine_handle :: from_address ( prefix ); } return coroutine_handle {}; } }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); inline bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () == rhs . address (); } inline bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs == rhs ); } inline bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () < rhs . address (); } inline bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } inline bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs > rhs ); } inline bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } struct noop_coroutine_promise {}; using noop_coroutine_handle = coroutine_handle < noop_coroutine_promise > ; template <> class coroutine_handle < noop_coroutine_promise > : public coroutine_handle < void > { public : coroutine_handle () noexcept : coroutine_handle < void > {} { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) this -> prefix . v = __builtin_coro_noop (); #else auto & p = this -> promise (); this -> prefix . v = & p ; #endif } public : constexpr explicit operator bool () const noexcept { return true ; } constexpr bool done () const noexcept { return false ; } constexpr void operator ()() const noexcept { return ; } constexpr void resume () const noexcept { return ; } constexpr void destroy () const noexcept { return ; } noop_coroutine_promise & promise () const noexcept { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) return * static_cast < noop_coroutine_promise *> ( __builtin_coro_promise ( this -> prefix . v , __alignof ( noop_coroutine_promise ), false )); #else static noop_coroutine_promise p {}; return p ; #endif } constexpr void * address () const noexcept { return this -> prefix . v ; } }; inline noop_coroutine_handle noop_coroutine () noexcept { return {}; } class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function won't be invoked } }; class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function will ignore the given handle } }; } // namespace experimental } // namespace std #if defined(__clang__) // // Note // VC++ header expects msvc intrinsics. Redirect them to Clang intrinsics. // If the project uses libc++ header files, this code won't be a problem // because they wont't be used // Reference // https://clang.llvm.org/docs/LanguageExtensions.html#c-coroutines-support-builtins // https://llvm.org/docs/Coroutines.html#example // inline bool _coro_finished ( msvc_frame_prefix * m ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed auto * c = reinterpret_cast < clang_frame_prefix *> ( m ); return __builtin_coro_done ( c ) ? 1 : 0 ; } inline size_t _coro_resume ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_resume ( c ); return 0 ; } inline void _coro_destroy ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_destroy ( c ); } #elif defined(_MSC_VER) inline bool _coro_finished ( const msvc_frame_prefix * prefix ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed return prefix -> index == 0 ; } namespace std :: experimental { // Helper traits for MSVC's coroutine compilation. // The original code is in <experimental/resumable> template < typename _Ret , typename ... _Ts > struct _Resumable_helper_traits { using promise_type = typename coroutine_traits < _Ret , _Ts ... >:: promise_type ; using handle_type = coroutine_handle < promise_type > ; static promise_type * _Promise_from_frame ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); return & prom ; } static handle_type _Handle_from_frame ( void * _Addr ) noexcept { auto * p = _Promise_from_frame ( _Addr ); return handle_type :: from_promise ( * p ); } static void _Set_exception ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); prom -> set_exception ( std :: current_exception ()); } static void _ConstructPromise ( void * addr , void * func , int _HeapElision ) noexcept ( false ) { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); prefix -> factivate = static_cast < procedure_t > ( func ); uint32_t * ptr = reinterpret_cast < uint32_t *> ( reinterpret_cast < uintptr_t > ( prefix ) + sizeof ( void * )); * ptr = 2 + ( _HeapElision ? 0 : 0x10000 ); auto * prom = _Promise_from_frame ( prefix ); :: new ( prom ) promise_type (); } static void _DestructPromise ( void * addr ) noexcept { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); _Promise_from_frame ( prefix ) ->~ promise_type (); } }; } // namespace std::experimental #elif defined(__GNUC__) inline bool is_suspended ( gcc_frame_prefix * g ) noexcept { return __builtin_coro_is_suspended ( g ); } #endif // __clang__ || _MSC_VER || __GNUC__ #pragma warning(pop) #endif // COROUTINE_PORTABLE_FRAME_H","title":"File frame.h"},{"location":"functions/","text":"Functions \u00b6 _ \u00b6 __builtin_coro_destroy ( frame.h ) __builtin_coro_done ( frame.h ) __builtin_coro_resume ( frame.h ) _coro_destroy ( frame.h ) _coro_done ( frame.h ) _coro_finished ( frame.h ) _coro_resume ( frame.h )","title":"Functions"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"functions/#_","text":"__builtin_coro_destroy ( frame.h ) __builtin_coro_done ( frame.h ) __builtin_coro_resume ( frame.h ) _coro_destroy ( frame.h ) _coro_done ( frame.h ) _coro_finished ( frame.h ) _coro_resume ( frame.h )","title":"_"},{"location":"group__BSD/","text":"Group BSD \u00b6 Modules > BSD Classes \u00b6 Type Name class coro::kqueue_owner RAII wrapping for kqueue file descriptor.","title":"Group BSD"},{"location":"group__BSD/#group-bsd","text":"Modules > BSD","title":"Group BSD"},{"location":"group__BSD/#classes","text":"Type Name class coro::kqueue_owner RAII wrapping for kqueue file descriptor.","title":"Classes"},{"location":"group__Linux/","text":"Group Linux \u00b6 Modules > Linux Classes \u00b6 Type Name class coro::epoll_owner RAII wrapping for epoll file descriptor. class coro::event RAII + stateful eventfd __ Public Functions \u00b6 Type Name auto coro::wait_in ( epoll_owner & ep, event & efd) Bind the given event ( eventfd ) to epoll_owner (Epoll) Public Functions Documentation \u00b6 function wait_in \u00b6 auto coro :: wait_in ( epoll_owner & ep , event & efd ) Parameters: ep epoll_owner efd event See also: event Returns: awaitable struct for the binding","title":"Group Linux"},{"location":"group__Linux/#group-linux","text":"Modules > Linux","title":"Group Linux"},{"location":"group__Linux/#classes","text":"Type Name class coro::epoll_owner RAII wrapping for epoll file descriptor. class coro::event RAII + stateful eventfd __","title":"Classes"},{"location":"group__Linux/#public-functions","text":"Type Name auto coro::wait_in ( epoll_owner & ep, event & efd) Bind the given event ( eventfd ) to epoll_owner (Epoll)","title":"Public Functions"},{"location":"group__Linux/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"group__Linux/#function-wait95in","text":"auto coro :: wait_in ( epoll_owner & ep , event & efd ) Parameters: ep epoll_owner efd event See also: event Returns: awaitable struct for the binding","title":"function wait_in"},{"location":"group__NetResolve/","text":"Group NetResolve \u00b6 Modules > NetResolve More... Public Functions \u00b6 Type Name uint32_t coro::get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in > output) noexcept Thin wrapper of getaddrinfo for IPv4. uint32_t coro::get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in6 > output) noexcept Thin wrapper of getaddrinfo for IPv6. uint32_t coro::get_name (const sockaddr_in & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST uint32_t coro::get_name (const sockaddr_in6 & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST Detailed Description \u00b6 Name resolution utilities Public Functions Documentation \u00b6 function get_address \u00b6 uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror function get_address \u00b6 uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror function get_name \u00b6 uint32_t coro :: get_name ( const sockaddr_in & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo function get_name \u00b6 uint32_t coro :: get_name ( const sockaddr_in6 & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"Group NetResolve"},{"location":"group__NetResolve/#group-netresolve","text":"Modules > NetResolve More...","title":"Group NetResolve"},{"location":"group__NetResolve/#public-functions","text":"Type Name uint32_t coro::get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in > output) noexcept Thin wrapper of getaddrinfo for IPv4. uint32_t coro::get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in6 > output) noexcept Thin wrapper of getaddrinfo for IPv6. uint32_t coro::get_name (const sockaddr_in & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST uint32_t coro::get_name (const sockaddr_in6 & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST","title":"Public Functions"},{"location":"group__NetResolve/#detailed-description","text":"Name resolution utilities","title":"Detailed Description"},{"location":"group__NetResolve/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"group__NetResolve/#function-get95address","text":"uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror","title":"function get_address"},{"location":"group__NetResolve/#function-get95address_1","text":"uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror","title":"function get_address"},{"location":"group__NetResolve/#function-get95name","text":"uint32_t coro :: get_name ( const sockaddr_in & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"function get_name"},{"location":"group__NetResolve/#function-get95name_1","text":"uint32_t coro :: get_name ( const sockaddr_in6 & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"function get_name"},{"location":"group__NetWork/","text":"Group NetWork \u00b6 Modules > NetWork More... Classes \u00b6 Type Name class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. Public Types \u00b6 Type Name typedef gsl::span< std::byte > coro::io_buffer_t This is simply a view to storage. Be aware that it doesn't have ownership. Public Functions \u00b6 Type Name auto coro::recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto coro::recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto coro::recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_recv awaitable with the given parameters. auto coro::send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_send awaitable with the given parameters. auto coro::send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. auto coro::send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. Detailed Description \u00b6 Helper types to apply co_await for socket operations Public Types Documentation \u00b6 typedef io_buffer_t \u00b6 using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ; Public Functions Documentation \u00b6 function recv_from \u00b6 auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from & function recv_from \u00b6 auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from & function recv_stream \u00b6 auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_recv & function send_stream \u00b6 auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_send & function send_to \u00b6 auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to & function send_to \u00b6 auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"Group NetWork"},{"location":"group__NetWork/#group-network","text":"Modules > NetWork More...","title":"Group NetWork"},{"location":"group__NetWork/#classes","text":"Type Name class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle.","title":"Classes"},{"location":"group__NetWork/#public-types","text":"Type Name typedef gsl::span< std::byte > coro::io_buffer_t This is simply a view to storage. Be aware that it doesn't have ownership.","title":"Public Types"},{"location":"group__NetWork/#public-functions","text":"Type Name auto coro::recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto coro::recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto coro::recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_recv awaitable with the given parameters. auto coro::send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_send awaitable with the given parameters. auto coro::send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. auto coro::send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters.","title":"Public Functions"},{"location":"group__NetWork/#detailed-description","text":"Helper types to apply co_await for socket operations","title":"Detailed Description"},{"location":"group__NetWork/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"group__NetWork/#typedef-io95buffer95t","text":"using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ;","title":"typedef io_buffer_t"},{"location":"group__NetWork/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"group__NetWork/#function-recv95from","text":"auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from &","title":"function recv_from"},{"location":"group__NetWork/#function-recv95from_1","text":"auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from &","title":"function recv_from"},{"location":"group__NetWork/#function-recv95stream","text":"auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_recv &","title":"function recv_stream"},{"location":"group__NetWork/#function-send95stream","text":"auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_send &","title":"function send_stream"},{"location":"group__NetWork/#function-send95to","text":"auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"function send_to"},{"location":"group__NetWork/#function-send95to_1","text":"auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"function send_to"},{"location":"group__POSIX/","text":"Group POSIX \u00b6 Modules > POSIX More... Classes \u00b6 Type Name class coro::pthread_detacher_t Special return type that wraps pthread_detach __ class coro::pthread_joiner_t Special return type that wraps pthread_join __ class coro::pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class coro::pthread_spawn_promise allows pthread_attr_t* for co_await operator class coro::pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. Detailed Description \u00b6 Helpers to apply co_await for thread object/operations","title":"Group POSIX"},{"location":"group__POSIX/#group-posix","text":"Modules > POSIX More...","title":"Group POSIX"},{"location":"group__POSIX/#classes","text":"Type Name class coro::pthread_detacher_t Special return type that wraps pthread_detach __ class coro::pthread_joiner_t Special return type that wraps pthread_join __ class coro::pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class coro::pthread_spawn_promise allows pthread_attr_t* for co_await operator class coro::pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it.","title":"Classes"},{"location":"group__POSIX/#detailed-description","text":"Helpers to apply co_await for thread object/operations","title":"Detailed Description"},{"location":"group__Return/","text":"Group Return \u00b6 Modules > Return More... Classes \u00b6 Type Name class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class coro::promise_aa class coro::promise_an class coro::promise_na class coro::promise_nn Detailed Description \u00b6 Types for easier coroutine promise/return type definition.","title":"Group Return"},{"location":"group__Return/#group-return","text":"Modules > Return More...","title":"Group Return"},{"location":"group__Return/#classes","text":"Type Name class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class coro::promise_aa class coro::promise_an class coro::promise_na class coro::promise_nn","title":"Classes"},{"location":"group__Return/#detailed-description","text":"Types for easier coroutine promise/return type definition.","title":"Detailed Description"},{"location":"group__Windows/","text":"Group Windows \u00b6 Modules > Windows More... Classes \u00b6 Type Name class coro::continue_on_apc Move into the designated thread's APC queue and continue the routine. class coro::continue_on_thread_pool Move into the win32 thread pool and continue the routine. class coro::set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. Detailed Description \u00b6 Most of the implementation use Win32 thread pool.","title":"Group Windows"},{"location":"group__Windows/#group-windows","text":"Modules > Windows More...","title":"Group Windows"},{"location":"group__Windows/#classes","text":"Type Name class coro::continue_on_apc Move into the designated thread's APC queue and continue the routine. class coro::continue_on_thread_pool Move into the win32 thread pool and continue the routine. class coro::set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body.","title":"Classes"},{"location":"group__Windows/#detailed-description","text":"Most of the implementation use Win32 thread pool.","title":"Detailed Description"},{"location":"hierarchy/","text":"Class Hierarchy \u00b6 This inheritance list is sorted roughly, but not completely, alphabetically: class coro::internal::list class coro::continue_on_apc Move into the designated thread's APC queue and continue the routine. class coro::continue_on_thread_pool Move into the win32 thread pool and continue the routine. class coro::enumerable class coro::enumerable::iterator class coro::promise_aa class coro::enumerable::promise_type class coro::epoll_owner RAII wrapping for epoll file descriptor. class coro::event RAII + stateful eventfd __ class std::experimental::coroutine_handle< void > class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class std::experimental::coroutine_handle< noop_coroutine_promise > class coro::promise_na class coro::frame_t::promise_type class coro::kqueue_owner RAII wrapping for kqueue file descriptor. class coro::reader class coro::peeker class coro::promise_an class coro::promise_nn class coro::pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class coro::pthread_detacher_t Special return type that wraps pthread_detach __ class coro::pthread_joiner_t Special return type that wraps pthread_join __ class coro::pthread_spawn_promise allows pthread_attr_t* for co_await operator class coro::pthread_detacher_t::promise_type class coro::pthread_joiner_t::promise_type class coro::pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class coro::set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. class coro::writer class std::experimental::coroutine_handle class std::experimental::suspend_always class std::experimental::suspend_never struct clang_frame_prefix struct coro::bypass_lock struct gcc_frame_prefix struct msvc_frame_prefix struct std::experimental::coroutine_traits struct std::experimental::noop_coroutine_promise class io_control_block class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class CRITICAL_SECTION class coro::section Standard lockable with win32 criticial section.","title":"Class Hierarchy"},{"location":"hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class coro::internal::list class coro::continue_on_apc Move into the designated thread's APC queue and continue the routine. class coro::continue_on_thread_pool Move into the win32 thread pool and continue the routine. class coro::enumerable class coro::enumerable::iterator class coro::promise_aa class coro::enumerable::promise_type class coro::epoll_owner RAII wrapping for epoll file descriptor. class coro::event RAII + stateful eventfd __ class std::experimental::coroutine_handle< void > class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class std::experimental::coroutine_handle< noop_coroutine_promise > class coro::promise_na class coro::frame_t::promise_type class coro::kqueue_owner RAII wrapping for kqueue file descriptor. class coro::reader class coro::peeker class coro::promise_an class coro::promise_nn class coro::pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class coro::pthread_detacher_t Special return type that wraps pthread_detach __ class coro::pthread_joiner_t Special return type that wraps pthread_join __ class coro::pthread_spawn_promise allows pthread_attr_t* for co_await operator class coro::pthread_detacher_t::promise_type class coro::pthread_joiner_t::promise_type class coro::pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class coro::set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. class coro::writer class std::experimental::coroutine_handle class std::experimental::suspend_always class std::experimental::suspend_never struct clang_frame_prefix struct coro::bypass_lock struct gcc_frame_prefix struct msvc_frame_prefix struct std::experimental::coroutine_traits struct std::experimental::noop_coroutine_promise class io_control_block class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class CRITICAL_SECTION class coro::section Standard lockable with win32 criticial section.","title":"Class Hierarchy"},{"location":"io__darwin_8cpp/","text":"File io_darwin.cpp \u00b6 File List > modules > net > io_darwin.cpp Go to the source code of this file. #include <chrono> #include <coroutine/net.h> #include <coroutine/unix.h> Namespaces \u00b6 Type Name namespace coro namespace chrono The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"File io\\_darwin.cpp"},{"location":"io__darwin_8cpp/#file-io95darwincpp","text":"File List > modules > net > io_darwin.cpp Go to the source code of this file. #include <chrono> #include <coroutine/net.h> #include <coroutine/unix.h>","title":"File io_darwin.cpp"},{"location":"io__darwin_8cpp/#namespaces","text":"Type Name namespace coro namespace chrono The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"Namespaces"},{"location":"io__darwin_8cpp_source/","text":"File io_darwin.cpp \u00b6 File List > modules > net > io_darwin.cpp Go to the documentation of this file. #include <chrono> #include <coroutine/net.h> #include <coroutine/unix.h> static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { kqueue_owner netkq {}; using net_callback_t = void ( * )( void * ctx , coroutine_handle < void > coro ); void poll_net_tasks ( const timespec & wait_time , // net_callback_t callback , void * ctx ) noexcept ( false ) { constexpr auto buf_size = 30u ; auto buf = make_unique < kevent64_s [] > ( buf_size ); const auto count = netkq . events ( wait_time , { buf . get (), buf_size }); for ( auto i = count ; i < count ; ++ i ) { auto * work = reinterpret_cast < io_work_t *> ( buf [ i ]. udata ); callback ( ctx , work -> task ); } } void resume_net_task ( void * , coroutine_handle < void > coro ) noexcept ( false ) { return coro . resume (); } void poll_net_tasks ( uint64_t nano ) noexcept ( false ) { auto timeout = nanoseconds { nano }; const auto sec = duration_cast < seconds > ( timeout ); const timespec wait_time { . tv_sec = sec . count (), . tv_nsec = ( timeout - sec ). count (), }; return poll_net_tasks ( wait_time , resume_net_task , nullptr ); } bool io_work_t :: ready () const noexcept { const auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; // it is possible to pass `rh` for the user data, // but will pass this object to support // receiving some values from `wait_io_tasks` req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); errc = sz < 0 ? errno : 0 ; return sz ; } auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io\\_darwin.cpp"},{"location":"io__darwin_8cpp_source/#file-io95darwincpp","text":"File List > modules > net > io_darwin.cpp Go to the documentation of this file. #include <chrono> #include <coroutine/net.h> #include <coroutine/unix.h> static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { kqueue_owner netkq {}; using net_callback_t = void ( * )( void * ctx , coroutine_handle < void > coro ); void poll_net_tasks ( const timespec & wait_time , // net_callback_t callback , void * ctx ) noexcept ( false ) { constexpr auto buf_size = 30u ; auto buf = make_unique < kevent64_s [] > ( buf_size ); const auto count = netkq . events ( wait_time , { buf . get (), buf_size }); for ( auto i = count ; i < count ; ++ i ) { auto * work = reinterpret_cast < io_work_t *> ( buf [ i ]. udata ); callback ( ctx , work -> task ); } } void resume_net_task ( void * , coroutine_handle < void > coro ) noexcept ( false ) { return coro . resume (); } void poll_net_tasks ( uint64_t nano ) noexcept ( false ) { auto timeout = nanoseconds { nano }; const auto sec = duration_cast < seconds > ( timeout ); const timespec wait_time { . tv_sec = sec . count (), . tv_nsec = ( timeout - sec ). count (), }; return poll_net_tasks ( wait_time , resume_net_task , nullptr ); } bool io_work_t :: ready () const noexcept { const auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; // it is possible to pass `rh` for the user data, // but will pass this object to support // receiving some values from `wait_io_tasks` req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); errc = sz < 0 ? errno : 0 ; return sz ; } auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io_darwin.cpp"},{"location":"io__linux_8cpp/","text":"File io_linux.cpp \u00b6 File List > modules > net > io_linux.cpp Go to the source code of this file. #include <chrono> #include <coroutine/linux.h> #include <coroutine/net.h> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_linux.cpp","title":"File io\\_linux.cpp"},{"location":"io__linux_8cpp/#file-io95linuxcpp","text":"File List > modules > net > io_linux.cpp Go to the source code of this file. #include <chrono> #include <coroutine/linux.h> #include <coroutine/net.h>","title":"File io_linux.cpp"},{"location":"io__linux_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_linux.cpp","title":"Namespaces"},{"location":"io__linux_8cpp_source/","text":"File io_linux.cpp \u00b6 File List > modules > net > io_linux.cpp Go to the documentation of this file. #include <chrono> #include <coroutine/linux.h> #include <coroutine/net.h> static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { epoll_owner iep {}, oep {}; // inbound, outbound void poll_net_tasks ( uint64_t nano ) noexcept ( false ) { const auto half_time = duration_cast < milliseconds > ( nanoseconds { nano } / 2 ); // event buffer for this poll constexpr auto buf_sz = 30u ; auto buf = make_unique < epoll_event [] > ( buf_sz ); // resume inbound coroutines auto count = iep . wait ( half_time . count (), { buf . get (), buf_sz }); for ( auto i = 0u ; i < count ; ++ i ) if ( auto coro = coroutine_handle < void >:: from_address ( buf [ i ]. data . ptr )) coro . resume (); // resume outbound coroutines count = oep . wait ( half_time . count (), { buf . get (), buf_sz }); for ( auto i = 0u ; i < count ; ++ i ) if ( auto coro = coroutine_handle < void >:: from_address ( buf [ i ]. data . ptr )) coro . resume (); } bool io_work_t :: ready () const noexcept { auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); oep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); iep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); oep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); iep . try_add ( sd , req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io\\_linux.cpp"},{"location":"io__linux_8cpp_source/#file-io95linuxcpp","text":"File List > modules > net > io_linux.cpp Go to the documentation of this file. #include <chrono> #include <coroutine/linux.h> #include <coroutine/net.h> static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { epoll_owner iep {}, oep {}; // inbound, outbound void poll_net_tasks ( uint64_t nano ) noexcept ( false ) { const auto half_time = duration_cast < milliseconds > ( nanoseconds { nano } / 2 ); // event buffer for this poll constexpr auto buf_sz = 30u ; auto buf = make_unique < epoll_event [] > ( buf_sz ); // resume inbound coroutines auto count = iep . wait ( half_time . count (), { buf . get (), buf_sz }); for ( auto i = 0u ; i < count ; ++ i ) if ( auto coro = coroutine_handle < void >:: from_address ( buf [ i ]. data . ptr )) coro . resume (); // resume outbound coroutines count = oep . wait ( half_time . count (), { buf . get (), buf_sz }); for ( auto i = 0u ; i < count ; ++ i ) if ( auto coro = coroutine_handle < void >:: from_address ( buf [ i ]. data . ptr )) coro . resume (); } bool io_work_t :: ready () const noexcept { auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); oep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); iep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); oep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); iep . try_add ( sd , req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io_linux.cpp"},{"location":"io__windows_8cpp/","text":"File io_windows.cpp \u00b6 File List > modules > net > io_windows.cpp Go to the source code of this file. #include <cassert> #include <coroutine/net.h> Namespaces \u00b6 Type Name namespace coro namespace gsl The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"File io\\_windows.cpp"},{"location":"io__windows_8cpp/#file-io95windowscpp","text":"File List > modules > net > io_windows.cpp Go to the source code of this file. #include <cassert> #include <coroutine/net.h>","title":"File io_windows.cpp"},{"location":"io__windows_8cpp/#namespaces","text":"Type Name namespace coro namespace gsl The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"Namespaces"},{"location":"io__windows_8cpp_source/","text":"File io_windows.cpp \u00b6 File List > modules > net > io_windows.cpp Go to the documentation of this file. #include <cassert> #include <coroutine/net.h> using namespace std ; using namespace gsl ; namespace coro { //void wait_net_tasks(enumerable<coroutine_handle<void>>& tasks, // chrono::nanoseconds) noexcept(false) { // // windows implementation rely on callback. // // So there is noting to yield ... // tasks = enumerable<coroutine_handle<void>>{}; // // Just comsume some items in this thread's APC queue // SleepEx(0, true); //} bool is_async_pending ( int ec ) noexcept { switch ( ec ) { case WSAEWOULDBLOCK : case EWOULDBLOCK : case EINPROGRESS : case ERROR_IO_PENDING : return true ; default : return false ; } } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .6 ) void CALLBACK on_io_done ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); // Mostly, `Internal` and `InternalHigh` holds exactly same value with the parameters. // So these assignments are redundant. Here, we are just making sure of it. work -> Internal = errc ; // -> return of `work.error()` work -> InternalHigh = sz ; // -> return of `work.resume()` assert ( static_cast < bool > ( work -> task )); work -> task . resume (); } bool io_work_t :: ready () const noexcept { return false ; // always trigger `await_suspend` in Windows API } uint32_t get_io_error ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < uint32_t > ( target -> Internal ); } int64_t get_io_length ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < int64_t > ( target -> InternalHigh ); } // see also: `on_io_done` uint32_t io_work_t :: error () const noexcept { return get_io_error ( this ); } // zero memory the `OVERLAPPED` part in the `io_work_t` auto zero_overlapped ( io_control_block * work ) noexcept -> io_control_block * { * work = OVERLAPPED {}; return work ; } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .4 ) // for clang, this is not constexpr function. auto make_wsa_buf ( io_buffer_t v ) noexcept -> WSABUF { WSABUF buf {}; // expect NRVO buf . buf = reinterpret_cast < char *> ( v . data ()); buf . len = gsl :: narrow_cast < ULONG > ( v . size_bytes ()); return buf ; } // ensure we are x64 static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in6 *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send_to :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASendTo ( sd , bufs , 1 , nullptr , flag , // addr , addrlen , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASendTo\" }; } } int64_t io_send_to :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv_from :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecvFrom ( sd , bufs , 1 , nullptr , & flag , // addr , & addrlen , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecvFrom\" }; } } int64_t io_recv_from :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_send` return * reinterpret_cast < io_send *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASend ( sd , bufs , 1 , nullptr , flag , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASend\" }; } } int64_t io_send :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_recv` return * reinterpret_cast < io_recv *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecv ( sd , bufs , 1 , nullptr , & flag , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecv\" }; } } int64_t io_recv :: resume () noexcept { return get_io_length ( this ); } } // namespace coro","title":"File io\\_windows.cpp"},{"location":"io__windows_8cpp_source/#file-io95windowscpp","text":"File List > modules > net > io_windows.cpp Go to the documentation of this file. #include <cassert> #include <coroutine/net.h> using namespace std ; using namespace gsl ; namespace coro { //void wait_net_tasks(enumerable<coroutine_handle<void>>& tasks, // chrono::nanoseconds) noexcept(false) { // // windows implementation rely on callback. // // So there is noting to yield ... // tasks = enumerable<coroutine_handle<void>>{}; // // Just comsume some items in this thread's APC queue // SleepEx(0, true); //} bool is_async_pending ( int ec ) noexcept { switch ( ec ) { case WSAEWOULDBLOCK : case EWOULDBLOCK : case EINPROGRESS : case ERROR_IO_PENDING : return true ; default : return false ; } } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .6 ) void CALLBACK on_io_done ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); // Mostly, `Internal` and `InternalHigh` holds exactly same value with the parameters. // So these assignments are redundant. Here, we are just making sure of it. work -> Internal = errc ; // -> return of `work.error()` work -> InternalHigh = sz ; // -> return of `work.resume()` assert ( static_cast < bool > ( work -> task )); work -> task . resume (); } bool io_work_t :: ready () const noexcept { return false ; // always trigger `await_suspend` in Windows API } uint32_t get_io_error ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < uint32_t > ( target -> Internal ); } int64_t get_io_length ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < int64_t > ( target -> InternalHigh ); } // see also: `on_io_done` uint32_t io_work_t :: error () const noexcept { return get_io_error ( this ); } // zero memory the `OVERLAPPED` part in the `io_work_t` auto zero_overlapped ( io_control_block * work ) noexcept -> io_control_block * { * work = OVERLAPPED {}; return work ; } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .4 ) // for clang, this is not constexpr function. auto make_wsa_buf ( io_buffer_t v ) noexcept -> WSABUF { WSABUF buf {}; // expect NRVO buf . buf = reinterpret_cast < char *> ( v . data ()); buf . len = gsl :: narrow_cast < ULONG > ( v . size_bytes ()); return buf ; } // ensure we are x64 static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in6 *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send_to :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASendTo ( sd , bufs , 1 , nullptr , flag , // addr , addrlen , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASendTo\" }; } } int64_t io_send_to :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv_from :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecvFrom ( sd , bufs , 1 , nullptr , & flag , // addr , & addrlen , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecvFrom\" }; } } int64_t io_recv_from :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_send` return * reinterpret_cast < io_send *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASend ( sd , bufs , 1 , nullptr , flag , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASend\" }; } } int64_t io_send :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_recv` return * reinterpret_cast < io_recv *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecv ( sd , bufs , 1 , nullptr , & flag , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecv\" }; } } int64_t io_recv :: resume () noexcept { return get_io_length ( this ); } } // namespace coro","title":"File io_windows.cpp"},{"location":"kqueue_8cpp/","text":"File kqueue.cpp \u00b6 File List > modules > system > kqueue.cpp Go to the source code of this file. #include <coroutine/unix.h> #include <system_error> #include <unistd.h> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/system/kqueue.cpp","title":"File kqueue.cpp"},{"location":"kqueue_8cpp/#file-kqueuecpp","text":"File List > modules > system > kqueue.cpp Go to the source code of this file. #include <coroutine/unix.h> #include <system_error> #include <unistd.h>","title":"File kqueue.cpp"},{"location":"kqueue_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/system/kqueue.cpp","title":"Namespaces"},{"location":"kqueue_8cpp_source/","text":"File kqueue.cpp \u00b6 File List > modules > system > kqueue.cpp Go to the documentation of this file. #include <coroutine/unix.h> #include <system_error> #include <unistd.h> namespace coro { kqueue_owner :: kqueue_owner () noexcept ( false ) : kqfd { kqueue ()} { if ( kqfd < 0 ) throw system_error { errno , system_category (), \"kqueue\" }; } kqueue_owner ::~ kqueue_owner () noexcept { close ( kqfd ); } void kqueue_owner :: change ( kevent64_s & req ) noexcept ( false ) { // attach the event config auto ec = kevent64 ( kqfd , & req , 1 , nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } ptrdiff_t kqueue_owner :: events ( const timespec & ts , gsl :: span < kevent64_s > events ) noexcept ( false ) { // wait for events ... auto count = kevent64 ( kqfd , nullptr , 0 , // events . data (), events . size (), // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; return static_cast < ptrdiff_t > ( count ); } } // namespace coro","title":"File kqueue.cpp"},{"location":"kqueue_8cpp_source/#file-kqueuecpp","text":"File List > modules > system > kqueue.cpp Go to the documentation of this file. #include <coroutine/unix.h> #include <system_error> #include <unistd.h> namespace coro { kqueue_owner :: kqueue_owner () noexcept ( false ) : kqfd { kqueue ()} { if ( kqfd < 0 ) throw system_error { errno , system_category (), \"kqueue\" }; } kqueue_owner ::~ kqueue_owner () noexcept { close ( kqfd ); } void kqueue_owner :: change ( kevent64_s & req ) noexcept ( false ) { // attach the event config auto ec = kevent64 ( kqfd , & req , 1 , nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } ptrdiff_t kqueue_owner :: events ( const timespec & ts , gsl :: span < kevent64_s > events ) noexcept ( false ) { // wait for events ... auto count = kevent64 ( kqfd , nullptr , 0 , // events . data (), events . size (), // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; return static_cast < ptrdiff_t > ( count ); } } // namespace coro","title":"File kqueue.cpp"},{"location":"libmain_8cpp/","text":"File libmain.cpp \u00b6 File List > modules > system > libmain.cpp Go to the source code of this file. Macros \u00b6 Type Name define EPILOGUE __attribute__((destructor)) define PROLOGUE __attribute__((constructor)) Macro Definition Documentation \u00b6 define EPILOGUE \u00b6 #define EPILOGUE __attribute__((destructor)) define PROLOGUE \u00b6 #define PROLOGUE __attribute__((constructor)) Author: github.com/luncliff ( luncliff@gmail.com ) The documentation for this class was generated from the following file modules/system/libmain.cpp","title":"File libmain.cpp"},{"location":"libmain_8cpp/#file-libmaincpp","text":"File List > modules > system > libmain.cpp Go to the source code of this file.","title":"File libmain.cpp"},{"location":"libmain_8cpp/#macros","text":"Type Name define EPILOGUE __attribute__((destructor)) define PROLOGUE __attribute__((constructor))","title":"Macros"},{"location":"libmain_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"libmain_8cpp/#define-epilogue","text":"#define EPILOGUE __attribute__((destructor))","title":"define EPILOGUE"},{"location":"libmain_8cpp/#define-prologue","text":"#define PROLOGUE __attribute__((constructor)) Author: github.com/luncliff ( luncliff@gmail.com ) The documentation for this class was generated from the following file modules/system/libmain.cpp","title":"define PROLOGUE"},{"location":"libmain_8cpp_source/","text":"File libmain.cpp \u00b6 File List > modules > system > libmain.cpp Go to the documentation of this file. #ifdef _WIN32 #define PROLOGUE #define EPILOGUE #else #define PROLOGUE __attribute__((constructor)) #define EPILOGUE __attribute__((destructor)) #endif #ifdef _WIN32 #include <Windows.h> // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx BOOL WINAPI DllMain ( HINSTANCE , DWORD , LPVOID ) noexcept { return TRUE ; } #endif","title":"File libmain.cpp"},{"location":"libmain_8cpp_source/#file-libmaincpp","text":"File List > modules > system > libmain.cpp Go to the documentation of this file. #ifdef _WIN32 #define PROLOGUE #define EPILOGUE #else #define PROLOGUE __attribute__((constructor)) #define EPILOGUE __attribute__((destructor)) #endif #ifdef _WIN32 #include <Windows.h> // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx BOOL WINAPI DllMain ( HINSTANCE , DWORD , LPVOID ) noexcept { return TRUE ; } #endif","title":"File libmain.cpp"},{"location":"linux_8cpp/","text":"File linux.cpp \u00b6 File List > modules > system > linux.cpp Go to the source code of this file. #include <coroutine/linux.h> #include <fcntl.h> #include <sys/eventfd.h> #include <unistd.h> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/system/linux.cpp","title":"File linux.cpp"},{"location":"linux_8cpp/#file-linuxcpp","text":"File List > modules > system > linux.cpp Go to the source code of this file. #include <coroutine/linux.h> #include <fcntl.h> #include <sys/eventfd.h> #include <unistd.h>","title":"File linux.cpp"},{"location":"linux_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/system/linux.cpp","title":"Namespaces"},{"location":"linux_8cpp_source/","text":"File linux.cpp \u00b6 File List > modules > system > linux.cpp Go to the documentation of this file. #include <coroutine/linux.h> #include <fcntl.h> #include <sys/eventfd.h> #include <unistd.h> using namespace std ; namespace coro { epoll_owner :: epoll_owner () noexcept ( false ) : epfd { epoll_create1 ( EPOLL_CLOEXEC )} { if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } epoll_owner ::~ epoll_owner () noexcept { close ( epfd ); } void epoll_owner :: try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl(EPOLL_CTL_ADD|EPOLL_CTL_MODE)\" }; } void epoll_owner :: remove ( uint64_t fd ) { epoll_event req {}; // just prevent non-null input const auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl(EPOLL_CTL_DEL)\" }; } ptrdiff_t epoll_owner :: wait ( uint32_t wait_ms , gsl :: span < epoll_event > output ) noexcept ( false ) { auto count = epoll_wait ( epfd , output . data (), output . size (), wait_ms ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; return count ; } // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) noexcept { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) noexcept { return static_cast < int64_t > ( ~ emask & state ); } void notify_event ( int64_t efd ) noexcept ( false ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd if ( write ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"write\" }; } void consume_event ( int64_t efd ) noexcept ( false ) { if ( read ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"read\" }; } event :: event () noexcept ( false ) : state {} { const auto fd = :: eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () noexcept { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } uint64_t event :: fd () const noexcept { return get_eventfd ( state ); } bool event :: is_set () const noexcept { return is_signaled ( state ); } void event :: set () noexcept ( false ) { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); notify_event ( fd ); // if it didn't throwed state = emask | static_cast < uint64_t > ( fd ); // it's signaled state from now } void event :: reset () noexcept ( false ) { const auto fd = get_eventfd ( state ); // if already signaled. nothing to do... if ( is_signaled ( state )) consume_event ( fd ); // make unsignaled state this -> state = static_cast < uint64_t > ( fd ); } } // namespace coro","title":"File linux.cpp"},{"location":"linux_8cpp_source/#file-linuxcpp","text":"File List > modules > system > linux.cpp Go to the documentation of this file. #include <coroutine/linux.h> #include <fcntl.h> #include <sys/eventfd.h> #include <unistd.h> using namespace std ; namespace coro { epoll_owner :: epoll_owner () noexcept ( false ) : epfd { epoll_create1 ( EPOLL_CLOEXEC )} { if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } epoll_owner ::~ epoll_owner () noexcept { close ( epfd ); } void epoll_owner :: try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl(EPOLL_CTL_ADD|EPOLL_CTL_MODE)\" }; } void epoll_owner :: remove ( uint64_t fd ) { epoll_event req {}; // just prevent non-null input const auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl(EPOLL_CTL_DEL)\" }; } ptrdiff_t epoll_owner :: wait ( uint32_t wait_ms , gsl :: span < epoll_event > output ) noexcept ( false ) { auto count = epoll_wait ( epfd , output . data (), output . size (), wait_ms ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; return count ; } // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) noexcept { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) noexcept { return static_cast < int64_t > ( ~ emask & state ); } void notify_event ( int64_t efd ) noexcept ( false ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd if ( write ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"write\" }; } void consume_event ( int64_t efd ) noexcept ( false ) { if ( read ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"read\" }; } event :: event () noexcept ( false ) : state {} { const auto fd = :: eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () noexcept { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } uint64_t event :: fd () const noexcept { return get_eventfd ( state ); } bool event :: is_set () const noexcept { return is_signaled ( state ); } void event :: set () noexcept ( false ) { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); notify_event ( fd ); // if it didn't throwed state = emask | static_cast < uint64_t > ( fd ); // it's signaled state from now } void event :: reset () noexcept ( false ) { const auto fd = get_eventfd ( state ); // if already signaled. nothing to do... if ( is_signaled ( state )) consume_event ( fd ); // make unsignaled state this -> state = static_cast < uint64_t > ( fd ); } } // namespace coro","title":"File linux.cpp"},{"location":"linux_8h/","text":"File linux.h \u00b6 File List > coroutine > linux.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/epoll.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"File linux.h"},{"location":"linux_8h/#file-linuxh","text":"File List > coroutine > linux.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/epoll.h>","title":"File linux.h"},{"location":"linux_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"linux_8h/#classes","text":"Type Name class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __","title":"Classes"},{"location":"linux_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"Detailed Description"},{"location":"linux_8h_source/","text":"File linux.h \u00b6 File List > coroutine > linux.h Go to the documentation of this file. #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if not(defined(__linux__)) #error \"expect Linux platform for this file\" #endif #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/epoll.h> // for Linux epoll namespace coro { using namespace std ; using namespace std :: experimental ; class epoll_owner final { int64_t epfd ; public : epoll_owner () noexcept ( false ); ~ epoll_owner () noexcept ; epoll_owner ( const epoll_owner & ) = delete ; epoll_owner ( epoll_owner && ) = delete ; epoll_owner & operator = ( const epoll_owner & ) = delete ; epoll_owner & operator = ( epoll_owner && ) = delete ; public : void try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ); void remove ( uint64_t fd ); ptrdiff_t wait ( uint32_t wait_ms , gsl :: span < epoll_event > list ) noexcept ( false ); public : [[ nodiscard ]] auto submit ( int64_t fd , epoll_event & req ) noexcept { class awaiter final : public suspend_always { epoll_owner & ep ; int64_t fd ; epoll_event & req ; public : constexpr awaiter ( epoll_owner & _ep , int64_t _fd , epoll_event & _req ) : ep { _ep }, fd { _fd }, req { _req } { } public : void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( req . data . ptr == nullptr ) req . data . ptr = coro . address (); return ep . try_add ( fd , req ); } }; return awaiter { * this , fd , req }; } }; class event final { uint64_t state ; public : event () noexcept ( false ); ~ event () noexcept ; event ( const event & ) = delete ; event ( event && ) = delete ; event & operator = ( const event & ) = delete ; event & operator = ( event && ) = delete ; uint64_t fd () const noexcept ; bool is_set () const noexcept ; void set () noexcept ( false ); void reset () noexcept ( false ); }; auto wait_in ( epoll_owner & ep , event & efd ) { class awaiter : epoll_event { epoll_owner & ep ; event & efd ; public : awaiter ( epoll_owner & _ep , event & _efd ) noexcept : epoll_event {}, ep { _ep }, efd { _efd } { this -> events = EPOLLET | EPOLLIN | EPOLLONESHOT ; } bool await_ready () const noexcept { return efd . is_set (); } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { this -> data . ptr = coro . address (); return ep . try_add ( efd . fd (), * this ); } void await_resume () noexcept { return efd . reset (); } }; return awaiter { ep , efd }; } } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File linux.h"},{"location":"linux_8h_source/#file-linuxh","text":"File List > coroutine > linux.h Go to the documentation of this file. #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if not(defined(__linux__)) #error \"expect Linux platform for this file\" #endif #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/epoll.h> // for Linux epoll namespace coro { using namespace std ; using namespace std :: experimental ; class epoll_owner final { int64_t epfd ; public : epoll_owner () noexcept ( false ); ~ epoll_owner () noexcept ; epoll_owner ( const epoll_owner & ) = delete ; epoll_owner ( epoll_owner && ) = delete ; epoll_owner & operator = ( const epoll_owner & ) = delete ; epoll_owner & operator = ( epoll_owner && ) = delete ; public : void try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ); void remove ( uint64_t fd ); ptrdiff_t wait ( uint32_t wait_ms , gsl :: span < epoll_event > list ) noexcept ( false ); public : [[ nodiscard ]] auto submit ( int64_t fd , epoll_event & req ) noexcept { class awaiter final : public suspend_always { epoll_owner & ep ; int64_t fd ; epoll_event & req ; public : constexpr awaiter ( epoll_owner & _ep , int64_t _fd , epoll_event & _req ) : ep { _ep }, fd { _fd }, req { _req } { } public : void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( req . data . ptr == nullptr ) req . data . ptr = coro . address (); return ep . try_add ( fd , req ); } }; return awaiter { * this , fd , req }; } }; class event final { uint64_t state ; public : event () noexcept ( false ); ~ event () noexcept ; event ( const event & ) = delete ; event ( event && ) = delete ; event & operator = ( const event & ) = delete ; event & operator = ( event && ) = delete ; uint64_t fd () const noexcept ; bool is_set () const noexcept ; void set () noexcept ( false ); void reset () noexcept ( false ); }; auto wait_in ( epoll_owner & ep , event & efd ) { class awaiter : epoll_event { epoll_owner & ep ; event & efd ; public : awaiter ( epoll_owner & _ep , event & _efd ) noexcept : epoll_event {}, ep { _ep }, efd { _efd } { this -> events = EPOLLET | EPOLLIN | EPOLLONESHOT ; } bool await_ready () const noexcept { return efd . is_set (); } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { this -> data . ptr = coro . address (); return ep . try_add ( efd . fd (), * this ); } void await_resume () noexcept { return efd . reset (); } }; return awaiter { ep , efd }; } } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File linux.h"},{"location":"macros/","text":"Macros \u00b6 c \u00b6 COROUTINE_PORTABLE_FRAME_H ( frame.h ) COROUTINE_NET_IO_H ( net.h ) COROUTINE_PROMISE_AND_RETURN_TYPES_H ( return.h ) COROUTINE_SYSTEM_WRAPPER_H ( windows.h ) e \u00b6 EPILOGUE ( libmain.cpp ) l \u00b6 LUNCLIFF_COROUTINE_CHANNEL_HPP ( channel.hpp ) p \u00b6 PROLOGUE ( libmain.cpp )","title":"Macros"},{"location":"macros/#macros","text":"","title":"Macros"},{"location":"macros/#c","text":"COROUTINE_PORTABLE_FRAME_H ( frame.h ) COROUTINE_NET_IO_H ( net.h ) COROUTINE_PROMISE_AND_RETURN_TYPES_H ( return.h ) COROUTINE_SYSTEM_WRAPPER_H ( windows.h )","title":"c"},{"location":"macros/#e","text":"EPILOGUE ( libmain.cpp )","title":"e"},{"location":"macros/#l","text":"LUNCLIFF_COROUTINE_CHANNEL_HPP ( channel.hpp )","title":"l"},{"location":"macros/#p","text":"PROLOGUE ( libmain.cpp )","title":"p"},{"location":"modules/","text":"Modules \u00b6 Here is a list of all modules: BSD Linux NetResolve NetWork POSIX Return Windows","title":"Groups"},{"location":"modules/#modules","text":"Here is a list of all modules: BSD Linux NetResolve NetWork POSIX Return Windows","title":"Modules"},{"location":"namespace_member_enums/","text":"Namespace Member Enums \u00b6","title":"Namespace Member Enums"},{"location":"namespace_member_enums/#namespace-member-enums","text":"","title":"Namespace Member Enums"},{"location":"namespace_member_functions/","text":"Namespace Member Functions \u00b6 c \u00b6 consume_event ( coro ) g \u00b6 GSL_SUPPRESS ( coro ) get_address ( coro ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro ) i \u00b6 is_async_pending ( coro ) is_signaled ( coro ) n \u00b6 notify_event ( coro ) noop_coroutine ( std::experimental ) o \u00b6 on_io_done ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental ) p \u00b6 poison ( coro::internal ) poll_net_tasks ( coro ) r \u00b6 recv_from ( coro ) recv_stream ( coro ) resume_net_task ( coro ) s \u00b6 select ( coro ) send_stream ( coro ) send_to ( coro ) w \u00b6 wait_event_on_thread_pool ( coro ) wait_in ( coro ) z \u00b6 zero_overlapped ( coro )","title":"Namespace Member Functions"},{"location":"namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"namespace_member_functions/#c","text":"consume_event ( coro )","title":"c"},{"location":"namespace_member_functions/#g","text":"GSL_SUPPRESS ( coro ) get_address ( coro ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro )","title":"g"},{"location":"namespace_member_functions/#i","text":"is_async_pending ( coro ) is_signaled ( coro )","title":"i"},{"location":"namespace_member_functions/#n","text":"notify_event ( coro ) noop_coroutine ( std::experimental )","title":"n"},{"location":"namespace_member_functions/#o","text":"on_io_done ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental )","title":"o"},{"location":"namespace_member_functions/#p","text":"poison ( coro::internal ) poll_net_tasks ( coro )","title":"p"},{"location":"namespace_member_functions/#r","text":"recv_from ( coro ) recv_stream ( coro ) resume_net_task ( coro )","title":"r"},{"location":"namespace_member_functions/#s","text":"select ( coro ) send_stream ( coro ) send_to ( coro )","title":"s"},{"location":"namespace_member_functions/#w","text":"wait_event_on_thread_pool ( coro ) wait_in ( coro )","title":"w"},{"location":"namespace_member_functions/#z","text":"zero_overlapped ( coro )","title":"z"},{"location":"namespace_member_typedefs/","text":"Namespace Member Typedefs \u00b6 i \u00b6 io_buffer_t ( coro ) n \u00b6 net_callback_t ( coro ) noop_coroutine_handle ( std::experimental )","title":"Namespace Member Typedefs"},{"location":"namespace_member_typedefs/#namespace-member-typedefs","text":"","title":"Namespace Member Typedefs"},{"location":"namespace_member_typedefs/#i","text":"io_buffer_t ( coro )","title":"i"},{"location":"namespace_member_typedefs/#n","text":"net_callback_t ( coro ) noop_coroutine_handle ( std::experimental )","title":"n"},{"location":"namespace_member_variables/","text":"Namespace Member Variables \u00b6 e \u00b6 emask ( coro ) i \u00b6 iep ( coro ) n \u00b6 netkq ( coro ) o \u00b6 oep ( coro )","title":"Namespace Member Variables"},{"location":"namespace_member_variables/#namespace-member-variables","text":"","title":"Namespace Member Variables"},{"location":"namespace_member_variables/#e","text":"emask ( coro )","title":"e"},{"location":"namespace_member_variables/#i","text":"iep ( coro )","title":"i"},{"location":"namespace_member_variables/#n","text":"netkq ( coro )","title":"n"},{"location":"namespace_member_variables/#o","text":"oep ( coro )","title":"o"},{"location":"namespace_members/","text":"Namespace Members \u00b6 c \u00b6 consume_event ( coro ) e \u00b6 emask ( coro ) g \u00b6 GSL_SUPPRESS ( coro ) get_address ( coro ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro ) i \u00b6 iep ( coro ) io_buffer_t ( coro ) is_async_pending ( coro ) is_signaled ( coro ) n \u00b6 net_callback_t ( coro ) netkq ( coro ) notify_event ( coro ) noop_coroutine ( std::experimental ) noop_coroutine_handle ( std::experimental ) o \u00b6 oep ( coro ) on_io_done ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental ) p \u00b6 poison ( coro::internal ) poll_net_tasks ( coro ) r \u00b6 recv_from ( coro ) recv_stream ( coro ) resume_net_task ( coro ) s \u00b6 select ( coro ) send_stream ( coro ) send_to ( coro ) w \u00b6 wait_event_on_thread_pool ( coro ) wait_in ( coro ) z \u00b6 zero_overlapped ( coro )","title":"Namespace Members"},{"location":"namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"namespace_members/#c","text":"consume_event ( coro )","title":"c"},{"location":"namespace_members/#e","text":"emask ( coro )","title":"e"},{"location":"namespace_members/#g","text":"GSL_SUPPRESS ( coro ) get_address ( coro ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro )","title":"g"},{"location":"namespace_members/#i","text":"iep ( coro ) io_buffer_t ( coro ) is_async_pending ( coro ) is_signaled ( coro )","title":"i"},{"location":"namespace_members/#n","text":"net_callback_t ( coro ) netkq ( coro ) notify_event ( coro ) noop_coroutine ( std::experimental ) noop_coroutine_handle ( std::experimental )","title":"n"},{"location":"namespace_members/#o","text":"oep ( coro ) on_io_done ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental )","title":"o"},{"location":"namespace_members/#p","text":"poison ( coro::internal ) poll_net_tasks ( coro )","title":"p"},{"location":"namespace_members/#r","text":"recv_from ( coro ) recv_stream ( coro ) resume_net_task ( coro )","title":"r"},{"location":"namespace_members/#s","text":"select ( coro ) send_stream ( coro ) send_to ( coro )","title":"s"},{"location":"namespace_members/#w","text":"wait_event_on_thread_pool ( coro ) wait_in ( coro )","title":"w"},{"location":"namespace_members/#z","text":"zero_overlapped ( coro )","title":"z"},{"location":"namespacecoro/","text":"Namespace coro \u00b6 Class List > coro More... Namespaces \u00b6 Type Name namespace internal Classes \u00b6 Type Name struct bypass_lock class channel <T, M> class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class enumerable <typename T> class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class kqueue_owner RAII wrapping for kqueue file descriptor. class peeker <typename T, typename M> class promise_aa class promise_an class promise_na class promise_nn class pthread_detacher_t Special return type that wraps pthread_detach __ class pthread_joiner_t Special return type that wraps pthread_join __ class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class reader <typename T, typename M> class section Standard lockable with win32 criticial section. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. class writer <typename T, typename M> Public Types \u00b6 Type Name typedef gsl::span< std::byte > io_buffer_t This is simply a view to storage. Be aware that it doesn't have ownership. typedef void(*)(void *ctx, coroutine_handle < void > coro) net_callback_t Public Attributes \u00b6 Type Name constexpr uint64_t emask = = 1ULL << 63 epoll_owner iep = {} kqueue_owner netkq = {} epoll_owner oep = {} Public Functions \u00b6 Type Name GSL_SUPPRESS (f. 4) noexcept void consume_event (int64_t efd) noexcept uint32_t get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in > output) noexcept Thin wrapper of getaddrinfo for IPv4. uint32_t get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in6 > output) noexcept Thin wrapper of getaddrinfo for IPv6. auto get_address (addrinfo * list) noexcept auto get_address (addrinfo * list, sockaddr_in addr) noexcept auto get_address (addrinfo * list, sockaddr_in6 addr) noexcept int64_t get_eventfd (uint64_t state) noexcept uint32_t get_io_error (const OVERLAPPED * target) noexcept int64_t get_io_length (const OVERLAPPED * target) noexcept uint32_t get_name (const sockaddr_in & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST uint32_t get_name (const sockaddr_in6 & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST bool is_async_pending (int ec) noexcept bool is_signaled (uint64_t state) noexcept void notify_event (int64_t efd) noexcept void CALLBACK on_io_done (DWORD errc, DWORD sz, LPWSAOVERLAPPED pover, DWORD flags) noexcept void poll_net_tasks (const timespec & wait_time, net_callback_t callback, void * ctx) noexcept void poll_net_tasks (uint64_t nano) noexcept auto recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_recv awaitable with the given parameters. void resume_net_task (void *, coroutine_handle < void > coro) noexcept void select ( channel < T, M > & ch, Fn && fn) noexcept void select (ChanType & ch, FuncType && fn, Args &&... args) noexcept auto send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_send awaitable with the given parameters. auto send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. auto send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. void __stdcall wait_event_on_thread_pool (PVOID ctx, BOOLEAN timedout) auto wait_in ( epoll_owner & ep, event & efd) Bind the given event ( eventfd ) to epoll_owner (Epoll) auto zero_overlapped (io_control_block * work) noexcept Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Public Types Documentation \u00b6 typedef io_buffer_t \u00b6 using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ; typedef net_callback_t \u00b6 using coro :: net_callback_t = typedef void ( * )( void * ctx , coroutine_handle < void > coro ); Public Attributes Documentation \u00b6 variable emask \u00b6 constexpr uint64_t coro :: emask ; variable iep \u00b6 epoll_owner coro :: iep ; variable netkq \u00b6 kqueue_owner coro :: netkq ; variable oep \u00b6 epoll_owner coro :: oep ; Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 coro :: GSL_SUPPRESS ( f . 4 ) noexcept function consume_event \u00b6 void coro :: consume_event ( int64_t efd ) noexcept function get_address \u00b6 uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror function get_address \u00b6 uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror function get_address \u00b6 auto coro :: get_address ( addrinfo * list ) noexcept function get_address \u00b6 auto coro :: get_address ( addrinfo * list , sockaddr_in addr ) noexcept function get_address \u00b6 auto coro :: get_address ( addrinfo * list , sockaddr_in6 addr ) noexcept function get_eventfd \u00b6 int64_t coro :: get_eventfd ( uint64_t state ) noexcept function get_io_error \u00b6 uint32_t coro :: get_io_error ( const OVERLAPPED * target ) noexcept function get_io_length \u00b6 int64_t coro :: get_io_length ( const OVERLAPPED * target ) noexcept function get_name \u00b6 uint32_t coro :: get_name ( const sockaddr_in & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo function get_name \u00b6 uint32_t coro :: get_name ( const sockaddr_in6 & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo function is_async_pending \u00b6 bool coro :: is_async_pending ( int ec ) noexcept function is_signaled \u00b6 bool coro :: is_signaled ( uint64_t state ) noexcept function notify_event \u00b6 void coro :: notify_event ( int64_t efd ) noexcept function on_io_done \u00b6 void CALLBACK coro :: on_io_done ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept function poll_net_tasks \u00b6 void coro :: poll_net_tasks ( const timespec & wait_time , net_callback_t callback , void * ctx ) noexcept function poll_net_tasks \u00b6 void coro :: poll_net_tasks ( uint64_t nano ) noexcept function recv_from \u00b6 auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from & function recv_from \u00b6 auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from & function recv_stream \u00b6 auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_recv & function resume_net_task \u00b6 void coro :: resume_net_task ( void * , coroutine_handle < void > coro ) noexcept function select \u00b6 template < typename T typename T , typename M typename M , typename Fn typename Fn > void coro :: select ( channel < T , M > & ch , Fn && fn ) noexcept function select \u00b6 template < typename ... Args , typename ChanType typename ChanType , typename FuncType typename FuncType > void coro :: select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept function send_stream \u00b6 auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_send & function send_to \u00b6 auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to & function send_to \u00b6 auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to & function wait_event_on_thread_pool \u00b6 void __stdcall coro :: wait_event_on_thread_pool ( PVOID ctx , BOOLEAN timedout ) function wait_in \u00b6 auto coro :: wait_in ( epoll_owner & ep , event & efd ) Parameters: ep epoll_owner efd event See also: event Returns: awaitable struct for the binding function zero_overlapped \u00b6 auto coro :: zero_overlapped ( io_control_block * work ) noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"Namespace coro"},{"location":"namespacecoro/#namespace-coro","text":"Class List > coro More...","title":"Namespace coro"},{"location":"namespacecoro/#namespaces","text":"Type Name namespace internal","title":"Namespaces"},{"location":"namespacecoro/#classes","text":"Type Name struct bypass_lock class channel <T, M> class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class enumerable <typename T> class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class kqueue_owner RAII wrapping for kqueue file descriptor. class peeker <typename T, typename M> class promise_aa class promise_an class promise_na class promise_nn class pthread_detacher_t Special return type that wraps pthread_detach __ class pthread_joiner_t Special return type that wraps pthread_join __ class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class reader <typename T, typename M> class section Standard lockable with win32 criticial section. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. class writer <typename T, typename M>","title":"Classes"},{"location":"namespacecoro/#public-types","text":"Type Name typedef gsl::span< std::byte > io_buffer_t This is simply a view to storage. Be aware that it doesn't have ownership. typedef void(*)(void *ctx, coroutine_handle < void > coro) net_callback_t","title":"Public Types"},{"location":"namespacecoro/#public-attributes","text":"Type Name constexpr uint64_t emask = = 1ULL << 63 epoll_owner iep = {} kqueue_owner netkq = {} epoll_owner oep = {}","title":"Public Attributes"},{"location":"namespacecoro/#public-functions","text":"Type Name GSL_SUPPRESS (f. 4) noexcept void consume_event (int64_t efd) noexcept uint32_t get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in > output) noexcept Thin wrapper of getaddrinfo for IPv4. uint32_t get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in6 > output) noexcept Thin wrapper of getaddrinfo for IPv6. auto get_address (addrinfo * list) noexcept auto get_address (addrinfo * list, sockaddr_in addr) noexcept auto get_address (addrinfo * list, sockaddr_in6 addr) noexcept int64_t get_eventfd (uint64_t state) noexcept uint32_t get_io_error (const OVERLAPPED * target) noexcept int64_t get_io_length (const OVERLAPPED * target) noexcept uint32_t get_name (const sockaddr_in & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST uint32_t get_name (const sockaddr_in6 & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST bool is_async_pending (int ec) noexcept bool is_signaled (uint64_t state) noexcept void notify_event (int64_t efd) noexcept void CALLBACK on_io_done (DWORD errc, DWORD sz, LPWSAOVERLAPPED pover, DWORD flags) noexcept void poll_net_tasks (const timespec & wait_time, net_callback_t callback, void * ctx) noexcept void poll_net_tasks (uint64_t nano) noexcept auto recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_recv awaitable with the given parameters. void resume_net_task (void *, coroutine_handle < void > coro) noexcept void select ( channel < T, M > & ch, Fn && fn) noexcept void select (ChanType & ch, FuncType && fn, Args &&... args) noexcept auto send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_send awaitable with the given parameters. auto send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. auto send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. void __stdcall wait_event_on_thread_pool (PVOID ctx, BOOLEAN timedout) auto wait_in ( epoll_owner & ep, event & efd) Bind the given event ( eventfd ) to epoll_owner (Epoll) auto zero_overlapped (io_control_block * work) noexcept","title":"Public Functions"},{"location":"namespacecoro/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com )","title":"Detailed Description"},{"location":"namespacecoro/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"namespacecoro/#typedef-io95buffer95t","text":"using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ;","title":"typedef io_buffer_t"},{"location":"namespacecoro/#typedef-net95callback95t","text":"using coro :: net_callback_t = typedef void ( * )( void * ctx , coroutine_handle < void > coro );","title":"typedef net_callback_t"},{"location":"namespacecoro/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"namespacecoro/#variable-emask","text":"constexpr uint64_t coro :: emask ;","title":"variable emask"},{"location":"namespacecoro/#variable-iep","text":"epoll_owner coro :: iep ;","title":"variable iep"},{"location":"namespacecoro/#variable-netkq","text":"kqueue_owner coro :: netkq ;","title":"variable netkq"},{"location":"namespacecoro/#variable-oep","text":"epoll_owner coro :: oep ;","title":"variable oep"},{"location":"namespacecoro/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"namespacecoro/#function-gsl95suppress","text":"coro :: GSL_SUPPRESS ( f . 4 ) noexcept","title":"function GSL_SUPPRESS"},{"location":"namespacecoro/#function-consume95event","text":"void coro :: consume_event ( int64_t efd ) noexcept","title":"function consume_event"},{"location":"namespacecoro/#function-get95address","text":"uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror","title":"function get_address"},{"location":"namespacecoro/#function-get95address_1","text":"uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror","title":"function get_address"},{"location":"namespacecoro/#function-get95address_2","text":"auto coro :: get_address ( addrinfo * list ) noexcept","title":"function get_address"},{"location":"namespacecoro/#function-get95address_3","text":"auto coro :: get_address ( addrinfo * list , sockaddr_in addr ) noexcept","title":"function get_address"},{"location":"namespacecoro/#function-get95address_4","text":"auto coro :: get_address ( addrinfo * list , sockaddr_in6 addr ) noexcept","title":"function get_address"},{"location":"namespacecoro/#function-get95eventfd","text":"int64_t coro :: get_eventfd ( uint64_t state ) noexcept","title":"function get_eventfd"},{"location":"namespacecoro/#function-get95io95error","text":"uint32_t coro :: get_io_error ( const OVERLAPPED * target ) noexcept","title":"function get_io_error"},{"location":"namespacecoro/#function-get95io95length","text":"int64_t coro :: get_io_length ( const OVERLAPPED * target ) noexcept","title":"function get_io_length"},{"location":"namespacecoro/#function-get95name","text":"uint32_t coro :: get_name ( const sockaddr_in & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"function get_name"},{"location":"namespacecoro/#function-get95name_1","text":"uint32_t coro :: get_name ( const sockaddr_in6 & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"function get_name"},{"location":"namespacecoro/#function-is95async95pending","text":"bool coro :: is_async_pending ( int ec ) noexcept","title":"function is_async_pending"},{"location":"namespacecoro/#function-is95signaled","text":"bool coro :: is_signaled ( uint64_t state ) noexcept","title":"function is_signaled"},{"location":"namespacecoro/#function-notify95event","text":"void coro :: notify_event ( int64_t efd ) noexcept","title":"function notify_event"},{"location":"namespacecoro/#function-on95io95done","text":"void CALLBACK coro :: on_io_done ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept","title":"function on_io_done"},{"location":"namespacecoro/#function-poll95net95tasks","text":"void coro :: poll_net_tasks ( const timespec & wait_time , net_callback_t callback , void * ctx ) noexcept","title":"function poll_net_tasks"},{"location":"namespacecoro/#function-poll95net95tasks_1","text":"void coro :: poll_net_tasks ( uint64_t nano ) noexcept","title":"function poll_net_tasks"},{"location":"namespacecoro/#function-recv95from","text":"auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from &","title":"function recv_from"},{"location":"namespacecoro/#function-recv95from_1","text":"auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from &","title":"function recv_from"},{"location":"namespacecoro/#function-recv95stream","text":"auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_recv &","title":"function recv_stream"},{"location":"namespacecoro/#function-resume95net95task","text":"void coro :: resume_net_task ( void * , coroutine_handle < void > coro ) noexcept","title":"function resume_net_task"},{"location":"namespacecoro/#function-select","text":"template < typename T typename T , typename M typename M , typename Fn typename Fn > void coro :: select ( channel < T , M > & ch , Fn && fn ) noexcept","title":"function select"},{"location":"namespacecoro/#function-select_1","text":"template < typename ... Args , typename ChanType typename ChanType , typename FuncType typename FuncType > void coro :: select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept","title":"function select"},{"location":"namespacecoro/#function-send95stream","text":"auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_send &","title":"function send_stream"},{"location":"namespacecoro/#function-send95to","text":"auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"function send_to"},{"location":"namespacecoro/#function-send95to_1","text":"auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"function send_to"},{"location":"namespacecoro/#function-wait95event95on95thread95pool","text":"void __stdcall coro :: wait_event_on_thread_pool ( PVOID ctx , BOOLEAN timedout )","title":"function wait_event_on_thread_pool"},{"location":"namespacecoro/#function-wait95in","text":"auto coro :: wait_in ( epoll_owner & ep , event & efd ) Parameters: ep epoll_owner efd event See also: event Returns: awaitable struct for the binding","title":"function wait_in"},{"location":"namespacecoro/#function-zero95overlapped","text":"auto coro :: zero_overlapped ( io_control_block * work ) noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"function zero_overlapped"},{"location":"namespacecoro_1_1internal/","text":"Namespace coro::internal \u00b6 Class List > coro > internal Classes \u00b6 Type Name class list <T> Public Static Functions \u00b6 Type Name void * poison () noexcept Public Static Functions Documentation \u00b6 function poison \u00b6 static inline void * coro :: internal :: poison () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"Namespace coro::internal"},{"location":"namespacecoro_1_1internal/#namespace-corointernal","text":"Class List > coro > internal","title":"Namespace coro::internal"},{"location":"namespacecoro_1_1internal/#classes","text":"Type Name class list <T>","title":"Classes"},{"location":"namespacecoro_1_1internal/#public-static-functions","text":"Type Name void * poison () noexcept","title":"Public Static Functions"},{"location":"namespacecoro_1_1internal/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"namespacecoro_1_1internal/#function-poison","text":"static inline void * coro :: internal :: poison () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"function poison"},{"location":"namespacegsl/","text":"Namespace gsl \u00b6 Class List > gsl The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"Namespace gsl"},{"location":"namespacegsl/#namespace-gsl","text":"Class List > gsl The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"Namespace gsl"},{"location":"namespaces/","text":"Namespace List \u00b6 Here is a list of all namespaces with brief descriptions: namespace coro namespace internal namespace gsl namespace std namespace experimental namespace chrono","title":"Namespaces"},{"location":"namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace coro namespace internal namespace gsl namespace std namespace experimental namespace chrono","title":"Namespace List"},{"location":"namespacestd/","text":"Namespace std \u00b6 Class List > std Namespaces \u00b6 Type Name namespace experimental The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Namespace std"},{"location":"namespacestd/#namespace-std","text":"Class List > std","title":"Namespace std"},{"location":"namespacestd/#namespaces","text":"Type Name namespace experimental The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Namespaces"},{"location":"namespacestd_1_1chrono/","text":"Namespace std::chrono \u00b6 Class List > chrono The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"Namespace std::chrono"},{"location":"namespacestd_1_1chrono/#namespace-stdchrono","text":"Class List > chrono The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"Namespace std::chrono"},{"location":"namespacestd_1_1experimental/","text":"Namespace std::experimental \u00b6 Class List > std > experimental Classes \u00b6 Type Name class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never Public Types \u00b6 Type Name typedef coroutine_handle < noop_coroutine_promise > noop_coroutine_handle Public Functions \u00b6 Type Name noop_coroutine_handle noop_coroutine () noexcept bool operator!= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator< (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator<= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator== (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator> (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator>= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept Public Types Documentation \u00b6 typedef noop_coroutine_handle \u00b6 using std :: experimental :: noop_coroutine_handle = typedef coroutine_handle < noop_coroutine_promise > ; Public Functions Documentation \u00b6 function noop_coroutine \u00b6 inline noop_coroutine_handle std :: experimental :: noop_coroutine () noexcept function operator!= \u00b6 inline bool std :: experimental :: operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator< \u00b6 inline bool std :: experimental :: operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator<= \u00b6 inline bool std :: experimental :: operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator== \u00b6 inline bool std :: experimental :: operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator> \u00b6 inline bool std :: experimental :: operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator>= \u00b6 inline bool std :: experimental :: operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Namespace std::experimental"},{"location":"namespacestd_1_1experimental/#namespace-stdexperimental","text":"Class List > std > experimental","title":"Namespace std::experimental"},{"location":"namespacestd_1_1experimental/#classes","text":"Type Name class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never","title":"Classes"},{"location":"namespacestd_1_1experimental/#public-types","text":"Type Name typedef coroutine_handle < noop_coroutine_promise > noop_coroutine_handle","title":"Public Types"},{"location":"namespacestd_1_1experimental/#public-functions","text":"Type Name noop_coroutine_handle noop_coroutine () noexcept bool operator!= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator< (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator<= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator== (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator> (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator>= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept","title":"Public Functions"},{"location":"namespacestd_1_1experimental/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"namespacestd_1_1experimental/#typedef-noop95coroutine95handle","text":"using std :: experimental :: noop_coroutine_handle = typedef coroutine_handle < noop_coroutine_promise > ;","title":"typedef noop_coroutine_handle"},{"location":"namespacestd_1_1experimental/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"namespacestd_1_1experimental/#function-noop95coroutine","text":"inline noop_coroutine_handle std :: experimental :: noop_coroutine () noexcept","title":"function noop_coroutine"},{"location":"namespacestd_1_1experimental/#function-operator","text":"inline bool std :: experimental :: operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator!="},{"location":"namespacestd_1_1experimental/#function-operator_1","text":"inline bool std :: experimental :: operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator&lt;"},{"location":"namespacestd_1_1experimental/#function-operator_2","text":"inline bool std :: experimental :: operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator&lt;="},{"location":"namespacestd_1_1experimental/#function-operator_3","text":"inline bool std :: experimental :: operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator=="},{"location":"namespacestd_1_1experimental/#function-operator_4","text":"inline bool std :: experimental :: operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator&gt;"},{"location":"namespacestd_1_1experimental/#function-operator_5","text":"inline bool std :: experimental :: operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function operator&gt;="},{"location":"net_8h/","text":"File net.h \u00b6 File List > coroutine > net.h Go to the source code of this file. Async I/O operation support with system socket functions. More... #include <coroutine/return.h> #include <gsl/gsl> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. Macros \u00b6 Type Name define COROUTINE_NET_IO_H Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 Macro Definition Documentation \u00b6 define COROUTINE_NET_IO_H \u00b6 #define COROUTINE_NET_IO_H The documentation for this class was generated from the following file interface/coroutine/net.h","title":"File net.h"},{"location":"net_8h/#file-neth","text":"File List > coroutine > net.h Go to the source code of this file. Async I/O operation support with system socket functions. More... #include <coroutine/return.h> #include <gsl/gsl>","title":"File net.h"},{"location":"net_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"net_8h/#classes","text":"Type Name class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle.","title":"Classes"},{"location":"net_8h/#macros","text":"Type Name define COROUTINE_NET_IO_H","title":"Macros"},{"location":"net_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0","title":"Detailed Description"},{"location":"net_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"net_8h/#define-coroutine95net95io95h","text":"#define COROUTINE_NET_IO_H The documentation for this class was generated from the following file interface/coroutine/net.h","title":"define COROUTINE_NET_IO_H"},{"location":"net_8h_source/","text":"File net.h \u00b6 File List > coroutine > net.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_NET_IO_H #define COROUTINE_NET_IO_H #include <coroutine/return.h> #include <gsl/gsl> #if __has_include(<WinSock2.h>) // use winsock #include <WS2tcpip.h> #include <WinSock2.h> #include <ws2def.h> static constexpr bool is_winsock = true ; static constexpr bool is_netinet = false ; using io_control_block = OVERLAPPED ; #elif __has_include(<netinet/in.h>) // use netinet #include <fcntl.h> #include <netdb.h> #include <netinet/in.h> #include <netinet/tcp.h> #include <sys/socket.h> #include <unistd.h> static constexpr bool is_winsock = false ; static constexpr bool is_netinet = true ; struct io_control_block { uint64_t internal ; // uint32_t errc, int32_t flag uint64_t internal_high ; // int64_t len, socklen_t addrlen union { struct { int32_t offset ; int32_t offset_high ; }; void * ptr ; // sockaddr* addr; }; int64_t handle ; // int64_t sd; }; #endif // winsock || netinet namespace coro { using namespace std ; using namespace std :: experimental ; using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); class io_work_t : public io_control_block { public : coroutine_handle < void > task {}; io_buffer_t buffer {}; protected : bool ready () const noexcept ; public : uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 56 ); class io_send_to final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); class io_recv_from final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); class io_send final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); class io_recv final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_send_to & ; auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_send_to & ; auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_recv_from & ; auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_recv_from & ; auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & ; auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & ; #if defined(__APPLE__) || defined(__UNIX__) || defined(__linux__) void poll_net_tasks ( uint64_t nano ) noexcept ( false ); #endif uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept ; uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept ; uint32_t get_name ( const sockaddr_in & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; uint32_t get_name ( const sockaddr_in6 & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; } // namespace coro #endif // COROUTINE_NET_IO_H","title":"File net.h"},{"location":"net_8h_source/#file-neth","text":"File List > coroutine > net.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_NET_IO_H #define COROUTINE_NET_IO_H #include <coroutine/return.h> #include <gsl/gsl> #if __has_include(<WinSock2.h>) // use winsock #include <WS2tcpip.h> #include <WinSock2.h> #include <ws2def.h> static constexpr bool is_winsock = true ; static constexpr bool is_netinet = false ; using io_control_block = OVERLAPPED ; #elif __has_include(<netinet/in.h>) // use netinet #include <fcntl.h> #include <netdb.h> #include <netinet/in.h> #include <netinet/tcp.h> #include <sys/socket.h> #include <unistd.h> static constexpr bool is_winsock = false ; static constexpr bool is_netinet = true ; struct io_control_block { uint64_t internal ; // uint32_t errc, int32_t flag uint64_t internal_high ; // int64_t len, socklen_t addrlen union { struct { int32_t offset ; int32_t offset_high ; }; void * ptr ; // sockaddr* addr; }; int64_t handle ; // int64_t sd; }; #endif // winsock || netinet namespace coro { using namespace std ; using namespace std :: experimental ; using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); class io_work_t : public io_control_block { public : coroutine_handle < void > task {}; io_buffer_t buffer {}; protected : bool ready () const noexcept ; public : uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 56 ); class io_send_to final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); class io_recv_from final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); class io_send final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); class io_recv final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_send_to & ; auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_send_to & ; auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_recv_from & ; auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_recv_from & ; auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & ; auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & ; #if defined(__APPLE__) || defined(__UNIX__) || defined(__linux__) void poll_net_tasks ( uint64_t nano ) noexcept ( false ); #endif uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept ; uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept ; uint32_t get_name ( const sockaddr_in & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; uint32_t get_name ( const sockaddr_in6 & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; } // namespace coro #endif // COROUTINE_NET_IO_H","title":"File net.h"},{"location":"pages/","text":"Related Pages \u00b6 Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"pages/#related-pages","text":"Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"pthread_8cpp/","text":"File pthread.cpp \u00b6 File List > modules > system > pthread.cpp Go to the source code of this file. #include <coroutine/pthread.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class section Standard lockable with win32 criticial section. The documentation for this class was generated from the following file modules/system/pthread.cpp","title":"File pthread.cpp"},{"location":"pthread_8cpp/#file-pthreadcpp","text":"File List > modules > system > pthread.cpp Go to the source code of this file. #include <coroutine/pthread.h>","title":"File pthread.cpp"},{"location":"pthread_8cpp/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"pthread_8cpp/#classes","text":"Type Name class section Standard lockable with win32 criticial section. The documentation for this class was generated from the following file modules/system/pthread.cpp","title":"Classes"},{"location":"pthread_8cpp_source/","text":"File pthread.cpp \u00b6 File List > modules > system > pthread.cpp Go to the documentation of this file. #include <coroutine/pthread.h> namespace coro { void * pthread_spawner_t :: pthread_resume ( void * ptr ) noexcept ( false ) { // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } void pthread_spawner_t :: resume_on_pthread ( coroutine_handle < void > rh ) // noexcept ( false ) { if ( auto ec = pthread_create ( this -> tid , this -> attr , // pthread_resume , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_joiner_t :: try_join () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; void * ptr {}; // we must acquire `tid` before the destruction if ( auto ec = pthread_join ( tid , & ptr )) { throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )) { frame . destroy (); } } pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_detacher_t :: try_detach () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; if ( auto ec = pthread_detach ( tid )) { throw system_error { ec , system_category (), \"pthread_join\" }; } } class section final { private : pthread_rwlock_t rwlock ; public : section () noexcept ( false ); ~ section () noexcept ; section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; bool try_lock () noexcept ; void lock () noexcept ( false ); void unlock () noexcept ( false ); }; section :: section () noexcept ( false ) : rwlock {} { if ( auto ec = pthread_rwlock_init ( & rwlock , nullptr )) throw system_error { ec , system_category (), \"pthread_rwlock_init\" }; } section ::~ section () noexcept { try { if ( auto ec = pthread_rwlock_destroy ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_destroy\" }; } catch ( const system_error & e ) { perror ( e . what ()); } catch (...) { perror ( \"Unknown exception in section dtor\" ); } } bool section :: try_lock () noexcept { auto ec = pthread_rwlock_trywrlock ( & rwlock ); return ec == 0 ; } void section :: lock () noexcept ( false ) { if ( auto ec = pthread_rwlock_wrlock ( & rwlock )) // EINVAL ? throw system_error { ec , system_category (), \"pthread_rwlock_wrlock\" }; } void section :: unlock () noexcept ( false ) { if ( auto ec = pthread_rwlock_unlock ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_unlock\" }; } } // namespace coro","title":"File pthread.cpp"},{"location":"pthread_8cpp_source/#file-pthreadcpp","text":"File List > modules > system > pthread.cpp Go to the documentation of this file. #include <coroutine/pthread.h> namespace coro { void * pthread_spawner_t :: pthread_resume ( void * ptr ) noexcept ( false ) { // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } void pthread_spawner_t :: resume_on_pthread ( coroutine_handle < void > rh ) // noexcept ( false ) { if ( auto ec = pthread_create ( this -> tid , this -> attr , // pthread_resume , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_joiner_t :: try_join () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; void * ptr {}; // we must acquire `tid` before the destruction if ( auto ec = pthread_join ( tid , & ptr )) { throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )) { frame . destroy (); } } pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_detacher_t :: try_detach () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; if ( auto ec = pthread_detach ( tid )) { throw system_error { ec , system_category (), \"pthread_join\" }; } } class section final { private : pthread_rwlock_t rwlock ; public : section () noexcept ( false ); ~ section () noexcept ; section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; bool try_lock () noexcept ; void lock () noexcept ( false ); void unlock () noexcept ( false ); }; section :: section () noexcept ( false ) : rwlock {} { if ( auto ec = pthread_rwlock_init ( & rwlock , nullptr )) throw system_error { ec , system_category (), \"pthread_rwlock_init\" }; } section ::~ section () noexcept { try { if ( auto ec = pthread_rwlock_destroy ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_destroy\" }; } catch ( const system_error & e ) { perror ( e . what ()); } catch (...) { perror ( \"Unknown exception in section dtor\" ); } } bool section :: try_lock () noexcept { auto ec = pthread_rwlock_trywrlock ( & rwlock ); return ec == 0 ; } void section :: lock () noexcept ( false ) { if ( auto ec = pthread_rwlock_wrlock ( & rwlock )) // EINVAL ? throw system_error { ec , system_category (), \"pthread_rwlock_wrlock\" }; } void section :: unlock () noexcept ( false ) { if ( auto ec = pthread_rwlock_unlock ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_unlock\" }; } } // namespace coro","title":"File pthread.cpp"},{"location":"pthread_8h/","text":"File pthread.h \u00b6 File List > coroutine > pthread.h Go to the source code of this file. More... #include <pthread.h> #include <system_error> #include <coroutine/frame.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class pthread_detacher_t Special return type that wraps pthread_detach __ class promise_type class pthread_joiner_t Special return type that wraps pthread_join __ class promise_type class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"File pthread.h"},{"location":"pthread_8h/#file-pthreadh","text":"File List > coroutine > pthread.h Go to the source code of this file. More... #include <pthread.h> #include <system_error> #include <coroutine/frame.h>","title":"File pthread.h"},{"location":"pthread_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"pthread_8h/#classes","text":"Type Name class pthread_detacher_t Special return type that wraps pthread_detach __ class promise_type class pthread_joiner_t Special return type that wraps pthread_join __ class promise_type class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it.","title":"Classes"},{"location":"pthread_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Detailed Description"},{"location":"pthread_8h_source/","text":"File pthread.h \u00b6 File List > coroutine > pthread.h Go to the documentation of this file. #ifndef COROUTINE_PTHREAD_UTILITY_H #define COROUTINE_PTHREAD_UTILITY_H #if not __has_include(<pthread.h>) #error \"expect <pthread.h> for this file\" #endif #include <pthread.h> #include <system_error> #include <coroutine/frame.h> namespace coro { using namespace std ; using namespace std :: experimental ; class pthread_spawner_t { void resume_on_pthread ( coroutine_handle < void > coro ) noexcept ( false ); static void * pthread_resume ( void * ptr ) noexcept ( false ); public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return resume_on_pthread ( coro ); } public : pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr } { } ~ pthread_spawner_t () noexcept = default ; private : pthread_t * const tid ; const pthread_attr_t * const attr ; }; class pthread_spawn_promise { public : pthread_t tid {}; public : auto initial_suspend () noexcept { return suspend_never {}; } void unhandled_exception () noexcept ( false ) { throw ; } auto await_transform ( const pthread_attr_t * attr ) noexcept ( false ) { if ( tid ) // already created. throw logic_error { \"pthread's spawn must be used once\" }; // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; class pthread_knower_t { public : operator pthread_t () const noexcept { return promise -> tid ; } protected : explicit pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept : promise { _promise } { } protected : pthread_spawn_promise * promise ; }; class pthread_joiner_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : auto final_suspend () noexcept { return suspend_always {}; } void return_void () noexcept { // we already returns coroutine's frame. // so `co_return` can't have its operand } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : void try_join () noexcept ( false ); public : ~ pthread_joiner_t () noexcept ( false ) { this -> try_join (); } pthread_joiner_t ( promise_type * p ) noexcept ( false ); }; class pthread_detacher_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : // detacher doesn't care about the coroutine frame's life cycle // it does nothing after `co_return` auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : void try_detach () noexcept ( false ); public : ~ pthread_detacher_t () noexcept ( false ) { this -> try_detach (); } pthread_detacher_t ( promise_type * p ) noexcept ( false ); }; } // namespace coro #endif // COROUTINE_PTHREAD_UTILITY_H","title":"File pthread.h"},{"location":"pthread_8h_source/#file-pthreadh","text":"File List > coroutine > pthread.h Go to the documentation of this file. #ifndef COROUTINE_PTHREAD_UTILITY_H #define COROUTINE_PTHREAD_UTILITY_H #if not __has_include(<pthread.h>) #error \"expect <pthread.h> for this file\" #endif #include <pthread.h> #include <system_error> #include <coroutine/frame.h> namespace coro { using namespace std ; using namespace std :: experimental ; class pthread_spawner_t { void resume_on_pthread ( coroutine_handle < void > coro ) noexcept ( false ); static void * pthread_resume ( void * ptr ) noexcept ( false ); public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return resume_on_pthread ( coro ); } public : pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr } { } ~ pthread_spawner_t () noexcept = default ; private : pthread_t * const tid ; const pthread_attr_t * const attr ; }; class pthread_spawn_promise { public : pthread_t tid {}; public : auto initial_suspend () noexcept { return suspend_never {}; } void unhandled_exception () noexcept ( false ) { throw ; } auto await_transform ( const pthread_attr_t * attr ) noexcept ( false ) { if ( tid ) // already created. throw logic_error { \"pthread's spawn must be used once\" }; // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; class pthread_knower_t { public : operator pthread_t () const noexcept { return promise -> tid ; } protected : explicit pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept : promise { _promise } { } protected : pthread_spawn_promise * promise ; }; class pthread_joiner_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : auto final_suspend () noexcept { return suspend_always {}; } void return_void () noexcept { // we already returns coroutine's frame. // so `co_return` can't have its operand } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : void try_join () noexcept ( false ); public : ~ pthread_joiner_t () noexcept ( false ) { this -> try_join (); } pthread_joiner_t ( promise_type * p ) noexcept ( false ); }; class pthread_detacher_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : // detacher doesn't care about the coroutine frame's life cycle // it does nothing after `co_return` auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : void try_detach () noexcept ( false ); public : ~ pthread_detacher_t () noexcept ( false ) { this -> try_detach (); } pthread_detacher_t ( promise_type * p ) noexcept ( false ); }; } // namespace coro #endif // COROUTINE_PTHREAD_UTILITY_H","title":"File pthread.h"},{"location":"resolver_8cpp/","text":"File resolver.cpp \u00b6 File List > modules > net > resolver.cpp Go to the source code of this file. #include <coroutine/net.h> #include <internal/yield.hpp> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/net/resolver.cpp","title":"File resolver.cpp"},{"location":"resolver_8cpp/#file-resolvercpp","text":"File List > modules > net > resolver.cpp Go to the source code of this file. #include <coroutine/net.h> #include <internal/yield.hpp>","title":"File resolver.cpp"},{"location":"resolver_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/net/resolver.cpp","title":"Namespaces"},{"location":"resolver_8cpp_source/","text":"File resolver.cpp \u00b6 File List > modules > net > resolver.cpp Go to the documentation of this file. #include <coroutine/net.h> #include <internal/yield.hpp> using namespace std ; namespace coro { GSL_SUPPRESS ( type .1 ) uint32_t get_name ( const sockaddr_in & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } GSL_SUPPRESS ( type .1 ) uint32_t get_name ( const sockaddr_in6 & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in6 ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } auto get_address ( addrinfo * list ) noexcept -> enumerable < sockaddr *> { auto on_return = gsl :: finally ([ list ]() noexcept { // RAII clean up for the assigned addrinfo :: freeaddrinfo ( list ); }); for ( addrinfo * it = list ; it != nullptr ; it = it -> ai_next ) { co_yield it -> ai_addr ; } } auto get_address ( addrinfo * list , sockaddr_in addr ) noexcept -> enumerable < sockaddr_in > { for ( sockaddr * item : get_address ( list )) { const auto * ptr = reinterpret_cast < sockaddr_in *> ( item ); addr = * ptr ; co_yield addr ; } } auto get_address ( addrinfo * list , sockaddr_in6 addr ) noexcept -> enumerable < sockaddr_in6 > { for ( sockaddr * item : get_address ( list )) { const auto * ptr = reinterpret_cast < sockaddr_in6 *> ( item ); addr = * ptr ; co_yield addr ; } } uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( host , serv , // & hint , & list )) return ec ; // std::system_error{ec, system_category(), ::gai_strerror(ec)}; auto i = 0u ; for ( auto addr : get_address ( list , sockaddr_in {})) { output [ i ++ ] = addr ; if ( i == output . size ()) break ; } return 0 ; } uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( host , serv , // & hint , & list )) return ec ; auto i = 0u ; for ( auto addr : get_address ( list , sockaddr_in6 {})) { output [ i ++ ] = addr ; if ( i == output . size ()) break ; } return 0 ; } } // namespace coro","title":"File resolver.cpp"},{"location":"resolver_8cpp_source/#file-resolvercpp","text":"File List > modules > net > resolver.cpp Go to the documentation of this file. #include <coroutine/net.h> #include <internal/yield.hpp> using namespace std ; namespace coro { GSL_SUPPRESS ( type .1 ) uint32_t get_name ( const sockaddr_in & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } GSL_SUPPRESS ( type .1 ) uint32_t get_name ( const sockaddr_in6 & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in6 ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } auto get_address ( addrinfo * list ) noexcept -> enumerable < sockaddr *> { auto on_return = gsl :: finally ([ list ]() noexcept { // RAII clean up for the assigned addrinfo :: freeaddrinfo ( list ); }); for ( addrinfo * it = list ; it != nullptr ; it = it -> ai_next ) { co_yield it -> ai_addr ; } } auto get_address ( addrinfo * list , sockaddr_in addr ) noexcept -> enumerable < sockaddr_in > { for ( sockaddr * item : get_address ( list )) { const auto * ptr = reinterpret_cast < sockaddr_in *> ( item ); addr = * ptr ; co_yield addr ; } } auto get_address ( addrinfo * list , sockaddr_in6 addr ) noexcept -> enumerable < sockaddr_in6 > { for ( sockaddr * item : get_address ( list )) { const auto * ptr = reinterpret_cast < sockaddr_in6 *> ( item ); addr = * ptr ; co_yield addr ; } } uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( host , serv , // & hint , & list )) return ec ; // std::system_error{ec, system_category(), ::gai_strerror(ec)}; auto i = 0u ; for ( auto addr : get_address ( list , sockaddr_in {})) { output [ i ++ ] = addr ; if ( i == output . size ()) break ; } return 0 ; } uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( host , serv , // & hint , & list )) return ec ; auto i = 0u ; for ( auto addr : get_address ( list , sockaddr_in6 {})) { output [ i ++ ] = addr ; if ( i == output . size ()) break ; } return 0 ; } } // namespace coro","title":"File resolver.cpp"},{"location":"return_8h/","text":"File return.h \u00b6 File List > coroutine > return.h Go to the source code of this file. Utility to define return types for coroutine. More... #include <type_traits> #include <coroutine/frame.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type class promise_aa class promise_an class promise_na class promise_nn Macros \u00b6 Type Name define COROUTINE_PROMISE_AND_RETURN_TYPES_H Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/ Macro Definition Documentation \u00b6 define COROUTINE_PROMISE_AND_RETURN_TYPES_H \u00b6 #define COROUTINE_PROMISE_AND_RETURN_TYPES_H The documentation for this class was generated from the following file interface/coroutine/return.h","title":"File return.h"},{"location":"return_8h/#file-returnh","text":"File List > coroutine > return.h Go to the source code of this file. Utility to define return types for coroutine. More... #include <type_traits> #include <coroutine/frame.h>","title":"File return.h"},{"location":"return_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"return_8h/#classes","text":"Type Name class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type class promise_aa class promise_an class promise_na class promise_nn","title":"Classes"},{"location":"return_8h/#macros","text":"Type Name define COROUTINE_PROMISE_AND_RETURN_TYPES_H","title":"Macros"},{"location":"return_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/","title":"Detailed Description"},{"location":"return_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"return_8h/#define-coroutine95promise95and95return95types95h","text":"#define COROUTINE_PROMISE_AND_RETURN_TYPES_H The documentation for this class was generated from the following file interface/coroutine/return.h","title":"define COROUTINE_PROMISE_AND_RETURN_TYPES_H"},{"location":"return_8h_source/","text":"File return.h \u00b6 File List > coroutine > return.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_PROMISE_AND_RETURN_TYPES_H #define COROUTINE_PROMISE_AND_RETURN_TYPES_H #include <type_traits> #include <coroutine/frame.h> namespace coro { #if __has_include(<coroutine>) // C++ 20 using namespace std ; #elif __has_include(<experimental/coroutine>) // C++ 17 using namespace std ; using namespace std :: experimental ; #endif class promise_nn { public : suspend_never initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } }; class promise_na { public : suspend_never initial_suspend () noexcept { return {}; } suspend_always final_suspend () noexcept { return {}; } }; class promise_an { public : suspend_always initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } }; class promise_aa { public : suspend_always initial_suspend () noexcept { return {}; } suspend_always final_suspend () noexcept { return {}; } }; class frame_t final : public coroutine_handle < void > { public : class promise_type final : public coro :: promise_na { public : void unhandled_exception () noexcept ( false ) { throw ; } void return_void () noexcept { } frame_t get_return_object () noexcept { frame_t frame {}; coroutine_handle < void >& ref = frame ; ref = coroutine_handle < promise_type >:: from_promise ( * this ); return frame ; } }; }; #if defined(__cpp_concepts) template < typename T , typename R = void > concept awaitable = requires ( T a , coroutine_handle < void > h ) { { a . await_ready () } -> bool ; { a . await_suspend ( h ) } -> void ; { a . await_resume () } -> R ; }; template < typename P > concept promise_requirement_basic = requires ( P p ) { { p . initial_suspend () } -> awaitable ; { p . final_suspend () } -> awaitable ; { p . unhandled_exception () } -> void ; }; #endif } // namespace coro #endif // COROUTINE_PROMISE_AND_RETURN_TYPES_H","title":"File return.h"},{"location":"return_8h_source/#file-returnh","text":"File List > coroutine > return.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_PROMISE_AND_RETURN_TYPES_H #define COROUTINE_PROMISE_AND_RETURN_TYPES_H #include <type_traits> #include <coroutine/frame.h> namespace coro { #if __has_include(<coroutine>) // C++ 20 using namespace std ; #elif __has_include(<experimental/coroutine>) // C++ 17 using namespace std ; using namespace std :: experimental ; #endif class promise_nn { public : suspend_never initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } }; class promise_na { public : suspend_never initial_suspend () noexcept { return {}; } suspend_always final_suspend () noexcept { return {}; } }; class promise_an { public : suspend_always initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } }; class promise_aa { public : suspend_always initial_suspend () noexcept { return {}; } suspend_always final_suspend () noexcept { return {}; } }; class frame_t final : public coroutine_handle < void > { public : class promise_type final : public coro :: promise_na { public : void unhandled_exception () noexcept ( false ) { throw ; } void return_void () noexcept { } frame_t get_return_object () noexcept { frame_t frame {}; coroutine_handle < void >& ref = frame ; ref = coroutine_handle < promise_type >:: from_promise ( * this ); return frame ; } }; }; #if defined(__cpp_concepts) template < typename T , typename R = void > concept awaitable = requires ( T a , coroutine_handle < void > h ) { { a . await_ready () } -> bool ; { a . await_suspend ( h ) } -> void ; { a . await_resume () } -> R ; }; template < typename P > concept promise_requirement_basic = requires ( P p ) { { p . initial_suspend () } -> awaitable ; { p . final_suspend () } -> awaitable ; { p . unhandled_exception () } -> void ; }; #endif } // namespace coro #endif // COROUTINE_PROMISE_AND_RETURN_TYPES_H","title":"File return.h"},{"location":"structclang__frame__prefix/","text":"Struct clang_frame_prefix \u00b6 Class List > clang_frame_prefix #include <frame.h> Public Attributes \u00b6 Type Name procedure_t factivate procedure_t fdestroy Public Attributes Documentation \u00b6 variable factivate \u00b6 procedure_t clang_frame_prefix :: factivate ; variable fdestroy \u00b6 procedure_t clang_frame_prefix :: fdestroy ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct clang\\_frame\\_prefix"},{"location":"structclang__frame__prefix/#struct-clang95frame95prefix","text":"Class List > clang_frame_prefix #include <frame.h>","title":"Struct clang_frame_prefix"},{"location":"structclang__frame__prefix/#public-attributes","text":"Type Name procedure_t factivate procedure_t fdestroy","title":"Public Attributes"},{"location":"structclang__frame__prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structclang__frame__prefix/#variable-factivate","text":"procedure_t clang_frame_prefix :: factivate ;","title":"variable factivate"},{"location":"structclang__frame__prefix/#variable-fdestroy","text":"procedure_t clang_frame_prefix :: fdestroy ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable fdestroy"},{"location":"structcoro_1_1bypass__lock/","text":"Struct coro::bypass_lock \u00b6 Class List > coro > bypass_lock #include <channel.hpp> Public Functions \u00b6 Type Name constexpr void lock () noexcept constexpr bool try_lock () noexcept constexpr void unlock () noexcept Public Functions Documentation \u00b6 function lock \u00b6 inline constexpr void coro :: bypass_lock :: lock () noexcept function try_lock \u00b6 inline constexpr bool coro :: bypass_lock :: try_lock () noexcept function unlock \u00b6 inline constexpr void coro :: bypass_lock :: unlock () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"Struct coro::bypass\\_lock"},{"location":"structcoro_1_1bypass__lock/#struct-corobypass95lock","text":"Class List > coro > bypass_lock #include <channel.hpp>","title":"Struct coro::bypass_lock"},{"location":"structcoro_1_1bypass__lock/#public-functions","text":"Type Name constexpr void lock () noexcept constexpr bool try_lock () noexcept constexpr void unlock () noexcept","title":"Public Functions"},{"location":"structcoro_1_1bypass__lock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structcoro_1_1bypass__lock/#function-lock","text":"inline constexpr void coro :: bypass_lock :: lock () noexcept","title":"function lock"},{"location":"structcoro_1_1bypass__lock/#function-try95lock","text":"inline constexpr bool coro :: bypass_lock :: try_lock () noexcept","title":"function try_lock"},{"location":"structcoro_1_1bypass__lock/#function-unlock","text":"inline constexpr void coro :: bypass_lock :: unlock () noexcept The documentation for this class was generated from the following file interface/internal/channel.hpp","title":"function unlock"},{"location":"structgcc__frame__prefix/","text":"Struct gcc_frame_prefix \u00b6 Class List > gcc_frame_prefix #include <frame.h> Public Attributes \u00b6 Type Name void * _unknown1 void * _unknown2 Public Attributes Documentation \u00b6 variable _unknown1 \u00b6 void * gcc_frame_prefix :: _unknown1 ; variable _unknown2 \u00b6 void * gcc_frame_prefix :: _unknown2 ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct gcc\\_frame\\_prefix"},{"location":"structgcc__frame__prefix/#struct-gcc95frame95prefix","text":"Class List > gcc_frame_prefix #include <frame.h>","title":"Struct gcc_frame_prefix"},{"location":"structgcc__frame__prefix/#public-attributes","text":"Type Name void * _unknown1 void * _unknown2","title":"Public Attributes"},{"location":"structgcc__frame__prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structgcc__frame__prefix/#variable-95unknown1","text":"void * gcc_frame_prefix :: _unknown1 ;","title":"variable _unknown1"},{"location":"structgcc__frame__prefix/#variable-95unknown2","text":"void * gcc_frame_prefix :: _unknown2 ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable _unknown2"},{"location":"structmsvc__frame__prefix/","text":"Struct msvc_frame_prefix \u00b6 Class List > msvc_frame_prefix #include <frame.h> Public Attributes \u00b6 Type Name procedure_t factivate uint16_t flag uint16_t index Public Attributes Documentation \u00b6 variable factivate \u00b6 procedure_t msvc_frame_prefix :: factivate ; variable flag \u00b6 uint16_t msvc_frame_prefix :: flag ; variable index \u00b6 uint16_t msvc_frame_prefix :: index ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct msvc\\_frame\\_prefix"},{"location":"structmsvc__frame__prefix/#struct-msvc95frame95prefix","text":"Class List > msvc_frame_prefix #include <frame.h>","title":"Struct msvc_frame_prefix"},{"location":"structmsvc__frame__prefix/#public-attributes","text":"Type Name procedure_t factivate uint16_t flag uint16_t index","title":"Public Attributes"},{"location":"structmsvc__frame__prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structmsvc__frame__prefix/#variable-factivate","text":"procedure_t msvc_frame_prefix :: factivate ;","title":"variable factivate"},{"location":"structmsvc__frame__prefix/#variable-flag","text":"uint16_t msvc_frame_prefix :: flag ;","title":"variable flag"},{"location":"structmsvc__frame__prefix/#variable-index","text":"uint16_t msvc_frame_prefix :: index ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable index"},{"location":"structstd_1_1experimental_1_1coroutine__traits/","text":"Struct std::experimental::coroutine_traits \u00b6 template <typename ReturnType typename ReturnType, typename... Args> Class List > std > experimental > coroutine_traits #include <frame.h> Public Types \u00b6 Type Name typedef typename ReturnType::promise_type promise_type Public Types Documentation \u00b6 typedef promise_type \u00b6 using std :: experimental :: coroutine_traits < ReturnType , Args >:: promise_type = typename ReturnType :: promise_type ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct std::experimental::coroutine\\_traits"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#struct-stdexperimentalcoroutine95traits","text":"template <typename ReturnType typename ReturnType, typename... Args> Class List > std > experimental > coroutine_traits #include <frame.h>","title":"Struct std::experimental::coroutine_traits"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#public-types","text":"Type Name typedef typename ReturnType::promise_type promise_type","title":"Public Types"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#typedef-promise95type","text":"using std :: experimental :: coroutine_traits < ReturnType , Args >:: promise_type = typename ReturnType :: promise_type ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"typedef promise_type"},{"location":"structstd_1_1experimental_1_1noop__coroutine__promise/","text":"Struct std::experimental::noop_coroutine_promise \u00b6 Class List > std > experimental > noop_coroutine_promise #include <frame.h> The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct std::experimental::noop\\_coroutine\\_promise"},{"location":"structstd_1_1experimental_1_1noop__coroutine__promise/#struct-stdexperimentalnoop95coroutine95promise","text":"Class List > std > experimental > noop_coroutine_promise #include <frame.h> The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct std::experimental::noop_coroutine_promise"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/","text":"Union std::experimental::coroutine_handle< void >::prefix_t \u00b6 Class List > std > experimental > coroutine_handle< void > > prefix_t #include <frame.h> Public Attributes \u00b6 Type Name clang_frame_prefix * c gcc_frame_prefix * g msvc_frame_prefix * m void * v = {} Public Attributes Documentation \u00b6 variable c \u00b6 clang_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: c ; variable g \u00b6 gcc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: g ; variable m \u00b6 msvc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: m ; variable v \u00b6 void * std :: experimental :: coroutine_handle < void >:: prefix_t :: v ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Union std::experimental::coroutine\\_handle&lt; void &gt;::prefix\\_t"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#union-stdexperimentalcoroutine95handle-void-prefix95t","text":"Class List > std > experimental > coroutine_handle< void > > prefix_t #include <frame.h>","title":"Union std::experimental::coroutine_handle&lt; void &gt;::prefix_t"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#public-attributes","text":"Type Name clang_frame_prefix * c gcc_frame_prefix * g msvc_frame_prefix * m void * v = {}","title":"Public Attributes"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-c","text":"clang_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: c ;","title":"variable c"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-g","text":"gcc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: g ;","title":"variable g"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-m","text":"msvc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: m ;","title":"variable m"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-v","text":"void * std :: experimental :: coroutine_handle < void >:: prefix_t :: v ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable v"},{"location":"unix_8h/","text":"File unix.h \u00b6 File List > coroutine > unix.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/event.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class kqueue_owner RAII wrapping for kqueue file descriptor. Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/unix.h","title":"File unix.h"},{"location":"unix_8h/#file-unixh","text":"File List > coroutine > unix.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/event.h>","title":"File unix.h"},{"location":"unix_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"unix_8h/#classes","text":"Type Name class kqueue_owner RAII wrapping for kqueue file descriptor.","title":"Classes"},{"location":"unix_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/unix.h","title":"Detailed Description"},{"location":"unix_8h_source/","text":"File unix.h \u00b6 File List > coroutine > unix.h Go to the documentation of this file. #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if not(defined(unix) or defined(__APPLE__) or defined(__FreeBSD__)) #error \"expect UNIX platform for this file\" #endif #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/event.h> // for BSD kqueue namespace coro { using namespace std ; using namespace std :: experimental ; class kqueue_owner final { int64_t kqfd ; public : kqueue_owner () noexcept ( false ); ~ kqueue_owner () noexcept ; kqueue_owner ( const kqueue_owner & ) = delete ; kqueue_owner ( kqueue_owner && ) = delete ; kqueue_owner & operator = ( const kqueue_owner & ) = delete ; kqueue_owner & operator = ( kqueue_owner && ) = delete ; public : void change ( kevent64_s & req ) noexcept ( false ); ptrdiff_t events ( const timespec & wait_time , gsl :: span < kevent64_s > list ) noexcept ( false ); public : [[ nodiscard ]] auto submit ( kevent64_s & req ) noexcept { class awaiter final : public suspend_always { kqueue_owner & kq ; kevent64_s & req ; public : constexpr awaiter ( kqueue_owner & _kq , kevent64_s & _req ) : kq { _kq }, req { _req } { } public : void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( req . udata == 0 ) req . udata = reinterpret_cast < uint64_t > ( coro . address ()); return kq . change ( req ); } }; return awaiter { * this , req }; } }; } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File unix.h"},{"location":"unix_8h_source/#file-unixh","text":"File List > coroutine > unix.h Go to the documentation of this file. #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if not(defined(unix) or defined(__APPLE__) or defined(__FreeBSD__)) #error \"expect UNIX platform for this file\" #endif #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/event.h> // for BSD kqueue namespace coro { using namespace std ; using namespace std :: experimental ; class kqueue_owner final { int64_t kqfd ; public : kqueue_owner () noexcept ( false ); ~ kqueue_owner () noexcept ; kqueue_owner ( const kqueue_owner & ) = delete ; kqueue_owner ( kqueue_owner && ) = delete ; kqueue_owner & operator = ( const kqueue_owner & ) = delete ; kqueue_owner & operator = ( kqueue_owner && ) = delete ; public : void change ( kevent64_s & req ) noexcept ( false ); ptrdiff_t events ( const timespec & wait_time , gsl :: span < kevent64_s > list ) noexcept ( false ); public : [[ nodiscard ]] auto submit ( kevent64_s & req ) noexcept { class awaiter final : public suspend_always { kqueue_owner & kq ; kevent64_s & req ; public : constexpr awaiter ( kqueue_owner & _kq , kevent64_s & _req ) : kq { _kq }, req { _req } { } public : void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( req . udata == 0 ) req . udata = reinterpret_cast < uint64_t > ( coro . address ()); return kq . change ( req ); } }; return awaiter { * this , req }; } }; } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File unix.h"},{"location":"variables/","text":"Variables \u00b6 a \u00b6 aligned_size_v ( frame.h )","title":"Variables"},{"location":"variables/#variables","text":"","title":"Variables"},{"location":"variables/#a","text":"aligned_size_v ( frame.h )","title":"a"},{"location":"windows_8cpp/","text":"File windows.cpp \u00b6 File List > modules > system > windows.cpp Go to the source code of this file. #include <Windows.h> #include <TlHelp32.h> #include <threadpoolapiset.h> #include <synchapi.h> #include <coroutine/windows.h> #include <gsl/gsl> #include <cassert> #include <system_error> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class section Standard lockable with win32 criticial section. The documentation for this class was generated from the following file modules/system/windows.cpp","title":"File windows.cpp"},{"location":"windows_8cpp/#file-windowscpp","text":"File List > modules > system > windows.cpp Go to the source code of this file. #include <Windows.h> #include <TlHelp32.h> #include <threadpoolapiset.h> #include <synchapi.h> #include <coroutine/windows.h> #include <gsl/gsl> #include <cassert> #include <system_error>","title":"File windows.cpp"},{"location":"windows_8cpp/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"windows_8cpp/#classes","text":"Type Name class section Standard lockable with win32 criticial section. The documentation for this class was generated from the following file modules/system/windows.cpp","title":"Classes"},{"location":"windows_8cpp_source/","text":"File windows.cpp \u00b6 File List > modules > system > windows.cpp Go to the documentation of this file. // clang-format off #include <Windows.h> #include <TlHelp32.h> #include <threadpoolapiset.h> #include <synchapi.h> // Windows Concurrency Runtime's event is not alertible. //#include <concrt.h> // clang-format on #include <coroutine/windows.h> #include <gsl/gsl> #include <cassert> #include <system_error> using namespace std ; using namespace gsl ; namespace coro { static_assert ( is_move_assignable_v < set_or_cancel > == false ); static_assert ( is_move_constructible_v < set_or_cancel > == false ); static_assert ( is_copy_assignable_v < set_or_cancel > == false ); static_assert ( is_copy_constructible_v < set_or_cancel > == false ); GSL_SUPPRESS ( con .4 ) void __stdcall wait_event_on_thread_pool ( PVOID ctx , BOOLEAN timedout ) { UNREFERENCED_PARAMETER ( timedout ); auto coro = coroutine_handle < void >:: from_address ( ctx ); assert ( coro . done () == false ); coro . resume (); } set_or_cancel :: set_or_cancel ( HANDLE target_event ) noexcept ( false ) : hobject { target_event } { // wait object is used as a storage for the event handle // until it is going to suspend } set_or_cancel ::~ set_or_cancel () noexcept { UnregisterWait ( hobject ); } auto set_or_cancel :: unregister () noexcept -> uint32_t { UnregisterWait ( hobject ); const auto ec = GetLastError (); if ( ec == ERROR_IO_PENDING ) { // this is expected since we are using INFINITE timeout return NO_ERROR ; } return ec ; } void set_or_cancel :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // since this point, wo becomes a handle for the request // this is one-shot event. so use infinite timeout if ( RegisterWaitForSingleObject ( addressof ( hobject ), hobject , wait_event_on_thread_pool , coro . address (), INFINITE , WT_EXECUTEONLYONCE ) == FALSE ) { throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"RegisterWaitForSingleObject\" }; } } // auto get_threads_of(DWORD pid) noexcept(false) -> enumerable<DWORD> { // // for current process // auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // if (snapshot == INVALID_HANDLE_VALUE) // co_return; // auto on_return = gsl::finally([=]() noexcept { CloseHandle(snapshot); }); // THREADENTRY32 entry{}; // entry.dwSize = sizeof(THREADENTRY32); // for (Thread32First(snapshot, &entry); Thread32Next(snapshot, &entry);) { // // filter other process's threads // if (entry.th32OwnerProcessID != pid) // co_yield entry.th32ThreadID; // entry.dwSize = sizeof(THREADENTRY32); // } // } GSL_SUPPRESS ( con .4 ) void continue_on_thread_pool :: resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , // PVOID ctx , PTP_WORK work ) { if ( auto coro = coroutine_handle < void >:: from_address ( ctx )) if ( coro . done () == false ) coro . resume (); :: CloseThreadpoolWork ( work ); // one-time work item } auto continue_on_thread_pool :: create_and_submit_work ( coroutine_handle < void > coro ) noexcept -> uint32_t { // just make sure no data loss in `static_cast` static_assert ( sizeof ( uint32_t ) == sizeof ( DWORD )); auto work = :: CreateThreadpoolWork ( resume_on_thread_pool , // coro . address (), nullptr ); if ( work == nullptr ) return GetLastError (); SubmitThreadpoolWork ( work ); return S_OK ; } GSL_SUPPRESS ( type .1 ) void continue_on_apc :: resume_on_apc ( ULONG_PTR param ) { auto ptr = reinterpret_cast < void *> ( param ); if ( auto coro = coroutine_handle < void >:: from_address ( ptr )) coro . resume (); } GSL_SUPPRESS ( type .1 ) auto continue_on_apc :: queue_user_apc ( coroutine_handle < void > coro ) noexcept -> uint32_t { const auto param = reinterpret_cast < ULONG_PTR > ( coro . address ()); if ( QueueUserAPC ( resume_on_apc , this -> thread , param ) == 0 ) return GetLastError (); return S_OK ; } class section final : CRITICAL_SECTION { section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; public : section () noexcept ( false ); ~ section () noexcept ; bool try_lock () noexcept ; void lock () noexcept ( false ); void unlock () noexcept ( false ); }; section :: section () noexcept ( false ) { InitializeCriticalSectionAndSpinCount ( this , 0600 ); } section ::~ section () noexcept { DeleteCriticalSection ( this ); } bool section :: try_lock () noexcept { return TryEnterCriticalSection ( this ); } void section :: lock () noexcept ( false ) { EnterCriticalSection ( this ); } void section :: unlock () noexcept ( false ) { LeaveCriticalSection ( this ); } } // namespace coro","title":"File windows.cpp"},{"location":"windows_8cpp_source/#file-windowscpp","text":"File List > modules > system > windows.cpp Go to the documentation of this file. // clang-format off #include <Windows.h> #include <TlHelp32.h> #include <threadpoolapiset.h> #include <synchapi.h> // Windows Concurrency Runtime's event is not alertible. //#include <concrt.h> // clang-format on #include <coroutine/windows.h> #include <gsl/gsl> #include <cassert> #include <system_error> using namespace std ; using namespace gsl ; namespace coro { static_assert ( is_move_assignable_v < set_or_cancel > == false ); static_assert ( is_move_constructible_v < set_or_cancel > == false ); static_assert ( is_copy_assignable_v < set_or_cancel > == false ); static_assert ( is_copy_constructible_v < set_or_cancel > == false ); GSL_SUPPRESS ( con .4 ) void __stdcall wait_event_on_thread_pool ( PVOID ctx , BOOLEAN timedout ) { UNREFERENCED_PARAMETER ( timedout ); auto coro = coroutine_handle < void >:: from_address ( ctx ); assert ( coro . done () == false ); coro . resume (); } set_or_cancel :: set_or_cancel ( HANDLE target_event ) noexcept ( false ) : hobject { target_event } { // wait object is used as a storage for the event handle // until it is going to suspend } set_or_cancel ::~ set_or_cancel () noexcept { UnregisterWait ( hobject ); } auto set_or_cancel :: unregister () noexcept -> uint32_t { UnregisterWait ( hobject ); const auto ec = GetLastError (); if ( ec == ERROR_IO_PENDING ) { // this is expected since we are using INFINITE timeout return NO_ERROR ; } return ec ; } void set_or_cancel :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // since this point, wo becomes a handle for the request // this is one-shot event. so use infinite timeout if ( RegisterWaitForSingleObject ( addressof ( hobject ), hobject , wait_event_on_thread_pool , coro . address (), INFINITE , WT_EXECUTEONLYONCE ) == FALSE ) { throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"RegisterWaitForSingleObject\" }; } } // auto get_threads_of(DWORD pid) noexcept(false) -> enumerable<DWORD> { // // for current process // auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // if (snapshot == INVALID_HANDLE_VALUE) // co_return; // auto on_return = gsl::finally([=]() noexcept { CloseHandle(snapshot); }); // THREADENTRY32 entry{}; // entry.dwSize = sizeof(THREADENTRY32); // for (Thread32First(snapshot, &entry); Thread32Next(snapshot, &entry);) { // // filter other process's threads // if (entry.th32OwnerProcessID != pid) // co_yield entry.th32ThreadID; // entry.dwSize = sizeof(THREADENTRY32); // } // } GSL_SUPPRESS ( con .4 ) void continue_on_thread_pool :: resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , // PVOID ctx , PTP_WORK work ) { if ( auto coro = coroutine_handle < void >:: from_address ( ctx )) if ( coro . done () == false ) coro . resume (); :: CloseThreadpoolWork ( work ); // one-time work item } auto continue_on_thread_pool :: create_and_submit_work ( coroutine_handle < void > coro ) noexcept -> uint32_t { // just make sure no data loss in `static_cast` static_assert ( sizeof ( uint32_t ) == sizeof ( DWORD )); auto work = :: CreateThreadpoolWork ( resume_on_thread_pool , // coro . address (), nullptr ); if ( work == nullptr ) return GetLastError (); SubmitThreadpoolWork ( work ); return S_OK ; } GSL_SUPPRESS ( type .1 ) void continue_on_apc :: resume_on_apc ( ULONG_PTR param ) { auto ptr = reinterpret_cast < void *> ( param ); if ( auto coro = coroutine_handle < void >:: from_address ( ptr )) coro . resume (); } GSL_SUPPRESS ( type .1 ) auto continue_on_apc :: queue_user_apc ( coroutine_handle < void > coro ) noexcept -> uint32_t { const auto param = reinterpret_cast < ULONG_PTR > ( coro . address ()); if ( QueueUserAPC ( resume_on_apc , this -> thread , param ) == 0 ) return GetLastError (); return S_OK ; } class section final : CRITICAL_SECTION { section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; public : section () noexcept ( false ); ~ section () noexcept ; bool try_lock () noexcept ; void lock () noexcept ( false ); void unlock () noexcept ( false ); }; section :: section () noexcept ( false ) { InitializeCriticalSectionAndSpinCount ( this , 0600 ); } section ::~ section () noexcept { DeleteCriticalSection ( this ); } bool section :: try_lock () noexcept { return TryEnterCriticalSection ( this ); } void section :: lock () noexcept ( false ) { EnterCriticalSection ( this ); } void section :: unlock () noexcept ( false ) { LeaveCriticalSection ( this ); } } // namespace coro","title":"File windows.cpp"},{"location":"windows_8h/","text":"File windows.h \u00b6 File List > coroutine > windows.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <system_error> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. Macros \u00b6 Type Name define COROUTINE_SYSTEM_WRAPPER_H Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 Macro Definition Documentation \u00b6 define COROUTINE_SYSTEM_WRAPPER_H \u00b6 #define COROUTINE_SYSTEM_WRAPPER_H The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"File windows.h"},{"location":"windows_8h/#file-windowsh","text":"File List > coroutine > windows.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <system_error>","title":"File windows.h"},{"location":"windows_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"windows_8h/#classes","text":"Type Name class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body.","title":"Classes"},{"location":"windows_8h/#macros","text":"Type Name define COROUTINE_SYSTEM_WRAPPER_H","title":"Macros"},{"location":"windows_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0","title":"Detailed Description"},{"location":"windows_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"windows_8h/#define-coroutine95system95wrapper95h","text":"#define COROUTINE_SYSTEM_WRAPPER_H The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"define COROUTINE_SYSTEM_WRAPPER_H"},{"location":"windows_8h_source/","text":"File windows.h \u00b6 File List > coroutine > windows.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if __has_include(<Windows.h>) #include <Windows.h> #else #error \"expect Windows platform for this file\" #endif #include <coroutine/frame.h> #include <system_error> namespace coro { using namespace std ; using namespace std :: experimental ; class set_or_cancel final { void * hobject ; set_or_cancel ( const set_or_cancel & ) = delete ; set_or_cancel ( set_or_cancel && ) = delete ; set_or_cancel & operator = ( const set_or_cancel & ) = delete ; set_or_cancel & operator = ( set_or_cancel && ) = delete ; public : explicit set_or_cancel ( void * target ) noexcept ( false ); ~ set_or_cancel () noexcept ; private : void suspend ( coroutine_handle < void > ) noexcept ( false ); public : uint32_t unregister () noexcept ; constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return suspend ( coro ); } uint32_t await_resume () noexcept { return unregister (); } }; class continue_on_thread_pool final { static void __stdcall resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); uint32_t create_and_submit_work ( coroutine_handle < void > ) noexcept ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { // nothing to do for this implementation } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = create_and_submit_work ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; class continue_on_apc final { static void __stdcall resume_on_apc ( ULONG_PTR ); uint32_t queue_user_apc ( coroutine_handle < void > ) noexcept ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = queue_user_apc ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"QueueUserAPC\" }; } public : explicit continue_on_apc ( HANDLE hThread ) noexcept : thread { hThread } { } private : HANDLE thread ; }; } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File windows.h"},{"location":"windows_8h_source/#file-windowsh","text":"File List > coroutine > windows.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if __has_include(<Windows.h>) #include <Windows.h> #else #error \"expect Windows platform for this file\" #endif #include <coroutine/frame.h> #include <system_error> namespace coro { using namespace std ; using namespace std :: experimental ; class set_or_cancel final { void * hobject ; set_or_cancel ( const set_or_cancel & ) = delete ; set_or_cancel ( set_or_cancel && ) = delete ; set_or_cancel & operator = ( const set_or_cancel & ) = delete ; set_or_cancel & operator = ( set_or_cancel && ) = delete ; public : explicit set_or_cancel ( void * target ) noexcept ( false ); ~ set_or_cancel () noexcept ; private : void suspend ( coroutine_handle < void > ) noexcept ( false ); public : uint32_t unregister () noexcept ; constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return suspend ( coro ); } uint32_t await_resume () noexcept { return unregister (); } }; class continue_on_thread_pool final { static void __stdcall resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); uint32_t create_and_submit_work ( coroutine_handle < void > ) noexcept ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { // nothing to do for this implementation } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = create_and_submit_work ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; class continue_on_apc final { static void __stdcall resume_on_apc ( ULONG_PTR ); uint32_t queue_user_apc ( coroutine_handle < void > ) noexcept ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = queue_user_apc ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"QueueUserAPC\" }; } public : explicit continue_on_apc ( HANDLE hThread ) noexcept : thread { hThread } { } private : HANDLE thread ; }; } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File windows.h"},{"location":"work-in-progress/","text":"","title":"Work in progress"},{"location":"yield_8hpp/","text":"File yield.hpp \u00b6 File List > interface > internal > yield.hpp Go to the source code of this file. enumerable is simply a copy of generator in VC++ More... #include <coroutine/return.h> #include <iterator> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class enumerable <typename T> class iterator class promise_type Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"File yield.hpp"},{"location":"yield_8hpp/#file-yieldhpp","text":"File List > interface > internal > yield.hpp Go to the source code of this file. enumerable is simply a copy of generator in VC++ More... #include <coroutine/return.h> #include <iterator>","title":"File yield.hpp"},{"location":"yield_8hpp/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"yield_8hpp/#classes","text":"Type Name class enumerable <typename T> class iterator class promise_type","title":"Classes"},{"location":"yield_8hpp/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"Detailed Description"},{"location":"yield_8hpp_source/","text":"File yield.hpp \u00b6 File List > interface > internal > yield.hpp Go to the documentation of this file. #ifndef COROUTINE_YIELD_HPP #define COROUTINE_YIELD_HPP #include <coroutine/return.h> #include <iterator> namespace coro { using namespace std :: experimental ; // <experimental/generator> from the VC++ template < typename T > class enumerable { public : class promise_type ; class iterator ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; private : coroutine_handle < promise_type > coro {}; public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( enumerable && rhs ) noexcept : coro { rhs . coro } { rhs . coro = nullptr ; } enumerable & operator = ( enumerable && rhs ) noexcept { std :: swap ( coro , rhs . coro ); return * this ; } enumerable () noexcept = default ; enumerable ( promise_type * ptr ) noexcept : coro { coroutine_handle < promise_type >:: from_promise ( * ptr )} { } ~ enumerable () noexcept { // enumerable will destroy the frame. // promise/iterator are free from those ownership if ( coro ) coro . destroy (); } public : iterator begin () noexcept ( false ) { if ( coro ) // resumeable? { coro . resume (); if ( coro . done ()) // finished? return iterator { nullptr }; } return iterator { coro }; } iterator end () noexcept { return iterator { nullptr }; } public : class promise_type final : public promise_aa { friend class iterator ; friend class enumerable ; pointer current = nullptr ; public : promise_type * get_return_object () noexcept { // enumerable will create coroutine handle from the address return this ; } void unhandled_exception () noexcept ( false ) { throw ; } // `co_yield` expression. for reference auto yield_value ( reference ref ) noexcept { current = std :: addressof ( ref ); return suspend_always {}; } // `co_yield` expression. for r-value auto yield_value ( value_type && v ) noexcept { return yield_value ( v ); } // `co_return` expression void return_void () noexcept { // no more access to value current = nullptr ; } }; class iterator final { public : using iterator_category = std :: forward_iterator_tag ; using difference_type = ptrdiff_t ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; public : coroutine_handle < promise_type > coro ; public : // `enumerable::end()` explicit iterator ( std :: nullptr_t ) noexcept : coro { nullptr } { } // `enumerable::begin()` explicit iterator ( coroutine_handle < promise_type > handle ) noexcept : coro { handle } { } public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ) { coro . resume (); if ( coro . done ()) // enumerable will destroy coro = nullptr ; // the frame later... return * this ; } pointer operator -> () noexcept { pointer ptr = coro . promise (). current ; return ptr ; } reference operator * () noexcept { return * ( this -> operator -> ()); } bool operator == ( const iterator & rhs ) const noexcept { return this -> coro == rhs . coro ; } bool operator != ( const iterator & rhs ) const noexcept { return ! ( * this == rhs ); } }; }; } // namespace coro #endif // COROUTINE_YIELD_HPP","title":"File yield.hpp"},{"location":"yield_8hpp_source/#file-yieldhpp","text":"File List > interface > internal > yield.hpp Go to the documentation of this file. #ifndef COROUTINE_YIELD_HPP #define COROUTINE_YIELD_HPP #include <coroutine/return.h> #include <iterator> namespace coro { using namespace std :: experimental ; // <experimental/generator> from the VC++ template < typename T > class enumerable { public : class promise_type ; class iterator ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; private : coroutine_handle < promise_type > coro {}; public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( enumerable && rhs ) noexcept : coro { rhs . coro } { rhs . coro = nullptr ; } enumerable & operator = ( enumerable && rhs ) noexcept { std :: swap ( coro , rhs . coro ); return * this ; } enumerable () noexcept = default ; enumerable ( promise_type * ptr ) noexcept : coro { coroutine_handle < promise_type >:: from_promise ( * ptr )} { } ~ enumerable () noexcept { // enumerable will destroy the frame. // promise/iterator are free from those ownership if ( coro ) coro . destroy (); } public : iterator begin () noexcept ( false ) { if ( coro ) // resumeable? { coro . resume (); if ( coro . done ()) // finished? return iterator { nullptr }; } return iterator { coro }; } iterator end () noexcept { return iterator { nullptr }; } public : class promise_type final : public promise_aa { friend class iterator ; friend class enumerable ; pointer current = nullptr ; public : promise_type * get_return_object () noexcept { // enumerable will create coroutine handle from the address return this ; } void unhandled_exception () noexcept ( false ) { throw ; } // `co_yield` expression. for reference auto yield_value ( reference ref ) noexcept { current = std :: addressof ( ref ); return suspend_always {}; } // `co_yield` expression. for r-value auto yield_value ( value_type && v ) noexcept { return yield_value ( v ); } // `co_return` expression void return_void () noexcept { // no more access to value current = nullptr ; } }; class iterator final { public : using iterator_category = std :: forward_iterator_tag ; using difference_type = ptrdiff_t ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; public : coroutine_handle < promise_type > coro ; public : // `enumerable::end()` explicit iterator ( std :: nullptr_t ) noexcept : coro { nullptr } { } // `enumerable::begin()` explicit iterator ( coroutine_handle < promise_type > handle ) noexcept : coro { handle } { } public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ) { coro . resume (); if ( coro . done ()) // enumerable will destroy coro = nullptr ; // the frame later... return * this ; } pointer operator -> () noexcept { pointer ptr = coro . promise (). current ; return ptr ; } reference operator * () noexcept { return * ( this -> operator -> ()); } bool operator == ( const iterator & rhs ) const noexcept { return this -> coro == rhs . coro ; } bool operator != ( const iterator & rhs ) const noexcept { return ! ( * this == rhs ); } }; }; } // namespace coro #endif // COROUTINE_YIELD_HPP","title":"File yield.hpp"},{"location":"articles/awaitable-event/","text":"Awaitable event using the coroutine, epoll , and eventfd \u00b6 commit: ad1e682f The note explains the detail of event in coroutine/concrt.h Summary \u00b6 Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); } Note \u00b6 Motivation \u00b6 It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work. Requirement \u00b6 The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that. Design \u00b6 Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor. Concerns \u00b6 You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() . Implementation \u00b6 Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations Wrapping epoll \u00b6 linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :) Polling epoll \u00b6 linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... } Event interface \u00b6 coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd . Event's state managment \u00b6 Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :) Event's await operations \u00b6 The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Summary for the implementation \u00b6 It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details. Conclusion \u00b6 Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Awaitable event using the coroutine, epoll and eventfd"},{"location":"articles/awaitable-event/#awaitable-event-using-the-coroutine-epoll-and-eventfd","text":"commit: ad1e682f The note explains the detail of event in coroutine/concrt.h","title":"Awaitable event using the coroutine, epoll, and eventfd"},{"location":"articles/awaitable-event/#summary","text":"Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Summary"},{"location":"articles/awaitable-event/#note","text":"","title":"Note"},{"location":"articles/awaitable-event/#motivation","text":"It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work.","title":"Motivation"},{"location":"articles/awaitable-event/#requirement","text":"The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that.","title":"Requirement"},{"location":"articles/awaitable-event/#design","text":"Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor.","title":"Design"},{"location":"articles/awaitable-event/#concerns","text":"You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() .","title":"Concerns"},{"location":"articles/awaitable-event/#implementation","text":"Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations","title":"Implementation"},{"location":"articles/awaitable-event/#wrapping-epoll","text":"linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :)","title":"Wrapping epoll"},{"location":"articles/awaitable-event/#polling-epoll","text":"linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... }","title":"Polling epoll"},{"location":"articles/awaitable-event/#event-interface","text":"coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd .","title":"Event interface"},{"location":"articles/awaitable-event/#events-state-managment","text":"Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :)","title":"Event's state managment"},{"location":"articles/awaitable-event/#events-await-operations","text":"The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } }","title":"Event's await operations"},{"location":"articles/awaitable-event/#summary-for-the-implementation","text":"It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details.","title":"Summary for the implementation"},{"location":"articles/awaitable-event/#conclusion","text":"Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Conclusion"},{"location":"articles/combining-coroutines-and-pthread_create/","text":"Combining C++ Coroutines and pthread_create \u00b6 commit: 93ed8748 Some system functions use callback and an argument in void* type. In this article, I'm going to cover how such functions can be wrapped with co_await The base of examples here is my experience to try something like CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" with the POSIX threads. If you are a beginner, please do read the article about promise_type by Lewiss Baker . The article will enhance your understanding greatly. Creating a new thread \u00b6 Design \u00b6 What I'm going to try is creating a new thread in a simple manner. Traditionally we had to separate the step before/after pthread_create . To do so, we must write an additional function which is executed on the new thread. Like the thread_start in the pthread_create manual . But co_await can glue two routines into one. Let's see how it looks like. void per_thread_task (); auto work_on_new_thread ( pthread_t & tid , const pthread_attr_t * attr ) -> no_return { // this line is executed on the spawner thread co_await spawn_pthread ( tid , attr ); // the function is executed on the pthread with 'tid' per_thread_task (); } Since it's an example, it will be differenct when you have to write for your own. What I want to show here is that the look & feel of the wrapping pattern. Implementation \u00b6 start_routine to resume the coroutine \u00b6 Obviously the most important functions are the life cycle functions. pthread_create pthread_join #include <pthread.h> // create a new thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // join with a terminated thread int pthread_join ( pthread_t thread , void ** retval ); Here, we can control 2 parameters. start_routine to designate a routine for the thread arg to forward an argument to the routine With them we can imagine some code in the system will be like this. void pthread_procedure ( void * out , ...){ // ... PC(Program Counter) jumps to here ... out = start_routine ( arg ); // perform `pthread_exit` ... // deliver 'out' to `pthread_join` or somewhere ... } We will define a simple function for the start_routine . It constructs the coroutine_handle from the arg and then resume it after checking with done . void * resume_on_pthread ( void * ptr ){ // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } Forwarding arg from co_await \u00b6 So to make the function work properly, we have to forward coroutine_handle<void> as an argument of arg . This is easy since there is a member fuction, address . await_suspend will give us the handle like the following code. struct pthread_spawner_t { constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } }; Or if you like the simplicity, you can inherit suspend_always in the std::experimental . #include <experimental/coroutine> using std :: experimental :: suspend_always ; struct pthread_spawner_t : public suspend_always { // hide the function of `suspend_always` ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } }; In the meantime, now we have an awaitable type that creates a new thread. So we can trigger it in 1 line. auto work_on_new_thread () -> no_return { co_await pthread_spawner_t {}; // ... } Concerns \u00b6 You might curious about throw in the second pthread_spawner_t::await_suspend . In general, the function is the last point for the error handling. For our case, suppose that pthread_create failed. The callback resume_on_pthread won't be invoked. That means the coroutine's frame can't be resume d and coverage after co_await is going to be lost. So we have to make caller handle the situation before the coroutine becomes suspended state. One of the way is to throw an exception in await_suspend . Dealing with the thread's join \u00b6 Design \u00b6 Now we have to support join for the thread. pthread_join is so simple that we can't misuse it. What we have care is not the function but the behavior after pthread_join returned without an error. Do you remember that I returned the coroutine frame's address for our start_routine ? void * resume_on_pthread ( void * ptr ){ auto task = coroutine_handle < void >:: from_address ( ptr ); // ... return task . address (); } So in somewhere we have to get the address and destroy it. auto join_and_destroy ( pthread_t tid ){ void * ptr {}; if ( auto ec = pthread_join ( tid , & ptr )) throw system_error { ec , system_category (), \"pthread_join\" }; auto coro = coroutine_handle < void >:: from_address ( ptr ); if ( coro ) coro . destroy (); } But this code is dangerous. The reason is that there is no way to know whether the frame is not destroyed. When the frame is final_suspend ed, we can check it is done() == true and then resume / destroy it. But when the corouitine didn't suspended after final_suspend , its co_return will destroy the frame immediately. So the coro.destroy() above is a double-delete situation. Here, our plan is to provide a special return type which guarantees safe destruction of the frame. Implementation \u00b6 Intend of the final suspension \u00b6 A coroutine's frame is preserved if its coroutine_traits<R>::promise_type does final suspension. That means, it intended manual destruction of the frame, like generator<T> . // From VC++, <experimental/generator> namespace experimental { template < typename _Ty , typename _Alloc = allocator < char >> struct generator { struct promise_type { _Ty const * _CurrentValue ; // ... bool final_suspend () { return ( true ); } // ... }; // ... ~ generator () { if ( _Coro ) { // manual destruction of // the generator coroutine's frame _Coro . destroy (); } } private : coroutine_handle < promise_type > _Coro = nullptr ; }; } // namespace experimental You can see destroy() is invoked in its destructor. We will follow the way. Preserving frame for pthread_join \u00b6 There are 2 things that should be guaranteed. Meet the condition final_suspend == true so pthread_join can receive the destroyable frame Perform destroy after pthread_join Here is the type. It will be a return type for the coroutine which co_await s pthread_spawner_t . class pthread_joiner_t final { public : class promise_type final { public : auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ // preserve the frame after `co_return` return suspend_always {}; } void return_void (){ // we already returns coroutine's frame. // so `co_return` can't have its operand } void unhandled_exception (){ // ... } auto get_return_object () -> promise_type * { return this ; } }; private : pthread_t tid ; public : pthread_joiner_t ( promise_type * ) : tid {} { } ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; So if we use it as a return for the coroutine function, it will be like the following. Review the look and feel with the pthread_spawner_t . auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); // It can be useful if the `joiner` supports `operator pthread_t()` // pthread_t worker_id = joiner; } It seems like we are almost done, but it's not. Concerns \u00b6 You may ask that such design is seriously vulnerable when pthread_exit is used explicitly. My answer for that is, most of pthread_exit 's usage is careful enough. You can note for the dangerous point in your comment, document, or even #warn for the issue. And the users are able to redesign/rewrite their own logic with the note. Context-Aware co_await through await_transform \u00b6 Design \u00b6 auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); } This example looks fine, but it will be more safe when pthread_spawner_t is used if and only if the return type is pthread_joiner_t . Fortuantely C++ Coroutines specifies await_transform which can do the work. So our final goal will be like this. Can you find the difference? auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await attr ; // ... } pthread_attr_t can't work alone since it's a reserved type for the pthread_create . So when there is an instance of it, there must be an intent to create a new thread with it. Therefore co_await on it does express something like \"wait for the thread creation and then ...\". Implementation \u00b6 Pairing pthread_joiner_t with pthread_spawner_t \u00b6 Until now, pthread_spawner_t was an global type that can be used anywhere. The first we have to do is to make it available only when pthread_joiner_t is known. Simply nesting it will do the work. class pthread_joiner_t final { public : class promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { // invoke `pthread_create` ... } void await_resume () noexcept { // nothing to do ... } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; }; Defining await_transform \u00b6 As mentioned above, we will define the await_transform in pthread_joiner_t::promise_type . The role of the function is to transform the operand of co_await to an awaitable type. In this case, the awaitable type is pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; // ... private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; class promise_type final { // ... see 'Preserving frame for `pthread_join`' ... // We can consider the `pthread_attr_t*` as an intent to create a new pthread. // Therefore, `promise_type` will transform the type to `pthread_spawner_t` auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr } } }; // ... same with above ... private : pthread_t tid ; }; By doing so we can achieve our design goal. Because typical return types for the coroutines are not aware of how to co_await on pthread_attr_t . Exposing pthread_t \u00b6 Now the last part is to store the new pthread's id in the pthread_joiner_t . This is what I wrote above. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; private : pthread_t tid ; public : // ... ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; However, we call pthread_create in pthread_spawner_t . So we can say there must be some sharing point to get the valid pthread_t from pthread_joiner_t . class pthread_joiner_t final { public : class pthread_spawner_t final { public : // ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())){ throw system_error { ec , system_category (), \"pthread_create\" }; } } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; // <--- duplicate with that of the `pthread_spawner_t` public : // ... ~ pthread_joiner_t () noexcept ( false ); }; At this moment, we must decide where to place the therad's id. In this code pthread_joiner_t is holding it as a member variable. That's pretty general for most of type for subroutines . Think of the implementation that pthread_spawner_t sends thread's id to pthread_joiner_t . If you decide to do so, you have to write a coroutine that aware of it's activator's address. To be more precise, the address of its return type's object. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // Can we know the address of the returned pthread_joiner_t object ? // Even if that is possible, using the address is a sound design ? } Definatly that will lead to the bad(compex) code. Remember that we are preserving the coroutine frame until pthread_join . In other words, it is a valid behavior to access the frame before we invoke pthread_join . With the point, let's save the thread's id in the coroutine's frame, and access to the memory location when the thread's id is needed. Placing the object in the coroutine's frame isn't that hard. Since the promise_type object is placed in the frame , accessing to it can be done with 1 pointer. I already showed you how to get a ponter to promise_type . Let me show you again. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; class promise_type final { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_always {}; } void unhandled_exception (){ } auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr }; } auto get_return_object () -> promise_type * { return this ; } public : pthread_t tid {}; }; public : // we will receive the pointer from `get_return_object` pthread_joiner_t ( promise_type * p ) : promise { p } { } ~ pthread_joiner_t () noexcept ( false ) { // ... join with the thread id ... // ... destroy the coroutine frame ... } // and we can access to the `tid` through the pointer operator pthread_t () const noexcept { return promise -> tid ; } private : promise_type * const promise ; }; So the last job is to update tid in the promise_type . Let's rewrite the pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; public : constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_create ( this -> tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // ... do nothing ... } private : // receives 2 pointer at once pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr }{ } pthread_t * const tid ; // pointer to the memory location in the promise const pthread_attr_t * const attr ; }; class promise_type final { auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // ... pthread_t tid {}; }; // ... }; Whoa, that was a long run ! Conclusion \u00b6 You can run the example with the WandBox. https://wandbox.org/permlink/qQ1vbwshsoujYnI0 In this article we covered 2 things by wrapping pthread_create for the coroutines step by step. How the awaitable can wrap the system function which uses a callback and it has a void* parameter How to define await_transform and which limitation it makes However, we only wrapped 2 pthread life cycle functions. So if the coroutine invokes pthread_exit instead of co_return , the assumption of the pthread_joiner_t will be broken. What I didn't cover here will be a good coroutine design practice for you. Move/Copy handling of the types The detach of a thread Triggering multiple thread createion for 1 pthread_joiner_t After Note \u00b6 Arthur O'Dwyer let me know how to improve the final(WandBox) example using private constructor. I will cover that in later post. Appreciate for his help and opinions! :D Allowing another awaitable types \u00b6 You may need to define more generic await_transform like this . class pthread_joiner_t final { public : class promise_type final { // the original auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // redirect to const pointer inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } // allow general co_await usage template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; // ... };","title":"Combining C++ coroutines and `pthread_create`"},{"location":"articles/combining-coroutines-and-pthread_create/#combining-c-coroutines-and-pthread_create","text":"commit: 93ed8748 Some system functions use callback and an argument in void* type. In this article, I'm going to cover how such functions can be wrapped with co_await The base of examples here is my experience to try something like CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" with the POSIX threads. If you are a beginner, please do read the article about promise_type by Lewiss Baker . The article will enhance your understanding greatly.","title":"Combining C++ Coroutines and pthread_create"},{"location":"articles/combining-coroutines-and-pthread_create/#creating-a-new-thread","text":"","title":"Creating a new thread"},{"location":"articles/combining-coroutines-and-pthread_create/#design","text":"What I'm going to try is creating a new thread in a simple manner. Traditionally we had to separate the step before/after pthread_create . To do so, we must write an additional function which is executed on the new thread. Like the thread_start in the pthread_create manual . But co_await can glue two routines into one. Let's see how it looks like. void per_thread_task (); auto work_on_new_thread ( pthread_t & tid , const pthread_attr_t * attr ) -> no_return { // this line is executed on the spawner thread co_await spawn_pthread ( tid , attr ); // the function is executed on the pthread with 'tid' per_thread_task (); } Since it's an example, it will be differenct when you have to write for your own. What I want to show here is that the look & feel of the wrapping pattern.","title":"Design"},{"location":"articles/combining-coroutines-and-pthread_create/#implementation","text":"","title":"Implementation"},{"location":"articles/combining-coroutines-and-pthread_create/#start_routine-to-resume-the-coroutine","text":"Obviously the most important functions are the life cycle functions. pthread_create pthread_join #include <pthread.h> // create a new thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // join with a terminated thread int pthread_join ( pthread_t thread , void ** retval ); Here, we can control 2 parameters. start_routine to designate a routine for the thread arg to forward an argument to the routine With them we can imagine some code in the system will be like this. void pthread_procedure ( void * out , ...){ // ... PC(Program Counter) jumps to here ... out = start_routine ( arg ); // perform `pthread_exit` ... // deliver 'out' to `pthread_join` or somewhere ... } We will define a simple function for the start_routine . It constructs the coroutine_handle from the arg and then resume it after checking with done . void * resume_on_pthread ( void * ptr ){ // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); }","title":"start_routine to resume the coroutine"},{"location":"articles/combining-coroutines-and-pthread_create/#forwarding-arg-from-co_await","text":"So to make the function work properly, we have to forward coroutine_handle<void> as an argument of arg . This is easy since there is a member fuction, address . await_suspend will give us the handle like the following code. struct pthread_spawner_t { constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } }; Or if you like the simplicity, you can inherit suspend_always in the std::experimental . #include <experimental/coroutine> using std :: experimental :: suspend_always ; struct pthread_spawner_t : public suspend_always { // hide the function of `suspend_always` ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } }; In the meantime, now we have an awaitable type that creates a new thread. So we can trigger it in 1 line. auto work_on_new_thread () -> no_return { co_await pthread_spawner_t {}; // ... }","title":"Forwarding arg from co_await"},{"location":"articles/combining-coroutines-and-pthread_create/#concerns","text":"You might curious about throw in the second pthread_spawner_t::await_suspend . In general, the function is the last point for the error handling. For our case, suppose that pthread_create failed. The callback resume_on_pthread won't be invoked. That means the coroutine's frame can't be resume d and coverage after co_await is going to be lost. So we have to make caller handle the situation before the coroutine becomes suspended state. One of the way is to throw an exception in await_suspend .","title":"Concerns"},{"location":"articles/combining-coroutines-and-pthread_create/#dealing-with-the-threads-join","text":"","title":"Dealing with the thread's join"},{"location":"articles/combining-coroutines-and-pthread_create/#design_1","text":"Now we have to support join for the thread. pthread_join is so simple that we can't misuse it. What we have care is not the function but the behavior after pthread_join returned without an error. Do you remember that I returned the coroutine frame's address for our start_routine ? void * resume_on_pthread ( void * ptr ){ auto task = coroutine_handle < void >:: from_address ( ptr ); // ... return task . address (); } So in somewhere we have to get the address and destroy it. auto join_and_destroy ( pthread_t tid ){ void * ptr {}; if ( auto ec = pthread_join ( tid , & ptr )) throw system_error { ec , system_category (), \"pthread_join\" }; auto coro = coroutine_handle < void >:: from_address ( ptr ); if ( coro ) coro . destroy (); } But this code is dangerous. The reason is that there is no way to know whether the frame is not destroyed. When the frame is final_suspend ed, we can check it is done() == true and then resume / destroy it. But when the corouitine didn't suspended after final_suspend , its co_return will destroy the frame immediately. So the coro.destroy() above is a double-delete situation. Here, our plan is to provide a special return type which guarantees safe destruction of the frame.","title":"Design"},{"location":"articles/combining-coroutines-and-pthread_create/#implementation_1","text":"","title":"Implementation"},{"location":"articles/combining-coroutines-and-pthread_create/#intend-of-the-final-suspension","text":"A coroutine's frame is preserved if its coroutine_traits<R>::promise_type does final suspension. That means, it intended manual destruction of the frame, like generator<T> . // From VC++, <experimental/generator> namespace experimental { template < typename _Ty , typename _Alloc = allocator < char >> struct generator { struct promise_type { _Ty const * _CurrentValue ; // ... bool final_suspend () { return ( true ); } // ... }; // ... ~ generator () { if ( _Coro ) { // manual destruction of // the generator coroutine's frame _Coro . destroy (); } } private : coroutine_handle < promise_type > _Coro = nullptr ; }; } // namespace experimental You can see destroy() is invoked in its destructor. We will follow the way.","title":"Intend of the final suspension"},{"location":"articles/combining-coroutines-and-pthread_create/#preserving-frame-for-pthread_join","text":"There are 2 things that should be guaranteed. Meet the condition final_suspend == true so pthread_join can receive the destroyable frame Perform destroy after pthread_join Here is the type. It will be a return type for the coroutine which co_await s pthread_spawner_t . class pthread_joiner_t final { public : class promise_type final { public : auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ // preserve the frame after `co_return` return suspend_always {}; } void return_void (){ // we already returns coroutine's frame. // so `co_return` can't have its operand } void unhandled_exception (){ // ... } auto get_return_object () -> promise_type * { return this ; } }; private : pthread_t tid ; public : pthread_joiner_t ( promise_type * ) : tid {} { } ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; So if we use it as a return for the coroutine function, it will be like the following. Review the look and feel with the pthread_spawner_t . auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); // It can be useful if the `joiner` supports `operator pthread_t()` // pthread_t worker_id = joiner; } It seems like we are almost done, but it's not.","title":"Preserving frame for pthread_join"},{"location":"articles/combining-coroutines-and-pthread_create/#concerns_1","text":"You may ask that such design is seriously vulnerable when pthread_exit is used explicitly. My answer for that is, most of pthread_exit 's usage is careful enough. You can note for the dangerous point in your comment, document, or even #warn for the issue. And the users are able to redesign/rewrite their own logic with the note.","title":"Concerns"},{"location":"articles/combining-coroutines-and-pthread_create/#context-aware-co_await-through-await_transform","text":"","title":"Context-Aware co_await through await_transform"},{"location":"articles/combining-coroutines-and-pthread_create/#design_2","text":"auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); } This example looks fine, but it will be more safe when pthread_spawner_t is used if and only if the return type is pthread_joiner_t . Fortuantely C++ Coroutines specifies await_transform which can do the work. So our final goal will be like this. Can you find the difference? auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await attr ; // ... } pthread_attr_t can't work alone since it's a reserved type for the pthread_create . So when there is an instance of it, there must be an intent to create a new thread with it. Therefore co_await on it does express something like \"wait for the thread creation and then ...\".","title":"Design"},{"location":"articles/combining-coroutines-and-pthread_create/#implementation_2","text":"","title":"Implementation"},{"location":"articles/combining-coroutines-and-pthread_create/#pairing-pthread_joiner_t-with-pthread_spawner_t","text":"Until now, pthread_spawner_t was an global type that can be used anywhere. The first we have to do is to make it available only when pthread_joiner_t is known. Simply nesting it will do the work. class pthread_joiner_t final { public : class promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { // invoke `pthread_create` ... } void await_resume () noexcept { // nothing to do ... } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; };","title":"Pairing pthread_joiner_t with pthread_spawner_t"},{"location":"articles/combining-coroutines-and-pthread_create/#defining-await_transform","text":"As mentioned above, we will define the await_transform in pthread_joiner_t::promise_type . The role of the function is to transform the operand of co_await to an awaitable type. In this case, the awaitable type is pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; // ... private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; class promise_type final { // ... see 'Preserving frame for `pthread_join`' ... // We can consider the `pthread_attr_t*` as an intent to create a new pthread. // Therefore, `promise_type` will transform the type to `pthread_spawner_t` auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr } } }; // ... same with above ... private : pthread_t tid ; }; By doing so we can achieve our design goal. Because typical return types for the coroutines are not aware of how to co_await on pthread_attr_t .","title":"Defining await_transform"},{"location":"articles/combining-coroutines-and-pthread_create/#exposing-pthread_t","text":"Now the last part is to store the new pthread's id in the pthread_joiner_t . This is what I wrote above. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; private : pthread_t tid ; public : // ... ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; However, we call pthread_create in pthread_spawner_t . So we can say there must be some sharing point to get the valid pthread_t from pthread_joiner_t . class pthread_joiner_t final { public : class pthread_spawner_t final { public : // ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())){ throw system_error { ec , system_category (), \"pthread_create\" }; } } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; // <--- duplicate with that of the `pthread_spawner_t` public : // ... ~ pthread_joiner_t () noexcept ( false ); }; At this moment, we must decide where to place the therad's id. In this code pthread_joiner_t is holding it as a member variable. That's pretty general for most of type for subroutines . Think of the implementation that pthread_spawner_t sends thread's id to pthread_joiner_t . If you decide to do so, you have to write a coroutine that aware of it's activator's address. To be more precise, the address of its return type's object. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // Can we know the address of the returned pthread_joiner_t object ? // Even if that is possible, using the address is a sound design ? } Definatly that will lead to the bad(compex) code. Remember that we are preserving the coroutine frame until pthread_join . In other words, it is a valid behavior to access the frame before we invoke pthread_join . With the point, let's save the thread's id in the coroutine's frame, and access to the memory location when the thread's id is needed. Placing the object in the coroutine's frame isn't that hard. Since the promise_type object is placed in the frame , accessing to it can be done with 1 pointer. I already showed you how to get a ponter to promise_type . Let me show you again. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; class promise_type final { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_always {}; } void unhandled_exception (){ } auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr }; } auto get_return_object () -> promise_type * { return this ; } public : pthread_t tid {}; }; public : // we will receive the pointer from `get_return_object` pthread_joiner_t ( promise_type * p ) : promise { p } { } ~ pthread_joiner_t () noexcept ( false ) { // ... join with the thread id ... // ... destroy the coroutine frame ... } // and we can access to the `tid` through the pointer operator pthread_t () const noexcept { return promise -> tid ; } private : promise_type * const promise ; }; So the last job is to update tid in the promise_type . Let's rewrite the pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; public : constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_create ( this -> tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // ... do nothing ... } private : // receives 2 pointer at once pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr }{ } pthread_t * const tid ; // pointer to the memory location in the promise const pthread_attr_t * const attr ; }; class promise_type final { auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // ... pthread_t tid {}; }; // ... }; Whoa, that was a long run !","title":"Exposing pthread_t"},{"location":"articles/combining-coroutines-and-pthread_create/#conclusion","text":"You can run the example with the WandBox. https://wandbox.org/permlink/qQ1vbwshsoujYnI0 In this article we covered 2 things by wrapping pthread_create for the coroutines step by step. How the awaitable can wrap the system function which uses a callback and it has a void* parameter How to define await_transform and which limitation it makes However, we only wrapped 2 pthread life cycle functions. So if the coroutine invokes pthread_exit instead of co_return , the assumption of the pthread_joiner_t will be broken. What I didn't cover here will be a good coroutine design practice for you. Move/Copy handling of the types The detach of a thread Triggering multiple thread createion for 1 pthread_joiner_t","title":"Conclusion"},{"location":"articles/combining-coroutines-and-pthread_create/#after-note","text":"Arthur O'Dwyer let me know how to improve the final(WandBox) example using private constructor. I will cover that in later post. Appreciate for his help and opinions! :D","title":"After Note"},{"location":"articles/combining-coroutines-and-pthread_create/#allowing-another-awaitable-types","text":"You may need to define more generic await_transform like this . class pthread_joiner_t final { public : class promise_type final { // the original auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // redirect to const pointer inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } // allow general co_await usage template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; // ... };","title":"Allowing another awaitable types"},{"location":"articles/designing-the-channel/","text":"Designing the coroutine channel \u00b6 commit: 1.4.3 This is a design note for the channel<T> . It's one of the oldest feature in this library. In this article, I will write about the design background of the type. Summary \u00b6 John Bandela already talked about the coroutine based channel in CppCon 2016 . However, I designed more limited one on my own. #include <coroutine/channel.hpp> using namespace coro ; constexpr int bye = 0 ; auto consumer ( channel < int >& ch ) -> no_return { // the type doesn't support for-co_await for now for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: we received a value if ( msg == bye ) break ; co_await ch . write ( msg ); // we can write in the reader coroutine } } auto producer_owner () -> no_return { channel < int > ch {}; consumer ( ch ); // start a consumer routine for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ok == true: we sent a value co_await ch . read ( msg ); // we can read in the writer coroutine } } Notice that we are reading before writing values to the channel. You can visit more example(test) codes for the type: test/channel_read_write_nolock.cpp test/channel_read_fail_after_close.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_ownership_consumer.cpp test/channel_ownership_producer.cpp test/channel_race_no_leak.cpp Note \u00b6 Motivation(Background) \u00b6 There are multiple ways to deliver value(normally an object) from a routine to another routine. channel<T> is designed to play a role as one of them. Before the coroutine \u00b6 Before the C++ Coroutines becames available, there were 2 ways. return : from callee subroutine to caller subroutine future<T> since C++11 : return with synchronization(shared state) return forwards a T type object from callee subroutine to caller subroutine. C++ 11 future<T> , do the same work but uses a shared state to provide synchronization. As we know, such a synchronization is for multi-threaded code. One of those methods' limitation is that they can deliver only 1 object (of T type), only 1 time (with the return ). Which makes inconvenience sometimes... After the coroutine \u00b6 By adopting coroutine to our world, now we can suspend, and get a new way of delivery. task<T> : 1 time delivery, from a coroutine to another coroutine generator<T> : multi-time delivery, from the generator coroutine to activator coroutine task<T> is the simplest way to get co_return from a coroutine. The most important design point for a coroutine function is that managing suspension( co_await ). It's because suspension is more general than finalization( co_return ). task<T> deals with the cases and activates(resumes) awaiting coroutine when the activatee coroutine returns. generator<T> uses co_yield to deliver value from activatee(generator coroutine) to activator(resumer subroutine) multiple times. For us, co_yield itself is a syntatic sugar that invokes yield_value and evaluate co_await (therefore, suspend) at the same time. Indeed there is a harmony in the way generator<T> works. However, what if we can't acquire the value from generator<T> immediately? What if advancing its iterator is asynchronous? async_generator<T> : generator<T> + awaitable iterator So async_generator<T> allows us to attach a coroutine which will be resumed when the generator coroutine can yield(perform the delivery). In my perspective, using co_await on its iterator is indeed a good idea for the interface design. Its user code remains very similar to that of the generator<T> The consumer coroutine is resumed automatically, so there is no coverage leak You can review existing implementations. Please let me know if there is another implementations so I can add them :) From the https://github.com/kirkshoop/await In this library, which is based on kirkshoop's work, sequence<T> From the adorable cppcoro Another type of the delivery? \u00b6 At this point, we can recognize that we don't have a bidirectional delivery . generator<T> delivers its co_yield ed value only in 1 direction, and so does async_generator<T> . Also, if we need to write multi-threaded code, there are still needs of the synchronization. It depends on the pattern and can managed well, but it's still hard to the beginners. For nondirectional delivery, there is a good example in the Go language. It's channel . The channel can suspend both producer and consumer goroutines by affecting their scheduling. However, there is a difference between the coroutine in the C++ and Goroutine in the Go language. Goroutine is scheduled by the Go runtime, but coroutine are not. It doesn't have a built-in scheduling. Basically, coroutine_handle<T> itself is a pointer and programmers have to manage them manually. Requirement \u00b6 So the requirement for our new type is like the following. channel<T> Non-directional delivery (at least bidirectional) Optional synchronization Coverage leak prevention Invalidation Zero allocation Non-directional delivery \u00b6 We should be able to write/read to a channel in a same coroutine. It's convenient. And that is important for the beginners. Optional synchronization \u00b6 It supports single-threaded code and there must be zero-cost in the case. Coverage leak prevention \u00b6 The type must prevent coverage leak. That means, it must do its best to make related coroutines reach their ends. Invalidation \u00b6 The channel must be able to notify its invalidation. So its user code can handle the operation failure and prevent undefined behavior while they are writing the code. With the coverage requirement above, user will co_return the coroutine, or delegate its work somehow. Zero allocation \u00b6 new / delete is not allowed to avoid unnecessary cost. Design Concerns \u00b6 Optional synchronization \u00b6 The logic will remain while user applies different synchronization types. So the type will use be template. template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel final { public : using mutex_type = M ; private : mutex_type mtx ; } Also, as you can see above, it will use do nothing lockable by default. // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } }; Invalidation \u00b6 unlike the channel of Go, the type doesn't provide explicit close operation Explicit close is simple enough because we can just check the channel's state and break the loop. But it is highly possible that user will carefully design the value if there is no close . Suppose we have a close for the channel: auto producer ( channel < int >& ch ) -> no_return { int msg {}; // ... while ( ch . closed () == false ){ co_await ch . write ( msg ); // ... if ( cond ) break ; } ch . close (); // ok, no more value co_return ; } auto consumer ( channel < int >& ch ) -> no_return { while ( ch . closed () == false ){ int msg = co_await ch . read (); // ... } } In this case, user will think about the state of the channel. The following questions can be managed by patternized code, but will always arise from the existance of close . Which line should the close placed? When it's already closed, what should I do for read/write? When we don't have a close , users will think about another issue. When should I stop the read/write? The question is about managing the loop, and probably they will use something like EOF (sentinel value). In my perspective, it is more likely to have well-designed space for the value_type of the channel: auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { co_await ch . write ( msg ); // ... } } auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } Implementation \u00b6 Watching the CppCon 2016 talk will help you a lot for the following notes. Making a linked list of the coroutine frames \u00b6 Since coroutine frames are allocated separatly, we can use them like a node in the linked list. By placing next pointer in those frame, we can make zero-allocation channel. Actually they are a kind of pre-allocation since the cost is already paid in the frame construction(invocation) steps. So it will be enough for channel<T> to have 2 linked lists and 1 mutex to operate correctly under multi-threaded code. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... private : mutex_type mtx ; } To make a linked list of the coroutine frames, the type places an objects in the coroutine frame that containes next pointer. // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... public : // place a writer in the coroutine's frame decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // place a reader in the coroutine's frame decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; You can find next pointer in the following writer and reader . Notice that they have a reserved space to receive coroutine_handle<void> from await_suspend . template < typename T , typename M > class writer final { public : using value_type = T ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; union { writer * next = nullptr ; // Next writer in the channel channel_type * chan ; }; }; template < typename T , typename M > class reader { public : using value_type = T ; using channel_type = channel < T , M > ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; union { reader * next = nullptr ; // Next reader in the channel channel_type * chan ; }; }; Because of the design we will place the objects in the frame. Consider: auto temporary_reader_object ( channel < int >& ch ) -> no_return { // co_await ch.read(); reader < int > reader = ch . read (); co_await reader ; } When it's used with for statement, there will be at most 2 read/writes. So it won't be that complicated. // at most 2 operation in 1 for loop auto consumer ( channel < int >& ch ) -> no_return { for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ... } } auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ... } } Preventing Coverage Leak \u00b6 We all know that RAII is the best way to make the type system work for us. Let's consider about it. What is the proper behavior of the linked list on its destruction? Like the std::list<T> , it must delete its existing nodes to prevent memory leak. Unfortunately, this case is really special because the nodes are existing coroutines' frame. That means, if we free the node, it will destroy all objects in the frame. That's really brutal because it can break all existing expectations of the function that manages its frame manually (with customized promise_type ). So the appropriate behavior is to resume those frames and let them recognize that they can't access the channel anymore. In its destructor , channel<T, M> resumes all awaiting coroutines in its linked lists. Notice the destructor is specified noexcept(false) because typically resume operation is not guaranteed noexcept . template < typename T , typename M > class channel { // ... ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; size_t repeat = 1 ; while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); // <-- use a poison value coro . resume (); // <-- resume write operations } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); // <-- resume read operations } } } } With the behavior, user code must be changed like the following. It receive not only a value from the channel but also one bool that notifies the channel is still accessible. // Before auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } // After auto consumer ( channel < int >& ch ) -> no_return { // it's returning tuple, // declare memory objects using structured binding for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: the channel is accessible // ... } } By doing so, if the reader/writer coroutines are written correctly, channel can guarantee there is no dangling coroutines in its linked lists, and prevent coverage leak of them. Using a poison in await_resume \u00b6 I used poison to replace explicit close . Remember that the co_await expression is affected by await_resume . Returning a tuple from the function can constrain user's code. In the implementation, to decide to return true or false , both reader<T, M> and writer<T, M> have to check if the poison is delivered. // Awaitable for channel's read operation template < typename T , typename M > class reader { // ... auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; Unlike reader, writer just returns bool . The signature makes its return can be used in if or while conveniently. // Awaitable for channel's write operation template < typename T , typename M > class writer final { // ... bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; Furthermore, the signature makes user to places a boolean in the coroutine's frame, not in the channel . So it's on-demand cost. Skip: await_ready and await_suspend \u00b6 This part is realted to the requirement, optional synchronization. It will be covered later because they are purely about the implementation. If you are really curious, visit this page . Conclusion \u00b6 The type doesn't weighted for the performance. What I focused was to enforce intuitive code and to guide users' consideration to their behavior (and undelying semantics). It's not replacement nor alternative of the other delivery methods. To summarize each methods, return : 1 time, directional, subroutine to subroutine future<T> : 1 time, directional, subroutine to subroutine, synchronization(shared state) task<T> : 1 time, directional, coroutine to coroutine generator<T> : multi-time, directional, coroutine to coroutine asnyc_generator<T> : multi-time, directional, coroutine to coroutine, awaitable iterator channel<T> : multi-time (with suspend), non-directional, optional synchronization For channel<T> itself... Non-directional delivery \u00b6 You can see the example with the Compiler Explorer(MSVC) or with the WandBox(clang-8) Coverage Leak \u00b6 For the requirement, channel becomes a linked list of each reader and writer. Its operations place reader/writer object in the coroutine frame. In the destructor, all objects in linked lists receive the poison value. Invalidation (Close Status) \u00b6 To detect invalidation of the channel, we check the poison value in the await_resume function. It's signature enforces to make a memory object( ok in the example) to receive channel's status. When the poison is delivered, co_await on the reader/writer will return false , so the user can break the loop. This can be done without use of close operation.","title":"Designing the coroutine channel"},{"location":"articles/designing-the-channel/#designing-the-coroutine-channel","text":"commit: 1.4.3 This is a design note for the channel<T> . It's one of the oldest feature in this library. In this article, I will write about the design background of the type.","title":"Designing the coroutine channel"},{"location":"articles/designing-the-channel/#summary","text":"John Bandela already talked about the coroutine based channel in CppCon 2016 . However, I designed more limited one on my own. #include <coroutine/channel.hpp> using namespace coro ; constexpr int bye = 0 ; auto consumer ( channel < int >& ch ) -> no_return { // the type doesn't support for-co_await for now for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: we received a value if ( msg == bye ) break ; co_await ch . write ( msg ); // we can write in the reader coroutine } } auto producer_owner () -> no_return { channel < int > ch {}; consumer ( ch ); // start a consumer routine for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ok == true: we sent a value co_await ch . read ( msg ); // we can read in the writer coroutine } } Notice that we are reading before writing values to the channel. You can visit more example(test) codes for the type: test/channel_read_write_nolock.cpp test/channel_read_fail_after_close.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_ownership_consumer.cpp test/channel_ownership_producer.cpp test/channel_race_no_leak.cpp","title":"Summary"},{"location":"articles/designing-the-channel/#note","text":"","title":"Note"},{"location":"articles/designing-the-channel/#motivationbackground","text":"There are multiple ways to deliver value(normally an object) from a routine to another routine. channel<T> is designed to play a role as one of them.","title":"Motivation(Background)"},{"location":"articles/designing-the-channel/#before-the-coroutine","text":"Before the C++ Coroutines becames available, there were 2 ways. return : from callee subroutine to caller subroutine future<T> since C++11 : return with synchronization(shared state) return forwards a T type object from callee subroutine to caller subroutine. C++ 11 future<T> , do the same work but uses a shared state to provide synchronization. As we know, such a synchronization is for multi-threaded code. One of those methods' limitation is that they can deliver only 1 object (of T type), only 1 time (with the return ). Which makes inconvenience sometimes...","title":"Before the coroutine"},{"location":"articles/designing-the-channel/#after-the-coroutine","text":"By adopting coroutine to our world, now we can suspend, and get a new way of delivery. task<T> : 1 time delivery, from a coroutine to another coroutine generator<T> : multi-time delivery, from the generator coroutine to activator coroutine task<T> is the simplest way to get co_return from a coroutine. The most important design point for a coroutine function is that managing suspension( co_await ). It's because suspension is more general than finalization( co_return ). task<T> deals with the cases and activates(resumes) awaiting coroutine when the activatee coroutine returns. generator<T> uses co_yield to deliver value from activatee(generator coroutine) to activator(resumer subroutine) multiple times. For us, co_yield itself is a syntatic sugar that invokes yield_value and evaluate co_await (therefore, suspend) at the same time. Indeed there is a harmony in the way generator<T> works. However, what if we can't acquire the value from generator<T> immediately? What if advancing its iterator is asynchronous? async_generator<T> : generator<T> + awaitable iterator So async_generator<T> allows us to attach a coroutine which will be resumed when the generator coroutine can yield(perform the delivery). In my perspective, using co_await on its iterator is indeed a good idea for the interface design. Its user code remains very similar to that of the generator<T> The consumer coroutine is resumed automatically, so there is no coverage leak You can review existing implementations. Please let me know if there is another implementations so I can add them :) From the https://github.com/kirkshoop/await In this library, which is based on kirkshoop's work, sequence<T> From the adorable cppcoro","title":"After the coroutine"},{"location":"articles/designing-the-channel/#another-type-of-the-delivery","text":"At this point, we can recognize that we don't have a bidirectional delivery . generator<T> delivers its co_yield ed value only in 1 direction, and so does async_generator<T> . Also, if we need to write multi-threaded code, there are still needs of the synchronization. It depends on the pattern and can managed well, but it's still hard to the beginners. For nondirectional delivery, there is a good example in the Go language. It's channel . The channel can suspend both producer and consumer goroutines by affecting their scheduling. However, there is a difference between the coroutine in the C++ and Goroutine in the Go language. Goroutine is scheduled by the Go runtime, but coroutine are not. It doesn't have a built-in scheduling. Basically, coroutine_handle<T> itself is a pointer and programmers have to manage them manually.","title":"Another type of the delivery?"},{"location":"articles/designing-the-channel/#requirement","text":"So the requirement for our new type is like the following. channel<T> Non-directional delivery (at least bidirectional) Optional synchronization Coverage leak prevention Invalidation Zero allocation","title":"Requirement"},{"location":"articles/designing-the-channel/#non-directional-delivery","text":"We should be able to write/read to a channel in a same coroutine. It's convenient. And that is important for the beginners.","title":"Non-directional delivery"},{"location":"articles/designing-the-channel/#optional-synchronization","text":"It supports single-threaded code and there must be zero-cost in the case.","title":"Optional synchronization"},{"location":"articles/designing-the-channel/#coverage-leak-prevention","text":"The type must prevent coverage leak. That means, it must do its best to make related coroutines reach their ends.","title":"Coverage leak prevention"},{"location":"articles/designing-the-channel/#invalidation","text":"The channel must be able to notify its invalidation. So its user code can handle the operation failure and prevent undefined behavior while they are writing the code. With the coverage requirement above, user will co_return the coroutine, or delegate its work somehow.","title":"Invalidation"},{"location":"articles/designing-the-channel/#zero-allocation","text":"new / delete is not allowed to avoid unnecessary cost.","title":"Zero allocation"},{"location":"articles/designing-the-channel/#design-concerns","text":"","title":"Design Concerns"},{"location":"articles/designing-the-channel/#optional-synchronization_1","text":"The logic will remain while user applies different synchronization types. So the type will use be template. template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel final { public : using mutex_type = M ; private : mutex_type mtx ; } Also, as you can see above, it will use do nothing lockable by default. // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } };","title":"Optional synchronization"},{"location":"articles/designing-the-channel/#invalidation_1","text":"unlike the channel of Go, the type doesn't provide explicit close operation Explicit close is simple enough because we can just check the channel's state and break the loop. But it is highly possible that user will carefully design the value if there is no close . Suppose we have a close for the channel: auto producer ( channel < int >& ch ) -> no_return { int msg {}; // ... while ( ch . closed () == false ){ co_await ch . write ( msg ); // ... if ( cond ) break ; } ch . close (); // ok, no more value co_return ; } auto consumer ( channel < int >& ch ) -> no_return { while ( ch . closed () == false ){ int msg = co_await ch . read (); // ... } } In this case, user will think about the state of the channel. The following questions can be managed by patternized code, but will always arise from the existance of close . Which line should the close placed? When it's already closed, what should I do for read/write? When we don't have a close , users will think about another issue. When should I stop the read/write? The question is about managing the loop, and probably they will use something like EOF (sentinel value). In my perspective, it is more likely to have well-designed space for the value_type of the channel: auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { co_await ch . write ( msg ); // ... } } auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } }","title":"Invalidation"},{"location":"articles/designing-the-channel/#implementation","text":"Watching the CppCon 2016 talk will help you a lot for the following notes.","title":"Implementation"},{"location":"articles/designing-the-channel/#making-a-linked-list-of-the-coroutine-frames","text":"Since coroutine frames are allocated separatly, we can use them like a node in the linked list. By placing next pointer in those frame, we can make zero-allocation channel. Actually they are a kind of pre-allocation since the cost is already paid in the frame construction(invocation) steps. So it will be enough for channel<T> to have 2 linked lists and 1 mutex to operate correctly under multi-threaded code. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... private : mutex_type mtx ; } To make a linked list of the coroutine frames, the type places an objects in the coroutine frame that containes next pointer. // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... public : // place a writer in the coroutine's frame decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // place a reader in the coroutine's frame decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; You can find next pointer in the following writer and reader . Notice that they have a reserved space to receive coroutine_handle<void> from await_suspend . template < typename T , typename M > class writer final { public : using value_type = T ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; union { writer * next = nullptr ; // Next writer in the channel channel_type * chan ; }; }; template < typename T , typename M > class reader { public : using value_type = T ; using channel_type = channel < T , M > ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; union { reader * next = nullptr ; // Next reader in the channel channel_type * chan ; }; }; Because of the design we will place the objects in the frame. Consider: auto temporary_reader_object ( channel < int >& ch ) -> no_return { // co_await ch.read(); reader < int > reader = ch . read (); co_await reader ; } When it's used with for statement, there will be at most 2 read/writes. So it won't be that complicated. // at most 2 operation in 1 for loop auto consumer ( channel < int >& ch ) -> no_return { for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ... } } auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ... } }","title":"Making a linked list of the coroutine frames"},{"location":"articles/designing-the-channel/#preventing-coverage-leak","text":"We all know that RAII is the best way to make the type system work for us. Let's consider about it. What is the proper behavior of the linked list on its destruction? Like the std::list<T> , it must delete its existing nodes to prevent memory leak. Unfortunately, this case is really special because the nodes are existing coroutines' frame. That means, if we free the node, it will destroy all objects in the frame. That's really brutal because it can break all existing expectations of the function that manages its frame manually (with customized promise_type ). So the appropriate behavior is to resume those frames and let them recognize that they can't access the channel anymore. In its destructor , channel<T, M> resumes all awaiting coroutines in its linked lists. Notice the destructor is specified noexcept(false) because typically resume operation is not guaranteed noexcept . template < typename T , typename M > class channel { // ... ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; size_t repeat = 1 ; while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); // <-- use a poison value coro . resume (); // <-- resume write operations } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); // <-- resume read operations } } } } With the behavior, user code must be changed like the following. It receive not only a value from the channel but also one bool that notifies the channel is still accessible. // Before auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } // After auto consumer ( channel < int >& ch ) -> no_return { // it's returning tuple, // declare memory objects using structured binding for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: the channel is accessible // ... } } By doing so, if the reader/writer coroutines are written correctly, channel can guarantee there is no dangling coroutines in its linked lists, and prevent coverage leak of them.","title":"Preventing Coverage Leak"},{"location":"articles/designing-the-channel/#using-a-poison-in-await_resume","text":"I used poison to replace explicit close . Remember that the co_await expression is affected by await_resume . Returning a tuple from the function can constrain user's code. In the implementation, to decide to return true or false , both reader<T, M> and writer<T, M> have to check if the poison is delivered. // Awaitable for channel's read operation template < typename T , typename M > class reader { // ... auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; Unlike reader, writer just returns bool . The signature makes its return can be used in if or while conveniently. // Awaitable for channel's write operation template < typename T , typename M > class writer final { // ... bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; Furthermore, the signature makes user to places a boolean in the coroutine's frame, not in the channel . So it's on-demand cost.","title":"Using a poison in await_resume"},{"location":"articles/designing-the-channel/#skip-await_ready-and-await_suspend","text":"This part is realted to the requirement, optional synchronization. It will be covered later because they are purely about the implementation. If you are really curious, visit this page .","title":"Skip: await_ready and await_suspend"},{"location":"articles/designing-the-channel/#conclusion","text":"The type doesn't weighted for the performance. What I focused was to enforce intuitive code and to guide users' consideration to their behavior (and undelying semantics). It's not replacement nor alternative of the other delivery methods. To summarize each methods, return : 1 time, directional, subroutine to subroutine future<T> : 1 time, directional, subroutine to subroutine, synchronization(shared state) task<T> : 1 time, directional, coroutine to coroutine generator<T> : multi-time, directional, coroutine to coroutine asnyc_generator<T> : multi-time, directional, coroutine to coroutine, awaitable iterator channel<T> : multi-time (with suspend), non-directional, optional synchronization For channel<T> itself...","title":"Conclusion"},{"location":"articles/designing-the-channel/#non-directional-delivery_1","text":"You can see the example with the Compiler Explorer(MSVC) or with the WandBox(clang-8)","title":"Non-directional delivery"},{"location":"articles/designing-the-channel/#coverage-leak","text":"For the requirement, channel becomes a linked list of each reader and writer. Its operations place reader/writer object in the coroutine frame. In the destructor, all objects in linked lists receive the poison value.","title":"Coverage Leak"},{"location":"articles/designing-the-channel/#invalidation-close-status","text":"To detect invalidation of the channel, we check the poison value in the await_resume function. It's signature enforces to make a memory object( ok in the example) to receive channel's status. When the poison is delivered, co_await on the reader/writer will return false , so the user can break the loop. This can be done without use of close operation.","title":"Invalidation (Close Status)"},{"location":"articles/exploring-msvc-coroutine-kor/","text":"MSVC Coroutine \uc54c\uc544\ubcf4\uae30 \u00b6 Written in 2017/03/02 English \ucc38\uace0\uc790\ub8cc \u00b6 \uc81c\uc548\uc11c \u00b6 N3858 N3977 N4134 N4402 Visual C++ Team Blog \u00b6 Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++ \uc601\uc0c1 \u00b6 CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\" GitHub \uc800\uc7a5\uc18c \u00b6 kirkshoop/ await \uc8fc\uc758\uc0ac\ud56d \u00b6 \uc6b0\uc120 MSVC\uc758 Coroutine\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 3\uac00\uc9c0\uac00 \ud544\uc694\ud558\ub2e4. Visual Studio 2015 Up3 \ud639\uc740 \uadf8 \uc774\uc0c1\uc758 \uac1c\ubc1c\ud658\uacbd /await : \ucef4\ud30c\uc77c \uc635\uc158 <experimental/*> : \uc18c\uc2a4 \ucf54\ub4dc\uc5d0 \ub123\uc744 \ud5e4\ub354\ud30c\uc77c \uc815\uc758 \u00b6 \uadf8\ub798\uc11c, \ucf54\ub8e8\ud2f4\uc774 \ub300\uccb4 \ubb54\uac00\uc694? \uace0\uc2dd(\u53e4\u5f0f) : \uae30\uacc4\ub808\ubca8\uc5d0\uc11c \uc0dd\uac01\ud558\uae30 \u00b6 \uae30\ubcf8\uc801\uc73c\ub85c, \ud504\ub85c\uc2dc\uc800\uc758 \ud638\ucd9c\uc740 goto \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uadf8\ub7f0\ub370 \uc5b4\ub514\ub85c goto \ud55c\ub2e4\ub294 \uac83\uc77c\uae4c? \ub2e4\uc74c\uc5d0 \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc77c \uac83\uc774\ub2e4. \uba85\ub839\uc5b4\ub294 \ub8e8\ud2f4\uacfc \ud504\ub85c\uadf8\ub7a8\uc758 \uc77c\ubd80\uc774\uae30\ub3c4 \ud55c\ub370, \uc7a0\uc2dc \uc5ec\uae30\uc11c \ud55c\ubc88 \uc9da\uc5b4\ubcf4\uaca0\ub2e4. [\ud504\ub85c\uadf8\ub7a8]\uc740 \uc77c\ub828\uc758 [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub4e4\ub85c \ubcfc \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc5ec\uae30\uc11c [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub780, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c \uac83\uc774\uc5b4\uc57c \ud558\uba70, \ud504\ub85c\uadf8\ub7a8\uc744 \uc218\ud589\ud558\ub294 \uae30\uacc4\uc758 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\uc758 \uac12\ub4e4\uc744 \ud569\uce5c \uac83(composition)\uc774\ub2e4. \ubcf4\ud1b5\uc740 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac \uac12\uc758 \uc870\ud569\uc774 \uc720\ud55c\ud558\ub3c4\ub85d \uc124\uacc4\ud55c\ub2e4. Program State = Environment X Memory (\ud568\uc218\uc801 \ud569\uc131 : Cartesian Product) \uc5ec\uae30\uc11c \uba85\ub839\uc5b4\ub4e4\uc740 \uc0c1\ud0dc\uac04\uc758 \uc804\uc774(transition)\ub77c\uace0 \uc815\uc758\ud560 \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc774\ub7ec\ud55c \uc804\uc774\ub4e4\uc744 \uc21c\uc11c\ub300\ub85c \ubb36\uc740 \uac83\uc744 \ub8e8\ud2f4(routine)\uc774\ub77c\uace0 \ud55c\ub2e4. Instruction : \uba85\ub839, \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\uc758 \uc804\uc774 Routine : \uc21c\uc11c\uac00 \uc788\ub294 \uba85\ub839 \ubb36\uc74c \uadf8\ub7ec\uba74 \uc774\uc81c \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc73c\ub85c \ub118\uc5b4\uac08 \ucc28\ub840\ub2e4. \uad00\uacc4 \u00b6 \ubaa8\ub4e0 \ud504\ub85c\uadf8\ub798\uba38\ub4e4\uc740 \ucf54\ub4dc\uc5d0 \ub300\ud574\uc11c \uc790\uc2e0\ub9cc\uc758 \uc2ec\uc0c1(Mental Model)\uc744 \uac16\uae30 \ub9c8\ub828\uc774\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc758 \uba58\ud0c8 \ubaa8\ub378 \ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uace0\uc790 \ud55c\ub2e4. \uc11c\ube0c\ub8e8\ud2f4 : Caller-Callee \u00b6 \uc11c\ube0c\ub8e8\ud2f4\uc758 \uad00\uacc4\ub294 \uc77c\ubc29\uc801\uc774\ub2e4. \ud638\ucd9c\uc790(Caller)\ub294 \uc774\ubbf8 \uc5b4\ub5a4 \uc0c1\ud0dc\uc5d0 \uc788\uace0(\uc774\uc804 \uc870\uac74), \uc5b4\ub5a4 \ub8e8\ud2f4\uc774 \ud544\uc694\ud55c\uc9c0, \ud639\uc740 \ud638\ucd9c\ud560\uc9c0 \uc54c\uace0\uc788\ub2e4. \ud53c\ud638\ucd9c\uc790(Callee)\ub294 \ud504\ub85c\uadf8\ub798\uba38\uc758 \uc758\ub3c4\ub300\ub85c \uc815\uc758\ub41c \ucf54\ub4dc\ub97c \uac00\uc9c0\uace0 \uc788\uace0, \ud638\ucd9c\uc790\uc640 \ubb34\uad00\ud558\uac8c \uba85\ub839\ub4e4\uc744 \uc218\ud589\ud55c\ub2e4. \uc5ec\uae30\uc11c \ubd80\uc218\ud6a8\uacfc(Side-effect)\uac00 \uc788\uc744 \uc218 \uc788\uc9c0\ub9cc, \uadf8\uac74 \uba85\ub839\uc758 \ub0b4\uc6a9\uc5d0 \ub300\ud55c \uac83\uc774\uace0 \uad00\uacc4\uc640\ub294 \ubb34\uad00\ud558\ub2e4. \ucf54\ub8e8\ud2f4 : Activator-Activator \u00b6 \ubcf4\ud1b5 \ucf54\ub8e8\ud2f4\uc740 cooperative\ud55c routine\uc774\ub2e4. \uc774 \ub54c\ubb38\uc5d0 \ud611\ub825\ub8e8\ud2f4\uc774\ub77c\uace0 \ubc88\uc5ed\ub418\uae30\ub3c4 \ud558\ub294\ub370, \uc774\ub7f0 \uc774\ub984\uc740 \ucf54\ub8e8\ud2f4\uc774 \ubb35\uc2dc\uc801\uc73c\ub85c \ub2e4\ub978 \ub8e8\ud2f4\uacfc \ud568\uaed8 \ub3d9\uc791\ud558\ub3c4\ub85d \uc124\uacc4\ub41c \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ub098\uc628 \ub8e8\ud2f4\ub4e4\uc740 \uc11c\ub85c\ub97c \ud65c\uc131\ud654\ud55c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \ud638\ucd9c\uc790(Invoker)\uc640 \uc7ac\uac1c\ub8e8\ud2f4(Resuming routine)\uc5d0 \uc758\ud574\uc11c \ud65c\uc131\ud654 \ub41c\ub2e4. \uc5ed\uc73c\ub85c \uc911\ub2e8\ud558\uac70\ub098 \ubc18\ud658\ud568\uc73c\ub85c\uc368 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\ub978 \ub8e8\ud2f4\uc744 \uc7ac\uac1c\uc2dc\ud0a4\uac8c \ub41c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c\ub294 Suspend/Return\ub4f1\uc73c\ub85c \uad6c\ubd84\ud558\uc600\uc73c\ub098, \ud65c\uc131\ud654\ub77c\ub294 \uac83\uc740 \uc2e4\uc81c\ub85c\ub294 \ub8e8\ud2f4 \uc548\uc758 \uc784\uc758\uc758 \uc9c0\uc810(\uba85\ub839\uc5b4)\uc73c\ub85c \uc810\ud504( goto / jmp )\ud558\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\ub294 \uac83\uc774 \ub2e4\ub978 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uac83\uacfc \uac19\uc744 \uc218 \uc788\uc73c\uba70, \ud568\uc218\uc758 \uc885\ub8cc\uc640 \uc911\ub2e8\uc758 \ucc28\uc774 \ub610\ud55c \ud655\uc5f0\ud558\uc9c0 \uc54a\uc744 \uc218 \uc788\ub2e4. \uc810\ud504\uc758 \ubaa9\ud45c\uc8fc\uc18c\uac00 \ub8e8\ud2f4\uc758 \ub3c4\uc785\ubd80(\ud568\uc218\ub77c\uba74 prologue)\ub77c\uba74 \ud65c\uc131\ud654\ub294 Invocation ( call )\uc774 \ub41c\ub2e4. \ubaa9\ud45c\uc8fc\uc18c\uac00 \ud504\ub85c\uc2dc\uc800\uc758 \ud55c\uac00\uc6b4\ub370 \uc704\uce58\ud558\uba74, \uc774\ub294 Activation ( resume )\uc774 \ub41c\ub2e4. Invocation: \ud638\ucd9c. \ub8e8\ud2f4\uc758 \uc2dc\uc791\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Activation: \ud65c\uc131\ud654. \ub8e8\ud2f4\uc758 \uc784\uc758 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc, \ucf54\ub8e8\ud2f4\uc740 \uc774\uc804 \uc0c1\ud0dc(Pre-condition)\uc640 \uc774\ud6c4 \uc0c1\ud0dc(Post-condition)\uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. \uc774 \ub9d0\uc740, \ucf54\ub8e8\ud2f4 \ub610\ud55c \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\ub97c \uc5b4\ub5bb\uac8c \uc804\uc774\uc2dc\ud0ac\uc9c0 \uc815\uc758\ub418\uc5b4\uc57c \ud55c\ub2e4\ub294 \ub9d0\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc11c\ube0c\ub8e8\ud2f4\uacfc\ub294 \ub2e4\ub974\uac8c, \ucf54\ub8e8\ud2f4\uc740 \uc790\uc2e0\ub9cc\uc758 \uc0c1\ud0dc\ub97c \uc720\uc9c0\ud55c \ucc44\ub85c \ub2e4\ub978 \uc8fc\uc18c\ub85c goto \ud560 \uc218 \uc788\ub2e4. \uc774\ub97c Suspension ( yield )\uc774\ub77c \ud55c\ub2e4. \uacbd\uc6b0\uc5d0 \ub530\ub77c \uc774\ub294 \ud504\ub85c\uc2dc\uc800\uc758 \uc885\ub8cc, \ud639\uc740 \ud568\uc218\uc758 \ubc18\ud658( return )\uc774 \ub420\uc218 \uc788\uc73c\uba70, \uadf8\ub54c\ub294 \uc885\ub8cc(finalization)\ub97c \ud568\uaed8 \uc218\ud589\ud558\uac8c \ub41c\ub2e4. Suspension: \uc911\ub2e8. \uc885\ub8cc\uc791\uc5c5 \uc5c6\uc774 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Finalization: \uc885\ub8cc. \ub8e8\ud2f4\uacfc \uad00\ub828\ub41c \uc790\uc6d0\ub4e4\uc744 \uc815\ub9ac(\ud30c\uad34)\ud558\uace0 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 \ucc28\uc774\uc810? \u00b6 \uc694\ucee8\ub300 \uac00\uc7a5 \ud070 \ucc28\uc774\uc810\uc740, \ucf54\ub8e8\ud2f4\uc740 \uc11c\ube0c\ub8e8\ud2f4\ubcf4\ub2e4 \ub354 \ub9ce\uc740 \ub3d9\uc791(Operation)\uc744 \uc9c0\uc6d0\ud55c\ub2e4\ub294 \uac83\uc774\ub2e4. \uc774\uac83\uc774 \ub3c4\ub110\ub4dc \ud06c\ub204\uc2a4\uac00 The Art of Computer Programming \uc5d0\uc11c \uc774\ub807\uac8c \uc11c\uc220\ud55c \uc774\uc720\ub2e4. \"Subroutines are special cases of ... coroutines\" - Donald Knuth \uc774\ub97c \ud45c\ub85c \uc815\ub9ac\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4. Operation Subroutine Coroutine Invoke o o \ud504\ub85c\uc2dc\uc800\ub97c \uc2dc\uc791\ud55c\ub2e4 Activate x o \ud2b9\uc815\ud55c \uc9c0\uc810\uc73c\ub85c \uc9c4\uc785\ud55c\ub2e4 Suspend x o Control Flow\ub97c \uba48\ucd98\ub2e4. Finalize o o \uc9c0\uc5ed\ubcc0\uc218, \ub9e4\uac1c\ubcc0\uc218\ub4e4\uc744 \uc815\ub9ac\ud558\uace0 return \ud55c\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc774 \uc81c\ud55c\ub418\uc5c8\uc9c0\ub9cc \uad00\uacc4\uc5d0 \ub300\ud55c \uace0\ub824\uac00 \ud544\uc694\uc5c6\uc5b4 \uac04\ub2e8\ud558\ub2e4. \ubc18\uba74\uc5d0 \ucf54\ub8e8\ud2f4\uc740 \ub354 \ub9ce\uc740 \ub3d9\uc791\uc774 \uac00\ub2a5\ud558\uc9c0\ub9cc, \uc911\ub2e8\uacfc \ud65c\uc131\ud654\uc5d0 \ub300\ud55c(\uadf8\ub9ac\uace0 \uac01\uac01\uc758 Pre/Post condition\uc5d0 \ub300\ud55c) \uc815\uc758\uac00 \ud544\uc694\ud558\ubbc0\ub85c \ub354 \ubcf5\uc7a1\ud558\ub2e4. Routine: \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub97c \ubcc0\ud654\uc2dc\ud0a4\ub294 \uba85\ub839\uc5b4 \ubb36\uc74c. \uadf8 \ub0b4\uc6a9\uc740 \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c\ub2e4. Subroutine: \ub3d9\uc791 2\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Finalize Coroutine: \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Activate Suspend Finalize \uc608\uc81c \u00b6 \ud06c\ub204\uc2a4\ub294 \uc774\ub7f0 \uac1c\ub150\uc774 \uc5b4\ub5bb\uac8c \ucf54\ub4dc\ub85c \ud45c\ud604\ub418\ub294\uc9c0 \uadf8\uc758 \ucc45\uc5d0\uc11c \uc124\uba85\ud558\uace0 \uc788\ub2e4. \ub2e4\uc74c \ucf54\ub4dc\ub294 The Art of Computer Programming\uc5d0 \uc788\ub294 MIX \uba85\ub839\uc5b4\ub4e4\uc744 \uadf8\ub300\ub85c \uc62e\uaca8\uc628 \uac83\uc73c\ub85c, \ubaa8\ub450 \uc774\ud574\ud560 \ud544\uc694\ub294 \uc5c6\ub2e4. \uc624\ub298\ub0a0\uc758 call / return \uad6c\uc870\uc640 \ub2ec\ub9ac, \ubaa8\ub4e0 \ub3d9\uc791\ub4e4\uc774 JMP \uba85\ub839\uc5b4\ub85c \uc218\ud589\ub418\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ud575\uc2ec\uc740 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\uc218\uc758 \uc9c4\uc785\uc810\uacfc \uc911\ub2e8\uc810\uc744 \uac00\uc9c4\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub354\ud574\uc11c, \ubb35\uc2dc\uc801\uc778 \uc0c1\ud0dc(\ub808\uc9c0\uc2a4\ud130 \ud639\uc740 \uba54\ubaa8\ub9ac)\ub97c \uac00\uc9c8 \uc218\ub3c4 \uc788\ub2e4. // MIX \uc608\uc81c, \uc8fc\uc11d\uc744 \ubcc0\uacbd\ud558\uc600\uc74c // \uc790\uc138\ud55c \ub0b4\uc6a9\uc740 The Art of Computer Programming 1.4.2 \uc5d0 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF . \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378 \u00b6 \uc2a4\ud0dd\uc774\ub2e4! \u00b6 \"\ud568\uc815\uc774\ub2e4!\" - \uc544\ud06c\ubc14 \uc81c\ub3c5 \uc624\ub298\ub0a0 \ub110\ub9ac \uc0ac\uc6a9\ub418\uace0 \uc788\ub294 High-level \uc5b8\uc5b4\ub4e4\uc740 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c\ub2e4. \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc740 \uc5b8\uc5b4\uc801\uc73c\ub85c \uba85\ud655\ud558\uac8c \uc815\uc758\ub418\uace0, \uc790\ub3d9\uc73c\ub85c \uad00\ub9ac\ub418\uba70, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uac1c\uc785\ud558\uc9c0 \uc54a\uc544\ub3c4 \ubb38\uc81c\uc5c6\uc774 \ub3d9\uc791\ud55c\ub2e4. \uad6c\uc870\uc801 \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc774\ub7f0 \uc2a4\ud0dd\uc911\uc2ec\uc758 \ubaa8\ub378\uacfc \uc870\ud654\ub97c \uc774\ub8e8\uc5b4\uc654\ub2e4. \uc774 \ubaa8\ub378\uc5d0\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uc218\ud559\uc801\uc73c\ub85c \ud45c\ud604\ud560 \uc218 \uc788\ub294 \uc218\uc2dd\ud2b8\ub9ac \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uacb0\uacfc\uc801\uc73c\ub85c main \ud568\uc218\ub294 \uc885\ub8cc\ud558\uba70, \uc801\ub2f9\ud55c \uacb0\uacfc\uac12\uc744 \ubc18\ud658\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ud45c\ud604\ud55c \uac83 \ucc98\ub7fc, \ud2b8\ub9ac\ud615 \ubaa8\ub378\uc5d0\uc11c \ud568\uc218\uc758 \ud750\ub984\uc740 \uc774 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uae4a\uc774-\uc6b0\uc120 \uc21c\uc11c\ub85c \uc21c\ud68c\ud558\uba70, \uc791\uc131\ud558\ub294 \uc2dc\uc810\ubd80\ud130 \uac01 \uad6c\ubb38(Statement)\ub4e4\uc758 \uc2e4\ud589 \uc21c\uc11c\uac00 \uc815\ud574\uc9c4\ub2e4. \uadf8\ub9bc\uc5d0\uc11c B \uad6c\ubb38\uc5d0 \ub3c4\ub2ec\ud558\uae30 \uc704\ud574\uc120, A \uad6c\ubb38\uc744 \ub9c8\uccd0\uc57c \ud55c\ub2e4. \uc774 \uc2dc\uc810\uc5d0 \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub294 \uad6c\ubb38 A\uc758 \uc601\ud5a5\uc744 \ubc1b\uc544 \ubcc0\ud558\uac8c \ub418\uba70, \ub808\uc9c0\uc2a4\ud130/\uba54\ubaa8\ub9ac\ub294 \uc801\ub2f9\ud55c \uac12\uc744 \uac00\uc9c0\uace0 \uc788\uc744 \uac83\uc774\ub2e4. Blocking \u00b6 \uc5ec\uae30\uc11c \ubb38\uc81c\uac00 \ub418\ub294 \uac83\uc740 \uc758\uc874\uc131\uc774\ub2e4. \ud2b8\ub9ac \ubaa8\ub378\uc740 \uc218\ud559\uc744 \ud504\ub85c\uadf8\ub7a8\uc73c\ub85c \uc62e\uaca8\ub193\uc740 \uac83\uc774\ub2e4. \uc218\uc2dd\uc5d0 \ud544\uc694\ud55c \ubaa8\ub4e0 \uac12\uc774 \uba54\ubaa8\ub9ac\uc5d0 \uc788\ub2e4\uba74, \ucef4\ud4e8\ud130\ub294 \uacc4\uc0b0\uc744 \ub3c4\uc911\uc5d0 \uba48\ucd94\uc9c0 \uc54a\uace0\ub3c4 \uc218\ud589\ud560 \uc218 \uc788\ub2e4. \ub2e4\ub9cc \uc6b0\ub9ac\uc758 \uc790\uc6d0\uc740 \ubb34\ud55c\ud558\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \ud504\ub85c\uadf8\ub7a8 \ud750\ub984\uc774 \uc2dc\uc791\ub418\ub294 \uc2dc\uc810\uc5d0 \ubaa8\ub4e0 \uac12\ub4e4\uc744 \uc900\ube44\ud560 \uc218\ub294 \uc5c6\ub2e4. \ub2e4\ub978 \uc6d0\uc778\ub3c4 \uc788\ub2e4. \uac12\uc774 \ubb3c\ub9ac\uc801\uc73c\ub85c \uac81\ub098 \uba3c \uacf3\uc5d0 \uc788\uc5b4\uc11c \uc2e4\uc2dc\uac04 \ud1b5\uc2e0\uc744 \ud574\uc57c\ud560\uc218\ub3c4 \uc788\ub2e4. \uacb0\uad6d \uc6b0\ub9ac\ub294 \ud544\uc5f0\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc744 \ud574\uc57c\ud55c\ub2e4. \uc804\ud1b5\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc740 \ub290\ub9ac\uace0, \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uba48\ucdb0\uc57c \ud588\ub2e4. \ubc18\uc751\uc131(Responsiveness)\uc744 \uc704\ud574 \ud504\ub85c\uadf8\ub7a8\uc774 \uba48\ucd94\uae30\ub97c \uc6d0\ud558\uc9c0 \uc54a\ub294\ub2e4\uba74 \uc5b4\ub5a8\uae4c? Non-blocking\uacfc \ube44\ub3d9\uae30(Asynchronous) \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc5ec\uae30\uc11c \uc2dc\uc791\ud55c\ub2e4. \uc774\ub294 \uc694\uc57d\ud558\uc790\uba74 \uae30\uc874\uc758 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uc77c\ubc18\ud654 \ud574\uc11c, \ud558\ub098\uc758 \uadf8\ub798\ud504\ub97c \uc791\uc131\ud558\ub294 \uac83\uc774\ub2e4. \uc0c1\ud0dc\uae30\uacc4\uac00 \uadf8\ub798\ud504\ub85c \ud45c\ud604\ub41c\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud574\ubcf4\ub77c. \uc774 \uadf8\ub798\ud504 \ubaa8\ub378\uc5d0\uc120 \ud504\ub85c\uadf8\ub7a8\uc740 \uc0c1\ud0dc\ub4e4\ub85c \uc774\ub8e8\uc5b4\uc9c4 \uadf8\ub798\ud504 \uac00 \ub41c\ub2e4. \uadf8\ub9ac\uace0 \ud504\ub85c\uc138\uc11c\ub4e4\uc740 \uc774 \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\ub294 \uac83\uc774\ub2e4. \ud504\ub85c\uc138\uc11c\ub294 \uc6b4\uc601\uccb4\uc81c\uc758 \ud504\ub85c\uc138\uc2a4, \uc2a4\ub808\ub4dc\uc77c \uc218 \uc788\ub2e4. \ub610\ub294 \uc5b8\uc5b4\ub808\ubca8\uc5d0\uc11c \uc9c0\uc6d0\ud558\ub294 \ucd94\uc0c1\ud654, \uac00\ub839 Erlang\uc758 \ud504\ub85c\uc138\uc2a4\ub098 Go\uc5b8\uc5b4\uc758 Goroutine\uc77c \uc218 \uc788\ub2e4. \ub354 \uc774\uc0c1\uc758 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc0dd\ub7b5\ud55c\ub2e4. \uc601\uc18d\uc131 \u00b6 \ud575\uc2ec\uc740, \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\uba74\uc11c \uc5b4\ub5bb\uac8c \uc815\uc810\uac04\uc758 \ubb38\ub9e5(context) \uad50\ud658\uc774 \uac00\ub2a5\ud560\uae4c \ud558\ub294 \uac83\uc774\ub2e4. \uc6b0\uc120 \uc11c\ube0c\ub8e8\ud2f4\uc740 return \uacfc \ub3d9\uc2dc\uc5d0 \ud30c\uad34\ub418\ubbc0\ub85c(\uc0ac\ub77c\uc9c0\ubbc0\ub85c) \uc774\uac83\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. \ub2ec\ub9ac \ub9d0\ud574 \uc11c\ube0c\ub8e8\ud2f4\uc740 \uc601\uc18d\uc131\uc774 \uc5c6\ub2e4. \uc774\ub294 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc774 \ub3d9\uc791\ud558\ub294 \ubc29\uc2dd\uc774\uc9c0\ub9cc, \ub3d9\uc2dc\uc5d0 \uc815\uc810(\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc)\uac04\uc758 \ubb38\ub9e5\uc804\ub2ec\uc744 \uc544\uc8fc \uc5b4\ub835\uac8c \ub9cc\ub4e4\uc5c8\ub2e4. \ucf5c\ubc31 \uc9c0\uc625 \ub3c4 \uacb0\uad6d\uc740 \ubb38\ub9e5\uc804\ub2ec\uc744 \ud558\uae30 \uc704\ud55c \uace0\uc721\uc9c0\ucc45\uc774\ub77c \ud560 \uc218 \uc788\ub2e4. \"\uc81c\uc784\uc2a4, \uc774 \ucf54\ub4dc\uc5d0\ub294 \ubc84\uadf8\uac00 \uc788\uc5b4\uc694. \uace0\uce60 \uc218 \uc788\uaca0\uc5b4\uc694?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); } \uc811\uadfc\ubc95 \u00b6 \uc6b0\ub9ac\uc5d0\uac90 \uc601\uc18d\uc131 \uc788\ub294 \ud568\uc218\uac00 \ud544\uc694\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc(finalization)\ud558\uc9c0 \uc54a\uc73c\uba74\uc11c \uc911\ub2e8(suspend/yield)\uc774 \uac00\ub2a5\ud588\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud558\uba74, \ub2f5\uc740 \uba85\ud655\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc788\uc73c\uba74 \uc774 \ubb38\uc81c\ub97c \ud574\uacb0\ud560 \uc218 \uc788\uc744 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc5b4\ub85c \uad6c\ud604\ud558\ub358 \uac1c\ub150\uc744 \uc5b4\ub5bb\uac8c \uc2a4\ud0dd \uc138\uc0c1\uc73c\ub85c \uac00\uc838\uc62c \uc218 \uc788\uc744\uae4c? \uc9c8\ubb38\uc744 \ubc14\uafd4\ubcf4\uc790. \ubb34\uc5c7\uc774 \uc601\uc18d\uc131\uc744 \uac00\uc838\uc57c \ud558\ub294\uac00?: \ubb38\ub9e5 \ubb38\ub9e5\uc740 \ubb34\uc5c7\uc778\uac00?: \ub8e8\ud2f4\uc758 \uc0c1\ud0dc \uc0c1\ud0dc\ub294 \ubb34\uc5c7\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c0\ub294\uac00?: \ud658\uacbd & \uba54\ubaa8\ub9ac \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\ub294 \uc5b4\ub514\uc5d0 \uc704\uce58\ud558\ub294\uac00?: \ud568\uc218 \ud504\ub808\uc784(Function Frame) \uc815\ub9ac\ud558\uc790\uba74, \uc9c8\ubb38\uc740 \uc5b4\ub5bb\uac8c \ud568\uc218 \ud504\ub808\uc784\ub4e4\uc744 \uc601\uc18d\uc131\uc788\uac8c \ub9cc\ub4e4 \uac83\uc778\uac00 \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc124\uba85\uc740 \uc790\uc138\ud788 \uae30\uc220\ud558\uc9c0\ub294 \uc54a\uaca0\uc9c0\ub9cc, \uc790\uc138\ud55c \uc124\uba85\uc744 \uc6d0\ud55c\ub2e4\uba74 \uc774 \ud398\uc774\uc9c0 \ub97c \ucc38\uace0\ud558\ub77c. \uc2a4\ud0dd \uc548? \ubc16! \u00b6 \"\uc65c \uc740\ud589\uc744 \ud130\ub098\uc694?\" \"\ub3c8\uc774 \uac70\uae30\uc5d0 \uc788\uc796\uc544\uc694\" - \uc5b4\ub290 \uc740\ud589 \uac15\ub3c4 \uc2a4\ud0dd \ub0b4(Stack-ful) \ucf54\ub8e8\ud2f4 / \ubd84\ud560 \uc2a4\ud0dd \u00b6 \uc5b8\uc5b4\ub9c8\ub2e4 \ub2e4\ub974\uaca0\uc9c0\ub9cc, C++\ub294 \ud568\uc218 \ud504\ub808\uc784\uc744 \uc2a4\ud0dd\uc5d0 \ubc30\uce58\ud55c\ub2e4. \uc774\ub7f0 \uc0c1\ud669\uc5d0\uc11c \ud504\ub808\uc784\uc744 \ubcf4\uc874\ud558\ub824\uba74, \ud504\ub808\uc784\uc744 \uadf8\ub300\ub85c \ubcf5\uc0ac\ud574\uc11c \uc5b4\ub518\uac00\uc5d0 \uc800\uc7a5\ud574\ub450\ub294 \uc218 \ubc16\uc5d0 \uc5c6\ub2e4. \ub2e4\ub978 \ubc29\ubc95\uc73c\ub85c\ub294 \uc801\ub2f9\ud55c \uacf5\uac04\uc744 \ub530\ub85c \uc608\uc57d\ud574\uc11c \ub300\uccb4 \uc2a4\ud0dd(side stack)\uc73c\ub85c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc774 \uc788\uc744 \uac83\uc774\ub2e4. \uc774 \ubd80\ubd84\uc740 \uc9c0\ub098\uce58\ub3c4\ub85d \ud558\uaca0\ub2e4. MSVC\ub294 \uc2a4\ud0dd \uc678 \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4. \uc2a4\ud0dd \uc678(Stack-less) \ucf54\ub8e8\ud2f4\uacfc \ud568\uc218 \ud504\ub808\uc784 \u00b6 N3858 \uc81c\uc548\uc11c\uc5d0\ub294 \uc774\ub978\ubc14 '\ub2e4\uc2dc \uc2dc\uc791\ud558\ub294 \ud568\uc218'(Resumable Function, \uc774\ud558 \uc7ac\uac1c\ud568\uc218)\uc758 \uad6c\ud604\uac00\ub2a5\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uadf8 \ubc29\ubc95\ub860 \uc911 \ud558\ub098\ub294 \ud799(Heap)\uc5d0 \ud568\uc218\uc758 \ud65c\uc131 \ud504\ub808\uc784(Activation Frame)\uc744 \ud560\ub2f9\ud558\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud504\ub808\uc784\uc740 \ub2e8\uc21c\ud558\uac8c\ub294 \uad6c\uc870\uccb4\uc77c \ubfd0\uc774\ub2e4. \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791 4\uac1c\ub294 \uc5b4\ub5bb\uac8c \ub41c \uac83\uc77c\uae4c? \uc774\ub4e4\uc740 Compiler Intrinsic \ud615\ud0dc\ub85c MSVC\uac00 \uc790\uccb4\uc801\uc73c\ub85c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... \uadf8\ub7ec\ub2c8 \uc774 \ubd80\ubd84\uc5d0 \ub300\ud574\uc11c\ub294 \uc190\ub308 \uc218 \uc788\ub294 \ubd80\ubd84\uc774 \uc5c6\ub2e4. \ub354 \uc790\uc138\ud55c \uc124\uba85\uc774 \ud544\uc694\ud558\ub2e4\uba74 \ucc38\uace0\uc790\ub8cc\uc5d0\uc11c CppCon \ubc1c\ud45c\ub4e4\uc744 \uc2dc\uccad\ud558\uae30\ub97c \uad8c\ud55c\ub2e4. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block \uc774 intrinsic\ub4e4 \uc911 Frame\uacfc Block\ub4e4\uc758 \uc5ed\ud560\uc5d0 \ub300\ud574\uc11c \uba85\ud655\ud558\uc9c0 \uc54a\uc740 \ubd80\ubd84\uc774 \ub0a8\uc544\uc788\ub294 \uac83 \uac19\uc2b5\ub2c8\ub2e4. \uae30\ud68c\uac00 \ub418\uba74 \uc5c5\ub370\uc774\ud2b8 \ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. The C++ Coroutine : Resumable Function \u00b6 \uc774 \uc2dc\uc810\uc5d0\uc11c \ub450 \uc6a9\uc5b4\ub97c \uc815\ub9ac\ud560 \ud544\uc694\uac00 \uc788\uc744 \uac83 \uac19\ub2e4. Coroutine : \uac1c\ub150 . \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Resumable Function : C++ \uc5b8\uc5b4\uc5d0\uc11c Coroutine\uc758 \uad6c\ud604 \ubc29\ubc95 \ucd94\uac00\ub85c \ub2e4\uc74c \ud45c\ub294 \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791\ub4e4\uc744 \uc5b4\ub5bb\uac8c \uc0ac\uc6a9\ud558\ub294\uc9c0 \uc815\ub9ac\ud55c \uac83\uc774\ub2e4. Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return \ud638\ucd9c(Invoke) \u00b6 \ud568\uc218 \ud638\ucd9c\uc5d0 \ub300\ud574\uc11c\ub294 \ubcc0\uacbd\uc0ac\ud56d\uc774 \uc5c6\ub2e4. \ud558\uc9c0\ub9cc \uc7ac\uac1c\ud568\uc218\ub294 std::future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4. \uc885\ub8cc(Finalize) \u00b6 \uc11c\ube0c\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ubc18\ud658\uc9c0\uc810\uc740 \uc775\ud788 \uc54c\ub824\uc9c4 return \ud0a4\uc6cc\ub4dc\ub97c \uc0ac\uc6a9\ud558\uba74 \ub41c\ub2e4. \ucf54\ub8e8\ud2f4\uc774\ub77c\uba74 co_return \ud0a4\uc6cc\ub4dc\uac00 \uc774 \uc5ed\ud560\uc744 \ub300\uc2e0\ud55c\ub2e4. \uc911\ub2e8(Suspend) \u00b6 \ud568\uc218\ub97c \uc911\ub2e8\ud558\uace0 Control Flow\ub97c \uc591\ubcf4\ud558\ub294 \ubc29\ubc95\uc740 co_yield expression\uacfc co_await \uc5f0\uc0b0\uc790\ub97c \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. \uc774 \ub458 \uc911 \ud558\ub098\ub77c\ub3c4 \uc0ac\uc6a9\ud558\uba74, \uadf8 \uc9c0\uc810\uc740 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc73c\ub85c \uc0ac\uc6a9\ub418\uba70 MSVC\ub294 \uadf8 \ud568\uc218\ub97c \uc7ac\uac1c\ud568\uc218\ub85c \ub9cc\ub4e4\uac8c \ub41c\ub2e4. (\ub354\ud574\uc11c co_return \uad6c\ubb38\ub3c4 \ud568\uc218 \ub0b4\uc5d0 \uc704\uce58\ud558\uba74 \uc7ac\uac1c\ud568\uc218\ub85c \uc778\uc2dd\ub41c\ub2e4.) \ud65c\uc131\ud654(Activate) \u00b6 \uc911\ub2e8\ub41c \ud568\uc218\ub97c \ud65c\uc131\ud654 \ud560 \ub54c\ub294, coroutine_handle \uacfc \uba64\ubc84\ud568\uc218 .resume() \ub97c \uc0ac\uc6a9\ud55c\ub2e4. \uc774 \ud638\ucd9c\uc740 Compiler Intrinsic\uc778 _coro_resume \uc704\uc5d0 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc62c\ub9b0 \uac83\uc774\ub2e4. Code \u00b6 \uc608\uc81c \ucf54\ub4dc\uc640 \uad00\ub828\ud574 kirkshoop\uc758 \uc800\uc7a5\uc18c \uac00 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uc2b5\ub2c8\ub2e4. \ubbf8\ub9ac \uc694\uc57d\ud558\uc790\uba74, MSVC\uc758 \uc694\uad6c\uc0ac\ud56d\uc744 \ub530\ub974\uae30\ub9cc \ud55c\ub2e4\uba74 C++\uc5d0\uc11c\ub3c4 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. \uc81c\uc548\uc11c\uc758 \uc774\ub984\uc774 \uc7ac\uac1c (\ub530\ub77c\uc11c, \uc601\uc18d\uc131 \uc788\ub294) \ud568\uc218 \ub77c\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud558\ub77c. \uc7ac\uac1c\ud568\uc218\uc5d0\ub294 \uba87\uac00\uc9c0 \uc885\ub958\uac00 \uc788\ub294\ub370, \ud568\uc218\uc5d0 \uc5b4\ub5a4 \uc5ed\ud560\uc744 \ub9e1\uae30\uace0\uc790 \ud558\ub290\ub0d0\uc5d0 \ub530\ub77c \ub2ec\ub77c\uc9c4\ub2e4. \uadf8\ub7ec\uba74 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc694\uad6c\uc0ac\ud56d\uc774\ub780 \ubb34\uc5c7\uc77c\uae4c? Promise : \ucef4\ud30c\uc77c\ub7ec\uac00 \uc6d0\ud558\ub294 \uac83 \u00b6 C++11\uc5d0 \ucd94\uac00\ub41c std::future<T> \uc640 std::promise<T> , \uadf8\ub9ac\uace0 \uc774 \ub450 \uc9dd\uad81\uc758 \uad00\uacc4\uc5d0 \ub300\ud574\uc11c \uc54c \uac83\uc774\ub77c \uc804\uc81c\ud558\uaca0\ub2e4. \uc77c\ubc18\uc801\uc73c\ub85c, future<T> \ub294 \" \ub098\uc911\uc5d0 \uac12\uc774\ub098 \uc608\uc678\ub97c \uc904\uac8c\"\ub77c\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. ( std::async \ub97c \ucc38\uace0\ud558\ub77c) \uadf8\ub9ac\uace0 \uac12/\uc608\uc678\ub294 promise<T> \ub97c \ud1b5\ud574\uc11c \uc804\ub2ec\ub41c\ub2e4. \uc774\ub294 \"\uacb0\uacfc\ub97c \uc900\ub2e4\ub294 \uc57d\uc18d \uc744 \uc9c0\ucf30\ub2e4.\"\ub77c\ub294 \uac83\uc774\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\uac00 future<T> \ub97c \ubc18\ud658\ud55c\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \ub9d0 \uadf8\ub300\ub85c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \uc2a4\uc2a4\ub85c \uc911\ub2e8\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0 \ud65c\uc131\ud654\ud55c \ub8e8\ud2f4 \uc785\uc7a5\uc5d0\uc11c\ub294 \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc\ud588\ub294\uc9c0 \uc54c \ubc29\ubc95\uc774 \uc5c6\ub2e4. \ubc18\ud658\uac12\uc774 \uc788\ub2e4\ub294 \uac83\uc744 \uc54c \uc218 \uc5c6\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud568\uc218\uc758 \uc2dc\uadf8\ub2c8\ucc98(Signature)\uc0c1\uc73c\ub85c\ub294, \ub098\uc911\uc5d0 \ub77c\ub294 \uc758\ubbf8\uac00 \ub2f4\uae34 \ud0c0\uc785 future \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud568\uc73c\ub85c\uc368 \uc77c\ubc18\uc801\uc778 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uace0 \uc788\ub2e4. \ub2e4\ub9cc \uae30\uc874\uacfc \ub2ec\ub9ac \uc5ec\uae30\uc11c\uc758 promise \ub294 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c\uac83\uc774\ub2e4. N4402 \ub294 \uc774 \ub0b4\uc6a9\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uc5b4\uc9f8\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uac8c \uc57d\uc18d\uc774 \ud544\uc694\ud55c \uac83\uc77c\uae4c? \uc774\ub294 \uc7ac\uac1c\ud568\uc218\uac00 \ucd94\uc0c1\ud654 \ud55c \uacb0\uacfc\ubb3c\uc774\uae30 \ub54c\ubb38\uc774\ub2e4. \uc2a4\ud0dd \uae30\ubc18\uc758 \ud658\uacbd\ub54c\ubb38\uc5d0, \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud558\uae30\ub294 \ud588\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc640 \uac19\uc774 1\ucc28\uc6d0\uc73c\ub85c \ubc30\uce58\ub41c(flat) \uad6c\ubb38\uad6c\uc870\ub294 \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 \uacb0\uad6d \ud799\uc5d0\uc11c \uc0b4\uc544\uc788\uc73c\uba70, \ud799 \uc601\uc5ed(\ud568\uc218 \ud504\ub808\uc784)\uc5d0\uc11c \uc2a4\ud0dd \uc601\uc5ed( future \ub610\ub294 awaitable)\uc73c\ub85c \uac12\uc744 \uc804\ub2ec\ud574\uc57c \ud558\uace0, \uc774 \uacfc\uc815\uc740 \uc77c\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4 \ub97c \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9c0\ub3c4\ub85d \ud55c \uac83\uc774\ub2e4. \ubb3c\ub860 \uc778\ud130\ud398\uc774\uc2a4\ub294 \ucef4\ud30c\uc77c\ub7ec\uc640 \ud504\ub85c\uadf8\ub798\uba38 \uc591\ucabd \ubaa8\ub450\ub97c \uc704\ud55c \uac83\uc774\ub2e4. Resumable Promise Requirement \u00b6 \uc7ac\uac1c\ud568\uc218\uc758 Promise \uc694\uad6c\uc0ac\ud56d \uadf8 \uc778\ud130\ud398\uc774\uc2a4\uac00 \uc5b4\ub5bb\uac8c \uc4f0\uc774\ub294\uc9c0\ub294 \uc7a0\uc2dc \ud6c4 \uae30\uc220\ud558\uace0, \uadf8\uc5d0 \uc55e\uc11c N4402 \ubb38\uc11c\ub97c \uc0b4\ud3b4\ubcf4\uc790. \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub294 Promise \ud0c0\uc785\uc740 \uc544\ub798 \ud45c\uc5d0 \uc5f4\uac70\ub41c \uba64\ubc84\ud568\uc218\ub4e4\uc744 \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4. \uc81c\uc548\uc11c\ub97c \uc694\uc57d\ud55c \uac83\uc774\ubbc0\ub85c, \ubcf4\ub2e4 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc81c\uc548\uc11c\ub97c \ucc38\uace0\ud558\uae30 \ubc14\ub780\ub2e4. Expression Note P{} \uc774 \ud0c0\uc785\uc740 default constructible \ud574\uc57c\ud55c\ub2e4. p.get_return_object() \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc744 \uacb0\uc815\ud55c\ub2e4. future<T> \ud639\uc740 \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc774 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4. p.return_value(v) co_return \uad6c\ubb38. \uacb0\uacfc\uac12\uc73c\ub85c v \ub97c \uc804\ub2ec\ud558\uba70, \uadf8 \uac12\uc740 \ub098\uc911\uc5d0 \uc0ac\uc6a9(consume)\ub41c\ub2e4. p.return_value() co_return \uad6c\ubb38. void \ud0c0\uc785\uc5d0 \uc0ac\uc6a9\ub418\uba70, \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\uc744 \uc758\ubbf8\ud558\uae30\ub3c4 \ud55c\ub2e4. \uc7ac\uac1c\ud568\uc218\uac00 \uc885\ub8cc\ub420\ub54c \uc0ac\uc6a9\ub41c\ub2e4. \uc774 \ud568\uc218\uac00 \ud638\ucd9c\ub418\ub294 \uac83\uc740 \"\ub354\uc774\uc0c1 \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\"\uc744 \uc758\ubbf8\ud55c\ub2e4. p.set_exception(e) \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. Resumer \uce21\uc5d0\uc11c \uacb0\uacfc\uac12\uc744 \uc0ac\uc6a9\ud558\ub824\uace0 \ud560\ub54c throw \ub41c\ub2e4. p.yield_value(v) co_yield \ud45c\ud604\uc2dd. return_value(v) \uc640 \uc720\uc0ac\ud558\ub2e4. p.initial_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810(initial suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. p.final_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810(final suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. \uc5ec\uae30\uc11c \uc77c\ubd80 \ud568\uc218\ub4e4\uc740 coroutine_traits<T> \uc640 \uc5f0\uad00\ub418\uc5b4\uc788\ub294\ub370, \uc774\ud6c4\uc5d0 \uc774 \ud0c0\uc785\uc758 \uc720\ub3d9\uc131\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\uaca0\ub2e4. \uc774\uc81c C++ \ucf54\ub8e8\ud2f4\uc758 \uc0ac\uc6a9\ubc29\ubc95\uc73c\ub85c \ucd08\uc810\uc744 \uc62e\uaca8\ubcf4\uc790. Generator \u00b6 \uac1c\ub150 \u00b6 Generator = Iterator + Resumable Function \ubc18\ubcf5\uc790\uac00 \ubcf4\uc774\ub294\uac00? generator<T> \ub294 \uac12\uc758 \uc218\uc5f4(sequence)\uc744 \ucd94\uc0c1\ud654 \ud55c \uac83\uc774\ub2e4. \uc774\ub54c \uac12\uc740 \uc7ac\uac1c\ud568\uc218\uc5d0 \uc758\ud574\uc11c \uc0dd\uc131\ub418\ub294\ub370, \uc7ac\uac1c\ud568\uc218\ub294 \uc0c8\ub85c \ud638\ucd9c\ub418\uba74 \ud568\uc218 \ud504\ub808\uc784\uc774 \ud799 \uc601\uc5ed\uc5d0 \uc720\uc9c0\ub418\ubbc0\ub85c, generator \ub9c8\ub2e4 \uace0\uc720\ud55c \ubb38\ub9e5\uc744 \uac00\uc9c0\uac8c \ub41c\ub2e4. Example \u00b6 \ub2e4\uc74c \ucf54\ub4dc\ub294 N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator \ub97c \uc791\uc131\ud55c \uac83\uc774\ub2e4. #include <experimental/generator> // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc9c0\uc815(Set)\ud558\uace0 \uc911\ub2e8(Suspend)\ud55c\ub2e4. co_yield f1 ; // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uad6c\ud55c \ub4a4 Shift \ud55c\ub2e4. int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // \ub354\uc774\uc0c1 \uac12\uc744 \uc0dd\uc131\ud558\uc9c0 \uc54a\ub294\ub2e4. } void usecase () { // 10\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \ubc1b\ub294\ub2e4. for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc5b4\ub5bb\uac8c \uc774\uac8c \uac00\ub2a5\ud55c\uac78\uae4c? generator<T> \uc758 \uc815\uc758\ub97c \uc0b4\ud3b4\ubcf4\uc790. \uc2e4\uccb4(Detail) \u00b6 \uac04\ub7b5\ud558\uac8c generator<T> \ub97c \uc62e\uaca8\uc654\ub2e4. iterator \uc640 promise_type \uc744 \uc9c0\uc6d0\ud558\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ub610\ud55c begin() / end() \ud568\uc218\ub85c Range-based for loop \ub97c \uc9c0\uc6d0\ud558\uace0 \uc788\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud578\ub4e4 coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc788\ub2e4\uba74 \uc7ac\uac1c\ud574\uc11c \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc788\ub2e4. if ( _Coro ) { _Coro . resume (); // \ud568\uc218\uac00 \ubc18\ud658\ub418\uc5c8\ub098? if ( _Coro . done ()) return { nullptr }; // return end(); } // \uc544\uc9c1 \ub05d\ub098\uc9c0 \uc54a\uc558\ub2e4. // \ub2e4\uc74c\uc5d0 \ub2e4\uc2dc resume\ud558\uc790... return { _Coro }; } iterator end () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc5c6\ub2e4\uba74, \uac12\uc744 \ub354 \uac00\uc838\uc62c \uc218 \uc5c6\ub2e4. return { nullptr }; } ~ generator () { // RAII : \ud568\uc218 \ud504\ub808\uc784\uc744 \ud30c\uad34\ud55c\ub2e4. if ( _Coro ) { _Coro . destroy (); } } }; \uc774\ub97c \ubc14\ud0d5\uc73c\ub85c \uc2e4\uc81c\ub85c\ub294 \uc774\ub7f0 \ucf54\ub4dc\uac00 \ub9cc\ub4e4\uc5b4\uc9c8 \uac83\uc774\ub2e4. void usecase () { // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int > gen = fibonacci ( 10 ); // `iter++`\ub294 delete\ub418\uc5c8\uc73c\ubbc0\ub85c \uc0ac\uc6a9\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc77c\ubc18\uc801\uc778 iterator-for \uad6c\ubb38\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. iterator \ub294 \uc5b4\ub5bb\uac8c \ub418\uc5b4\uc788\uc744\uae4c? template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // \ubc18\ubcf5\uc790 \uc778\ud130\ud398\uc774\uc2a4 struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // \ub2e4\uc74c\uc73c\ub85c \uc774\ub3d9\ud560\ub54c... iterator & operator ++ () { // \ud568\uc218\ub97c \uc7ac\uac1c\ud574\uc11c \uac12\uc744 yield\ud558\ub3c4\ub85d \ud55c\ub2e4. _Coro . resume (); // \ub9cc\uc57d \ud568\uc218\uac00 return\ud588\ub2e4\uba74, \uadf8 \ud578\ub4e4\uc740 generator\uac00 \uc18c\uba78\uc2dc\ud0ac \uac83\uc774\ub2e4. if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // MSVC\uc758 \ucf54\uba58\ud2b8\ub294, \uc694\uc57d\ud558\uc790\uba74, // \ud6c4\uc704\uc99d\uac00\uc2dd\uc740 iterator\ub97c \ub36e\uc5b4\uc4f8 \uc218 \uc788\uace0, // \uc774\ub85c\uc778\ud574 handle\uc774 nullptr\ub85c \ubc14\ub00c\uba74\uc11c // \ud568\uc218 \ud504\ub808\uc784 \ub0b4\uc5d0 \ub9c8\uc9c0\ub9c9 \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc5c6\ub2e4\ub294 \uac83\uc774\ub2e4. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // `promise`\uc5d0 \ud3ec\uc778\ud130\uac00 \uc788\ub2e4. \ud3ec\uc778\ud130\ub97c \ucc38\uc870\ud574 \ud504\ub808\uc784 \uc548\uc758 \uac12\uc744 \uac00\uc838\uc628\ub2e4. _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; \uc774 \ucf54\ub4dc\ub97c \ubcf4\uba74 \ubc18\ubcf5\uc790\uac00 \ud568\uc218\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc7ac\uac1c\ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 generator<T> \uc758 promise_type \uc744 \ud1b5\ud574\uc11c \uac12\uc744 \ud68d\ub4dd\ud55c\ub2e4. \uc774 \uacbd\uc6b0\ub294 usecase \ud568\uc218\uac00 generator \uc758 \ud638\ucd9c\uc790\uba74\uc11c \uc7ac\uac1c\uc790\uc778 \uac83\uc774\ub2e4. \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810 \u00b6 \uc774\uc81c \ud575\uc2ec\uc774 \ub418\ub294 promise_type \uc744 \ubcfc \ucc28\ub840\ub2e4. \uae30\uc220\ub41c \uac83 \ubcf4\ub2e4 \ucf54\ub4dc\uac00 \uc880 \ub354 \uc788\uc9c0\ub9cc \ub2e8\uc21c\ud654 \ud558\uc600\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } \uc774 promise_type \uc740 \uc694\uad6c\uc0ac\ud56d \uc911\uc5d0\uc11c 4\uac1c\uc758 \uba64\ubc84\ud568\uc218\ub97c \ub9cc\uc871\ud55c\ub2e4. get_return_object , initial_suspend , final_suspend , \uadf8\ub9ac\uace0 yield_value \uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. co_yield \ub294 \"\uac12\uc744 \uc9c0\uc815\ud558\uace0 \uc911\ub2e8\ud558\ub77c\"\uc640 \uac19\uc740 \uc758\ubbf8\uc778\ub370, \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774\ub97c \uc774\ub807\uac8c \ubcc0\uacbd\ud55c\ub2e4. co_yield : co_await + p.yield_value(x) \ub530\ub77c\uc11c, co_yield \uc5d0 \uc778\uc790 \ud45c\ud604\uc2dd\uc774 \uc5c6\ub2e4\ub294 \uac83\uc740 \ubd88\uac00\ub2a5 \ud558\ub2e4. x \ub294 void \uac00 \ub420 \uc218 \uc5c6\uae30 \ub54c\ubb38\uc774\ub2e4. \uac19\uc740 \uc774\uc720\ub85c generator<void> \ub294 \ucef4\ud30c\uc77c \uc5d0\ub7ec\uac00 \ub418\uba70, \uc5f0\uc18d\ub41c \uac12\uc758 \ucd94\uc0c1\ud654\ub77c\ub294 \uc815\uc758\uc5d0\ub3c4 \uc704\ubc30\ub41c\ub2e4. \uc5c4\ubc00\ud788 \ub9d0\ud574 \uc5ec\uae30\uc11c co_await \ub294 suspend \ub97c \uc758\ubbf8\ud55c\ub2e4. \uc790\uc138\ud55c \uc124\uba85\uc740 \ud6c4\uc220\ud55c\ub2e4. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud45c\ud604\uc2dd\uc744 \uc544\ub798\uc640 \uac19\uc774 \ubc14\uafbc\ub2e4. // co_yield f1; p . yield_value ( f1 ); // \uac12\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc9c0\uc815\ud558\uace0 co_await suspend_always {}; // \uc911\ub2e8\ud55c\ub2e4. // ... } co_return ; // \ub354\uc774\uc0c1 \uac12\uc774 \uc5c6\ub2e4. } \uc774 \ucf54\ub4dc\uc5d0\ub294 promise_type p{} \uac19\uc740 \ubcc0\uc218 \uc120\uc5b8\uc774\ub098, \ub2e4\ub978 \ud568\uc218\ub4e4\uc758 \ud638\ucd9c\uc774 \uc5c6\ub2e4. \uadf8 \uc774\uc720\ub294 \ub2e4\uc74c \ub2e8\uc6d0\uc5d0\uc11c \ub2e4\ub8e8\uaca0\ub2e4. Resumable Function \u00b6 \uc7ac\uac1c \ud568\uc218 \uc774\ubc88\uc5d4 \uc880 \ub354 \uc0c1\ud5a5\uc2dd\uc73c\ub85c \uc54c\uc544\ubcf4\uc790. \uc608\uc81c\ucf54\ub4dc\ub294 Awaitable Concept\ub97c \uc774\ud574\ud55c \ub4a4\uc5d0 \ubd10\uc57c \ud55c\ub2e4. \uac1c\ub150 \u00b6 Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> \ub294 \ub2e8\uc21c\ud55c \uc608\uc81c\uc600\ub2e4. generator \ub294 coroutine_handle \uc744 \uba64\ubc84\ubcc0\uc218\ub85c \uac00\uc9c0\uace0 \uc788\uc5c8\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ubb34\uc5c7\uc778\uc9c0 \uc0b4\ud3b4\ubd10\uc57c \ud55c\ub2e4. \uc0ac\uc2e4, coroutine_handle \uc758 \uc608\uc804 \uc774\ub984\uc740 resumable_handle \uc600\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 C++\uc0c1\uc5d0\uc11c \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud55c \uac83\uc774\ub77c\uace0 \uc124\uba85\ud588\ub294\ub370, coroutine_handle \ub294 \ub2ec\ub9ac \ub9d0\ud558\uba74 \uc7ac\uac1c\ud568\uc218\uc5d0 \ub300\ud55c \ud578\ub4e4(Resumable Function Handle)\uc774\ub2e4. Windows API\ub97c \uc0ac\uc6a9\ud574\ubcf8 \uacbd\ud5d8\uc774 \uc788\ub2e4\uba74 Handle \uc774 \uacb0\uad6d void* \ub77c\ub294 \uac83\uc744 \uc54c \uac83\uc774\ub2e4. \uc5ec\uae30\uc11c\ub3c4 \ub3d9\uc77c\ud558\ub2e4. \uc55e\uc11c \uc124\uba85\ud588\ub358 \uac83 \ucc98\ub7fc MSVC\ub294 \ud799 \uc601\uc5ed\uc5d0 \ud504\ub808\uc784\uc744 \ub3d9\uc801\ud560\ub2f9\ud558\uace0, \uac70\uae30\uc5d0 \uc57d\uac04\uc758 intrinsic\uc744 \ub354\ud558\ub294 \ud615\ud0dc\ub85c \uc2a4\ud0dd \uc678(stack-less) \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4. coroutine_handle \uc740 \uc774\ub4e4\uc744 \ud558\ub098\uc758 \ud0c0\uc785\uc73c\ub85c \ubb36\uc5b4\ub193\uc740 \uac83\uc774\ub2e4. \uc7ac\uac1c\ud568\uc218\uc758 \ud504\ub808\uc784 \u00b6 \uadf8\ub7ec\uba74, Resumable Frame \uc740 \ub300\uccb4 \uc5b4\ub5bb\uac8c \uc0dd\uacbc\uc744\uae4c? \uc77c\ub2e8 \ud504\ub808\uc784\uc740 Head\uc640 Body\ub85c \ub098\ub25c\ub2e4. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Head // - Fn : \uc7ac\uac1c\ud560 \ub54c \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc758 \uc8fc\uc18c // - cdecl : \uc774 Convention\uc5d0\uc11c \ud568\uc218 \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 Caller \uac00 \ub2f4\ub2f9\ud55c\ub2e4. // - Index : Resumption point\uc758 \uc778\ub371\uc2a4 // 0\ubc88\uc740 \ud568\uc218\uac00 \uc885\ub8cc\ub41c(`done()`) \uacbd\uc6b0\uc5d0 \uc0ac\uc6a9\ud55c\ub2e4. // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Body \uc5d0\ub294... // - Promise \ud0c0\uc785 \uac1c\uccb4 // - \ud504\ub808\uc784\uc73c\ub85c \uc774\ub3d9\uc2dc\ud0a8 Arguments // - \ud568\uc218 Body // - \uc9c0\uc5ed/\uc784\uc2dc \ubcc0\uc218\ub4e4 // - Platform \uc804\uc6a9 // - \ub808\uc9c0\uc2a4\ud130 \ub4f1\ub4f1 // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : \uc774\ub984\ucc98\ub7fc _Resumable_frame_prefix \uac00 \ud568\uc218\ud504\ub808\uc784\uc758 \uc55e\ubd80\ubd84\uc774 \ub41c\ub2e4. MSVC \ub294 \uc774 \uacf5\uac04\uc5d0 sizeof(void *) * 2 (x64 \uc5d0\uc11c 16 \ubc14\uc774\ud2b8)\ub9cc\ud07c\uc758 \uace0\uc815\ub41c \ud06c\uae30\ub97c \uc0ac\uc6a9\ud55c\ub2e4. Fn : cdecl \ud638\ucd9c \uaddc\uc57d\uc73c\ub85c \uc120\uc5b8\ub418\uc5b4\uc788\ub2e4\ub294 \uc810\uc774 \ud2b9\uc774\ud55c\ub370, cdecl \uc5d0\uc11c \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 \ud638\ucd9c\uc790\uc758 \uc5ed\ud560\uc774\uba70, \ub530\ub77c\uc11c Fn \uc744 \ud638\ucd9c\ud558\ub294 \uac83\uc740 \uadf8 \uc2dc\uc810\uc758 \uc2a4\ud0dd\uacfc \ud568\uc218 \ud504\ub808\uc784\uc5d0 \uc601\ud5a5\uc744 \ubbf8\uce58\uc9c0 \uc54a\ub294\ub2e4. Index : \uc7ac\uac1c\ud568\uc218\ub294 \ub2e4\uc218\uc758 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\ub4e4\uc744 \uac00\uc9c0\uace0 \uc788\uace0, Index \ub294 \uac01 \uc9c0\uc810\ub4e4\ub85c switch \ud558\ub294\ub370 \uc0ac\uc6a9\ub41c\ub2e4. Flag : ??? \uc774\uac74 \ub300\uccb4 \ubb58\uae4c ??? Body : N4402\uc5d0 \ud568\uc218 \ud504\ub808\uc784\uc758 \uad6c\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. James McNellis\uc758 \ubc1c\ud45c\uc790\ub8cc\uc5d0 \uc758\ud558\uba74, \ucef4\ud30c\uc77c\ub7ec\uac00 \uc0dd\uc131\ud558\ub294 \ud504\ub808\uc784\uc740 \ub2e4\uc74c\uc744 \ud3ec\ud568\ud55c\ub2e4. \uc77c\ubc18\uc801\uc778 \uc2a4\ud0dd \ud504\ub808\uc784\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // `fibonacci` \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784(\uc608\uc2dc) struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci\ub294 `generator<int>`\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int >:: promise_type _p ; // \ud504\ub808\uc784\uc5d0 \uc778\uc790\ub97c \uc800\uc7a5\ud55c\ub2e4. int _n ; // fibonacci(n); int _f1 , _f2 ; // \uc9c0\uc5ed \ubcc0\uc218 int _i , _f3 ; // \uc784\uc2dc \ubcc0\uc218 // Platform \uc804\uc6a9 \uc800\uc7a5\uc18c // \ub808\uc9c0\uc2a4\ud130\ub098 \uc774\uac83\uc800\uac83... }; Coroutine Traits \u00b6 p.get_return_object() \uc5d0 \ub300\ud574\uc11c \ub2e4\ub8e8\uc9c0 \uc54a\uc558\uc5c8\ub294\ub370, \uc5ec\uae30\uc11c \uac19\uc774 \ub2e4\ub8e8\uace0\uc790 \ud55c\ub2e4. \uba3c\uc800 coroutine_traits \ub97c \ub208\uc5ec\uaca8\ubd10\uc57c \ud55c\ub2e4. // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; \uad49\uc7a5\ud788 \ub2e8\uc21c\ud55c\ub370, coroutine_traits \uc774 \uc694\uad6c\ud558\ub294 \uac83\uc740 \uacb0\uad6d promise_type \ub97c \uad6c\ud604\ud558\ub77c\ub294 \uac83\uc774\ub2e4. \uc774\uc5d0 \ub300\ud55c \uac80\uc0ac\ub294 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uc774\ub8e8\uc5b4\uc9c0\uace0, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement \ub97c \ub9cc\uc871\uc2dc\ucf1c\uc57c \ud55c\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\ub294 future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \uc0ac\uc2e4 \uadf8\uac83\uc740 \ubd80\uc815\ud655\ud55c \uc124\uba85\uc774\uc5c8\ub2e4. coroutine_traits \ub97c \ub9cc\uc871\uc2dc\ud0a4\uae30\ub9cc \ud55c\ub2e4\uba74, \uadf8 \ud0c0\uc785\uc740 \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc774 \ub420 \uc218 \uc788\ub2e4. std::future<T> \ub97c \uc704\ud55c coroutine_traits \uc758 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 \ubc84\uc804\uc744 \uc62e\uaca8\uc654\ub2e4. generator<T> \uc758 \uacbd\uc6b0\ub294 \ub0b4\ubd80\uc5d0 promise_type \uc744 \uad6c\ud604\ud558\uace0 \uc788\uc5c8\ub294\ub370, \uc608\uc804\ubd80\ud130 \uc0ac\uc6a9\ud558\ub358 \ud0c0\uc785\ub4e4\uc774\ub098 \ucee4\uc2a4\ud140 \ud0c0\uc785\ub4e4\uc740 \uc774\ub7f0 \ud2b8\ub9ad\uc744 \uc0ac\uc6a9\ud574\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc720\uc5f0\ud558\uac8c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. // <future> \ud5e4\ub354 #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // `std::future<T>`\ub97c \uc704\ud55c \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // `future<_Ty>`\ub97c \ubc18\ud658\ud558\ub294 \uc7ac\uac1c\ud568\uc218\ub4e4\uc744 \uc704\ud55c \ud0c0\uc785\uc815\uc758 struct promise_type { // `std::promise<T>`\ub97c \uadf8\ub300\ub85c \uc0ac\uc6a9\ud55c\ub2e4. promise < _Ty > _MyPromise ; // \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc740 `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // `false`\uc77c \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool initial_suspend () const { return ( false ); } // `false`\uc77c \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool final_suspend () const { return ( false ); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif MSVC\ub294 co_await / co_yield / co_return \ud0a4\uc6cc\ub4dc \uc911 \ud558\ub098\ub97c \ud655\uc778\ud558\uba74, coroutine_traits \ub97c \uc0ac\uc6a9\ud574 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uac80\uc0ac\ub97c \uc218\ud589\ud560 \uc218 \uc788\ub3c4\ub85d \ucf54\ub4dc\ub974 \uc0dd\uc131\ud55c\ub2e4. MSVC\uac00 \ud558\ub294 \uc77c\uc744 \ud655\uc778\ud558\uae30 \uc704\ud574 fibonacci \uc608\uc81c\ub85c \ub2e4\uc2dc \uac00\ubcf4\uc790. \uc774 \ucf54\ub4dc\ub294 \ud2c0\ub9b0 \ud615\ud0dc\uc77c \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc815\ud655\ud55c \uba54\ucee4\ub2c8\uc998\uc744 \ud655\uc778\ud558\uac8c \ub418\uba74 \uac31\uc2e0\ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // \ubcc4\uce6d : \ubc18\ud658\ud0c0\uc785 using return_type = generator < int > ; // \ubc18\ud658\ud0c0\uc785\uc774 Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294\uac00? using traits = coroutine_traite < return_type > ; // \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud55c\ub2e4\uba74 \uc774 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4. // fibonacci \ud568\uc218\ub97c \uc704\ud55c \uac00\uc0c1\uc758 \ud504\ub808\uc784. \uc704\uc640 \ub3d9\uc77c\ud558\ub2e4. struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // \ud504\ub808\uc784\uc744 \ub3d9\uc801\uc73c\ub85c \ud560\ub2f9\ud55c\ub2e4. context(ctx)\ub77c\uace0 \ud558\uaca0\ub2e4. // \ud2b9\uc815\ud55c Allocator\ub97c \uc0ac\uc6a9\ud574 \ucee4\uc2a4\ud130\ub9c8\uc774\uc988 \ud560 \uc218\ub3c4 \uc788\uc9c0\ub9cc \uc5ec\uae30\uc120 \ub2e8\uc21c\ud788 new\ub85c \uc124\uba85\ud55c\ub2e4. __frame * ctx = new __frame { std :: move ( n )}; // \ubc18\ud658 \uac1c\uccb4\ub97c \uc0dd\uc131\ud55c\ub2e4. return_type __return = ctx -> _promise . get_return_object (); // true\uc77c \uacbd\uc6b0 \uc911\ub2e8, false\uc77c \uacbd\uc6b0 \uc9c4\ud589\ud55c\ub2e4. if ( ctx -> _promise . initial_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __initial_suspend_point : } // \uc0ac\uc6a9\uc790 \ucf54\ub4dc\ub294 \ud504\ub808\uc784\uc744 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ubcc0\uacbd\ub41c\ub2e4. // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // promise\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // `ctx->_prefix`\uc758 Index\ub97c \uc870\uc815\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4. // co_await suspend_always{}; __suspend_resume_point_1 : // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uacc4\uc0b0\ud558\uace0 Shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __final_suspend_point : } // \uc815\ub9ac\uc791\uc5c5... } \uc0dd\uac01\ubcf4\ub2e4 \ucef4\ud30c\uc77c\ub7ec\uac00 \ub9ce\uc740 \uc791\uc5c5\uc744, \ud558\uc9c0\ub9cc \uae30\uc874\uc5d0 \uc2a4\ud0dd \ud504\ub808\uc784\uc5d0 \ub300\ud574\uc11c \ud558\ub358\uac83\uacfc \uc720\uc0ac\ud55c \uc791\uc5c5\uc744 \ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\uc5c8\ub2e4. ctx \uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ud799\uc601\uc5ed\uc5d0 \uc704\uce58\ud55c \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc740 this \ud3ec\uc778\ud130\uc758 \uc0ac\uc6a9\uacfc \ub2e4\ub974\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \uc774\ub7f0 \ud504\ub808\uc784 \uae30\ubc18 \uad6c\ud604\uc758 \ube44\uc6a9\uc740 \ucd94\uac00\uc801\uc778 co_await \uad00\ub828 \ube44\uc6a9\uc774\uc678\uc5d0\ub294 \ubb34\uc2dc\ud560 \uc218 \uc788\ub294 \uc218\uc900\uc77c \uac83\uc774\ub2e4. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend; \uc7a0\uae50 \uc815\ub9ac \u00b6 co_return \uacfc co_yield \uc5d0 \ub300\ud574\uc11c generator<T> \uc608\uc81c\ub97c \ud1b5\ud574 \uc0b4\ud3b4\ubd24\ub2e4. Generator\ub294 \ubc18\ubcf5\uc790\uc640 \uc7ac\uac1c\ud568\uc218\ub97c \ud569\uce5c \uac83\uc774\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 coroutine_handle \uc744 \uc0ac\uc6a9\ud558\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\uc640 \ucef4\ud30c\uc77c\ub7ec Intrinsic\uc744 \ud569\uccd0\ub193\uc740 \uac83\uc774\ub2e4. \ud504\ub808\uc784 \uae30\ubc18\uc758 \uad6c\ud604\uc740 this \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ubcc0\uc218\ub97c \uc870\uc791\ud558\ub294 \uac83\uacfc \uc720\uc0ac\ud558\ub2e4. \ucef4\ud30c\uc77c \uc2dc\uac04(\uc815\uc801) \uac80\uc0ac\ub97c \uc704\ud574 coroutine_traits<T> \uac00 \uc0ac\uc6a9\ub41c\ub2e4. \uc774\ub97c \ud1b5\ud574 promise_type \uc744 \uad6c\ud604\ud558\ub3c4\ub85d \uac15\uc81c\ud558\uba70, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement\ub97c \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4. std::future<T> \uc758 \uacbd\uc6b0 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654\uac00 \uae30\ubcf8\uc801\uc73c\ub85c \uc9c0\uc6d0\ub41c\ub2e4. \"\uae30\ub2e4\ub9b4 \uc218 \uc788\ub2e4\"\ub294 \uac1c\ub150\uc5d0 \ub300\ud574\uc11c \u00b6 operator co_await = Syntactic Sugar + Resumable Function \uc7ac\uac1c\ud568\uc218\uc758 \ub9c8\uc9c0\ub9c9 \ud575\uc2ec\uc740 \ub2e8\ud56d \uc5f0\uc0b0\uc790 co_await \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ubb38\ub9e5\uc0c1\uc73c\ub85c, await\ub294 suspend\uc640 \uac19\uc740\uc758\ubbf8\ub2e4 . \uadf8\ub9ac\uace0 \uc774 \uc911\ub2e8 \ub54c\ubb38\uc5d0, \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \uc790\uc5f0\uc2a4\ub7fd\uac8c \ube44\ub3d9\uae30 \uac00 \ub41c\ub2e4. \uba58\ud0c8 \ubaa8\ub378 \uc0c1\uc5d0\uc11c \uc774\ub7f0 \ud2b9\uc131\uc740 \uaf64 \uc911\uc694\ud55c \uc810\uc778\ub370, C# \uc5b8\uc5b4\uc758 async & await \uae30\ub2a5\uacfc \uc720\uc0ac\ud558\ub2e4\uace0 \ubcfc \uc218 \uc788\ub2e4. C++ \uc138\uc0c1\uc5d0\uc11c \ub2e4\ub978\uc810\uc740, \ud504\ub85c\uadf8\ub798\uba38\uc758 \ucf54\ub4dc\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc9c0\uc6d0\uc744 \uc0ac\uc6a9\ud574\uc11c \uc218\ub3d9\uc73c\ub85c \uad00\ub9ac\ud560 \uc218 \uc788\ub2e4\ub294 \uc810\uc774\ub2e4. Example \u00b6 MSVC \ube14\ub85c\uadf8\uc758 \uc608\uc81c\ub97c \uac00\uc838\uc654\ub2e4. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // \uc5f0\uc0b0\uc790 \uc624\ubc84\ub85c\ub4dc // co_await \ub294 \uae30\ubcf8 \ud0c0\uc785(primitive type) \uc778\uc790\ub294 \ubc1b\uc9c0 \uc54a\ub294\ub2e4. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc120 \ud568\uc218 3\uac1c\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback\uc744 \uc218\ud589\ud558\ub294 Thread\uc5d0\uc11c Resume\ud55c\ub2e4. coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // \uc900\ube44\uac00 \uc548\ub418\uc5c8\uc73c\uba74 (`false`), `await_suspend`\ub97c \ud638\ucd9c\ud55c\ub2e4. // \uac12\uc774 \uc900\ube44\ub418\uc5c8\uc73c\uba74 (`true`), `await_resume`\ub97c \ubc14\ub85c \ud638\ucd9c\ud55c\ub2e4. bool await_ready () const { return duration . count () <= 0 ; } // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \ubb34\uc2dc\ub420 \uc218 \uc788\ub2e4. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // \ud0c0\uc774\uba38\ub97c \uc138\ud305\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4.... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // \uc7ac\uac1c\ub41c \ud6c4\uc5d0\ub294 T \ud0c0\uc785 \uac12\uc744 \ubc18\ud658\ud55c\ub2e4. // `void`\ub3c4 \uac00\ub2a5\ud558\ub2e4. void await_resume () {} }; return awaiter { duration }; } // \ucf54\ub8e8\ud2f4(\uc7ac\uac1c\ud568\uc218) future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // 1 \ubc00\ub9ac\ucd08\ub97c \uae30\ub2e4\ub9b0\ub2e4... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // \ud3c9\ubc94\ud55c \uc11c\ube0c\ub8e8\ud2f4 void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } \uc774 \ucf54\ub4dc\ub294 \ub300\ub7b5 \uc774\ub7f0 \uc2dd\uc73c\ub85c \uc9c4\ud589\ub41c\ub2e4. \uae30\ub2e4\ub9ac\uae30 \uc704\ud55c \uc778\ud130\ud398\uc774\uc2a4 \u00b6 co_await \ub294 \ub3d9\uc791\ud558\uae30 \uc704\ud574\uc11c \ud2b9\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc694\uad6c\ud55c\ub2e4. \uc704\uc5d0\uc11c \ubcf8 \uac83 \ucc98\ub7fc, Awaitable Interface\ub294 3\uac00\uc9c0 \ud568\uc218\ub97c \uad6c\ud604\ud574\uc57c\ub9cc \ud55c\ub2e4. await_ready await_suspend await_resume \uc774\ub4e4\uc740 \uba64\ubc84\ud568\uc218\uc77c \uc218\ub3c4 \uc788\uace0, \uc77c\ubc18 \ud568\uc218\ub85c\ub3c4 \uac00\ub2a5\ud558\ub2e4. future<T> \uc5ed\uc2dc \uc774 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. \ub2ec\ub9ac\ub9d0\ud574, future<T> \uac00 co_await \uc758 \uc778\uc790\uac00 \ub420\uc218\ub3c4 \uc788\ub2e4\ub294 \uc758\ubbf8\ub2e4. \uc544\ub798 \ucf54\ub4dc\ucc98\ub7fc \ube44\ud6a8\uc728\uc801\uc77c \uc218\ub3c4 \uc788\uaca0\uc9c0\ub9cc, \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c \uac04\ub2e8\ud55c \uc624\ubc84\ub85c\ub4dc \ub9cc\uc73c\ub85c\ub3c4 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4\ub294 \uc7a5\uc810\uc774 \uc788\ub2e4. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // future\ub97c await\ud558\uba74 \uc2a4\ub808\ub4dc\ub97c \ub9cc\ub4e4\uc5b4\uc11c detach\uc2dc\ud0a8\ub2e4. // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std \ucef4\ud30c\uc77c\ub7ec \ucabd\uc740 \uc5b4\ub5a8\uae4c? \uc774 \ucf54\ub4dc\uac00 \uc5b4\ub5bb\uac8c \ubc14\ub014\uae4c? \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810 \u00b6 operator co_await = Syntactic Sugar + Resumable Function co_await \ub294 \ud45c\ud604\uc744 \ubc14\uafbc\ub2e4\ub294 \uc810\uc5d0\uc11c \uacb0\uad6d syntatic sugar\ub77c\uace0 \ud560\uc218 \uc788\ub2e4. \uc778\uc790\ud0c0\uc785\uc774 Awaitable Interface\ub97c \uc54c\ub9de\uac8c \uad6c\ud604\ud558\uae30\ub9cc \ud55c\ub2e4\uba74, \ucef4\ud30c\uc77c\ub7ec\ub294 \ucf54\ub4dc\ub97c \ubc14\uafd4\uc900\ub2e4. \uc880\uc804\uc758 \uc608\uc81c\ucf54\ub4dc\ub97c \uc880\ub354 \uc790\uc138\ud558\uac8c \uc0b4\ud3b4\ubcf4\uaca0\ub2e4. // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // `co_await`\ud0a4\uc6cc\ub4dc\uac00 \uc788\uc73c\ubbc0\ub85c \uc7ac\uac1c\ud568\uc218\uac00 \ub41c\ub2e4. future < void > test () { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4... __frame * context ; // ... // Awaitable interface\ub97c \uad6c\ud604\ud558\uc600\ub2e4. // \uc815\ud655\ud558\uac8c\ub294 \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc774 \ubcc0\uc218\uac00 \uc0dd\uc131\ub420 \uac83\uc774\ub2e4. awaiter aw = operator co_await ( 1 ms ); // \uac12\uc774 \uc900\ube44\ub418\uc5b4 \uc788\ub294\uac00? if ( aw . await_ready () == false ) // await_ready(aw); { // \uac12\uc774 \uc5c6\uc73c\ubbc0\ub85c \uae30\ub2e4\ub824\uc57c \ud55c\ub2e4. // \ud568\uc218 \ud504\ub808\uc784\uc744 `coroutine_handle` \ud0c0\uc785\uc73c\ub85c \uac10\uc2f8\uace0... coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); // suspend \ud568\uc218\ub97c \ud638\ucd9c\ud55c\ub2e4. aw . await_suspend ( resume_cb ); // \uc911\ub2e8 \uc9c1\uc804\uc5d0 \ud504\ub808\uc784\uc5d0 Index\ub97c \ubcc0\uacbd\ud558\uace0...... __suspend_resume_point_1 : // \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc774 \uc5ec\uae30\uc5d0 \uc788\uc73c\ubbc0\ub85c ready\uc5d0\uc11c true\ub97c \ubc18\ud658\ud558\uba74 // \ud568\uc218\ub294 \uba48\ucd94\uc9c0 \uc54a\uace0 \uc9c4\ud589\ud55c\ub2e4. } // await_resume\uc774 \ubc18\ud658\ud0c0\uc785\uc774 \uc788\ub2e4\uba74 value\uc5d0 \uac12\uc744 \uc800\uc7a5\ud55c\ub2e4. // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } \uc774\uc81c \uc778\ud130\ud398\uc774\uc2a4\uc758 \uac01 \ud568\uc218\ub4e4\uc5d0 \ub300\ud574\uc11c \uc9da\uc5b4\ubcfc \uc218 \uc788\uaca0\ub2e4. await_ready : \"\uc9c0\uae08 \uac12\uc774 \uc788\ub294\uac00?\" await_ready \uc740 \ubd84\uae30\uc810\uc774 \ub41c\ub2e4. \uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\uba74 await_resume \uc5d0\uc11c \ubc14\ub85c \uadf8 \uac12\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uaca0\uc9c0\ub9cc, \uadf8\ub807\uc9c0 \uc54a\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc73c\ub85c \ubd84\uae30\ud574 \ud568\uc218\ub97c \uc911\ub2e8\ud55c\ub2e4. await_ready \ud568\uc218\uac00 \uc5b8\uc81c\ub098 true \ub97c \ubc18\ud658\ud55c\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc740 Dead Code\uac00 \ub418\uace0, \ucef4\ud30c\uc77c\ub7ec\uc758 \ucd5c\uc801\ud654 \uacfc\uc815\uc5d0\uc11c \uc18c\uba78\ub420 \uac83\uc774\ub2e4. \uc774 \uacbd\uc6b0\ub294 \ud504\ub808\uc784\uae4c\uc9c0 \uc18c\uba78\ub418\uace0 \uc77c\ubc18 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \ucd5c\uc801\ud654\ub420 \uc218 \ub3c4 \uc788\ub2e4. \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8 \ubc94\uc704\ub85c \uc9c4\uc785\ud558\uba74, \ud568\uc218 \ud504\ub808\uc784\uc744 coroutine_handle<> \ub85c \uac10\uc2f8\uc11c \uc778\uc790\ub85c \ub118\uaca8\uc900\ub2e4. coroutine_handle<>::from_address \ud568\uc218\uac00 \uc774 \uc5ed\ud560\uc744 \ud574\uc900\ub2e4. await_suspend : \"\uace7 \ub8e8\ud2f4\uc774 \uba48\ucda5\ub2c8\ub2e4. \ud574\uc57c\ud560 \uc77c\uc774\ub77c\ub3c4?\" await_suspend \ub294 coroutine_handle<> \uc744 \uc778\uc790\ub85c \ubc1b\uace0, \uc911\ub2e8\ud558\uae30 \uc804\uc5d0 \ud574\uc57c\ud560 \ub0b4\uc6a9\uc744 \ucf54\ub4dc\ub85c \ub07c\uc6cc\ub123\uc744 \uc218 \uc788\uac8c \ub41c\ub2e4. // Windows Thread Pool Timer\ub97c \uc0ac\uc6a9\ud55c\ub2e4. // Timer Callback\uc5d0 \ud504\ub808\uc784\uc758 \uc8fc\uc18c\ub97c \ub118\uaca8\uc8fc\ub294 \ubc29\uc2dd\uc73c\ub85c \ucf54\ub8e8\ud2f4\uc744 \ub9c8\ubb34\ub9ac\ud55c\ub2e4. class awaiter { bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // \ud3ec\uc778\ud130\ub85c \ubcc0\ud658\ud55c\ub2e4. resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Windows Thread Pool\uc5d0 \uc788\ub294 \uc2a4\ub808\ub4dc\uac00 Callback\uc744 \ud638\ucd9c\ud558\uac8c \ub41c\ub2e4. // \uc790\uc5f0\uc2a4\ub7fd\uac8c Resumer Thread\uac00 \ub41c\ub2e4. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // \ud504\ub808\uc784 \ud3ec\uc778\ud130\ub97c \ud578\ub4e4\ub85c \ubcc0\ud658, \uadf8\ub9ac\uace0 \uc7ac\uac1c. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"\uc5ec\uae30 \uacb0\uacfc\uac12\uacfc \uc2e4\ud589 \ud750\ub984\uc774\uc694.\" \ud568\uc218\ub97c \uc7ac\uac1c\ud558\uba74 \uc911\ub2e8\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\uba70, \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8\ubc94\uc704\ub97c \ubc97\uc5b4\ub098 await_resume \uc744 \ud638\ucd9c\ud55c\ub2e4. \uc911\ub2e8\ud558\ub358 \uc2dc\uc810\uc5d0\ub294 \uacb0\uacfc\uac12\uc774 \uc5c6\uc5c8\uae30 \ub54c\ubb38\uc5d0, \ud568\uc218\uac00 \uc7ac\uac1c\ub418\uc5c8\ub2e4\ub294 \uac83\uc740 \uacb0\uacfc\uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\ub294 \uc758\ubbf8\uac00 \ub41c\ub2e4. \ub9cc\uc57d void\ub77c\uba74 co_await \uc544\ub798\uc5d0 \uc788\ub294 \ucf54\ub4dc\ub97c \uc2e4\ud589\ud574\uc57c \ud558\ub3c4\ub85d \uc2e4\ud589\ud750\ub984\uc744 \ub118\uaca8\uc900\ub2e4\ub294 \uc758\ubbf8\uc77c \uac83\uc774\ub2e4. co_await Tricks \u00b6 Kenny Kerr \uc640 James Mcnellis \ub294 \uc774\ub7f0 \uba54\ucee4\ub2c8\uc998\uc744 \uc0ac\uc6a9\ud55c \ud2b8\ub9ad\ub4e4\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\ub294\ub370, \uc2dc\uac04\uc801 \uc5ec\uc720\uac00 \uc788\ub2e4\uba74 \uaf2d \ubcf4\uae30\ub97c \uad8c\ud55c\ub2e4. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Async Generator \u00b6 \uac1c\ub150 \u00b6 Async Generator = Awaitable iterator + Resumable function Generator\uc640 \ub9e4\uc6b0 \uc720\uc0ac\ud558\uc9c0\ub9cc, \ub2e4\ub978\uc810\uc740 \ubc18\ubcf5\uc790\uac00 Awaitable\ud558\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub2ec\ub9ac \ub9d0\ud558\uba74, Awaitable iterator \uc5d0 \ub300\ud574\uc11c for co_await \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. Kirkshoop\uc758 \uc124\uba85 \uc774 \ub3c4\uc6c0\uc774 \ub420 \uac83\uc774\ub2e4. Example \u00b6 \uc774 \uae30\ub2a5\uc744 \uc81c\ub300\ub85c \uc0ac\uc6a9\ud574\ubcf4\uc9c0 \ubabb\ud574 \uc81c\ub300\ub85c \ub41c \uc608\uc81c\ub97c \uc801\uc9c0 \ubabb\ud588\ub2e4. \ud558\uc9c0\ub9cc \uc9c0\uae08\uae4c\uc9c0\uc758 \uc608\uc81c\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810\uc5d0 \ub300\ud55c \uc124\uba85\uc744 \uc77d\uc5c8\ub2e4\uba74 \uc774 \ucf54\ub4dc\uac00 \uc774\ud574\ub420 \uac83\uc774\ub77c \uc0dd\uac01\ud55c\ub2e4. // \ubb34\ud55c\ud55c \uc815\uc218 \uc218\uc5f4 async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await \uad6c\ubb38 for co_await ( int v : infinite ()) { // `v`\ub85c \ubb34\uc5b8\uac00 \ud55c\ub2e4... } } iterator \uac00 Awaitable\ud558\ub2e4\uace0 \ud588\ub294\ub370, \uc774\ub294 usecase \uac00 \ub2e4\uc74c\uacfc \uac19\ub2e4\ub294 \uc758\ubbf8\ub2e4. std :: future < void > usecase () { // \uae30\ub2e4\ub9b4 \uc218 \uc788\ub294 \ubc18\ubcf5\uc790 : awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `begin()` \uc5d0 // `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. iter != gen . end (); // `end()` \ub294 nullptr\uc640 \uac19\ub2e4. co_await ++ iter ) // `operator++()`\uc5d0 `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. { int v = * iter ; // ... } } generator<T> \uc608\uc81c\uc640 \ub2e4\ub978 \uc810\uc740 \ud568\uc218\uac00 2\uac1c \uc9c0\uc810\uc5d0\uc11c \ubc18\ubcf5\uc790\ub97c \uae30\ub2e4\ub9ac\uace0 \uc788\ub2e4\ub294 \uac83\uc774\ub2e4. \ub530\ub77c\uc11c begin() \uacfc operator++() \ub294 usecase \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8/\uc7ac\uac1c\uc9c0\uc810\uc774 \ub41c\ub2e4. \uc5ec\uae30\uc120 value_type \uc740 \uae30\ubcf8 \uc790\ub8cc\ud615 int \ub77c\uc11c \uc5b4\ub824\uc6b4 \ucf54\ub4dc\ub294 \uc5c6\ub2e4. Awaitable iterator \ucf54\ub4dc\ub294 \ub2e4\uc74c\ucc98\ub7fc \ub9cc\ub4e4 \uc218 \uc788\ub2e4. \uc0ac\uc2e4 std::experimental::generator<T> \uc758 \ucf54\ub4dc\ub97c \uac70\uc758 \uadf8\ub300\ub85c \uac00\uc838\uc628 \uac83\uc774\ub2e4. // generator\uac00 \uc544\ub2c8\ub77c iterator\uac00 \ube44\ub3d9\uae30\ub85c \ub3d9\uc791\ud55c\ub2e4.(awaitable). template < typename T > struct async_generator { struct promise_type ; // Awaitable interface\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // \uc9c0\uae08\uc740 \uc608\uc81c\uc774\ubbc0\ub85c, \uc5b8\uc81c\ub098 \uac12\uc774 \uc874\uc7ac\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\uc9c0\ub3c4 \uc54a\ub294\ub2e4. bool await_ready () const { return true ; } // \uc911\ub2e8\ud558\uc9c0 \uc54a\uc73c\ubbc0\ub85c \ub0b4\uc6a9\uc774 \uc5c6\ub2e4. void await_suspend ( coroutine_handle <> hcoro ) {} // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc774 `co_await`\uc5d0\uac8c \uc804\ub2ec\ub41c\ub2e4. iterator await_resume () const { return * this ; } }; // iterator }; // async_generator \uba64\ubc84\ud568\uc218 3\uac1c\ub97c iterator \uc5d0 \ucd94\uac00\ud568\uc73c\ub85c\uc368, awaitable \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uc600\uace0 for co_await \uad6c\ubb38\uc744 \uc4f8 \uc218 \uc788\uc5c8\ub2e4. \ud558\uc9c0\ub9cc Awaitable Interface \ub2e8\ub77d\uc5d0\uc11c \uc124\uba85\ud588\ub4ef \uad73\uc774 \uba64\ubc84\ud568\uc218\uc77c \ud544\uc694\ub294 \uc5c6\ub2e4. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } \uc774\ub807\uac8c \ubcf4\uc870 \ud568\uc218\ub97c \uc815\uc758\ud558\ub294 \uac83 \ub9cc\uc73c\ub85c\ub3c4 \uae30\uc874\uc5d0 \uc0ac\uc6a9\ud558\ub358 iterator \ud0c0\uc785\ub4e4\uc744 \uc7ac\ud65c\uc6a9\ud560 \uc218 \uc788\ub2e4. \ub05d! \ud6c4\uae30 \u00b6 MSVC \ucf54\ub8e8\ud2f4\uc758 \uac1c\ub150\uacfc \ucf54\ub4dc\ub97c \ud6d1\uc5b4\ubd24\ub2e4. \uadf8\uac8c \uc804\ubd80\ub2e4. \ubd80\ub514 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uae30\ub97c. \uc0ac\uc2e4 \uc774 Feature\uc758 \ub514\uc2a4\uc5b4\uc148\ube14\ub9ac \uacb0\uacfc\uc5d0 \ub300\ud574\uc11c\ub3c4 \uc4f0\uace0 \uc2f6\uc5c8\ub294\ub370, \uad00\ub828\ud574\uc11c\ub294 \uc544\uc9c1 \ucd08\ubcf4\uc790 \ub2e8\uacc4\ub77c \uc81c\ub300\ub85c \uc124\uba85\ud560 \uc218\uac00 \uc5c6\uc5c8\ub2e4. \uae30\ud68c\uac00 \ub41c\ub2e4\uba74 \ucc28\ud6c4\uc5d0 \ub2e4\uc2dc \uae00\uc744 \uc368\ubcf4\uace0 \uc2f6\ub2e4. \ub098\uc911\uc5d0 \ub354\uc6b1 \uac1c\uc120\ud560 \uae30\ud68c\uac00 \uc788\uae30\ub97c. :D","title":"MSVC Coroutine \uc54c\uc544\ubcf4\uae30"},{"location":"articles/exploring-msvc-coroutine-kor/#msvc-coroutine","text":"Written in 2017/03/02 English","title":"MSVC Coroutine \uc54c\uc544\ubcf4\uae30"},{"location":"articles/exploring-msvc-coroutine-kor/#_1","text":"","title":"\ucc38\uace0\uc790\ub8cc"},{"location":"articles/exploring-msvc-coroutine-kor/#_2","text":"N3858 N3977 N4134 N4402","title":"\uc81c\uc548\uc11c"},{"location":"articles/exploring-msvc-coroutine-kor/#visual-c-team-blog","text":"Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++","title":"Visual C++ Team Blog"},{"location":"articles/exploring-msvc-coroutine-kor/#_3","text":"CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\"","title":"\uc601\uc0c1"},{"location":"articles/exploring-msvc-coroutine-kor/#github","text":"kirkshoop/ await","title":"GitHub \uc800\uc7a5\uc18c"},{"location":"articles/exploring-msvc-coroutine-kor/#_4","text":"\uc6b0\uc120 MSVC\uc758 Coroutine\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 3\uac00\uc9c0\uac00 \ud544\uc694\ud558\ub2e4. Visual Studio 2015 Up3 \ud639\uc740 \uadf8 \uc774\uc0c1\uc758 \uac1c\ubc1c\ud658\uacbd /await : \ucef4\ud30c\uc77c \uc635\uc158 <experimental/*> : \uc18c\uc2a4 \ucf54\ub4dc\uc5d0 \ub123\uc744 \ud5e4\ub354\ud30c\uc77c","title":"\uc8fc\uc758\uc0ac\ud56d"},{"location":"articles/exploring-msvc-coroutine-kor/#_5","text":"\uadf8\ub798\uc11c, \ucf54\ub8e8\ud2f4\uc774 \ub300\uccb4 \ubb54\uac00\uc694?","title":"\uc815\uc758"},{"location":"articles/exploring-msvc-coroutine-kor/#_6","text":"\uae30\ubcf8\uc801\uc73c\ub85c, \ud504\ub85c\uc2dc\uc800\uc758 \ud638\ucd9c\uc740 goto \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uadf8\ub7f0\ub370 \uc5b4\ub514\ub85c goto \ud55c\ub2e4\ub294 \uac83\uc77c\uae4c? \ub2e4\uc74c\uc5d0 \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc77c \uac83\uc774\ub2e4. \uba85\ub839\uc5b4\ub294 \ub8e8\ud2f4\uacfc \ud504\ub85c\uadf8\ub7a8\uc758 \uc77c\ubd80\uc774\uae30\ub3c4 \ud55c\ub370, \uc7a0\uc2dc \uc5ec\uae30\uc11c \ud55c\ubc88 \uc9da\uc5b4\ubcf4\uaca0\ub2e4. [\ud504\ub85c\uadf8\ub7a8]\uc740 \uc77c\ub828\uc758 [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub4e4\ub85c \ubcfc \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc5ec\uae30\uc11c [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub780, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c \uac83\uc774\uc5b4\uc57c \ud558\uba70, \ud504\ub85c\uadf8\ub7a8\uc744 \uc218\ud589\ud558\ub294 \uae30\uacc4\uc758 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\uc758 \uac12\ub4e4\uc744 \ud569\uce5c \uac83(composition)\uc774\ub2e4. \ubcf4\ud1b5\uc740 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac \uac12\uc758 \uc870\ud569\uc774 \uc720\ud55c\ud558\ub3c4\ub85d \uc124\uacc4\ud55c\ub2e4. Program State = Environment X Memory (\ud568\uc218\uc801 \ud569\uc131 : Cartesian Product) \uc5ec\uae30\uc11c \uba85\ub839\uc5b4\ub4e4\uc740 \uc0c1\ud0dc\uac04\uc758 \uc804\uc774(transition)\ub77c\uace0 \uc815\uc758\ud560 \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc774\ub7ec\ud55c \uc804\uc774\ub4e4\uc744 \uc21c\uc11c\ub300\ub85c \ubb36\uc740 \uac83\uc744 \ub8e8\ud2f4(routine)\uc774\ub77c\uace0 \ud55c\ub2e4. Instruction : \uba85\ub839, \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\uc758 \uc804\uc774 Routine : \uc21c\uc11c\uac00 \uc788\ub294 \uba85\ub839 \ubb36\uc74c \uadf8\ub7ec\uba74 \uc774\uc81c \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc73c\ub85c \ub118\uc5b4\uac08 \ucc28\ub840\ub2e4.","title":"\uace0\uc2dd(\u53e4\u5f0f) : \uae30\uacc4\ub808\ubca8\uc5d0\uc11c \uc0dd\uac01\ud558\uae30"},{"location":"articles/exploring-msvc-coroutine-kor/#_7","text":"\ubaa8\ub4e0 \ud504\ub85c\uadf8\ub798\uba38\ub4e4\uc740 \ucf54\ub4dc\uc5d0 \ub300\ud574\uc11c \uc790\uc2e0\ub9cc\uc758 \uc2ec\uc0c1(Mental Model)\uc744 \uac16\uae30 \ub9c8\ub828\uc774\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc758 \uba58\ud0c8 \ubaa8\ub378 \ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uace0\uc790 \ud55c\ub2e4.","title":"\uad00\uacc4"},{"location":"articles/exploring-msvc-coroutine-kor/#caller-callee","text":"\uc11c\ube0c\ub8e8\ud2f4\uc758 \uad00\uacc4\ub294 \uc77c\ubc29\uc801\uc774\ub2e4. \ud638\ucd9c\uc790(Caller)\ub294 \uc774\ubbf8 \uc5b4\ub5a4 \uc0c1\ud0dc\uc5d0 \uc788\uace0(\uc774\uc804 \uc870\uac74), \uc5b4\ub5a4 \ub8e8\ud2f4\uc774 \ud544\uc694\ud55c\uc9c0, \ud639\uc740 \ud638\ucd9c\ud560\uc9c0 \uc54c\uace0\uc788\ub2e4. \ud53c\ud638\ucd9c\uc790(Callee)\ub294 \ud504\ub85c\uadf8\ub798\uba38\uc758 \uc758\ub3c4\ub300\ub85c \uc815\uc758\ub41c \ucf54\ub4dc\ub97c \uac00\uc9c0\uace0 \uc788\uace0, \ud638\ucd9c\uc790\uc640 \ubb34\uad00\ud558\uac8c \uba85\ub839\ub4e4\uc744 \uc218\ud589\ud55c\ub2e4. \uc5ec\uae30\uc11c \ubd80\uc218\ud6a8\uacfc(Side-effect)\uac00 \uc788\uc744 \uc218 \uc788\uc9c0\ub9cc, \uadf8\uac74 \uba85\ub839\uc758 \ub0b4\uc6a9\uc5d0 \ub300\ud55c \uac83\uc774\uace0 \uad00\uacc4\uc640\ub294 \ubb34\uad00\ud558\ub2e4.","title":"\uc11c\ube0c\ub8e8\ud2f4 : Caller-Callee"},{"location":"articles/exploring-msvc-coroutine-kor/#activator-activator","text":"\ubcf4\ud1b5 \ucf54\ub8e8\ud2f4\uc740 cooperative\ud55c routine\uc774\ub2e4. \uc774 \ub54c\ubb38\uc5d0 \ud611\ub825\ub8e8\ud2f4\uc774\ub77c\uace0 \ubc88\uc5ed\ub418\uae30\ub3c4 \ud558\ub294\ub370, \uc774\ub7f0 \uc774\ub984\uc740 \ucf54\ub8e8\ud2f4\uc774 \ubb35\uc2dc\uc801\uc73c\ub85c \ub2e4\ub978 \ub8e8\ud2f4\uacfc \ud568\uaed8 \ub3d9\uc791\ud558\ub3c4\ub85d \uc124\uacc4\ub41c \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ub098\uc628 \ub8e8\ud2f4\ub4e4\uc740 \uc11c\ub85c\ub97c \ud65c\uc131\ud654\ud55c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \ud638\ucd9c\uc790(Invoker)\uc640 \uc7ac\uac1c\ub8e8\ud2f4(Resuming routine)\uc5d0 \uc758\ud574\uc11c \ud65c\uc131\ud654 \ub41c\ub2e4. \uc5ed\uc73c\ub85c \uc911\ub2e8\ud558\uac70\ub098 \ubc18\ud658\ud568\uc73c\ub85c\uc368 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\ub978 \ub8e8\ud2f4\uc744 \uc7ac\uac1c\uc2dc\ud0a4\uac8c \ub41c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c\ub294 Suspend/Return\ub4f1\uc73c\ub85c \uad6c\ubd84\ud558\uc600\uc73c\ub098, \ud65c\uc131\ud654\ub77c\ub294 \uac83\uc740 \uc2e4\uc81c\ub85c\ub294 \ub8e8\ud2f4 \uc548\uc758 \uc784\uc758\uc758 \uc9c0\uc810(\uba85\ub839\uc5b4)\uc73c\ub85c \uc810\ud504( goto / jmp )\ud558\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\ub294 \uac83\uc774 \ub2e4\ub978 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uac83\uacfc \uac19\uc744 \uc218 \uc788\uc73c\uba70, \ud568\uc218\uc758 \uc885\ub8cc\uc640 \uc911\ub2e8\uc758 \ucc28\uc774 \ub610\ud55c \ud655\uc5f0\ud558\uc9c0 \uc54a\uc744 \uc218 \uc788\ub2e4. \uc810\ud504\uc758 \ubaa9\ud45c\uc8fc\uc18c\uac00 \ub8e8\ud2f4\uc758 \ub3c4\uc785\ubd80(\ud568\uc218\ub77c\uba74 prologue)\ub77c\uba74 \ud65c\uc131\ud654\ub294 Invocation ( call )\uc774 \ub41c\ub2e4. \ubaa9\ud45c\uc8fc\uc18c\uac00 \ud504\ub85c\uc2dc\uc800\uc758 \ud55c\uac00\uc6b4\ub370 \uc704\uce58\ud558\uba74, \uc774\ub294 Activation ( resume )\uc774 \ub41c\ub2e4. Invocation: \ud638\ucd9c. \ub8e8\ud2f4\uc758 \uc2dc\uc791\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Activation: \ud65c\uc131\ud654. \ub8e8\ud2f4\uc758 \uc784\uc758 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc, \ucf54\ub8e8\ud2f4\uc740 \uc774\uc804 \uc0c1\ud0dc(Pre-condition)\uc640 \uc774\ud6c4 \uc0c1\ud0dc(Post-condition)\uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. \uc774 \ub9d0\uc740, \ucf54\ub8e8\ud2f4 \ub610\ud55c \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\ub97c \uc5b4\ub5bb\uac8c \uc804\uc774\uc2dc\ud0ac\uc9c0 \uc815\uc758\ub418\uc5b4\uc57c \ud55c\ub2e4\ub294 \ub9d0\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc11c\ube0c\ub8e8\ud2f4\uacfc\ub294 \ub2e4\ub974\uac8c, \ucf54\ub8e8\ud2f4\uc740 \uc790\uc2e0\ub9cc\uc758 \uc0c1\ud0dc\ub97c \uc720\uc9c0\ud55c \ucc44\ub85c \ub2e4\ub978 \uc8fc\uc18c\ub85c goto \ud560 \uc218 \uc788\ub2e4. \uc774\ub97c Suspension ( yield )\uc774\ub77c \ud55c\ub2e4. \uacbd\uc6b0\uc5d0 \ub530\ub77c \uc774\ub294 \ud504\ub85c\uc2dc\uc800\uc758 \uc885\ub8cc, \ud639\uc740 \ud568\uc218\uc758 \ubc18\ud658( return )\uc774 \ub420\uc218 \uc788\uc73c\uba70, \uadf8\ub54c\ub294 \uc885\ub8cc(finalization)\ub97c \ud568\uaed8 \uc218\ud589\ud558\uac8c \ub41c\ub2e4. Suspension: \uc911\ub2e8. \uc885\ub8cc\uc791\uc5c5 \uc5c6\uc774 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Finalization: \uc885\ub8cc. \ub8e8\ud2f4\uacfc \uad00\ub828\ub41c \uc790\uc6d0\ub4e4\uc744 \uc815\ub9ac(\ud30c\uad34)\ud558\uace0 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83","title":"\ucf54\ub8e8\ud2f4 : Activator-Activator"},{"location":"articles/exploring-msvc-coroutine-kor/#_8","text":"\uc694\ucee8\ub300 \uac00\uc7a5 \ud070 \ucc28\uc774\uc810\uc740, \ucf54\ub8e8\ud2f4\uc740 \uc11c\ube0c\ub8e8\ud2f4\ubcf4\ub2e4 \ub354 \ub9ce\uc740 \ub3d9\uc791(Operation)\uc744 \uc9c0\uc6d0\ud55c\ub2e4\ub294 \uac83\uc774\ub2e4. \uc774\uac83\uc774 \ub3c4\ub110\ub4dc \ud06c\ub204\uc2a4\uac00 The Art of Computer Programming \uc5d0\uc11c \uc774\ub807\uac8c \uc11c\uc220\ud55c \uc774\uc720\ub2e4. \"Subroutines are special cases of ... coroutines\" - Donald Knuth \uc774\ub97c \ud45c\ub85c \uc815\ub9ac\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4. Operation Subroutine Coroutine Invoke o o \ud504\ub85c\uc2dc\uc800\ub97c \uc2dc\uc791\ud55c\ub2e4 Activate x o \ud2b9\uc815\ud55c \uc9c0\uc810\uc73c\ub85c \uc9c4\uc785\ud55c\ub2e4 Suspend x o Control Flow\ub97c \uba48\ucd98\ub2e4. Finalize o o \uc9c0\uc5ed\ubcc0\uc218, \ub9e4\uac1c\ubcc0\uc218\ub4e4\uc744 \uc815\ub9ac\ud558\uace0 return \ud55c\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc774 \uc81c\ud55c\ub418\uc5c8\uc9c0\ub9cc \uad00\uacc4\uc5d0 \ub300\ud55c \uace0\ub824\uac00 \ud544\uc694\uc5c6\uc5b4 \uac04\ub2e8\ud558\ub2e4. \ubc18\uba74\uc5d0 \ucf54\ub8e8\ud2f4\uc740 \ub354 \ub9ce\uc740 \ub3d9\uc791\uc774 \uac00\ub2a5\ud558\uc9c0\ub9cc, \uc911\ub2e8\uacfc \ud65c\uc131\ud654\uc5d0 \ub300\ud55c(\uadf8\ub9ac\uace0 \uac01\uac01\uc758 Pre/Post condition\uc5d0 \ub300\ud55c) \uc815\uc758\uac00 \ud544\uc694\ud558\ubbc0\ub85c \ub354 \ubcf5\uc7a1\ud558\ub2e4. Routine: \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub97c \ubcc0\ud654\uc2dc\ud0a4\ub294 \uba85\ub839\uc5b4 \ubb36\uc74c. \uadf8 \ub0b4\uc6a9\uc740 \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c\ub2e4. Subroutine: \ub3d9\uc791 2\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Finalize Coroutine: \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Activate Suspend Finalize","title":"\ucc28\uc774\uc810?"},{"location":"articles/exploring-msvc-coroutine-kor/#_9","text":"\ud06c\ub204\uc2a4\ub294 \uc774\ub7f0 \uac1c\ub150\uc774 \uc5b4\ub5bb\uac8c \ucf54\ub4dc\ub85c \ud45c\ud604\ub418\ub294\uc9c0 \uadf8\uc758 \ucc45\uc5d0\uc11c \uc124\uba85\ud558\uace0 \uc788\ub2e4. \ub2e4\uc74c \ucf54\ub4dc\ub294 The Art of Computer Programming\uc5d0 \uc788\ub294 MIX \uba85\ub839\uc5b4\ub4e4\uc744 \uadf8\ub300\ub85c \uc62e\uaca8\uc628 \uac83\uc73c\ub85c, \ubaa8\ub450 \uc774\ud574\ud560 \ud544\uc694\ub294 \uc5c6\ub2e4. \uc624\ub298\ub0a0\uc758 call / return \uad6c\uc870\uc640 \ub2ec\ub9ac, \ubaa8\ub4e0 \ub3d9\uc791\ub4e4\uc774 JMP \uba85\ub839\uc5b4\ub85c \uc218\ud589\ub418\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ud575\uc2ec\uc740 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\uc218\uc758 \uc9c4\uc785\uc810\uacfc \uc911\ub2e8\uc810\uc744 \uac00\uc9c4\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub354\ud574\uc11c, \ubb35\uc2dc\uc801\uc778 \uc0c1\ud0dc(\ub808\uc9c0\uc2a4\ud130 \ud639\uc740 \uba54\ubaa8\ub9ac)\ub97c \uac00\uc9c8 \uc218\ub3c4 \uc788\ub2e4. // MIX \uc608\uc81c, \uc8fc\uc11d\uc744 \ubcc0\uacbd\ud558\uc600\uc74c // \uc790\uc138\ud55c \ub0b4\uc6a9\uc740 The Art of Computer Programming 1.4.2 \uc5d0 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF .","title":"\uc608\uc81c"},{"location":"articles/exploring-msvc-coroutine-kor/#_10","text":"","title":"\ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378"},{"location":"articles/exploring-msvc-coroutine-kor/#_11","text":"\"\ud568\uc815\uc774\ub2e4!\" - \uc544\ud06c\ubc14 \uc81c\ub3c5 \uc624\ub298\ub0a0 \ub110\ub9ac \uc0ac\uc6a9\ub418\uace0 \uc788\ub294 High-level \uc5b8\uc5b4\ub4e4\uc740 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c\ub2e4. \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc740 \uc5b8\uc5b4\uc801\uc73c\ub85c \uba85\ud655\ud558\uac8c \uc815\uc758\ub418\uace0, \uc790\ub3d9\uc73c\ub85c \uad00\ub9ac\ub418\uba70, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uac1c\uc785\ud558\uc9c0 \uc54a\uc544\ub3c4 \ubb38\uc81c\uc5c6\uc774 \ub3d9\uc791\ud55c\ub2e4. \uad6c\uc870\uc801 \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc774\ub7f0 \uc2a4\ud0dd\uc911\uc2ec\uc758 \ubaa8\ub378\uacfc \uc870\ud654\ub97c \uc774\ub8e8\uc5b4\uc654\ub2e4. \uc774 \ubaa8\ub378\uc5d0\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uc218\ud559\uc801\uc73c\ub85c \ud45c\ud604\ud560 \uc218 \uc788\ub294 \uc218\uc2dd\ud2b8\ub9ac \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uacb0\uacfc\uc801\uc73c\ub85c main \ud568\uc218\ub294 \uc885\ub8cc\ud558\uba70, \uc801\ub2f9\ud55c \uacb0\uacfc\uac12\uc744 \ubc18\ud658\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ud45c\ud604\ud55c \uac83 \ucc98\ub7fc, \ud2b8\ub9ac\ud615 \ubaa8\ub378\uc5d0\uc11c \ud568\uc218\uc758 \ud750\ub984\uc740 \uc774 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uae4a\uc774-\uc6b0\uc120 \uc21c\uc11c\ub85c \uc21c\ud68c\ud558\uba70, \uc791\uc131\ud558\ub294 \uc2dc\uc810\ubd80\ud130 \uac01 \uad6c\ubb38(Statement)\ub4e4\uc758 \uc2e4\ud589 \uc21c\uc11c\uac00 \uc815\ud574\uc9c4\ub2e4. \uadf8\ub9bc\uc5d0\uc11c B \uad6c\ubb38\uc5d0 \ub3c4\ub2ec\ud558\uae30 \uc704\ud574\uc120, A \uad6c\ubb38\uc744 \ub9c8\uccd0\uc57c \ud55c\ub2e4. \uc774 \uc2dc\uc810\uc5d0 \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub294 \uad6c\ubb38 A\uc758 \uc601\ud5a5\uc744 \ubc1b\uc544 \ubcc0\ud558\uac8c \ub418\uba70, \ub808\uc9c0\uc2a4\ud130/\uba54\ubaa8\ub9ac\ub294 \uc801\ub2f9\ud55c \uac12\uc744 \uac00\uc9c0\uace0 \uc788\uc744 \uac83\uc774\ub2e4.","title":"\uc2a4\ud0dd\uc774\ub2e4!"},{"location":"articles/exploring-msvc-coroutine-kor/#blocking","text":"\uc5ec\uae30\uc11c \ubb38\uc81c\uac00 \ub418\ub294 \uac83\uc740 \uc758\uc874\uc131\uc774\ub2e4. \ud2b8\ub9ac \ubaa8\ub378\uc740 \uc218\ud559\uc744 \ud504\ub85c\uadf8\ub7a8\uc73c\ub85c \uc62e\uaca8\ub193\uc740 \uac83\uc774\ub2e4. \uc218\uc2dd\uc5d0 \ud544\uc694\ud55c \ubaa8\ub4e0 \uac12\uc774 \uba54\ubaa8\ub9ac\uc5d0 \uc788\ub2e4\uba74, \ucef4\ud4e8\ud130\ub294 \uacc4\uc0b0\uc744 \ub3c4\uc911\uc5d0 \uba48\ucd94\uc9c0 \uc54a\uace0\ub3c4 \uc218\ud589\ud560 \uc218 \uc788\ub2e4. \ub2e4\ub9cc \uc6b0\ub9ac\uc758 \uc790\uc6d0\uc740 \ubb34\ud55c\ud558\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \ud504\ub85c\uadf8\ub7a8 \ud750\ub984\uc774 \uc2dc\uc791\ub418\ub294 \uc2dc\uc810\uc5d0 \ubaa8\ub4e0 \uac12\ub4e4\uc744 \uc900\ube44\ud560 \uc218\ub294 \uc5c6\ub2e4. \ub2e4\ub978 \uc6d0\uc778\ub3c4 \uc788\ub2e4. \uac12\uc774 \ubb3c\ub9ac\uc801\uc73c\ub85c \uac81\ub098 \uba3c \uacf3\uc5d0 \uc788\uc5b4\uc11c \uc2e4\uc2dc\uac04 \ud1b5\uc2e0\uc744 \ud574\uc57c\ud560\uc218\ub3c4 \uc788\ub2e4. \uacb0\uad6d \uc6b0\ub9ac\ub294 \ud544\uc5f0\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc744 \ud574\uc57c\ud55c\ub2e4. \uc804\ud1b5\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc740 \ub290\ub9ac\uace0, \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uba48\ucdb0\uc57c \ud588\ub2e4. \ubc18\uc751\uc131(Responsiveness)\uc744 \uc704\ud574 \ud504\ub85c\uadf8\ub7a8\uc774 \uba48\ucd94\uae30\ub97c \uc6d0\ud558\uc9c0 \uc54a\ub294\ub2e4\uba74 \uc5b4\ub5a8\uae4c? Non-blocking\uacfc \ube44\ub3d9\uae30(Asynchronous) \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc5ec\uae30\uc11c \uc2dc\uc791\ud55c\ub2e4. \uc774\ub294 \uc694\uc57d\ud558\uc790\uba74 \uae30\uc874\uc758 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uc77c\ubc18\ud654 \ud574\uc11c, \ud558\ub098\uc758 \uadf8\ub798\ud504\ub97c \uc791\uc131\ud558\ub294 \uac83\uc774\ub2e4. \uc0c1\ud0dc\uae30\uacc4\uac00 \uadf8\ub798\ud504\ub85c \ud45c\ud604\ub41c\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud574\ubcf4\ub77c. \uc774 \uadf8\ub798\ud504 \ubaa8\ub378\uc5d0\uc120 \ud504\ub85c\uadf8\ub7a8\uc740 \uc0c1\ud0dc\ub4e4\ub85c \uc774\ub8e8\uc5b4\uc9c4 \uadf8\ub798\ud504 \uac00 \ub41c\ub2e4. \uadf8\ub9ac\uace0 \ud504\ub85c\uc138\uc11c\ub4e4\uc740 \uc774 \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\ub294 \uac83\uc774\ub2e4. \ud504\ub85c\uc138\uc11c\ub294 \uc6b4\uc601\uccb4\uc81c\uc758 \ud504\ub85c\uc138\uc2a4, \uc2a4\ub808\ub4dc\uc77c \uc218 \uc788\ub2e4. \ub610\ub294 \uc5b8\uc5b4\ub808\ubca8\uc5d0\uc11c \uc9c0\uc6d0\ud558\ub294 \ucd94\uc0c1\ud654, \uac00\ub839 Erlang\uc758 \ud504\ub85c\uc138\uc2a4\ub098 Go\uc5b8\uc5b4\uc758 Goroutine\uc77c \uc218 \uc788\ub2e4. \ub354 \uc774\uc0c1\uc758 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc0dd\ub7b5\ud55c\ub2e4.","title":"Blocking"},{"location":"articles/exploring-msvc-coroutine-kor/#_12","text":"\ud575\uc2ec\uc740, \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\uba74\uc11c \uc5b4\ub5bb\uac8c \uc815\uc810\uac04\uc758 \ubb38\ub9e5(context) \uad50\ud658\uc774 \uac00\ub2a5\ud560\uae4c \ud558\ub294 \uac83\uc774\ub2e4. \uc6b0\uc120 \uc11c\ube0c\ub8e8\ud2f4\uc740 return \uacfc \ub3d9\uc2dc\uc5d0 \ud30c\uad34\ub418\ubbc0\ub85c(\uc0ac\ub77c\uc9c0\ubbc0\ub85c) \uc774\uac83\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. \ub2ec\ub9ac \ub9d0\ud574 \uc11c\ube0c\ub8e8\ud2f4\uc740 \uc601\uc18d\uc131\uc774 \uc5c6\ub2e4. \uc774\ub294 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc774 \ub3d9\uc791\ud558\ub294 \ubc29\uc2dd\uc774\uc9c0\ub9cc, \ub3d9\uc2dc\uc5d0 \uc815\uc810(\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc)\uac04\uc758 \ubb38\ub9e5\uc804\ub2ec\uc744 \uc544\uc8fc \uc5b4\ub835\uac8c \ub9cc\ub4e4\uc5c8\ub2e4. \ucf5c\ubc31 \uc9c0\uc625 \ub3c4 \uacb0\uad6d\uc740 \ubb38\ub9e5\uc804\ub2ec\uc744 \ud558\uae30 \uc704\ud55c \uace0\uc721\uc9c0\ucc45\uc774\ub77c \ud560 \uc218 \uc788\ub2e4. \"\uc81c\uc784\uc2a4, \uc774 \ucf54\ub4dc\uc5d0\ub294 \ubc84\uadf8\uac00 \uc788\uc5b4\uc694. \uace0\uce60 \uc218 \uc788\uaca0\uc5b4\uc694?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); }","title":"\uc601\uc18d\uc131"},{"location":"articles/exploring-msvc-coroutine-kor/#_13","text":"\uc6b0\ub9ac\uc5d0\uac90 \uc601\uc18d\uc131 \uc788\ub294 \ud568\uc218\uac00 \ud544\uc694\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc(finalization)\ud558\uc9c0 \uc54a\uc73c\uba74\uc11c \uc911\ub2e8(suspend/yield)\uc774 \uac00\ub2a5\ud588\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud558\uba74, \ub2f5\uc740 \uba85\ud655\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc788\uc73c\uba74 \uc774 \ubb38\uc81c\ub97c \ud574\uacb0\ud560 \uc218 \uc788\uc744 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc5b4\ub85c \uad6c\ud604\ud558\ub358 \uac1c\ub150\uc744 \uc5b4\ub5bb\uac8c \uc2a4\ud0dd \uc138\uc0c1\uc73c\ub85c \uac00\uc838\uc62c \uc218 \uc788\uc744\uae4c? \uc9c8\ubb38\uc744 \ubc14\uafd4\ubcf4\uc790. \ubb34\uc5c7\uc774 \uc601\uc18d\uc131\uc744 \uac00\uc838\uc57c \ud558\ub294\uac00?: \ubb38\ub9e5 \ubb38\ub9e5\uc740 \ubb34\uc5c7\uc778\uac00?: \ub8e8\ud2f4\uc758 \uc0c1\ud0dc \uc0c1\ud0dc\ub294 \ubb34\uc5c7\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c0\ub294\uac00?: \ud658\uacbd & \uba54\ubaa8\ub9ac \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\ub294 \uc5b4\ub514\uc5d0 \uc704\uce58\ud558\ub294\uac00?: \ud568\uc218 \ud504\ub808\uc784(Function Frame) \uc815\ub9ac\ud558\uc790\uba74, \uc9c8\ubb38\uc740 \uc5b4\ub5bb\uac8c \ud568\uc218 \ud504\ub808\uc784\ub4e4\uc744 \uc601\uc18d\uc131\uc788\uac8c \ub9cc\ub4e4 \uac83\uc778\uac00 \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc124\uba85\uc740 \uc790\uc138\ud788 \uae30\uc220\ud558\uc9c0\ub294 \uc54a\uaca0\uc9c0\ub9cc, \uc790\uc138\ud55c \uc124\uba85\uc744 \uc6d0\ud55c\ub2e4\uba74 \uc774 \ud398\uc774\uc9c0 \ub97c \ucc38\uace0\ud558\ub77c.","title":"\uc811\uadfc\ubc95"},{"location":"articles/exploring-msvc-coroutine-kor/#_14","text":"\"\uc65c \uc740\ud589\uc744 \ud130\ub098\uc694?\" \"\ub3c8\uc774 \uac70\uae30\uc5d0 \uc788\uc796\uc544\uc694\" - \uc5b4\ub290 \uc740\ud589 \uac15\ub3c4","title":"\uc2a4\ud0dd \uc548? \ubc16!"},{"location":"articles/exploring-msvc-coroutine-kor/#stack-ful","text":"\uc5b8\uc5b4\ub9c8\ub2e4 \ub2e4\ub974\uaca0\uc9c0\ub9cc, C++\ub294 \ud568\uc218 \ud504\ub808\uc784\uc744 \uc2a4\ud0dd\uc5d0 \ubc30\uce58\ud55c\ub2e4. \uc774\ub7f0 \uc0c1\ud669\uc5d0\uc11c \ud504\ub808\uc784\uc744 \ubcf4\uc874\ud558\ub824\uba74, \ud504\ub808\uc784\uc744 \uadf8\ub300\ub85c \ubcf5\uc0ac\ud574\uc11c \uc5b4\ub518\uac00\uc5d0 \uc800\uc7a5\ud574\ub450\ub294 \uc218 \ubc16\uc5d0 \uc5c6\ub2e4. \ub2e4\ub978 \ubc29\ubc95\uc73c\ub85c\ub294 \uc801\ub2f9\ud55c \uacf5\uac04\uc744 \ub530\ub85c \uc608\uc57d\ud574\uc11c \ub300\uccb4 \uc2a4\ud0dd(side stack)\uc73c\ub85c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc774 \uc788\uc744 \uac83\uc774\ub2e4. \uc774 \ubd80\ubd84\uc740 \uc9c0\ub098\uce58\ub3c4\ub85d \ud558\uaca0\ub2e4. MSVC\ub294 \uc2a4\ud0dd \uc678 \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4.","title":"\uc2a4\ud0dd \ub0b4(Stack-ful) \ucf54\ub8e8\ud2f4 / \ubd84\ud560 \uc2a4\ud0dd"},{"location":"articles/exploring-msvc-coroutine-kor/#stack-less","text":"N3858 \uc81c\uc548\uc11c\uc5d0\ub294 \uc774\ub978\ubc14 '\ub2e4\uc2dc \uc2dc\uc791\ud558\ub294 \ud568\uc218'(Resumable Function, \uc774\ud558 \uc7ac\uac1c\ud568\uc218)\uc758 \uad6c\ud604\uac00\ub2a5\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uadf8 \ubc29\ubc95\ub860 \uc911 \ud558\ub098\ub294 \ud799(Heap)\uc5d0 \ud568\uc218\uc758 \ud65c\uc131 \ud504\ub808\uc784(Activation Frame)\uc744 \ud560\ub2f9\ud558\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud504\ub808\uc784\uc740 \ub2e8\uc21c\ud558\uac8c\ub294 \uad6c\uc870\uccb4\uc77c \ubfd0\uc774\ub2e4. \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791 4\uac1c\ub294 \uc5b4\ub5bb\uac8c \ub41c \uac83\uc77c\uae4c? \uc774\ub4e4\uc740 Compiler Intrinsic \ud615\ud0dc\ub85c MSVC\uac00 \uc790\uccb4\uc801\uc73c\ub85c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... \uadf8\ub7ec\ub2c8 \uc774 \ubd80\ubd84\uc5d0 \ub300\ud574\uc11c\ub294 \uc190\ub308 \uc218 \uc788\ub294 \ubd80\ubd84\uc774 \uc5c6\ub2e4. \ub354 \uc790\uc138\ud55c \uc124\uba85\uc774 \ud544\uc694\ud558\ub2e4\uba74 \ucc38\uace0\uc790\ub8cc\uc5d0\uc11c CppCon \ubc1c\ud45c\ub4e4\uc744 \uc2dc\uccad\ud558\uae30\ub97c \uad8c\ud55c\ub2e4. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block \uc774 intrinsic\ub4e4 \uc911 Frame\uacfc Block\ub4e4\uc758 \uc5ed\ud560\uc5d0 \ub300\ud574\uc11c \uba85\ud655\ud558\uc9c0 \uc54a\uc740 \ubd80\ubd84\uc774 \ub0a8\uc544\uc788\ub294 \uac83 \uac19\uc2b5\ub2c8\ub2e4. \uae30\ud68c\uac00 \ub418\uba74 \uc5c5\ub370\uc774\ud2b8 \ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.","title":"\uc2a4\ud0dd \uc678(Stack-less) \ucf54\ub8e8\ud2f4\uacfc \ud568\uc218 \ud504\ub808\uc784"},{"location":"articles/exploring-msvc-coroutine-kor/#the-c-coroutine-resumable-function","text":"\uc774 \uc2dc\uc810\uc5d0\uc11c \ub450 \uc6a9\uc5b4\ub97c \uc815\ub9ac\ud560 \ud544\uc694\uac00 \uc788\uc744 \uac83 \uac19\ub2e4. Coroutine : \uac1c\ub150 . \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Resumable Function : C++ \uc5b8\uc5b4\uc5d0\uc11c Coroutine\uc758 \uad6c\ud604 \ubc29\ubc95 \ucd94\uac00\ub85c \ub2e4\uc74c \ud45c\ub294 \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791\ub4e4\uc744 \uc5b4\ub5bb\uac8c \uc0ac\uc6a9\ud558\ub294\uc9c0 \uc815\ub9ac\ud55c \uac83\uc774\ub2e4. Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return","title":"The C++ Coroutine : Resumable Function"},{"location":"articles/exploring-msvc-coroutine-kor/#invoke","text":"\ud568\uc218 \ud638\ucd9c\uc5d0 \ub300\ud574\uc11c\ub294 \ubcc0\uacbd\uc0ac\ud56d\uc774 \uc5c6\ub2e4. \ud558\uc9c0\ub9cc \uc7ac\uac1c\ud568\uc218\ub294 std::future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4.","title":"\ud638\ucd9c(Invoke)"},{"location":"articles/exploring-msvc-coroutine-kor/#finalize","text":"\uc11c\ube0c\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ubc18\ud658\uc9c0\uc810\uc740 \uc775\ud788 \uc54c\ub824\uc9c4 return \ud0a4\uc6cc\ub4dc\ub97c \uc0ac\uc6a9\ud558\uba74 \ub41c\ub2e4. \ucf54\ub8e8\ud2f4\uc774\ub77c\uba74 co_return \ud0a4\uc6cc\ub4dc\uac00 \uc774 \uc5ed\ud560\uc744 \ub300\uc2e0\ud55c\ub2e4.","title":"\uc885\ub8cc(Finalize)"},{"location":"articles/exploring-msvc-coroutine-kor/#suspend","text":"\ud568\uc218\ub97c \uc911\ub2e8\ud558\uace0 Control Flow\ub97c \uc591\ubcf4\ud558\ub294 \ubc29\ubc95\uc740 co_yield expression\uacfc co_await \uc5f0\uc0b0\uc790\ub97c \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. \uc774 \ub458 \uc911 \ud558\ub098\ub77c\ub3c4 \uc0ac\uc6a9\ud558\uba74, \uadf8 \uc9c0\uc810\uc740 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc73c\ub85c \uc0ac\uc6a9\ub418\uba70 MSVC\ub294 \uadf8 \ud568\uc218\ub97c \uc7ac\uac1c\ud568\uc218\ub85c \ub9cc\ub4e4\uac8c \ub41c\ub2e4. (\ub354\ud574\uc11c co_return \uad6c\ubb38\ub3c4 \ud568\uc218 \ub0b4\uc5d0 \uc704\uce58\ud558\uba74 \uc7ac\uac1c\ud568\uc218\ub85c \uc778\uc2dd\ub41c\ub2e4.)","title":"\uc911\ub2e8(Suspend)"},{"location":"articles/exploring-msvc-coroutine-kor/#activate","text":"\uc911\ub2e8\ub41c \ud568\uc218\ub97c \ud65c\uc131\ud654 \ud560 \ub54c\ub294, coroutine_handle \uacfc \uba64\ubc84\ud568\uc218 .resume() \ub97c \uc0ac\uc6a9\ud55c\ub2e4. \uc774 \ud638\ucd9c\uc740 Compiler Intrinsic\uc778 _coro_resume \uc704\uc5d0 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc62c\ub9b0 \uac83\uc774\ub2e4.","title":"\ud65c\uc131\ud654(Activate)"},{"location":"articles/exploring-msvc-coroutine-kor/#code","text":"\uc608\uc81c \ucf54\ub4dc\uc640 \uad00\ub828\ud574 kirkshoop\uc758 \uc800\uc7a5\uc18c \uac00 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uc2b5\ub2c8\ub2e4. \ubbf8\ub9ac \uc694\uc57d\ud558\uc790\uba74, MSVC\uc758 \uc694\uad6c\uc0ac\ud56d\uc744 \ub530\ub974\uae30\ub9cc \ud55c\ub2e4\uba74 C++\uc5d0\uc11c\ub3c4 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. \uc81c\uc548\uc11c\uc758 \uc774\ub984\uc774 \uc7ac\uac1c (\ub530\ub77c\uc11c, \uc601\uc18d\uc131 \uc788\ub294) \ud568\uc218 \ub77c\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud558\ub77c. \uc7ac\uac1c\ud568\uc218\uc5d0\ub294 \uba87\uac00\uc9c0 \uc885\ub958\uac00 \uc788\ub294\ub370, \ud568\uc218\uc5d0 \uc5b4\ub5a4 \uc5ed\ud560\uc744 \ub9e1\uae30\uace0\uc790 \ud558\ub290\ub0d0\uc5d0 \ub530\ub77c \ub2ec\ub77c\uc9c4\ub2e4. \uadf8\ub7ec\uba74 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc694\uad6c\uc0ac\ud56d\uc774\ub780 \ubb34\uc5c7\uc77c\uae4c?","title":"Code"},{"location":"articles/exploring-msvc-coroutine-kor/#promise","text":"C++11\uc5d0 \ucd94\uac00\ub41c std::future<T> \uc640 std::promise<T> , \uadf8\ub9ac\uace0 \uc774 \ub450 \uc9dd\uad81\uc758 \uad00\uacc4\uc5d0 \ub300\ud574\uc11c \uc54c \uac83\uc774\ub77c \uc804\uc81c\ud558\uaca0\ub2e4. \uc77c\ubc18\uc801\uc73c\ub85c, future<T> \ub294 \" \ub098\uc911\uc5d0 \uac12\uc774\ub098 \uc608\uc678\ub97c \uc904\uac8c\"\ub77c\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. ( std::async \ub97c \ucc38\uace0\ud558\ub77c) \uadf8\ub9ac\uace0 \uac12/\uc608\uc678\ub294 promise<T> \ub97c \ud1b5\ud574\uc11c \uc804\ub2ec\ub41c\ub2e4. \uc774\ub294 \"\uacb0\uacfc\ub97c \uc900\ub2e4\ub294 \uc57d\uc18d \uc744 \uc9c0\ucf30\ub2e4.\"\ub77c\ub294 \uac83\uc774\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\uac00 future<T> \ub97c \ubc18\ud658\ud55c\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \ub9d0 \uadf8\ub300\ub85c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \uc2a4\uc2a4\ub85c \uc911\ub2e8\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0 \ud65c\uc131\ud654\ud55c \ub8e8\ud2f4 \uc785\uc7a5\uc5d0\uc11c\ub294 \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc\ud588\ub294\uc9c0 \uc54c \ubc29\ubc95\uc774 \uc5c6\ub2e4. \ubc18\ud658\uac12\uc774 \uc788\ub2e4\ub294 \uac83\uc744 \uc54c \uc218 \uc5c6\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud568\uc218\uc758 \uc2dc\uadf8\ub2c8\ucc98(Signature)\uc0c1\uc73c\ub85c\ub294, \ub098\uc911\uc5d0 \ub77c\ub294 \uc758\ubbf8\uac00 \ub2f4\uae34 \ud0c0\uc785 future \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud568\uc73c\ub85c\uc368 \uc77c\ubc18\uc801\uc778 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uace0 \uc788\ub2e4. \ub2e4\ub9cc \uae30\uc874\uacfc \ub2ec\ub9ac \uc5ec\uae30\uc11c\uc758 promise \ub294 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c\uac83\uc774\ub2e4. N4402 \ub294 \uc774 \ub0b4\uc6a9\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uc5b4\uc9f8\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uac8c \uc57d\uc18d\uc774 \ud544\uc694\ud55c \uac83\uc77c\uae4c? \uc774\ub294 \uc7ac\uac1c\ud568\uc218\uac00 \ucd94\uc0c1\ud654 \ud55c \uacb0\uacfc\ubb3c\uc774\uae30 \ub54c\ubb38\uc774\ub2e4. \uc2a4\ud0dd \uae30\ubc18\uc758 \ud658\uacbd\ub54c\ubb38\uc5d0, \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud558\uae30\ub294 \ud588\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc640 \uac19\uc774 1\ucc28\uc6d0\uc73c\ub85c \ubc30\uce58\ub41c(flat) \uad6c\ubb38\uad6c\uc870\ub294 \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 \uacb0\uad6d \ud799\uc5d0\uc11c \uc0b4\uc544\uc788\uc73c\uba70, \ud799 \uc601\uc5ed(\ud568\uc218 \ud504\ub808\uc784)\uc5d0\uc11c \uc2a4\ud0dd \uc601\uc5ed( future \ub610\ub294 awaitable)\uc73c\ub85c \uac12\uc744 \uc804\ub2ec\ud574\uc57c \ud558\uace0, \uc774 \uacfc\uc815\uc740 \uc77c\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4 \ub97c \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9c0\ub3c4\ub85d \ud55c \uac83\uc774\ub2e4. \ubb3c\ub860 \uc778\ud130\ud398\uc774\uc2a4\ub294 \ucef4\ud30c\uc77c\ub7ec\uc640 \ud504\ub85c\uadf8\ub798\uba38 \uc591\ucabd \ubaa8\ub450\ub97c \uc704\ud55c \uac83\uc774\ub2e4.","title":"Promise : \ucef4\ud30c\uc77c\ub7ec\uac00 \uc6d0\ud558\ub294 \uac83"},{"location":"articles/exploring-msvc-coroutine-kor/#resumable-promise-requirement","text":"\uc7ac\uac1c\ud568\uc218\uc758 Promise \uc694\uad6c\uc0ac\ud56d \uadf8 \uc778\ud130\ud398\uc774\uc2a4\uac00 \uc5b4\ub5bb\uac8c \uc4f0\uc774\ub294\uc9c0\ub294 \uc7a0\uc2dc \ud6c4 \uae30\uc220\ud558\uace0, \uadf8\uc5d0 \uc55e\uc11c N4402 \ubb38\uc11c\ub97c \uc0b4\ud3b4\ubcf4\uc790. \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub294 Promise \ud0c0\uc785\uc740 \uc544\ub798 \ud45c\uc5d0 \uc5f4\uac70\ub41c \uba64\ubc84\ud568\uc218\ub4e4\uc744 \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4. \uc81c\uc548\uc11c\ub97c \uc694\uc57d\ud55c \uac83\uc774\ubbc0\ub85c, \ubcf4\ub2e4 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc81c\uc548\uc11c\ub97c \ucc38\uace0\ud558\uae30 \ubc14\ub780\ub2e4. Expression Note P{} \uc774 \ud0c0\uc785\uc740 default constructible \ud574\uc57c\ud55c\ub2e4. p.get_return_object() \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc744 \uacb0\uc815\ud55c\ub2e4. future<T> \ud639\uc740 \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc774 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4. p.return_value(v) co_return \uad6c\ubb38. \uacb0\uacfc\uac12\uc73c\ub85c v \ub97c \uc804\ub2ec\ud558\uba70, \uadf8 \uac12\uc740 \ub098\uc911\uc5d0 \uc0ac\uc6a9(consume)\ub41c\ub2e4. p.return_value() co_return \uad6c\ubb38. void \ud0c0\uc785\uc5d0 \uc0ac\uc6a9\ub418\uba70, \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\uc744 \uc758\ubbf8\ud558\uae30\ub3c4 \ud55c\ub2e4. \uc7ac\uac1c\ud568\uc218\uac00 \uc885\ub8cc\ub420\ub54c \uc0ac\uc6a9\ub41c\ub2e4. \uc774 \ud568\uc218\uac00 \ud638\ucd9c\ub418\ub294 \uac83\uc740 \"\ub354\uc774\uc0c1 \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\"\uc744 \uc758\ubbf8\ud55c\ub2e4. p.set_exception(e) \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. Resumer \uce21\uc5d0\uc11c \uacb0\uacfc\uac12\uc744 \uc0ac\uc6a9\ud558\ub824\uace0 \ud560\ub54c throw \ub41c\ub2e4. p.yield_value(v) co_yield \ud45c\ud604\uc2dd. return_value(v) \uc640 \uc720\uc0ac\ud558\ub2e4. p.initial_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810(initial suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. p.final_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810(final suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. \uc5ec\uae30\uc11c \uc77c\ubd80 \ud568\uc218\ub4e4\uc740 coroutine_traits<T> \uc640 \uc5f0\uad00\ub418\uc5b4\uc788\ub294\ub370, \uc774\ud6c4\uc5d0 \uc774 \ud0c0\uc785\uc758 \uc720\ub3d9\uc131\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\uaca0\ub2e4. \uc774\uc81c C++ \ucf54\ub8e8\ud2f4\uc758 \uc0ac\uc6a9\ubc29\ubc95\uc73c\ub85c \ucd08\uc810\uc744 \uc62e\uaca8\ubcf4\uc790.","title":"Resumable Promise Requirement"},{"location":"articles/exploring-msvc-coroutine-kor/#generator","text":"","title":"Generator"},{"location":"articles/exploring-msvc-coroutine-kor/#_15","text":"Generator = Iterator + Resumable Function \ubc18\ubcf5\uc790\uac00 \ubcf4\uc774\ub294\uac00? generator<T> \ub294 \uac12\uc758 \uc218\uc5f4(sequence)\uc744 \ucd94\uc0c1\ud654 \ud55c \uac83\uc774\ub2e4. \uc774\ub54c \uac12\uc740 \uc7ac\uac1c\ud568\uc218\uc5d0 \uc758\ud574\uc11c \uc0dd\uc131\ub418\ub294\ub370, \uc7ac\uac1c\ud568\uc218\ub294 \uc0c8\ub85c \ud638\ucd9c\ub418\uba74 \ud568\uc218 \ud504\ub808\uc784\uc774 \ud799 \uc601\uc5ed\uc5d0 \uc720\uc9c0\ub418\ubbc0\ub85c, generator \ub9c8\ub2e4 \uace0\uc720\ud55c \ubb38\ub9e5\uc744 \uac00\uc9c0\uac8c \ub41c\ub2e4.","title":"\uac1c\ub150"},{"location":"articles/exploring-msvc-coroutine-kor/#example","text":"\ub2e4\uc74c \ucf54\ub4dc\ub294 N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator \ub97c \uc791\uc131\ud55c \uac83\uc774\ub2e4. #include <experimental/generator> // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc9c0\uc815(Set)\ud558\uace0 \uc911\ub2e8(Suspend)\ud55c\ub2e4. co_yield f1 ; // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uad6c\ud55c \ub4a4 Shift \ud55c\ub2e4. int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // \ub354\uc774\uc0c1 \uac12\uc744 \uc0dd\uc131\ud558\uc9c0 \uc54a\ub294\ub2e4. } void usecase () { // 10\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \ubc1b\ub294\ub2e4. for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc5b4\ub5bb\uac8c \uc774\uac8c \uac00\ub2a5\ud55c\uac78\uae4c? generator<T> \uc758 \uc815\uc758\ub97c \uc0b4\ud3b4\ubcf4\uc790.","title":"Example"},{"location":"articles/exploring-msvc-coroutine-kor/#detail","text":"\uac04\ub7b5\ud558\uac8c generator<T> \ub97c \uc62e\uaca8\uc654\ub2e4. iterator \uc640 promise_type \uc744 \uc9c0\uc6d0\ud558\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ub610\ud55c begin() / end() \ud568\uc218\ub85c Range-based for loop \ub97c \uc9c0\uc6d0\ud558\uace0 \uc788\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud578\ub4e4 coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc788\ub2e4\uba74 \uc7ac\uac1c\ud574\uc11c \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc788\ub2e4. if ( _Coro ) { _Coro . resume (); // \ud568\uc218\uac00 \ubc18\ud658\ub418\uc5c8\ub098? if ( _Coro . done ()) return { nullptr }; // return end(); } // \uc544\uc9c1 \ub05d\ub098\uc9c0 \uc54a\uc558\ub2e4. // \ub2e4\uc74c\uc5d0 \ub2e4\uc2dc resume\ud558\uc790... return { _Coro }; } iterator end () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc5c6\ub2e4\uba74, \uac12\uc744 \ub354 \uac00\uc838\uc62c \uc218 \uc5c6\ub2e4. return { nullptr }; } ~ generator () { // RAII : \ud568\uc218 \ud504\ub808\uc784\uc744 \ud30c\uad34\ud55c\ub2e4. if ( _Coro ) { _Coro . destroy (); } } }; \uc774\ub97c \ubc14\ud0d5\uc73c\ub85c \uc2e4\uc81c\ub85c\ub294 \uc774\ub7f0 \ucf54\ub4dc\uac00 \ub9cc\ub4e4\uc5b4\uc9c8 \uac83\uc774\ub2e4. void usecase () { // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int > gen = fibonacci ( 10 ); // `iter++`\ub294 delete\ub418\uc5c8\uc73c\ubbc0\ub85c \uc0ac\uc6a9\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc77c\ubc18\uc801\uc778 iterator-for \uad6c\ubb38\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. iterator \ub294 \uc5b4\ub5bb\uac8c \ub418\uc5b4\uc788\uc744\uae4c? template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // \ubc18\ubcf5\uc790 \uc778\ud130\ud398\uc774\uc2a4 struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // \ub2e4\uc74c\uc73c\ub85c \uc774\ub3d9\ud560\ub54c... iterator & operator ++ () { // \ud568\uc218\ub97c \uc7ac\uac1c\ud574\uc11c \uac12\uc744 yield\ud558\ub3c4\ub85d \ud55c\ub2e4. _Coro . resume (); // \ub9cc\uc57d \ud568\uc218\uac00 return\ud588\ub2e4\uba74, \uadf8 \ud578\ub4e4\uc740 generator\uac00 \uc18c\uba78\uc2dc\ud0ac \uac83\uc774\ub2e4. if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // MSVC\uc758 \ucf54\uba58\ud2b8\ub294, \uc694\uc57d\ud558\uc790\uba74, // \ud6c4\uc704\uc99d\uac00\uc2dd\uc740 iterator\ub97c \ub36e\uc5b4\uc4f8 \uc218 \uc788\uace0, // \uc774\ub85c\uc778\ud574 handle\uc774 nullptr\ub85c \ubc14\ub00c\uba74\uc11c // \ud568\uc218 \ud504\ub808\uc784 \ub0b4\uc5d0 \ub9c8\uc9c0\ub9c9 \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc5c6\ub2e4\ub294 \uac83\uc774\ub2e4. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // `promise`\uc5d0 \ud3ec\uc778\ud130\uac00 \uc788\ub2e4. \ud3ec\uc778\ud130\ub97c \ucc38\uc870\ud574 \ud504\ub808\uc784 \uc548\uc758 \uac12\uc744 \uac00\uc838\uc628\ub2e4. _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; \uc774 \ucf54\ub4dc\ub97c \ubcf4\uba74 \ubc18\ubcf5\uc790\uac00 \ud568\uc218\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc7ac\uac1c\ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 generator<T> \uc758 promise_type \uc744 \ud1b5\ud574\uc11c \uac12\uc744 \ud68d\ub4dd\ud55c\ub2e4. \uc774 \uacbd\uc6b0\ub294 usecase \ud568\uc218\uac00 generator \uc758 \ud638\ucd9c\uc790\uba74\uc11c \uc7ac\uac1c\uc790\uc778 \uac83\uc774\ub2e4.","title":"\uc2e4\uccb4(Detail)"},{"location":"articles/exploring-msvc-coroutine-kor/#_16","text":"\uc774\uc81c \ud575\uc2ec\uc774 \ub418\ub294 promise_type \uc744 \ubcfc \ucc28\ub840\ub2e4. \uae30\uc220\ub41c \uac83 \ubcf4\ub2e4 \ucf54\ub4dc\uac00 \uc880 \ub354 \uc788\uc9c0\ub9cc \ub2e8\uc21c\ud654 \ud558\uc600\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } \uc774 promise_type \uc740 \uc694\uad6c\uc0ac\ud56d \uc911\uc5d0\uc11c 4\uac1c\uc758 \uba64\ubc84\ud568\uc218\ub97c \ub9cc\uc871\ud55c\ub2e4. get_return_object , initial_suspend , final_suspend , \uadf8\ub9ac\uace0 yield_value \uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. co_yield \ub294 \"\uac12\uc744 \uc9c0\uc815\ud558\uace0 \uc911\ub2e8\ud558\ub77c\"\uc640 \uac19\uc740 \uc758\ubbf8\uc778\ub370, \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774\ub97c \uc774\ub807\uac8c \ubcc0\uacbd\ud55c\ub2e4. co_yield : co_await + p.yield_value(x) \ub530\ub77c\uc11c, co_yield \uc5d0 \uc778\uc790 \ud45c\ud604\uc2dd\uc774 \uc5c6\ub2e4\ub294 \uac83\uc740 \ubd88\uac00\ub2a5 \ud558\ub2e4. x \ub294 void \uac00 \ub420 \uc218 \uc5c6\uae30 \ub54c\ubb38\uc774\ub2e4. \uac19\uc740 \uc774\uc720\ub85c generator<void> \ub294 \ucef4\ud30c\uc77c \uc5d0\ub7ec\uac00 \ub418\uba70, \uc5f0\uc18d\ub41c \uac12\uc758 \ucd94\uc0c1\ud654\ub77c\ub294 \uc815\uc758\uc5d0\ub3c4 \uc704\ubc30\ub41c\ub2e4. \uc5c4\ubc00\ud788 \ub9d0\ud574 \uc5ec\uae30\uc11c co_await \ub294 suspend \ub97c \uc758\ubbf8\ud55c\ub2e4. \uc790\uc138\ud55c \uc124\uba85\uc740 \ud6c4\uc220\ud55c\ub2e4. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud45c\ud604\uc2dd\uc744 \uc544\ub798\uc640 \uac19\uc774 \ubc14\uafbc\ub2e4. // co_yield f1; p . yield_value ( f1 ); // \uac12\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc9c0\uc815\ud558\uace0 co_await suspend_always {}; // \uc911\ub2e8\ud55c\ub2e4. // ... } co_return ; // \ub354\uc774\uc0c1 \uac12\uc774 \uc5c6\ub2e4. } \uc774 \ucf54\ub4dc\uc5d0\ub294 promise_type p{} \uac19\uc740 \ubcc0\uc218 \uc120\uc5b8\uc774\ub098, \ub2e4\ub978 \ud568\uc218\ub4e4\uc758 \ud638\ucd9c\uc774 \uc5c6\ub2e4. \uadf8 \uc774\uc720\ub294 \ub2e4\uc74c \ub2e8\uc6d0\uc5d0\uc11c \ub2e4\ub8e8\uaca0\ub2e4.","title":"\ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810"},{"location":"articles/exploring-msvc-coroutine-kor/#resumable-function","text":"\uc7ac\uac1c \ud568\uc218 \uc774\ubc88\uc5d4 \uc880 \ub354 \uc0c1\ud5a5\uc2dd\uc73c\ub85c \uc54c\uc544\ubcf4\uc790. \uc608\uc81c\ucf54\ub4dc\ub294 Awaitable Concept\ub97c \uc774\ud574\ud55c \ub4a4\uc5d0 \ubd10\uc57c \ud55c\ub2e4.","title":"Resumable Function"},{"location":"articles/exploring-msvc-coroutine-kor/#_17","text":"Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> \ub294 \ub2e8\uc21c\ud55c \uc608\uc81c\uc600\ub2e4. generator \ub294 coroutine_handle \uc744 \uba64\ubc84\ubcc0\uc218\ub85c \uac00\uc9c0\uace0 \uc788\uc5c8\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ubb34\uc5c7\uc778\uc9c0 \uc0b4\ud3b4\ubd10\uc57c \ud55c\ub2e4. \uc0ac\uc2e4, coroutine_handle \uc758 \uc608\uc804 \uc774\ub984\uc740 resumable_handle \uc600\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 C++\uc0c1\uc5d0\uc11c \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud55c \uac83\uc774\ub77c\uace0 \uc124\uba85\ud588\ub294\ub370, coroutine_handle \ub294 \ub2ec\ub9ac \ub9d0\ud558\uba74 \uc7ac\uac1c\ud568\uc218\uc5d0 \ub300\ud55c \ud578\ub4e4(Resumable Function Handle)\uc774\ub2e4. Windows API\ub97c \uc0ac\uc6a9\ud574\ubcf8 \uacbd\ud5d8\uc774 \uc788\ub2e4\uba74 Handle \uc774 \uacb0\uad6d void* \ub77c\ub294 \uac83\uc744 \uc54c \uac83\uc774\ub2e4. \uc5ec\uae30\uc11c\ub3c4 \ub3d9\uc77c\ud558\ub2e4. \uc55e\uc11c \uc124\uba85\ud588\ub358 \uac83 \ucc98\ub7fc MSVC\ub294 \ud799 \uc601\uc5ed\uc5d0 \ud504\ub808\uc784\uc744 \ub3d9\uc801\ud560\ub2f9\ud558\uace0, \uac70\uae30\uc5d0 \uc57d\uac04\uc758 intrinsic\uc744 \ub354\ud558\ub294 \ud615\ud0dc\ub85c \uc2a4\ud0dd \uc678(stack-less) \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4. coroutine_handle \uc740 \uc774\ub4e4\uc744 \ud558\ub098\uc758 \ud0c0\uc785\uc73c\ub85c \ubb36\uc5b4\ub193\uc740 \uac83\uc774\ub2e4.","title":"\uac1c\ub150"},{"location":"articles/exploring-msvc-coroutine-kor/#_18","text":"\uadf8\ub7ec\uba74, Resumable Frame \uc740 \ub300\uccb4 \uc5b4\ub5bb\uac8c \uc0dd\uacbc\uc744\uae4c? \uc77c\ub2e8 \ud504\ub808\uc784\uc740 Head\uc640 Body\ub85c \ub098\ub25c\ub2e4. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Head // - Fn : \uc7ac\uac1c\ud560 \ub54c \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc758 \uc8fc\uc18c // - cdecl : \uc774 Convention\uc5d0\uc11c \ud568\uc218 \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 Caller \uac00 \ub2f4\ub2f9\ud55c\ub2e4. // - Index : Resumption point\uc758 \uc778\ub371\uc2a4 // 0\ubc88\uc740 \ud568\uc218\uac00 \uc885\ub8cc\ub41c(`done()`) \uacbd\uc6b0\uc5d0 \uc0ac\uc6a9\ud55c\ub2e4. // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Body \uc5d0\ub294... // - Promise \ud0c0\uc785 \uac1c\uccb4 // - \ud504\ub808\uc784\uc73c\ub85c \uc774\ub3d9\uc2dc\ud0a8 Arguments // - \ud568\uc218 Body // - \uc9c0\uc5ed/\uc784\uc2dc \ubcc0\uc218\ub4e4 // - Platform \uc804\uc6a9 // - \ub808\uc9c0\uc2a4\ud130 \ub4f1\ub4f1 // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : \uc774\ub984\ucc98\ub7fc _Resumable_frame_prefix \uac00 \ud568\uc218\ud504\ub808\uc784\uc758 \uc55e\ubd80\ubd84\uc774 \ub41c\ub2e4. MSVC \ub294 \uc774 \uacf5\uac04\uc5d0 sizeof(void *) * 2 (x64 \uc5d0\uc11c 16 \ubc14\uc774\ud2b8)\ub9cc\ud07c\uc758 \uace0\uc815\ub41c \ud06c\uae30\ub97c \uc0ac\uc6a9\ud55c\ub2e4. Fn : cdecl \ud638\ucd9c \uaddc\uc57d\uc73c\ub85c \uc120\uc5b8\ub418\uc5b4\uc788\ub2e4\ub294 \uc810\uc774 \ud2b9\uc774\ud55c\ub370, cdecl \uc5d0\uc11c \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 \ud638\ucd9c\uc790\uc758 \uc5ed\ud560\uc774\uba70, \ub530\ub77c\uc11c Fn \uc744 \ud638\ucd9c\ud558\ub294 \uac83\uc740 \uadf8 \uc2dc\uc810\uc758 \uc2a4\ud0dd\uacfc \ud568\uc218 \ud504\ub808\uc784\uc5d0 \uc601\ud5a5\uc744 \ubbf8\uce58\uc9c0 \uc54a\ub294\ub2e4. Index : \uc7ac\uac1c\ud568\uc218\ub294 \ub2e4\uc218\uc758 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\ub4e4\uc744 \uac00\uc9c0\uace0 \uc788\uace0, Index \ub294 \uac01 \uc9c0\uc810\ub4e4\ub85c switch \ud558\ub294\ub370 \uc0ac\uc6a9\ub41c\ub2e4. Flag : ??? \uc774\uac74 \ub300\uccb4 \ubb58\uae4c ??? Body : N4402\uc5d0 \ud568\uc218 \ud504\ub808\uc784\uc758 \uad6c\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. James McNellis\uc758 \ubc1c\ud45c\uc790\ub8cc\uc5d0 \uc758\ud558\uba74, \ucef4\ud30c\uc77c\ub7ec\uac00 \uc0dd\uc131\ud558\ub294 \ud504\ub808\uc784\uc740 \ub2e4\uc74c\uc744 \ud3ec\ud568\ud55c\ub2e4. \uc77c\ubc18\uc801\uc778 \uc2a4\ud0dd \ud504\ub808\uc784\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // `fibonacci` \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784(\uc608\uc2dc) struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci\ub294 `generator<int>`\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int >:: promise_type _p ; // \ud504\ub808\uc784\uc5d0 \uc778\uc790\ub97c \uc800\uc7a5\ud55c\ub2e4. int _n ; // fibonacci(n); int _f1 , _f2 ; // \uc9c0\uc5ed \ubcc0\uc218 int _i , _f3 ; // \uc784\uc2dc \ubcc0\uc218 // Platform \uc804\uc6a9 \uc800\uc7a5\uc18c // \ub808\uc9c0\uc2a4\ud130\ub098 \uc774\uac83\uc800\uac83... };","title":"\uc7ac\uac1c\ud568\uc218\uc758 \ud504\ub808\uc784"},{"location":"articles/exploring-msvc-coroutine-kor/#coroutine-traits","text":"p.get_return_object() \uc5d0 \ub300\ud574\uc11c \ub2e4\ub8e8\uc9c0 \uc54a\uc558\uc5c8\ub294\ub370, \uc5ec\uae30\uc11c \uac19\uc774 \ub2e4\ub8e8\uace0\uc790 \ud55c\ub2e4. \uba3c\uc800 coroutine_traits \ub97c \ub208\uc5ec\uaca8\ubd10\uc57c \ud55c\ub2e4. // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; \uad49\uc7a5\ud788 \ub2e8\uc21c\ud55c\ub370, coroutine_traits \uc774 \uc694\uad6c\ud558\ub294 \uac83\uc740 \uacb0\uad6d promise_type \ub97c \uad6c\ud604\ud558\ub77c\ub294 \uac83\uc774\ub2e4. \uc774\uc5d0 \ub300\ud55c \uac80\uc0ac\ub294 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uc774\ub8e8\uc5b4\uc9c0\uace0, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement \ub97c \ub9cc\uc871\uc2dc\ucf1c\uc57c \ud55c\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\ub294 future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \uc0ac\uc2e4 \uadf8\uac83\uc740 \ubd80\uc815\ud655\ud55c \uc124\uba85\uc774\uc5c8\ub2e4. coroutine_traits \ub97c \ub9cc\uc871\uc2dc\ud0a4\uae30\ub9cc \ud55c\ub2e4\uba74, \uadf8 \ud0c0\uc785\uc740 \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc774 \ub420 \uc218 \uc788\ub2e4. std::future<T> \ub97c \uc704\ud55c coroutine_traits \uc758 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 \ubc84\uc804\uc744 \uc62e\uaca8\uc654\ub2e4. generator<T> \uc758 \uacbd\uc6b0\ub294 \ub0b4\ubd80\uc5d0 promise_type \uc744 \uad6c\ud604\ud558\uace0 \uc788\uc5c8\ub294\ub370, \uc608\uc804\ubd80\ud130 \uc0ac\uc6a9\ud558\ub358 \ud0c0\uc785\ub4e4\uc774\ub098 \ucee4\uc2a4\ud140 \ud0c0\uc785\ub4e4\uc740 \uc774\ub7f0 \ud2b8\ub9ad\uc744 \uc0ac\uc6a9\ud574\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc720\uc5f0\ud558\uac8c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. // <future> \ud5e4\ub354 #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // `std::future<T>`\ub97c \uc704\ud55c \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // `future<_Ty>`\ub97c \ubc18\ud658\ud558\ub294 \uc7ac\uac1c\ud568\uc218\ub4e4\uc744 \uc704\ud55c \ud0c0\uc785\uc815\uc758 struct promise_type { // `std::promise<T>`\ub97c \uadf8\ub300\ub85c \uc0ac\uc6a9\ud55c\ub2e4. promise < _Ty > _MyPromise ; // \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc740 `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // `false`\uc77c \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool initial_suspend () const { return ( false ); } // `false`\uc77c \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool final_suspend () const { return ( false ); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif MSVC\ub294 co_await / co_yield / co_return \ud0a4\uc6cc\ub4dc \uc911 \ud558\ub098\ub97c \ud655\uc778\ud558\uba74, coroutine_traits \ub97c \uc0ac\uc6a9\ud574 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uac80\uc0ac\ub97c \uc218\ud589\ud560 \uc218 \uc788\ub3c4\ub85d \ucf54\ub4dc\ub974 \uc0dd\uc131\ud55c\ub2e4. MSVC\uac00 \ud558\ub294 \uc77c\uc744 \ud655\uc778\ud558\uae30 \uc704\ud574 fibonacci \uc608\uc81c\ub85c \ub2e4\uc2dc \uac00\ubcf4\uc790. \uc774 \ucf54\ub4dc\ub294 \ud2c0\ub9b0 \ud615\ud0dc\uc77c \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc815\ud655\ud55c \uba54\ucee4\ub2c8\uc998\uc744 \ud655\uc778\ud558\uac8c \ub418\uba74 \uac31\uc2e0\ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // \ubcc4\uce6d : \ubc18\ud658\ud0c0\uc785 using return_type = generator < int > ; // \ubc18\ud658\ud0c0\uc785\uc774 Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294\uac00? using traits = coroutine_traite < return_type > ; // \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud55c\ub2e4\uba74 \uc774 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4. // fibonacci \ud568\uc218\ub97c \uc704\ud55c \uac00\uc0c1\uc758 \ud504\ub808\uc784. \uc704\uc640 \ub3d9\uc77c\ud558\ub2e4. struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // \ud504\ub808\uc784\uc744 \ub3d9\uc801\uc73c\ub85c \ud560\ub2f9\ud55c\ub2e4. context(ctx)\ub77c\uace0 \ud558\uaca0\ub2e4. // \ud2b9\uc815\ud55c Allocator\ub97c \uc0ac\uc6a9\ud574 \ucee4\uc2a4\ud130\ub9c8\uc774\uc988 \ud560 \uc218\ub3c4 \uc788\uc9c0\ub9cc \uc5ec\uae30\uc120 \ub2e8\uc21c\ud788 new\ub85c \uc124\uba85\ud55c\ub2e4. __frame * ctx = new __frame { std :: move ( n )}; // \ubc18\ud658 \uac1c\uccb4\ub97c \uc0dd\uc131\ud55c\ub2e4. return_type __return = ctx -> _promise . get_return_object (); // true\uc77c \uacbd\uc6b0 \uc911\ub2e8, false\uc77c \uacbd\uc6b0 \uc9c4\ud589\ud55c\ub2e4. if ( ctx -> _promise . initial_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __initial_suspend_point : } // \uc0ac\uc6a9\uc790 \ucf54\ub4dc\ub294 \ud504\ub808\uc784\uc744 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ubcc0\uacbd\ub41c\ub2e4. // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // promise\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // `ctx->_prefix`\uc758 Index\ub97c \uc870\uc815\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4. // co_await suspend_always{}; __suspend_resume_point_1 : // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uacc4\uc0b0\ud558\uace0 Shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __final_suspend_point : } // \uc815\ub9ac\uc791\uc5c5... } \uc0dd\uac01\ubcf4\ub2e4 \ucef4\ud30c\uc77c\ub7ec\uac00 \ub9ce\uc740 \uc791\uc5c5\uc744, \ud558\uc9c0\ub9cc \uae30\uc874\uc5d0 \uc2a4\ud0dd \ud504\ub808\uc784\uc5d0 \ub300\ud574\uc11c \ud558\ub358\uac83\uacfc \uc720\uc0ac\ud55c \uc791\uc5c5\uc744 \ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\uc5c8\ub2e4. ctx \uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ud799\uc601\uc5ed\uc5d0 \uc704\uce58\ud55c \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc740 this \ud3ec\uc778\ud130\uc758 \uc0ac\uc6a9\uacfc \ub2e4\ub974\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \uc774\ub7f0 \ud504\ub808\uc784 \uae30\ubc18 \uad6c\ud604\uc758 \ube44\uc6a9\uc740 \ucd94\uac00\uc801\uc778 co_await \uad00\ub828 \ube44\uc6a9\uc774\uc678\uc5d0\ub294 \ubb34\uc2dc\ud560 \uc218 \uc788\ub294 \uc218\uc900\uc77c \uac83\uc774\ub2e4. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend;","title":"Coroutine Traits"},{"location":"articles/exploring-msvc-coroutine-kor/#_19","text":"co_return \uacfc co_yield \uc5d0 \ub300\ud574\uc11c generator<T> \uc608\uc81c\ub97c \ud1b5\ud574 \uc0b4\ud3b4\ubd24\ub2e4. Generator\ub294 \ubc18\ubcf5\uc790\uc640 \uc7ac\uac1c\ud568\uc218\ub97c \ud569\uce5c \uac83\uc774\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 coroutine_handle \uc744 \uc0ac\uc6a9\ud558\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\uc640 \ucef4\ud30c\uc77c\ub7ec Intrinsic\uc744 \ud569\uccd0\ub193\uc740 \uac83\uc774\ub2e4. \ud504\ub808\uc784 \uae30\ubc18\uc758 \uad6c\ud604\uc740 this \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ubcc0\uc218\ub97c \uc870\uc791\ud558\ub294 \uac83\uacfc \uc720\uc0ac\ud558\ub2e4. \ucef4\ud30c\uc77c \uc2dc\uac04(\uc815\uc801) \uac80\uc0ac\ub97c \uc704\ud574 coroutine_traits<T> \uac00 \uc0ac\uc6a9\ub41c\ub2e4. \uc774\ub97c \ud1b5\ud574 promise_type \uc744 \uad6c\ud604\ud558\ub3c4\ub85d \uac15\uc81c\ud558\uba70, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement\ub97c \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4. std::future<T> \uc758 \uacbd\uc6b0 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654\uac00 \uae30\ubcf8\uc801\uc73c\ub85c \uc9c0\uc6d0\ub41c\ub2e4.","title":"\uc7a0\uae50 \uc815\ub9ac"},{"location":"articles/exploring-msvc-coroutine-kor/#_20","text":"operator co_await = Syntactic Sugar + Resumable Function \uc7ac\uac1c\ud568\uc218\uc758 \ub9c8\uc9c0\ub9c9 \ud575\uc2ec\uc740 \ub2e8\ud56d \uc5f0\uc0b0\uc790 co_await \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ubb38\ub9e5\uc0c1\uc73c\ub85c, await\ub294 suspend\uc640 \uac19\uc740\uc758\ubbf8\ub2e4 . \uadf8\ub9ac\uace0 \uc774 \uc911\ub2e8 \ub54c\ubb38\uc5d0, \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \uc790\uc5f0\uc2a4\ub7fd\uac8c \ube44\ub3d9\uae30 \uac00 \ub41c\ub2e4. \uba58\ud0c8 \ubaa8\ub378 \uc0c1\uc5d0\uc11c \uc774\ub7f0 \ud2b9\uc131\uc740 \uaf64 \uc911\uc694\ud55c \uc810\uc778\ub370, C# \uc5b8\uc5b4\uc758 async & await \uae30\ub2a5\uacfc \uc720\uc0ac\ud558\ub2e4\uace0 \ubcfc \uc218 \uc788\ub2e4. C++ \uc138\uc0c1\uc5d0\uc11c \ub2e4\ub978\uc810\uc740, \ud504\ub85c\uadf8\ub798\uba38\uc758 \ucf54\ub4dc\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc9c0\uc6d0\uc744 \uc0ac\uc6a9\ud574\uc11c \uc218\ub3d9\uc73c\ub85c \uad00\ub9ac\ud560 \uc218 \uc788\ub2e4\ub294 \uc810\uc774\ub2e4.","title":"\"\uae30\ub2e4\ub9b4 \uc218 \uc788\ub2e4\"\ub294 \uac1c\ub150\uc5d0 \ub300\ud574\uc11c"},{"location":"articles/exploring-msvc-coroutine-kor/#example_1","text":"MSVC \ube14\ub85c\uadf8\uc758 \uc608\uc81c\ub97c \uac00\uc838\uc654\ub2e4. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // \uc5f0\uc0b0\uc790 \uc624\ubc84\ub85c\ub4dc // co_await \ub294 \uae30\ubcf8 \ud0c0\uc785(primitive type) \uc778\uc790\ub294 \ubc1b\uc9c0 \uc54a\ub294\ub2e4. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc120 \ud568\uc218 3\uac1c\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback\uc744 \uc218\ud589\ud558\ub294 Thread\uc5d0\uc11c Resume\ud55c\ub2e4. coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // \uc900\ube44\uac00 \uc548\ub418\uc5c8\uc73c\uba74 (`false`), `await_suspend`\ub97c \ud638\ucd9c\ud55c\ub2e4. // \uac12\uc774 \uc900\ube44\ub418\uc5c8\uc73c\uba74 (`true`), `await_resume`\ub97c \ubc14\ub85c \ud638\ucd9c\ud55c\ub2e4. bool await_ready () const { return duration . count () <= 0 ; } // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \ubb34\uc2dc\ub420 \uc218 \uc788\ub2e4. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // \ud0c0\uc774\uba38\ub97c \uc138\ud305\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4.... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // \uc7ac\uac1c\ub41c \ud6c4\uc5d0\ub294 T \ud0c0\uc785 \uac12\uc744 \ubc18\ud658\ud55c\ub2e4. // `void`\ub3c4 \uac00\ub2a5\ud558\ub2e4. void await_resume () {} }; return awaiter { duration }; } // \ucf54\ub8e8\ud2f4(\uc7ac\uac1c\ud568\uc218) future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // 1 \ubc00\ub9ac\ucd08\ub97c \uae30\ub2e4\ub9b0\ub2e4... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // \ud3c9\ubc94\ud55c \uc11c\ube0c\ub8e8\ud2f4 void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } \uc774 \ucf54\ub4dc\ub294 \ub300\ub7b5 \uc774\ub7f0 \uc2dd\uc73c\ub85c \uc9c4\ud589\ub41c\ub2e4.","title":"Example"},{"location":"articles/exploring-msvc-coroutine-kor/#_21","text":"co_await \ub294 \ub3d9\uc791\ud558\uae30 \uc704\ud574\uc11c \ud2b9\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc694\uad6c\ud55c\ub2e4. \uc704\uc5d0\uc11c \ubcf8 \uac83 \ucc98\ub7fc, Awaitable Interface\ub294 3\uac00\uc9c0 \ud568\uc218\ub97c \uad6c\ud604\ud574\uc57c\ub9cc \ud55c\ub2e4. await_ready await_suspend await_resume \uc774\ub4e4\uc740 \uba64\ubc84\ud568\uc218\uc77c \uc218\ub3c4 \uc788\uace0, \uc77c\ubc18 \ud568\uc218\ub85c\ub3c4 \uac00\ub2a5\ud558\ub2e4. future<T> \uc5ed\uc2dc \uc774 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. \ub2ec\ub9ac\ub9d0\ud574, future<T> \uac00 co_await \uc758 \uc778\uc790\uac00 \ub420\uc218\ub3c4 \uc788\ub2e4\ub294 \uc758\ubbf8\ub2e4. \uc544\ub798 \ucf54\ub4dc\ucc98\ub7fc \ube44\ud6a8\uc728\uc801\uc77c \uc218\ub3c4 \uc788\uaca0\uc9c0\ub9cc, \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c \uac04\ub2e8\ud55c \uc624\ubc84\ub85c\ub4dc \ub9cc\uc73c\ub85c\ub3c4 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4\ub294 \uc7a5\uc810\uc774 \uc788\ub2e4. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // future\ub97c await\ud558\uba74 \uc2a4\ub808\ub4dc\ub97c \ub9cc\ub4e4\uc5b4\uc11c detach\uc2dc\ud0a8\ub2e4. // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std \ucef4\ud30c\uc77c\ub7ec \ucabd\uc740 \uc5b4\ub5a8\uae4c? \uc774 \ucf54\ub4dc\uac00 \uc5b4\ub5bb\uac8c \ubc14\ub014\uae4c?","title":"\uae30\ub2e4\ub9ac\uae30 \uc704\ud55c \uc778\ud130\ud398\uc774\uc2a4"},{"location":"articles/exploring-msvc-coroutine-kor/#_22","text":"operator co_await = Syntactic Sugar + Resumable Function co_await \ub294 \ud45c\ud604\uc744 \ubc14\uafbc\ub2e4\ub294 \uc810\uc5d0\uc11c \uacb0\uad6d syntatic sugar\ub77c\uace0 \ud560\uc218 \uc788\ub2e4. \uc778\uc790\ud0c0\uc785\uc774 Awaitable Interface\ub97c \uc54c\ub9de\uac8c \uad6c\ud604\ud558\uae30\ub9cc \ud55c\ub2e4\uba74, \ucef4\ud30c\uc77c\ub7ec\ub294 \ucf54\ub4dc\ub97c \ubc14\uafd4\uc900\ub2e4. \uc880\uc804\uc758 \uc608\uc81c\ucf54\ub4dc\ub97c \uc880\ub354 \uc790\uc138\ud558\uac8c \uc0b4\ud3b4\ubcf4\uaca0\ub2e4. // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // `co_await`\ud0a4\uc6cc\ub4dc\uac00 \uc788\uc73c\ubbc0\ub85c \uc7ac\uac1c\ud568\uc218\uac00 \ub41c\ub2e4. future < void > test () { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4... __frame * context ; // ... // Awaitable interface\ub97c \uad6c\ud604\ud558\uc600\ub2e4. // \uc815\ud655\ud558\uac8c\ub294 \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc774 \ubcc0\uc218\uac00 \uc0dd\uc131\ub420 \uac83\uc774\ub2e4. awaiter aw = operator co_await ( 1 ms ); // \uac12\uc774 \uc900\ube44\ub418\uc5b4 \uc788\ub294\uac00? if ( aw . await_ready () == false ) // await_ready(aw); { // \uac12\uc774 \uc5c6\uc73c\ubbc0\ub85c \uae30\ub2e4\ub824\uc57c \ud55c\ub2e4. // \ud568\uc218 \ud504\ub808\uc784\uc744 `coroutine_handle` \ud0c0\uc785\uc73c\ub85c \uac10\uc2f8\uace0... coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); // suspend \ud568\uc218\ub97c \ud638\ucd9c\ud55c\ub2e4. aw . await_suspend ( resume_cb ); // \uc911\ub2e8 \uc9c1\uc804\uc5d0 \ud504\ub808\uc784\uc5d0 Index\ub97c \ubcc0\uacbd\ud558\uace0...... __suspend_resume_point_1 : // \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc774 \uc5ec\uae30\uc5d0 \uc788\uc73c\ubbc0\ub85c ready\uc5d0\uc11c true\ub97c \ubc18\ud658\ud558\uba74 // \ud568\uc218\ub294 \uba48\ucd94\uc9c0 \uc54a\uace0 \uc9c4\ud589\ud55c\ub2e4. } // await_resume\uc774 \ubc18\ud658\ud0c0\uc785\uc774 \uc788\ub2e4\uba74 value\uc5d0 \uac12\uc744 \uc800\uc7a5\ud55c\ub2e4. // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } \uc774\uc81c \uc778\ud130\ud398\uc774\uc2a4\uc758 \uac01 \ud568\uc218\ub4e4\uc5d0 \ub300\ud574\uc11c \uc9da\uc5b4\ubcfc \uc218 \uc788\uaca0\ub2e4. await_ready : \"\uc9c0\uae08 \uac12\uc774 \uc788\ub294\uac00?\" await_ready \uc740 \ubd84\uae30\uc810\uc774 \ub41c\ub2e4. \uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\uba74 await_resume \uc5d0\uc11c \ubc14\ub85c \uadf8 \uac12\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uaca0\uc9c0\ub9cc, \uadf8\ub807\uc9c0 \uc54a\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc73c\ub85c \ubd84\uae30\ud574 \ud568\uc218\ub97c \uc911\ub2e8\ud55c\ub2e4. await_ready \ud568\uc218\uac00 \uc5b8\uc81c\ub098 true \ub97c \ubc18\ud658\ud55c\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc740 Dead Code\uac00 \ub418\uace0, \ucef4\ud30c\uc77c\ub7ec\uc758 \ucd5c\uc801\ud654 \uacfc\uc815\uc5d0\uc11c \uc18c\uba78\ub420 \uac83\uc774\ub2e4. \uc774 \uacbd\uc6b0\ub294 \ud504\ub808\uc784\uae4c\uc9c0 \uc18c\uba78\ub418\uace0 \uc77c\ubc18 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \ucd5c\uc801\ud654\ub420 \uc218 \ub3c4 \uc788\ub2e4. \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8 \ubc94\uc704\ub85c \uc9c4\uc785\ud558\uba74, \ud568\uc218 \ud504\ub808\uc784\uc744 coroutine_handle<> \ub85c \uac10\uc2f8\uc11c \uc778\uc790\ub85c \ub118\uaca8\uc900\ub2e4. coroutine_handle<>::from_address \ud568\uc218\uac00 \uc774 \uc5ed\ud560\uc744 \ud574\uc900\ub2e4. await_suspend : \"\uace7 \ub8e8\ud2f4\uc774 \uba48\ucda5\ub2c8\ub2e4. \ud574\uc57c\ud560 \uc77c\uc774\ub77c\ub3c4?\" await_suspend \ub294 coroutine_handle<> \uc744 \uc778\uc790\ub85c \ubc1b\uace0, \uc911\ub2e8\ud558\uae30 \uc804\uc5d0 \ud574\uc57c\ud560 \ub0b4\uc6a9\uc744 \ucf54\ub4dc\ub85c \ub07c\uc6cc\ub123\uc744 \uc218 \uc788\uac8c \ub41c\ub2e4. // Windows Thread Pool Timer\ub97c \uc0ac\uc6a9\ud55c\ub2e4. // Timer Callback\uc5d0 \ud504\ub808\uc784\uc758 \uc8fc\uc18c\ub97c \ub118\uaca8\uc8fc\ub294 \ubc29\uc2dd\uc73c\ub85c \ucf54\ub8e8\ud2f4\uc744 \ub9c8\ubb34\ub9ac\ud55c\ub2e4. class awaiter { bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // \ud3ec\uc778\ud130\ub85c \ubcc0\ud658\ud55c\ub2e4. resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Windows Thread Pool\uc5d0 \uc788\ub294 \uc2a4\ub808\ub4dc\uac00 Callback\uc744 \ud638\ucd9c\ud558\uac8c \ub41c\ub2e4. // \uc790\uc5f0\uc2a4\ub7fd\uac8c Resumer Thread\uac00 \ub41c\ub2e4. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // \ud504\ub808\uc784 \ud3ec\uc778\ud130\ub97c \ud578\ub4e4\ub85c \ubcc0\ud658, \uadf8\ub9ac\uace0 \uc7ac\uac1c. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"\uc5ec\uae30 \uacb0\uacfc\uac12\uacfc \uc2e4\ud589 \ud750\ub984\uc774\uc694.\" \ud568\uc218\ub97c \uc7ac\uac1c\ud558\uba74 \uc911\ub2e8\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\uba70, \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8\ubc94\uc704\ub97c \ubc97\uc5b4\ub098 await_resume \uc744 \ud638\ucd9c\ud55c\ub2e4. \uc911\ub2e8\ud558\ub358 \uc2dc\uc810\uc5d0\ub294 \uacb0\uacfc\uac12\uc774 \uc5c6\uc5c8\uae30 \ub54c\ubb38\uc5d0, \ud568\uc218\uac00 \uc7ac\uac1c\ub418\uc5c8\ub2e4\ub294 \uac83\uc740 \uacb0\uacfc\uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\ub294 \uc758\ubbf8\uac00 \ub41c\ub2e4. \ub9cc\uc57d void\ub77c\uba74 co_await \uc544\ub798\uc5d0 \uc788\ub294 \ucf54\ub4dc\ub97c \uc2e4\ud589\ud574\uc57c \ud558\ub3c4\ub85d \uc2e4\ud589\ud750\ub984\uc744 \ub118\uaca8\uc900\ub2e4\ub294 \uc758\ubbf8\uc77c \uac83\uc774\ub2e4.","title":"\ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810"},{"location":"articles/exploring-msvc-coroutine-kor/#co_await-tricks","text":"Kenny Kerr \uc640 James Mcnellis \ub294 \uc774\ub7f0 \uba54\ucee4\ub2c8\uc998\uc744 \uc0ac\uc6a9\ud55c \ud2b8\ub9ad\ub4e4\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\ub294\ub370, \uc2dc\uac04\uc801 \uc5ec\uc720\uac00 \uc788\ub2e4\uba74 \uaf2d \ubcf4\uae30\ub97c \uad8c\ud55c\ub2e4. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"co_await Tricks"},{"location":"articles/exploring-msvc-coroutine-kor/#async-generator","text":"","title":"Async Generator"},{"location":"articles/exploring-msvc-coroutine-kor/#_23","text":"Async Generator = Awaitable iterator + Resumable function Generator\uc640 \ub9e4\uc6b0 \uc720\uc0ac\ud558\uc9c0\ub9cc, \ub2e4\ub978\uc810\uc740 \ubc18\ubcf5\uc790\uac00 Awaitable\ud558\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub2ec\ub9ac \ub9d0\ud558\uba74, Awaitable iterator \uc5d0 \ub300\ud574\uc11c for co_await \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. Kirkshoop\uc758 \uc124\uba85 \uc774 \ub3c4\uc6c0\uc774 \ub420 \uac83\uc774\ub2e4.","title":"\uac1c\ub150"},{"location":"articles/exploring-msvc-coroutine-kor/#example_2","text":"\uc774 \uae30\ub2a5\uc744 \uc81c\ub300\ub85c \uc0ac\uc6a9\ud574\ubcf4\uc9c0 \ubabb\ud574 \uc81c\ub300\ub85c \ub41c \uc608\uc81c\ub97c \uc801\uc9c0 \ubabb\ud588\ub2e4. \ud558\uc9c0\ub9cc \uc9c0\uae08\uae4c\uc9c0\uc758 \uc608\uc81c\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810\uc5d0 \ub300\ud55c \uc124\uba85\uc744 \uc77d\uc5c8\ub2e4\uba74 \uc774 \ucf54\ub4dc\uac00 \uc774\ud574\ub420 \uac83\uc774\ub77c \uc0dd\uac01\ud55c\ub2e4. // \ubb34\ud55c\ud55c \uc815\uc218 \uc218\uc5f4 async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await \uad6c\ubb38 for co_await ( int v : infinite ()) { // `v`\ub85c \ubb34\uc5b8\uac00 \ud55c\ub2e4... } } iterator \uac00 Awaitable\ud558\ub2e4\uace0 \ud588\ub294\ub370, \uc774\ub294 usecase \uac00 \ub2e4\uc74c\uacfc \uac19\ub2e4\ub294 \uc758\ubbf8\ub2e4. std :: future < void > usecase () { // \uae30\ub2e4\ub9b4 \uc218 \uc788\ub294 \ubc18\ubcf5\uc790 : awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `begin()` \uc5d0 // `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. iter != gen . end (); // `end()` \ub294 nullptr\uc640 \uac19\ub2e4. co_await ++ iter ) // `operator++()`\uc5d0 `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. { int v = * iter ; // ... } } generator<T> \uc608\uc81c\uc640 \ub2e4\ub978 \uc810\uc740 \ud568\uc218\uac00 2\uac1c \uc9c0\uc810\uc5d0\uc11c \ubc18\ubcf5\uc790\ub97c \uae30\ub2e4\ub9ac\uace0 \uc788\ub2e4\ub294 \uac83\uc774\ub2e4. \ub530\ub77c\uc11c begin() \uacfc operator++() \ub294 usecase \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8/\uc7ac\uac1c\uc9c0\uc810\uc774 \ub41c\ub2e4. \uc5ec\uae30\uc120 value_type \uc740 \uae30\ubcf8 \uc790\ub8cc\ud615 int \ub77c\uc11c \uc5b4\ub824\uc6b4 \ucf54\ub4dc\ub294 \uc5c6\ub2e4. Awaitable iterator \ucf54\ub4dc\ub294 \ub2e4\uc74c\ucc98\ub7fc \ub9cc\ub4e4 \uc218 \uc788\ub2e4. \uc0ac\uc2e4 std::experimental::generator<T> \uc758 \ucf54\ub4dc\ub97c \uac70\uc758 \uadf8\ub300\ub85c \uac00\uc838\uc628 \uac83\uc774\ub2e4. // generator\uac00 \uc544\ub2c8\ub77c iterator\uac00 \ube44\ub3d9\uae30\ub85c \ub3d9\uc791\ud55c\ub2e4.(awaitable). template < typename T > struct async_generator { struct promise_type ; // Awaitable interface\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // \uc9c0\uae08\uc740 \uc608\uc81c\uc774\ubbc0\ub85c, \uc5b8\uc81c\ub098 \uac12\uc774 \uc874\uc7ac\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\uc9c0\ub3c4 \uc54a\ub294\ub2e4. bool await_ready () const { return true ; } // \uc911\ub2e8\ud558\uc9c0 \uc54a\uc73c\ubbc0\ub85c \ub0b4\uc6a9\uc774 \uc5c6\ub2e4. void await_suspend ( coroutine_handle <> hcoro ) {} // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc774 `co_await`\uc5d0\uac8c \uc804\ub2ec\ub41c\ub2e4. iterator await_resume () const { return * this ; } }; // iterator }; // async_generator \uba64\ubc84\ud568\uc218 3\uac1c\ub97c iterator \uc5d0 \ucd94\uac00\ud568\uc73c\ub85c\uc368, awaitable \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uc600\uace0 for co_await \uad6c\ubb38\uc744 \uc4f8 \uc218 \uc788\uc5c8\ub2e4. \ud558\uc9c0\ub9cc Awaitable Interface \ub2e8\ub77d\uc5d0\uc11c \uc124\uba85\ud588\ub4ef \uad73\uc774 \uba64\ubc84\ud568\uc218\uc77c \ud544\uc694\ub294 \uc5c6\ub2e4. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } \uc774\ub807\uac8c \ubcf4\uc870 \ud568\uc218\ub97c \uc815\uc758\ud558\ub294 \uac83 \ub9cc\uc73c\ub85c\ub3c4 \uae30\uc874\uc5d0 \uc0ac\uc6a9\ud558\ub358 iterator \ud0c0\uc785\ub4e4\uc744 \uc7ac\ud65c\uc6a9\ud560 \uc218 \uc788\ub2e4.","title":"Example"},{"location":"articles/exploring-msvc-coroutine-kor/#_24","text":"MSVC \ucf54\ub8e8\ud2f4\uc758 \uac1c\ub150\uacfc \ucf54\ub4dc\ub97c \ud6d1\uc5b4\ubd24\ub2e4. \uadf8\uac8c \uc804\ubd80\ub2e4. \ubd80\ub514 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uae30\ub97c. \uc0ac\uc2e4 \uc774 Feature\uc758 \ub514\uc2a4\uc5b4\uc148\ube14\ub9ac \uacb0\uacfc\uc5d0 \ub300\ud574\uc11c\ub3c4 \uc4f0\uace0 \uc2f6\uc5c8\ub294\ub370, \uad00\ub828\ud574\uc11c\ub294 \uc544\uc9c1 \ucd08\ubcf4\uc790 \ub2e8\uacc4\ub77c \uc81c\ub300\ub85c \uc124\uba85\ud560 \uc218\uac00 \uc5c6\uc5c8\ub2e4. \uae30\ud68c\uac00 \ub41c\ub2e4\uba74 \ucc28\ud6c4\uc5d0 \ub2e4\uc2dc \uae00\uc744 \uc368\ubcf4\uace0 \uc2f6\ub2e4. \ub098\uc911\uc5d0 \ub354\uc6b1 \uac1c\uc120\ud560 \uae30\ud68c\uac00 \uc788\uae30\ub97c. :D","title":"\ub05d! \ud6c4\uae30"},{"location":"articles/exploring-msvc-coroutine/","text":"Exploring MSVC Coroutine \u00b6 Written in 2017/02/17 \ud55c\uad6d\uc5b4 Reference \u00b6 Proposal \u00b6 N3858 N3977 N4134 N4402 Visual C++ Team Blog \u00b6 Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++ Video \u00b6 CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\" GitHub \u00b6 kirkshoop/ await Caution \u00b6 To try this feature, you need 3 things. Visual Studio 2015 Up3 or later. /await Compiler option <experimental/*> header files to include. Definition \u00b6 So, what is coroutine? Old Fashion : The Machine Level \u00b6 For me, the story starts from The Art of Computer Programming , written by Donald Knuth. Basically, the procedure call is goto . But, goto where? As you know, program can be thought as a sequence of states. And program's state, which is defined by programmer, is composition of machine environment and memory. It can be finite, or infinite. Program State = Environment X Memory (Cartesian Product) Here, instructions are transition between states. And routine is a ordered group of instructions. Instruction : Transition between states Routine : Ordered group of instructions Now, let's go to subroutine & coroutine. Concept : Relation \u00b6 All programmers have their own mental model for codes. Lets start from the point. Mental model for subroutine and coroutine. Subroutine : Caller-Callee \u00b6 Caller expects some states (Pre-condition). And it knows which routine is required. Callee, with specified (in other words, well-defined) codes, do its work without consideration of its caller. It can be impure with side-effect. But it's about work, not the relation. Coroutine : Activator-Activator \u00b6 Coroutine is cooperative routine. In other worlds, it is aware of the other routines. Notice that both are activated and activating by each other. Coroutine is activated by Invoker and Resuming routine. And by suspending or returning, coroutine activates its peer. In real, these activations are equal to jump( goto / jmp ) instruction. So some suspension can be considered as invocation. Or there might not be significant difference between suspension and finalization. If the point is entry(prologue) of routine, it is invocation ( call ). If the flow goes to the middle of procedure, then it's activation ( resume ). Invocation: Jump to start the routine Activation: Jump into a point of the routine Like subroutine, coroutines has specification for its pre-condition and post-condition. Therefore it must be designed with consideration of modification on program state. But after its work, it preserves the state and goto another point. This is suspension ( yield ). Of course, this can be return. In that case, it just finalizes and then return to its caller. (Since they have activation records) Suspension: Jump to another point without finalization Finalization: Destroy(cleanup) all function resources Difference? \u00b6 So, the major difference of coroutine/subroutine is that coroutine supports more operations. This is why Knuth summarized in his book. \"Subroutines are special cases of ... coroutines\" - Donald Knuth Let's see that in table form. Operation Subroutine Coroutine Invoke o o General procedure start Activate x o goto a specific point of procedure Suspend x o Yield current control flow Finalize o o Cleanup and return Clearly, subroutine is limited but easy and simple in relationship. However, coroutine have more operations, but might be complex because it suspension and activation should be managed. Routine: Group of instructions that modify the program state to another with defined statements Subroutine: Routine that supports 2 operations Invoke Finalize Coroutine: Routine that supports 4 operations Invoke Activate Suspend Finalize Example \u00b6 Knuth wrote how this is expressed in code. You don't have to understand all MIX instructions. Unlike theseday's subroutine, operations are usually JMP without abstraction. What I want to explain is that there is a gap between High-level and Assembly languages. The key point is coroutine has multiple points for entry and exit . Also, they have some implicit states. // MIX example, modified // The Art of Computer Programming 1.4.2. // For detail, read the book. :D // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF . Motivation : Programming Model \u00b6 It's a stack! \u00b6 \"It's A Trap!\" - Admiral Ackbar These days, we are familiar with high-level languages with runtime stack. It's fancy, well-defined, and automated. Think of structured, stack-ful program's model. In the model, the program is basically a mathematical expression tree that flows in depth-first order. For instance, main function finished at some time point and then it returns a value. Like figure, functions in this model embeds a sequence of statements when it is written. To reach the statement B, we have to finish the traversal for statement A. Then, the program state is affected by statement A. Memory locations will containing result values. Environments like registers will be set as defined. Blocking \u00b6 But the dependency became a problem. Remind that tree model follows mathematics. If we have all values in the expression, the calculation can be processed without blocking. Since we don't have infinite resource, we can't prepare all values when the flow starts. So, we need some In/Out operations. which is extremely slow. Waiting its result blocks our control flow. We don't want to stop our program. We want responsiveness. That's why we started to use non-blocking operations and to apply some asynchronous programming models. We generalized the program tree to a graph form. Which is another notation for state machine. Now, the program is graph of states . And our processors traverse over it. Processor can be OS Process, OS Thread, or some language supported abstraction such as Goroutine and Erlang process. But, Let me skip them, we are thinking about coroutine now. Persistence \u00b6 The point is, we have to deliver some context between vertices of the graph. But subroutine can't do this. Because it always destroyes(finalizes) itself. Subroutine is lack of persistence. It returns to caller. That's how runtime stack works. But it disabled us to pass contexts between states. Think of callback hell to enable that context forwarding. \"James. This code has a bug. Can you fix it?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); } Approach \u00b6 We need some persistent function. Reminding coroutine suspend/yield its control without finalization, the answer is crystal clear. Coroutine can take the role. But how can we migrate that assembly concept into our stack world? Let's change the question. What should be persistent?: Context What is context?: The routine's state What makes the state?: Environment & Memory Where are they?: Function Frame Henceforce, our migration starts from how to make those frames persistent . If you can't get what it is, visit this page . Stackful? Stackless! \u00b6 \"Why do you rob banks?\" \"That's where the money is.\" - Bank robber Stackful or Segmented Stack \u00b6 It differes upon language, but C++ places function frames in runtime stack. To preserve some frame, we have to dump it and store it in some location. Or we can make a smaller chunk of space and use it as a side(alternantive) stack for function. But let's bypass them. Our focus, MSVC coroutine is stackless. Stackless - Function Frame \u00b6 N3858 wrote about resumable function's implementability. It suggested heap-allocated activation frames. But frame is just a structure. Remind that we need 4 operations for coroutine. Those are declared as compiler intrinsic. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... So there is nothing we can touch.(Unless you are in MSVC team... right?) But if you want more detail, follow the references above and watch CppCon talks. you may noticed there are 2 kinds of concept. Frame and Block. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block It is not clear for me now. Let me update this section later. In my opinion, the frame is activation record for the function (In the case, resumable function). And block is space for function code. Therefore, it will contain local/captured arguments, And it's size will depends on maximum stack size of the function. ... Probably. The C++ Coroutine : Resumable Function \u00b6 At this point, we have to define 2 terms. Coroutine : Concept . Routine that supports 4 operations Resumable Function : Implementation of coroutine concept in C++ world And the following table is about how to use its operations Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return Invoke \u00b6 For function call, there is no change. But the resumable function returns std::future<T> . Finalize \u00b6 Cleanup and return point can be specified the well-known keyword, return . For same purpose, in resumable function, co_return statement is used. Suspend \u00b6 When you wan to suspend funtion and yield its control, co_yield expression and co_await operator can do that. By adding 1 of them, the suspend/resume point is specified and MSVC will treat the function as coroutine. (Also, co_return statement can be used) Activate \u00b6 When we have to activate suspended function, we will use coroutine_handle and its memeber function, .resume() . This is an interface to compiler intrinsic _coro_resume above. Code \u00b6 Example codes are inspired by kirkshoop's repository . In short, if we follows MSVC's requirement, we can use C++ coroutine. But notice that the title of proposal is resumable (therefore, persistent) function. However, its category differs to which meaning you want to carry with. Before that, let's start with compiler's requirement. Promise : Compiler's Requirement \u00b6 You may already know about std::future<T> and std::promise<T> , and relation of the pair. Usually, future<T> is something like \"I will return value or exception later \" (See std::async() ). And the value/exception is transferred via promise<T> . It is, \"I kept the promise for the value\". And I already explained that resumable returns future<T> . Literally, This is not weird because coroutine can suspends itself and therefore its activator can't sure that it has returned. However, with the signature, programmer can still explicitly specify for return type just like conventional subroutine. But here, the promise is for resumable function. See N4402 . You may ask why this is necessary. The answer is that resumable function is abstraction . Because of stack, we had migrated the coroutine concept but not assembly-like flat code. Our resumable function lives in heap and to pass value from heap space(from function frame) to stack space(to future or awaitable), there must be some interface . For both compiler and programmer. Resumable Promise Requirement \u00b6 I will explain how this interface is used soon. According to N4402, the promise type for resumable function should support operations in the table below. I summarized note column. For detail, please read the document. Expression Note P{} Promise must be default constructible p.get_return_object() The return value of funtion. It can be future<T> , or some user-defined type. p.return_value(v) co_return statement. Pass the value v and the value will be consumed later. p.return_value() co_return statement. Pass void . Can be invoked when the coroutine returns. And calling this can be thought as \"No more value\". p.set_exception(e) Pass the exception. It will throw when the resumer activates the function with this context. p.yield_value(v) co_yield expression. Similar to return_value(v) . p.initial_suspend() If return true , suspends at initial suspend point. p.final_suspend() If return true , suspends at final suspend point. Some operations are related to coroutine_traits<T> . Later section will describe its flexibility. It is pretty abstract for now, but we are in progress. Lets move our focus to usecases of C++ coroutine. Generator \u00b6 Concept \u00b6 Generator = Iterator + Resumable Function See? There is an iterator. generator<T> is abstraction for sequence of values, which are generated by resumable function. The function is persistent, and contains some unique context in its frame. Example \u00b6 The following code is simple generator for fibonacci numbers. #include <experimental/generator> // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // Set the value and suspend co_yield f1 ; // Calculate next fibo and shift int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // No more value } void usecase () { // A sequence of 10 fibo numbers for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } How this can be possible? Well, lets see the definition of generator<T> . Detail \u00b6 Here is a skeleton of generator<T> . We can see that it supports iterator and promise_type . and begin() / end() function to support Range-based for loop template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // Handle for Resumable Funtion coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // If we have handle, we can resume it to get the value. if ( _Coro ) { _Coro . resume (); // The function returned? if ( _Coro . done ()) return { nullptr }; // return end(); } // The function is not finished. // Will be reused later... return { _Coro }; } iterator end () { // No handle, No more value. return { nullptr }; } ~ generator () { // RAII : Destroy function frame if ( _Coro ) { _Coro . destroy (); } } }; So, the actual usecase function will be like this. void usecase () { // A generator for 10 fibo numbers generator < int > gen = fibonacci ( 10 ); // We cannot use `iter++` because it is deleted. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } Pretty simple with the iterator! Let's hack the iterator then... template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Iterator interface struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // When we move next... iterator & operator ++ () { // Make the function yield next value _Coro . resume (); // If done, just release. // Generator will destroy it later... if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // This is MSVC comment.... // In short, post increment can overlap the handle in iterator. // And it can leak the last value in coroutine frame. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // We use `promise` to get the value. // It is pointing the value in function frame _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; At this point, we can understand that iterator is resuming the function repetitively. And acquiring value from generator<T> 's promise_type . So in this case, usecase function is both invoker and resumer for the generator . Compiler's View \u00b6 Now, the keystone promise_type is on the stage. It has more codes but I will skip them for simplicity. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } The promise_type supports 4 functions in requirement. get_return_object , initial_suspend , final_suspend , and yield_value . In short, co_yield is equal to \"Set the value and suspend\". Compiler will change the expression like following. co_yield : co_await + p.yield_value(x) Therefore, co_yield with empty expression is impossible . Because x can't be void . Since generator is abstraction of sequence, this is natural constraint. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // Compiler changes the expression to... // co_yield f1; p . yield_value ( f1 ); // Set the value pointer co_await suspend_always {}; // And suspend. // ... } co_return ; // No more value } Notice that there is no promise_type p{} or something else. Its secret will be covered in next section. Resumable Function \u00b6 This section starts from detail. The example code will be seen after explanation of awaitable concept. Concept \u00b6 Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> was simple example. And you may remember that it contains coroutine_handle . Let's cover the type. coroutine_handle was resumable_handle . Remembering that resumable function is C++ implementation of coroutine concept, it is alias of resumable function handle. If you have an experience of Windows API, you probably know what handle means. It is void * . We already talked about how stackless coroutine can be implemented. MSVC uses heap allocated function frame and supports several intrinsics. With the pointer to frame in heap, coroutine_handle adds some operation over it. Resumable Frame \u00b6 Then, how does the frame look like? As I commented above, the frame of resumable function. It has head and body. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // Head of function frame // - Fn : Instruction address for resume operation // - cdecl : Caller manages the frame. Callee won't touch it. // - Index : Index to resumption point. // 0 is special value for `done()` // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // Coroutine Frame will include... // - Promise // - Captured arguments // - Function body // - Local Variables and Temporaries // - Platform context // - Registers // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : Like its name, _Resumable_frame_prefix is head of coroutine frame. MSVC uses fixed size of sizeof(void *) * 2 (16 bytes in x64) for this struct. Fn : Note that this is declared as cdecl convention. Since cdecl specifies stack cleanup (in the case, frame destruction) is up to caller, the call of Fn won't destroy the frame. Index : Resumable function can have multiple resumption point. This is a index for the point. Flag : ??? Who are you ??? Body : N4402 describes what frame includes. Based on James McNellis's PPT, the compiler-generated frame body will be like the following code. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // Possible frame for fibonacci function struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _p ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; Coroutine Traits \u00b6 We didn't cover p.get_return_object() yet. This is the section for the topic. Let me explain coroutine_traits first... // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; It's pretty simple. coroutine_traits requires promise_type to be implemented at compile time. And it must follow Resumable Promise Requirement . I explaind that resumable function returns future<T> , but that was not correct. If there is a type that fulfills the coroutine_traits , it can be return type of Resumable function. Let't go to template specialization of coroutine_traits for std::future<T> . Previous example, generator<T> implemented promise type in itself, but with the specialization trick, we can reuse some old types or try some custom type. // <future> #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // Template Specialization for `std::future<T>` template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // defines resumable traits for functions returning future<_Ty> struct promise_type { // `std::promise<T>` promise < _Ty > _MyPromise ; // Resumable function can return `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // if `false`, we skip the initial suspend point. bool initial_suspend () const { return ( false ); } // if `false`, we skip the final suspend point. bool final_suspend () const { return ( false ); } // Pass the value through `std::promise<T>` template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // Pass the exception through `std::promise<T>` void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif When MSVC meets co_await / co_yield / co_return , it applies coroutine_traits to enable compile-time check. Let's see the fibonacci example again. It will show what MSVC does. The code might be wrong. I will update it as I find correct mechanism. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { using return_type = generator < int > ; // At this point, compiler will generate code // and check `return_type` fulfills promise requirement. using traits = coroutine_traite < return_type > ; // Requirement : OK. // We can generate unique frame type for this function. // Possible frame for fibonacci function struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // We are forwarding arguments to frame! // Let's call it context(ctx) __frame * ctx = new __frame { std :: move ( n )}; // Generate return objet // In this case, `generator<int>` return_type __return = ctx -> _promise . get_return_object (); // if true, suspend. // if false, keep move... if ( ctx -> _promise . initial_suspend () ){ // always true // suspend... __initial_suspend_point : } // User code : use variables in frame(ctx)... // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // Pass value through promise // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // instructions for suspension with `ctx->_prefix`... // co_await suspend_always{}; __suspend_resume_point_1 : // Calculate next fibo and shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // always true // suspend... __final_suspend_point : } // Instructions for clean up... } So we could find out that compiler do a lot of job instead of us. And using frame pointer ctx is not that different from this pointer for memeber functions. Therefore, the cost for frame-based code will be negligible. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend; Section Summary \u00b6 We covered co_return and co_yield with generator<T> example. Generator was a combination of iterator and resumable function. Resumable functions use coroutine_handle , which is basically raw pointer to function frame and some operations that rely on compiler intrinsics. The mechanism for frame-based approach was pretty similar to this pointer approach. For compile-time(static) assertion, coroutine_traits<T> is used. It enforce the return type to support promise_type that fulfills resumable promise requirement. And there was a specialization especially for std::future<T> . The Awaitable Concept \u00b6 operator co_await = Syntactic Sugar + Resumable Function The last core of resumable function is co_await . It is unary operator. In this semantics, await is synonym of suspend . And because of suspension, its return value becomes asynchronous . This is the important point for our mental model. You may thought async & await of C# language, The difference in C++ world is that we can manage them manually , with our code and compiler support. Example \u00b6 The code is sample from MSVC blog. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // operator overload. // co_await can't use primitive type parameter. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // Awaitable must implements 3 function. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback Thread will resume the function coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // If not ready (`false`), invoke `await_suspend` // If ready (`true`), go to `await_resume` directly. bool await_ready () const { return duration . count () <= 0 ; } // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // Set the timer and then suspend... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Return T type's value after resumed. // T can be `void`. void await_resume () {} }; return awaiter { duration }; } // Resumable Function future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // await for 1 millisecond... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // This is normal subroutine void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } It's flow is like the figure. Awaitable Interface \u00b6 co_await requires some interface for its operation. As we can see in code above, Awaitable interface should implement at least 3 functions. await_ready await_suspend await_resume It can be both member and normal function. future<T> also implements this interface. so future can be an argument for co_await . But just like the code await_suspend , it can be inefficient. For user-defined type, simple overload is enough. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std How about compiler's view? How does it change our code? Compiler's View \u00b6 operator co_await = Syntactic Sugar + Resumable Function I explained that co_await is syntatic sugar. If operator's argument type implements awaitable concept appropriately, the code will be modified by compiler. Revisiting previous example, test function which awaits for 1 millisecond, let's see how it works... // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // With `co_await` keyword in function body, // compiler will make this function to resumable. future < void > test () { // Compiler-generated coroutine frame... __frame * context ; // ... // Awaitable type implements awaitable interface. // Precisely, this will be temporary variable in frame. awaiter aw = operator co_await ( 1 ms ); // Do we have expected value now? // If not, suspend. // If ready, skip the suspend and resume directly. if ( aw . await_ready () == false ) // await_ready(aw); { // Wrap the function frame to `coroutine_handle` type coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); aw . await_suspend ( resume_cb ); // some instructions.... __suspend_resume_point_1 : // Since resume point is in this scope, // there won't be suspension if ready()==true. } // If await_resume has return type... // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } So there are some points for each of interface functions. await_ready : \"Do we have return value now?\" await_ready makes the branch. It asks value for await_resume is ready. If not, the control flows into the scope of if statement. If it's ready, await_ready returns true and await_resume will be invoked directly. Compiler can optimize the code if it returns false always. In the case, we don't need suspension and therefore frame wrapping becomes unnecessary. The coroutine will become normal subroutine after optimization steps. In suspension scope, we must ready for suspension. Since coroutine_handle<> is just a raw pointer to frame, we can wrap it easily with static function coroutine_handle<>::from_address . await_suspend : \"The routine will suspend soon. Do what you have to do!\" await_suspend receives coroutine_handle<> for its argument. With this function, we can interleave our code for suspension handling. // The example code set the Windows Thread Pool Timer // and forward frame's address as callback argument. class awaiter { // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // Unwrap the handle resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // A thread in Windows Thread Pool will invoke this callback. // And it will be resumer for the function. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Wrap the frame to handle again. And resume. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"Now, here is the return value and control flow\" Suspend/resume point is created for resume operation. When the coroutine handle's .resume() is invoked, the function will set the context(frame pointer) and jump to it. The flow then exits the scope and call await_resume . Notice that we did suspend because the value wasn't ready( await_ready ). When the function is resumed, there should be return value. If await_resume 's return type is void, it means control flow is back. co_await Tricks \u00b6 Kenny Kerr and James Mcnellis introduced several tricks with this mechanism. I strongly recommend you to watch the video. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Async Generator \u00b6 Concept \u00b6 Async Generator = Awaitable iterator + Resumable function This is similar to Generator's concept, but it has awaitable iterator . In other words, we can use for co_await statement for it. Kirkshoop will give you clear explanation for this. Example \u00b6 I won't write hard example since I hadn't try this feature. But previous examples and explanations will help your understanding. // Infinite sequence of interger. async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await statement for co_await ( int v : infinite ()) { // do something with `v`... } } I sad iterator is awaitable. So real code of usecase will be like following. std :: future < void > usecase () { // generator with awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `co_await` + `begin()` iter != gen . end (); // `end()` has nullptr co_await ++ iter ) // `co_await` + `operator++()` { int v = * iter ; // ... } } The only difference form generator<T> example is that the function is awaiting iterator at 2 points. begin() and operator++() . These are points for resume operation. Here, value type is primitive type int . So there won't be complex code here. The following code shows how to make awaitable iterator. The other code for generator body and promise_type is exactly same with std::experimental::generator<T> // Actually, generator is not async. Its iterator is async(awaitable). template < typename T > struct async_generator { struct promise_type ; // Same with experimental generator // We will implement awaitable interface... struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // Since this is syntactic example, there is no suspension. bool await_ready () const { return true ; } // With no suspension, there is nothing to do with handle. void await_suspend ( coroutine_handle <> hcoro ) {} // Return awaitable iterator at resume point iterator await_resume () const { return * this ; } }; // iterator }; // async_generator By adding 3 member functions for iterator , we could make it awaitable and became available to use for co_await statement. But as I mentioned at Awaitable Interface section, you don't have to add member function. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } Adding these helper functions for old types will work fine. Conclusion \u00b6 So, we have traveled MSVC coroutine from concept to code. That's all. I wish I made helpful description. I'd like to add disassembly experience about this feature, but I can't make it because I'm a beginner for that ability. I will try that topic later. I couldn't make this article in more detail. Maybe there could be a chance to update this...! :D","title":"Exploring MSVC Coroutine"},{"location":"articles/exploring-msvc-coroutine/#exploring-msvc-coroutine","text":"Written in 2017/02/17 \ud55c\uad6d\uc5b4","title":"Exploring MSVC Coroutine"},{"location":"articles/exploring-msvc-coroutine/#reference","text":"","title":"Reference"},{"location":"articles/exploring-msvc-coroutine/#proposal","text":"N3858 N3977 N4134 N4402","title":"Proposal"},{"location":"articles/exploring-msvc-coroutine/#visual-c-team-blog","text":"Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++","title":"Visual C++ Team Blog"},{"location":"articles/exploring-msvc-coroutine/#video","text":"CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\"","title":"Video"},{"location":"articles/exploring-msvc-coroutine/#github","text":"kirkshoop/ await","title":"GitHub"},{"location":"articles/exploring-msvc-coroutine/#caution","text":"To try this feature, you need 3 things. Visual Studio 2015 Up3 or later. /await Compiler option <experimental/*> header files to include.","title":"Caution"},{"location":"articles/exploring-msvc-coroutine/#definition","text":"So, what is coroutine?","title":"Definition"},{"location":"articles/exploring-msvc-coroutine/#old-fashion-the-machine-level","text":"For me, the story starts from The Art of Computer Programming , written by Donald Knuth. Basically, the procedure call is goto . But, goto where? As you know, program can be thought as a sequence of states. And program's state, which is defined by programmer, is composition of machine environment and memory. It can be finite, or infinite. Program State = Environment X Memory (Cartesian Product) Here, instructions are transition between states. And routine is a ordered group of instructions. Instruction : Transition between states Routine : Ordered group of instructions Now, let's go to subroutine & coroutine.","title":"Old Fashion : The Machine Level"},{"location":"articles/exploring-msvc-coroutine/#concept-relation","text":"All programmers have their own mental model for codes. Lets start from the point. Mental model for subroutine and coroutine.","title":"Concept : Relation"},{"location":"articles/exploring-msvc-coroutine/#subroutine-caller-callee","text":"Caller expects some states (Pre-condition). And it knows which routine is required. Callee, with specified (in other words, well-defined) codes, do its work without consideration of its caller. It can be impure with side-effect. But it's about work, not the relation.","title":"Subroutine : Caller-Callee"},{"location":"articles/exploring-msvc-coroutine/#coroutine-activator-activator","text":"Coroutine is cooperative routine. In other worlds, it is aware of the other routines. Notice that both are activated and activating by each other. Coroutine is activated by Invoker and Resuming routine. And by suspending or returning, coroutine activates its peer. In real, these activations are equal to jump( goto / jmp ) instruction. So some suspension can be considered as invocation. Or there might not be significant difference between suspension and finalization. If the point is entry(prologue) of routine, it is invocation ( call ). If the flow goes to the middle of procedure, then it's activation ( resume ). Invocation: Jump to start the routine Activation: Jump into a point of the routine Like subroutine, coroutines has specification for its pre-condition and post-condition. Therefore it must be designed with consideration of modification on program state. But after its work, it preserves the state and goto another point. This is suspension ( yield ). Of course, this can be return. In that case, it just finalizes and then return to its caller. (Since they have activation records) Suspension: Jump to another point without finalization Finalization: Destroy(cleanup) all function resources","title":"Coroutine : Activator-Activator"},{"location":"articles/exploring-msvc-coroutine/#difference","text":"So, the major difference of coroutine/subroutine is that coroutine supports more operations. This is why Knuth summarized in his book. \"Subroutines are special cases of ... coroutines\" - Donald Knuth Let's see that in table form. Operation Subroutine Coroutine Invoke o o General procedure start Activate x o goto a specific point of procedure Suspend x o Yield current control flow Finalize o o Cleanup and return Clearly, subroutine is limited but easy and simple in relationship. However, coroutine have more operations, but might be complex because it suspension and activation should be managed. Routine: Group of instructions that modify the program state to another with defined statements Subroutine: Routine that supports 2 operations Invoke Finalize Coroutine: Routine that supports 4 operations Invoke Activate Suspend Finalize","title":"Difference?"},{"location":"articles/exploring-msvc-coroutine/#example","text":"Knuth wrote how this is expressed in code. You don't have to understand all MIX instructions. Unlike theseday's subroutine, operations are usually JMP without abstraction. What I want to explain is that there is a gap between High-level and Assembly languages. The key point is coroutine has multiple points for entry and exit . Also, they have some implicit states. // MIX example, modified // The Art of Computer Programming 1.4.2. // For detail, read the book. :D // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF .","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#motivation-programming-model","text":"","title":"Motivation : Programming Model"},{"location":"articles/exploring-msvc-coroutine/#its-a-stack","text":"\"It's A Trap!\" - Admiral Ackbar These days, we are familiar with high-level languages with runtime stack. It's fancy, well-defined, and automated. Think of structured, stack-ful program's model. In the model, the program is basically a mathematical expression tree that flows in depth-first order. For instance, main function finished at some time point and then it returns a value. Like figure, functions in this model embeds a sequence of statements when it is written. To reach the statement B, we have to finish the traversal for statement A. Then, the program state is affected by statement A. Memory locations will containing result values. Environments like registers will be set as defined.","title":"It's a stack!"},{"location":"articles/exploring-msvc-coroutine/#blocking","text":"But the dependency became a problem. Remind that tree model follows mathematics. If we have all values in the expression, the calculation can be processed without blocking. Since we don't have infinite resource, we can't prepare all values when the flow starts. So, we need some In/Out operations. which is extremely slow. Waiting its result blocks our control flow. We don't want to stop our program. We want responsiveness. That's why we started to use non-blocking operations and to apply some asynchronous programming models. We generalized the program tree to a graph form. Which is another notation for state machine. Now, the program is graph of states . And our processors traverse over it. Processor can be OS Process, OS Thread, or some language supported abstraction such as Goroutine and Erlang process. But, Let me skip them, we are thinking about coroutine now.","title":"Blocking"},{"location":"articles/exploring-msvc-coroutine/#persistence","text":"The point is, we have to deliver some context between vertices of the graph. But subroutine can't do this. Because it always destroyes(finalizes) itself. Subroutine is lack of persistence. It returns to caller. That's how runtime stack works. But it disabled us to pass contexts between states. Think of callback hell to enable that context forwarding. \"James. This code has a bug. Can you fix it?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); }","title":"Persistence"},{"location":"articles/exploring-msvc-coroutine/#approach","text":"We need some persistent function. Reminding coroutine suspend/yield its control without finalization, the answer is crystal clear. Coroutine can take the role. But how can we migrate that assembly concept into our stack world? Let's change the question. What should be persistent?: Context What is context?: The routine's state What makes the state?: Environment & Memory Where are they?: Function Frame Henceforce, our migration starts from how to make those frames persistent . If you can't get what it is, visit this page .","title":"Approach"},{"location":"articles/exploring-msvc-coroutine/#stackful-stackless","text":"\"Why do you rob banks?\" \"That's where the money is.\" - Bank robber","title":"Stackful? Stackless!"},{"location":"articles/exploring-msvc-coroutine/#stackful-or-segmented-stack","text":"It differes upon language, but C++ places function frames in runtime stack. To preserve some frame, we have to dump it and store it in some location. Or we can make a smaller chunk of space and use it as a side(alternantive) stack for function. But let's bypass them. Our focus, MSVC coroutine is stackless.","title":"Stackful or Segmented Stack"},{"location":"articles/exploring-msvc-coroutine/#stackless-function-frame","text":"N3858 wrote about resumable function's implementability. It suggested heap-allocated activation frames. But frame is just a structure. Remind that we need 4 operations for coroutine. Those are declared as compiler intrinsic. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... So there is nothing we can touch.(Unless you are in MSVC team... right?) But if you want more detail, follow the references above and watch CppCon talks. you may noticed there are 2 kinds of concept. Frame and Block. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block It is not clear for me now. Let me update this section later. In my opinion, the frame is activation record for the function (In the case, resumable function). And block is space for function code. Therefore, it will contain local/captured arguments, And it's size will depends on maximum stack size of the function. ... Probably.","title":"Stackless - Function Frame"},{"location":"articles/exploring-msvc-coroutine/#the-c-coroutine-resumable-function","text":"At this point, we have to define 2 terms. Coroutine : Concept . Routine that supports 4 operations Resumable Function : Implementation of coroutine concept in C++ world And the following table is about how to use its operations Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return","title":"The C++ Coroutine : Resumable Function"},{"location":"articles/exploring-msvc-coroutine/#invoke","text":"For function call, there is no change. But the resumable function returns std::future<T> .","title":"Invoke"},{"location":"articles/exploring-msvc-coroutine/#finalize","text":"Cleanup and return point can be specified the well-known keyword, return . For same purpose, in resumable function, co_return statement is used.","title":"Finalize"},{"location":"articles/exploring-msvc-coroutine/#suspend","text":"When you wan to suspend funtion and yield its control, co_yield expression and co_await operator can do that. By adding 1 of them, the suspend/resume point is specified and MSVC will treat the function as coroutine. (Also, co_return statement can be used)","title":"Suspend"},{"location":"articles/exploring-msvc-coroutine/#activate","text":"When we have to activate suspended function, we will use coroutine_handle and its memeber function, .resume() . This is an interface to compiler intrinsic _coro_resume above.","title":"Activate"},{"location":"articles/exploring-msvc-coroutine/#code","text":"Example codes are inspired by kirkshoop's repository . In short, if we follows MSVC's requirement, we can use C++ coroutine. But notice that the title of proposal is resumable (therefore, persistent) function. However, its category differs to which meaning you want to carry with. Before that, let's start with compiler's requirement.","title":"Code"},{"location":"articles/exploring-msvc-coroutine/#promise-compilers-requirement","text":"You may already know about std::future<T> and std::promise<T> , and relation of the pair. Usually, future<T> is something like \"I will return value or exception later \" (See std::async() ). And the value/exception is transferred via promise<T> . It is, \"I kept the promise for the value\". And I already explained that resumable returns future<T> . Literally, This is not weird because coroutine can suspends itself and therefore its activator can't sure that it has returned. However, with the signature, programmer can still explicitly specify for return type just like conventional subroutine. But here, the promise is for resumable function. See N4402 . You may ask why this is necessary. The answer is that resumable function is abstraction . Because of stack, we had migrated the coroutine concept but not assembly-like flat code. Our resumable function lives in heap and to pass value from heap space(from function frame) to stack space(to future or awaitable), there must be some interface . For both compiler and programmer.","title":"Promise : Compiler's Requirement"},{"location":"articles/exploring-msvc-coroutine/#resumable-promise-requirement","text":"I will explain how this interface is used soon. According to N4402, the promise type for resumable function should support operations in the table below. I summarized note column. For detail, please read the document. Expression Note P{} Promise must be default constructible p.get_return_object() The return value of funtion. It can be future<T> , or some user-defined type. p.return_value(v) co_return statement. Pass the value v and the value will be consumed later. p.return_value() co_return statement. Pass void . Can be invoked when the coroutine returns. And calling this can be thought as \"No more value\". p.set_exception(e) Pass the exception. It will throw when the resumer activates the function with this context. p.yield_value(v) co_yield expression. Similar to return_value(v) . p.initial_suspend() If return true , suspends at initial suspend point. p.final_suspend() If return true , suspends at final suspend point. Some operations are related to coroutine_traits<T> . Later section will describe its flexibility. It is pretty abstract for now, but we are in progress. Lets move our focus to usecases of C++ coroutine.","title":"Resumable Promise Requirement"},{"location":"articles/exploring-msvc-coroutine/#generator","text":"","title":"Generator"},{"location":"articles/exploring-msvc-coroutine/#concept","text":"Generator = Iterator + Resumable Function See? There is an iterator. generator<T> is abstraction for sequence of values, which are generated by resumable function. The function is persistent, and contains some unique context in its frame.","title":"Concept"},{"location":"articles/exploring-msvc-coroutine/#example_1","text":"The following code is simple generator for fibonacci numbers. #include <experimental/generator> // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // Set the value and suspend co_yield f1 ; // Calculate next fibo and shift int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // No more value } void usecase () { // A sequence of 10 fibo numbers for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } How this can be possible? Well, lets see the definition of generator<T> .","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#detail","text":"Here is a skeleton of generator<T> . We can see that it supports iterator and promise_type . and begin() / end() function to support Range-based for loop template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // Handle for Resumable Funtion coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // If we have handle, we can resume it to get the value. if ( _Coro ) { _Coro . resume (); // The function returned? if ( _Coro . done ()) return { nullptr }; // return end(); } // The function is not finished. // Will be reused later... return { _Coro }; } iterator end () { // No handle, No more value. return { nullptr }; } ~ generator () { // RAII : Destroy function frame if ( _Coro ) { _Coro . destroy (); } } }; So, the actual usecase function will be like this. void usecase () { // A generator for 10 fibo numbers generator < int > gen = fibonacci ( 10 ); // We cannot use `iter++` because it is deleted. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } Pretty simple with the iterator! Let's hack the iterator then... template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Iterator interface struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // When we move next... iterator & operator ++ () { // Make the function yield next value _Coro . resume (); // If done, just release. // Generator will destroy it later... if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // This is MSVC comment.... // In short, post increment can overlap the handle in iterator. // And it can leak the last value in coroutine frame. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // We use `promise` to get the value. // It is pointing the value in function frame _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; At this point, we can understand that iterator is resuming the function repetitively. And acquiring value from generator<T> 's promise_type . So in this case, usecase function is both invoker and resumer for the generator .","title":"Detail"},{"location":"articles/exploring-msvc-coroutine/#compilers-view","text":"Now, the keystone promise_type is on the stage. It has more codes but I will skip them for simplicity. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } The promise_type supports 4 functions in requirement. get_return_object , initial_suspend , final_suspend , and yield_value . In short, co_yield is equal to \"Set the value and suspend\". Compiler will change the expression like following. co_yield : co_await + p.yield_value(x) Therefore, co_yield with empty expression is impossible . Because x can't be void . Since generator is abstraction of sequence, this is natural constraint. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // Compiler changes the expression to... // co_yield f1; p . yield_value ( f1 ); // Set the value pointer co_await suspend_always {}; // And suspend. // ... } co_return ; // No more value } Notice that there is no promise_type p{} or something else. Its secret will be covered in next section.","title":"Compiler's View"},{"location":"articles/exploring-msvc-coroutine/#resumable-function","text":"This section starts from detail. The example code will be seen after explanation of awaitable concept.","title":"Resumable Function"},{"location":"articles/exploring-msvc-coroutine/#concept_1","text":"Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> was simple example. And you may remember that it contains coroutine_handle . Let's cover the type. coroutine_handle was resumable_handle . Remembering that resumable function is C++ implementation of coroutine concept, it is alias of resumable function handle. If you have an experience of Windows API, you probably know what handle means. It is void * . We already talked about how stackless coroutine can be implemented. MSVC uses heap allocated function frame and supports several intrinsics. With the pointer to frame in heap, coroutine_handle adds some operation over it.","title":"Concept"},{"location":"articles/exploring-msvc-coroutine/#resumable-frame","text":"Then, how does the frame look like? As I commented above, the frame of resumable function. It has head and body. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // Head of function frame // - Fn : Instruction address for resume operation // - cdecl : Caller manages the frame. Callee won't touch it. // - Index : Index to resumption point. // 0 is special value for `done()` // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // Coroutine Frame will include... // - Promise // - Captured arguments // - Function body // - Local Variables and Temporaries // - Platform context // - Registers // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : Like its name, _Resumable_frame_prefix is head of coroutine frame. MSVC uses fixed size of sizeof(void *) * 2 (16 bytes in x64) for this struct. Fn : Note that this is declared as cdecl convention. Since cdecl specifies stack cleanup (in the case, frame destruction) is up to caller, the call of Fn won't destroy the frame. Index : Resumable function can have multiple resumption point. This is a index for the point. Flag : ??? Who are you ??? Body : N4402 describes what frame includes. Based on James McNellis's PPT, the compiler-generated frame body will be like the following code. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // Possible frame for fibonacci function struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _p ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. };","title":"Resumable Frame"},{"location":"articles/exploring-msvc-coroutine/#coroutine-traits","text":"We didn't cover p.get_return_object() yet. This is the section for the topic. Let me explain coroutine_traits first... // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; It's pretty simple. coroutine_traits requires promise_type to be implemented at compile time. And it must follow Resumable Promise Requirement . I explaind that resumable function returns future<T> , but that was not correct. If there is a type that fulfills the coroutine_traits , it can be return type of Resumable function. Let't go to template specialization of coroutine_traits for std::future<T> . Previous example, generator<T> implemented promise type in itself, but with the specialization trick, we can reuse some old types or try some custom type. // <future> #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // Template Specialization for `std::future<T>` template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // defines resumable traits for functions returning future<_Ty> struct promise_type { // `std::promise<T>` promise < _Ty > _MyPromise ; // Resumable function can return `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // if `false`, we skip the initial suspend point. bool initial_suspend () const { return ( false ); } // if `false`, we skip the final suspend point. bool final_suspend () const { return ( false ); } // Pass the value through `std::promise<T>` template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // Pass the exception through `std::promise<T>` void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif When MSVC meets co_await / co_yield / co_return , it applies coroutine_traits to enable compile-time check. Let's see the fibonacci example again. It will show what MSVC does. The code might be wrong. I will update it as I find correct mechanism. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { using return_type = generator < int > ; // At this point, compiler will generate code // and check `return_type` fulfills promise requirement. using traits = coroutine_traite < return_type > ; // Requirement : OK. // We can generate unique frame type for this function. // Possible frame for fibonacci function struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // We are forwarding arguments to frame! // Let's call it context(ctx) __frame * ctx = new __frame { std :: move ( n )}; // Generate return objet // In this case, `generator<int>` return_type __return = ctx -> _promise . get_return_object (); // if true, suspend. // if false, keep move... if ( ctx -> _promise . initial_suspend () ){ // always true // suspend... __initial_suspend_point : } // User code : use variables in frame(ctx)... // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // Pass value through promise // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // instructions for suspension with `ctx->_prefix`... // co_await suspend_always{}; __suspend_resume_point_1 : // Calculate next fibo and shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // always true // suspend... __final_suspend_point : } // Instructions for clean up... } So we could find out that compiler do a lot of job instead of us. And using frame pointer ctx is not that different from this pointer for memeber functions. Therefore, the cost for frame-based code will be negligible. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend;","title":"Coroutine Traits"},{"location":"articles/exploring-msvc-coroutine/#section-summary","text":"We covered co_return and co_yield with generator<T> example. Generator was a combination of iterator and resumable function. Resumable functions use coroutine_handle , which is basically raw pointer to function frame and some operations that rely on compiler intrinsics. The mechanism for frame-based approach was pretty similar to this pointer approach. For compile-time(static) assertion, coroutine_traits<T> is used. It enforce the return type to support promise_type that fulfills resumable promise requirement. And there was a specialization especially for std::future<T> .","title":"Section Summary"},{"location":"articles/exploring-msvc-coroutine/#the-awaitable-concept","text":"operator co_await = Syntactic Sugar + Resumable Function The last core of resumable function is co_await . It is unary operator. In this semantics, await is synonym of suspend . And because of suspension, its return value becomes asynchronous . This is the important point for our mental model. You may thought async & await of C# language, The difference in C++ world is that we can manage them manually , with our code and compiler support.","title":"The Awaitable Concept"},{"location":"articles/exploring-msvc-coroutine/#example_2","text":"The code is sample from MSVC blog. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // operator overload. // co_await can't use primitive type parameter. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // Awaitable must implements 3 function. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback Thread will resume the function coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // If not ready (`false`), invoke `await_suspend` // If ready (`true`), go to `await_resume` directly. bool await_ready () const { return duration . count () <= 0 ; } // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // Set the timer and then suspend... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Return T type's value after resumed. // T can be `void`. void await_resume () {} }; return awaiter { duration }; } // Resumable Function future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // await for 1 millisecond... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // This is normal subroutine void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } It's flow is like the figure.","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#awaitable-interface","text":"co_await requires some interface for its operation. As we can see in code above, Awaitable interface should implement at least 3 functions. await_ready await_suspend await_resume It can be both member and normal function. future<T> also implements this interface. so future can be an argument for co_await . But just like the code await_suspend , it can be inefficient. For user-defined type, simple overload is enough. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std How about compiler's view? How does it change our code?","title":"Awaitable Interface"},{"location":"articles/exploring-msvc-coroutine/#compilers-view_1","text":"operator co_await = Syntactic Sugar + Resumable Function I explained that co_await is syntatic sugar. If operator's argument type implements awaitable concept appropriately, the code will be modified by compiler. Revisiting previous example, test function which awaits for 1 millisecond, let's see how it works... // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // With `co_await` keyword in function body, // compiler will make this function to resumable. future < void > test () { // Compiler-generated coroutine frame... __frame * context ; // ... // Awaitable type implements awaitable interface. // Precisely, this will be temporary variable in frame. awaiter aw = operator co_await ( 1 ms ); // Do we have expected value now? // If not, suspend. // If ready, skip the suspend and resume directly. if ( aw . await_ready () == false ) // await_ready(aw); { // Wrap the function frame to `coroutine_handle` type coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); aw . await_suspend ( resume_cb ); // some instructions.... __suspend_resume_point_1 : // Since resume point is in this scope, // there won't be suspension if ready()==true. } // If await_resume has return type... // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } So there are some points for each of interface functions. await_ready : \"Do we have return value now?\" await_ready makes the branch. It asks value for await_resume is ready. If not, the control flows into the scope of if statement. If it's ready, await_ready returns true and await_resume will be invoked directly. Compiler can optimize the code if it returns false always. In the case, we don't need suspension and therefore frame wrapping becomes unnecessary. The coroutine will become normal subroutine after optimization steps. In suspension scope, we must ready for suspension. Since coroutine_handle<> is just a raw pointer to frame, we can wrap it easily with static function coroutine_handle<>::from_address . await_suspend : \"The routine will suspend soon. Do what you have to do!\" await_suspend receives coroutine_handle<> for its argument. With this function, we can interleave our code for suspension handling. // The example code set the Windows Thread Pool Timer // and forward frame's address as callback argument. class awaiter { // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // Unwrap the handle resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // A thread in Windows Thread Pool will invoke this callback. // And it will be resumer for the function. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Wrap the frame to handle again. And resume. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"Now, here is the return value and control flow\" Suspend/resume point is created for resume operation. When the coroutine handle's .resume() is invoked, the function will set the context(frame pointer) and jump to it. The flow then exits the scope and call await_resume . Notice that we did suspend because the value wasn't ready( await_ready ). When the function is resumed, there should be return value. If await_resume 's return type is void, it means control flow is back.","title":"Compiler's View"},{"location":"articles/exploring-msvc-coroutine/#co_await-tricks","text":"Kenny Kerr and James Mcnellis introduced several tricks with this mechanism. I strongly recommend you to watch the video. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"co_await Tricks"},{"location":"articles/exploring-msvc-coroutine/#async-generator","text":"","title":"Async Generator"},{"location":"articles/exploring-msvc-coroutine/#concept_2","text":"Async Generator = Awaitable iterator + Resumable function This is similar to Generator's concept, but it has awaitable iterator . In other words, we can use for co_await statement for it. Kirkshoop will give you clear explanation for this.","title":"Concept"},{"location":"articles/exploring-msvc-coroutine/#example_3","text":"I won't write hard example since I hadn't try this feature. But previous examples and explanations will help your understanding. // Infinite sequence of interger. async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await statement for co_await ( int v : infinite ()) { // do something with `v`... } } I sad iterator is awaitable. So real code of usecase will be like following. std :: future < void > usecase () { // generator with awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `co_await` + `begin()` iter != gen . end (); // `end()` has nullptr co_await ++ iter ) // `co_await` + `operator++()` { int v = * iter ; // ... } } The only difference form generator<T> example is that the function is awaiting iterator at 2 points. begin() and operator++() . These are points for resume operation. Here, value type is primitive type int . So there won't be complex code here. The following code shows how to make awaitable iterator. The other code for generator body and promise_type is exactly same with std::experimental::generator<T> // Actually, generator is not async. Its iterator is async(awaitable). template < typename T > struct async_generator { struct promise_type ; // Same with experimental generator // We will implement awaitable interface... struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // Since this is syntactic example, there is no suspension. bool await_ready () const { return true ; } // With no suspension, there is nothing to do with handle. void await_suspend ( coroutine_handle <> hcoro ) {} // Return awaitable iterator at resume point iterator await_resume () const { return * this ; } }; // iterator }; // async_generator By adding 3 member functions for iterator , we could make it awaitable and became available to use for co_await statement. But as I mentioned at Awaitable Interface section, you don't have to add member function. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } Adding these helper functions for old types will work fine.","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#conclusion","text":"So, we have traveled MSVC coroutine from concept to code. That's all. I wish I made helpful description. I'd like to add disassembly experience about this feature, but I can't make it because I'm a beginner for that ability. I will try that topic later. I couldn't make this article in more detail. Maybe there could be a chance to update this...! :D","title":"Conclusion"},{"location":"articles/russian-roulette-kor/","text":"Russian Roulette and C++ Coroutines \u00b6 English \uc774\ubc88\uc5d0\ub294 \uc5ec\ub7ec \ucf54\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc5d0 \uc9d1\uc911\ud558\uace0 \uc774\ub4e4\uc758 \uc9c4\ud589\uc744 \ud558\ub098\uc758 \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uc218\ud589\ud558\ub294 \ucf54\ub4dc\ub97c \ud558\ub098 \uc791\uc131\ud574\ubcf4\uace0\uc790 \ud569\ub2c8\ub2e4. \uc608\uc2dc\ub85c\ub294 \uad49\uc7a5\ud788 \uc720\uba85\ud55c \uaddc\uce59\uc744 \uac00\uc9c4 \ub7ec\uc2dc\uc548 \ub8f0\ub81b\uacfc \uadf8 \uac8c\uc784\uc758 \ucc38\uac00\uc790\ub4e4\uc744 \uc0ac\uc6a9\ud574 \ubd24\uc2b5\ub2c8\ub2e4. \ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 1: \uc57d\uc2e4/\ubc29\uc544\uc1e0 \u00b6 \uc6b0\uc120 \ub9ac\ubcfc\ubc84\ub97c \ub9cc\ub4dc\ub294 \uac83\ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \ucc38\uac00 \uc778\uc6d0\uc774 \uc5bc\ub9c8\ub098 \uc788\uc744\uc9c0 \ubaa8\ub974\uae30 \ub54c\ubb38\uc5d0, uint32_t \ub97c \uc0ac\uc6a9\ud574 \ucda9\ubd84\ud788 \ub9ce\uc740 \uc57d\uc2e4(chamber)\uc744 \uc900\ube44\ud560 \uac81\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \uc784\uc758\uc758 \uc57d\uc2e4\uc744 \uc120\ud0dd\ud558\ub294 select_chamber \ub97c \uc544\ub798\uc640 \uac19\uc774 \uc815\uc758\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } \uacbd\uc6b0\uc5d0 \ub530\ub77c\uc11c\ub294 \uc778\uc790\ub97c \ubc1b\uc544 \uc0c1\ud669\uc5d0 \ub530\ub77c \uc57d\uc2e4\uc744 \uc120\ud0dd\ud560\uc9c0 \ubaa8\ub974\uc9c0\ub9cc, \uc774 \uc608\uc2dc\uc5d0\uc11c\ub294 \uac00\uc7a5 \ub2e8\uc21c\ud55c \ubc29\ubc95(\ubb34\uc791\uc704)\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc57d\uc2e4\uc774 \uc788\uc73c\ub2c8 \uc774\uc81c \ubc29\uc544\uc1e0(trigger)\ub97c \uc900\ube44\ud574\uc57c\uaca0\uad70\uc694. \ubc29\uc544\uc1e0\ub294 \ub2f9\uae38( pull ) \uc218 \uc788\uc73c\uba70, \ud604\uc7ac \uacf5\uc774\uac00 \ub9de\ubb3c\ub9b0 \uc57d\uc2e4( current )\uacfc \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud574\uc11c \uc54c\uace0 \uc788\uc2b5\ub2c8\ub2e4. \ud55c\ubc88 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uba74 \uc57d\uc2e4\uc774 \ud68c\uc804\ud560\ud14c\ub2c8, \uc5ec\uae30\uc11c\ub294 \uac04\ub2e8\ud788 chamber_t \uc758 \uac12\uc744 1 \uac10\uc18c \uc2dc\ud0a4\ub294 \uac83\uc73c\ub85c \uc57d\uc2e4\uc744 \ud68c\uc804\uc2dc\ud0a4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... }; \ucc38\uac00\uc790 \ud589\ub3d9 \uc815\uc758\ud558\uae30 \u00b6 \uc5ec\uae30\uc11c \ubc29\uc544\uc1e0\ub294 Awaitable \ud0c0\uc785\uc73c\ub85c \uc815\uc758\ud574\uc11c, \uac8c\uc784 \ucc38\uac00\uc790\ub4e4\uc774 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae34 \ud6c4 \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\ub3c4\ub85d \ub9cc\ub4e4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; \uc774\ub807\uac8c \uc815\uc758\ud55c \uc774\uc720\ub294 \ucc38\uac00\uc790(player)\ub4e4\uc774 3\uac00\uc9c0 \uc0c1\ud0dc\ub97c \uac00\uc9c0\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4. \ubc29\uc544\uc1e0\ub97c \ub2f9\uacbc\uc9c0\ub9cc, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc9c0 \uc54a\uc558\ub2e4 (\uc0b4\uc558\ub2e4!) \ubc29\uc544\uc1e0\ub97c \ub2f9\uaca8\uc11c, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc5c8\ub2e4 (X\ub97c \ub20c\ub7ec \uc870\uc758\ub97c \ud45c\ud558\uc2ed\uc2dc\uc624.) \ucc28\ub840\ub97c \uae30\ub2e4\ub9ac\ub358 \uc911 \ub2e4\ub978 \uc0ac\ub78c\uc774 \uc774\ubbf8 \ucd1d\uc54c\uc744 \ubc1b\uc558\ub2e4 \ucf54\ub4dc\ub85c \ud45c\ud604\ud558\uc790\uba74 \uc544\ub798\uc640 \uac19\uc2b5\ub2c8\ub2e4. index \ub97c \uc0ac\uc6a9\ud574 \uac01 player \ub4e4\uc744 \uad6c\ubd84\ud558\uace0, \ucf54\ub8e8\ud2f4 \uc678\ubd80\uc5d0 \uc704\uce58\ud55c fired (\ubd88\uc774\uc57c!)\uc758 \uac12\uc744 \ubcc0\uacbd\ud558\ub294 \ubc29\ubc95\uc73c\ub85c \ucd1d\uc54c\uc774 \ubc1c\uc0ac\ub418\uc5c8\uc744 \ub54c \ub2e4\ub978 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \uc774\ub97c \ud655\uc778\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. \ubaa8\ub450\uac00 \uac19\uc740 \ub9ac\ubcfc\ubc84\uc758 \ubc29\uc544\uc1e0\ub97c \uc0ac\uc6a9\ud558\ubbc0\ub85c, trigger \ub294 \ucc38\uc870\ub97c \uc0ac\uc6a9\ud558\uc600\uc2b5\ub2c8\ub2e4. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } \uc774\ub807\uac8c \ud558\uba74 \uc2e4\uc81c\ub85c\ub294 \ubaa8\ub4e0 \ucc38\uac00\uc790 \ucf54\ub8e8\ud2f4\ub4e4\uc740 \ubc29\uc544\uc1e0\ub97c \ubbf8\ub9ac \ub2f9\uaca8\ub193\uace0 \uae30\ub2e4\ub9ac\uac8c(suspend) \ub429\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \ubc29\uc544\uc1e0\ub97c \ud55c\ubc88\uc529 \ub2f9\uae30\uba74\uc11c \ucc28\ub840\ub300\ub85c \uae68\uc6cc\ubcf4\ub294(resume) \uac83\uc774\uc8e0. \ucc28\ub840\uac00 \ub418\uba74(resumed) trigger_t \uc740 await_resume \uc758 \ubc18\ud658\uac12\uc744 \ud1b5\ud574 \uacb0\uacfc( fired )\ub97c \uc804\ub2ec\ud560 \uac83\uc774\uace0 \uadf8 \uac12\uc5d0 \ub530\ub77c\uc11c player \uc758 \ub3d9\uc791\uc774 \ub2ec\ub77c\uc9c0\uac8c \ub429\ub2c8\ub2e4. \ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 2 \u00b6 \uc774\uc81c \ub9ac\ubcfc\ubc84\ub97c \ub9c8\uc800 \uc644\uc131\ud558\uace0, user_behavior_t \uc5d0 \ub300\ud574 \uc124\uba85\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc774\ubbf8 \uc704\uc5d0\uc11c trigger_t \ub97c \uc815\uc758 \ud588\uc73c\ubbc0\ub85c, revolver_t \ub294 1\uac1c\uc758 \ubc29\uc544\uc1e0\uc640 \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud55c \uc815\ubcf4\ub97c \uac00\uc9c0\uace0 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; \ubb3c\ub860 \ub204\uad70\uac00\ub294 \ub2f9\ucca8 \ub418\uc5b4\uc57c \ud558\uae30 \ub54c\ubb38\uc5d0, \ubaa8\ub4c8\ub85c \uc5f0\uc0b0\uc744 \ud558\ub294 \uac83\ub3c4 \uc78a\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4. \uac8c\uc784 \uc9c4\ud589\uacfc\uc815 \u00b6 \uc774\uc81c \ucc38\uac00\uc790\uc640 \ub3c4\uad6c(\ub9ac\ubcfc\ubc84)\uac00 \ubaa8\ub450 \uc815\uc758\ub418\uc5c8\uc73c\ub2c8, \uac8c\uc784 \uc9c4\ud589\uacfc\uc815\uc744 \ud45c\ud604\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \uc774 \uac8c\uc784\uc5d0\uc11c\ub294 \ucd1d 6\uba85\uc758 \ucc38\uac00\uc790\uac00 \uc788\ub2e4\uace0 \uac00\uc815\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } \ucc38\uac00\uc790\uc640 \ub3c4\uad6c\uac00 \uc900\ube44\ub418\uba74, russian_roulette \uc744 \ud638\ucd9c\ud558\uc5ec \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. GSL(C++ \ud575\uc2ec \uac00\uc774\ub4dc\ub77c\uc778 \uc9c0\uc6d0 \ub77c\uc774\ube0c\ub7ec\ub9ac)\uc5d0 \uc775\uc219\ud558\uc9c0 \uc54a\uc73c\uc2dc\ub354\ub77c\ub3c4 \uc77d\ub294\ub370 \ubb38\uc81c\ub294 \uc5c6\uc744 \uac83\uc785\ub2c8\ub2e4. \ubaa8\ub974\ub294 \ubd84\ub4e4\uc744 \uc704\ud574 \uc124\uba85\ud558\uc790\uba74, gsl::span \uc740 \ubc94\uc704\ub97c \ud45c\ud604\ud558\uc5ec range- for \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\uace0, gsl::finally \ub294 \uac1c\uccb4\uac00 \uc18c\uba78\ud558\ub294 \uc2dc\uc810\uc5d0 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uae30\ub2a5\uc744 \ud569\ub2c8\ub2e4. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } \ubaa8\ub4e0 player \ub4e4\uc774 fired \uc640 revolver \ub97c \uacf5\uc720\ud558\uba70 \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. \uc774\ub4e4\uc758 \ud589\ub3d9\uc740 \ucf54\ub8e8\ud2f4\uc73c\ub85c \uc815\uc758\ud558\uc600\uc2b5\ub2c8\ub2e4. \ucc38\uac00\uc790\ub4e4\uc758 \uc218\uc640 \ubb34\uad00\ud558\uac8c, russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc740 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uac00 \ub418\uc5b4 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \ucc28\ub840\ub300\ub85c \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uac8c \ub9cc\ub4e4\uac83\uc785\ub2c8\ub2e4. \uc774\ub294 task.resume() \uc744 \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9d1\ub2c8\ub2e4. \uac8c\uc784\uc740 fired \uac00 true \uac00 \ub420 \ub54c\uae4c\uc9c0 \uacc4\uc18d\ub429\ub2c8\ub2e4. \uac8c\uc784\uc774 \ub05d\ub098\uba74 on_finish \uac1c\uccb4\uac00 \ubaa8\ub4e0 \ucc38\uac00\uc790\ub4e4\uc774 \uc0ac\uc6a9\ud55c \uba54\ubaa8\ub9ac(\ucf54\ub8e8\ud2f4 \ud504\ub808\uc784)\ub97c \ud68c\uc218\ud560 \uac83\uc785\ub2c8\ub2e4. \uac04\ub2e8\ud788 frame.destroy() \ud558\ub294 \uac83\uc73c\ub85c \uc774\ub97c \ucc98\ub9ac\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. Player \ucf54\ub8e8\ud2f4\uc744 \uc704\ud55c \ubc18\ud658 \ud0c0\uc785 \u00b6 C++ 20 Coroutines\uc5d0\uc11c \ucf54\ub8e8\ud2f4\uc744 \uc815\uc758\ud558\ub824\uba74, Coroutine Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294 \ubc18\ud658 \ud0c0\uc785\uc744 \uac00\uc838\uc57c \ud569\ub2c8\ub2e4. \uc774 \uc870\uac74\uc5d0 \ub9de\ucdb0\uc11c user_behavior_t \ub97c \uc815\uc758\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. Promise\uc5d0 \ub300\ud55c \uc0c1\uc138\ud55c \uc124\uba85\uc740 Lewiss Baker\uac00 \ub2e4\ub8ec \ubc14 \uc788\uc2b5\ub2c8\ub2e4 . \ud55c\uae00 \uc790\ub8cc\ub294 C++ Korea 5\ud68c \uc138\ubbf8\ub098\uc758 \ubc1c\ud45c\uc790\ub8cc \ub97c \ucc38\uace0\ud574\uc8fc\uc2dc\uae38 \ubc14\ub78d\ub2c8\ub2e4. \uc6b0\uc120 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc744 \uad00\ub9ac\ud558\ub294 user_behavior_t::promise_type \uc744 \uc815\uc758\ud574\uc57c \ud569\ub2c8\ub2e4. \uc5c4\ubc00\ud558\uac8c\ub294 coroutine_traits<user_behavior_t, ...>::promise_type \uc774\uc9c0\ub9cc, \uc5ec\uae30\uc11c\ub294 \uac00\uc7a5 \uac04\ub2e8\ud55c \ubc29\ubc95\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; \uac01 \ud568\uc218\ub4e4\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4. initial_suspend : \ucf54\ub8e8\ud2f4\uc774 \ud638\ucd9c(invoke)\ub418\uc5b4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc774 \uc0dd\uc131\ub41c \uc9c1\ud6c4 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 final_suspend : \ucf54\ub8e8\ud2f4\uc774 \ubc18\ud658( co_return )\ub41c \uc774\ud6c4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 unhandled_exception : \ucf54\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ucc98\ub9ac\ub418\uc9c0 \ubabb\ud55c Exception\uc774 \ubc1c\uc0dd\ud560\ub54c \ud638\ucd9c suspend_always \ud0c0\uc785 \uac1c\uccb4\ub97c \ubc18\ud658\ud558\ub294 \ud589\uc704\ub294 \ub2e8\uc21c\ud788 \ud604\uc7ac \ucf54\ub8e8\ud2f4\uc744 \uc911\ub2e8\ud558\uaca0\ub2e4\ub294 \uc758\ubbf8\uc785\ub2c8\ub2e4. \ub9cc\uc57d \uc911\ub2e8\ud558\uc9c0 \uc54a\uace0 \ubc14\ub85c \uc9c4\ud589\ud55c\ub2e4\uba74 suspend_never \ub97c \ubc18\ud658\ud558\uba74 \ub429\ub2c8\ub2e4. \uc704\uc5d0\uc11c \uc791\uc131\ud55c \uc608\uc2dc\uc5d0\uc11c player \ucf54\ub8e8\ud2f4\ub4e4\uc758 \uc9c4\ud589(suspend, resume) \uc5ec\ubd80\ub294 \ubaa8\ub450 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uc778 russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uad00\ub9ac\ud558\ubbc0\ub85c \ub450 \uacbd\uc6b0 \ubaa8\ub450 suspend_always \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. Player \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc811\uadfc \u00b6 user_behavior_t::promise_type \ub294 promise_manual_control \ub97c \uc0c1\uc18d\ubc1b\uc73c\uba74\uc11c, 2\uac00\uc9c0 \uba64\ubc84 \ud568\uc218\ub97c \uc815\uc758\ud569\ub2c8\ub2e4. return_void : co_return \uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4 get_return_object : \ucf54\ub8e8\ud2f4\uc758 \ubc18\ud658\ud0c0\uc785\uc744 \uc0dd\uc131\ud560 \uc218 \uc788\ub3c4\ub85d \uc784\uc758\uc758 \uac1c\uccb4\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4. \uc774 \uacbd\uc6b0\ub294 user_behavior_t \ub97c \ubc14\ub85c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; user_behavior_t \ub294 coroutine_handle<void> \ub97c \uc0c1\uc18d \ubc1b\uc544 resume , done , destroy \uc640 \uac19\uc774 \ucf54\ub8e8\ud2f4\uc744 \uc81c\uc5b4\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. \uc774\ub97c \uc704\ud574\uc11c\ub294 promise_type \uc73c\ub85c\ubd80\ud130 coroutine_handle<void> \ub97c \uc5bb\uc744 \ubc29\ubc95\uc774 \ud544\uc694\ud55c\ub370, \uc774\ub294 coroutine_handle<promise_type> \uc744 \uc0ac\uc6a9\ud558\uc5ec \ud574\uacb0\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc81c\uc5b4\ub294 russian_roulette \uc5d0\uc11c \uc9c1\uc811 \uc774\ub8e8\uc5b4\uc9c0\ubbc0\ub85c \uc9c0\uae08\uacfc \uac19\uc740 \ucf54\ub4dc\ub85c\ub3c4 \ubb38\uc81c\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. \ud558\uc9c0\ub9cc coroutine_handle<void> \ub294 \ub9c8\uce58 void* \ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0, \ubd80\uc8fc\uc758\ud55c \uc2e4\uc218\ub97c \uc608\ubc29\ud558\ub824\uba74 \ubcf5\uc0ac/\uc774\ub3d9 \uc0dd\uc131\uc790, \ubcf5\uc0ac/\uc774\ub3d9 \ub300\uc785 \uc5f0\uc0b0\uc790, \uc18c\uba78\uc790\ub97c \ucd94\uac00\ub85c \uc815\uc758\ud574\uc57c \ud560 \uac83\uc785\ub2c8\ub2e4. \uacb0\ub860 \u00b6 All-in-one \ucf54\ub4dc\ub294 Compiler Explorer\uc5d0\uc11c \uc2e4\ud589\ud574\ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4. https://github.com/Naios/continuable \ucc98\ub7fc future<T> \ub97c \ub354 \ud3b8\ub9ac\ud558\uac8c \uc0ac\uc6a9\ud558\uae30 \uc704\ud574 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560\uc218\ub3c4 \uc788\uc9c0\ub9cc, \uc774\ub294 \ud55c\uac00\uc9c0 \ubc29\ubc95\uc77c \ubfd0\uc785\ub2c8\ub2e4. \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc911\ub2e8 \uc9c0\uc810\uc5d0 \ub300\ud55c \uc815\ubcf4(index)\uac00 \uc788\uae30 \ub54c\ubb38\uc5d0 \uad6c\ud604\ub808\ubca8\uc5d0\uc11c\ub294 \uc0c1\ud0dc \ud328\ud134\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ub2e4\ub9cc \ucc28\uc774\uc810\uc774 \uc788\ub2e4\uba74 \uc0c1\ud0dc \ud328\ud134\uc774 \ucd94\uac00\uc801\uc778 \ud0c0\uc785\uc744 \uc791\uc131\ud574\uc57c \ud558\uc9c0\ub9cc, \ucf54\ub8e8\ud2f4\uc5d0\uc11c\ub294 \uc911\ub2e8(suspend)\uacfc \uc7ac\uac1c(resume)\ub97c \uc790\uc5f0\uc2a4\ub7fd\uac8c \uae30\uc220\ud558\ub294\ub370 \uc880 \ub354 \ucd08\uc810\uc744 \ub458 \uc218 \uc788\uc8e0. \uc774\ub294 \uc911\ub2e8\uacfc \uc7ac\uac1c\ud558\ub294 \uacfc\uc815\uc774 \ucf54\ub4dc\uc758 \uad6c\uc870\uc5d0 \uc601\ud5a5\uc744 \uc8fc\ub294 \uc77c\uc774 \uc904\uc5b4\ub4e0\ub2e4\uace0 \uc694\uc57d\ud560 \uc218 \uc788\uaca0\uc2b5\ub2c8\ub2e4.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette-kor/#russian-roulette-and-c-coroutines","text":"English \uc774\ubc88\uc5d0\ub294 \uc5ec\ub7ec \ucf54\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc5d0 \uc9d1\uc911\ud558\uace0 \uc774\ub4e4\uc758 \uc9c4\ud589\uc744 \ud558\ub098\uc758 \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uc218\ud589\ud558\ub294 \ucf54\ub4dc\ub97c \ud558\ub098 \uc791\uc131\ud574\ubcf4\uace0\uc790 \ud569\ub2c8\ub2e4. \uc608\uc2dc\ub85c\ub294 \uad49\uc7a5\ud788 \uc720\uba85\ud55c \uaddc\uce59\uc744 \uac00\uc9c4 \ub7ec\uc2dc\uc548 \ub8f0\ub81b\uacfc \uadf8 \uac8c\uc784\uc758 \ucc38\uac00\uc790\ub4e4\uc744 \uc0ac\uc6a9\ud574 \ubd24\uc2b5\ub2c8\ub2e4.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette-kor/#1","text":"\uc6b0\uc120 \ub9ac\ubcfc\ubc84\ub97c \ub9cc\ub4dc\ub294 \uac83\ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \ucc38\uac00 \uc778\uc6d0\uc774 \uc5bc\ub9c8\ub098 \uc788\uc744\uc9c0 \ubaa8\ub974\uae30 \ub54c\ubb38\uc5d0, uint32_t \ub97c \uc0ac\uc6a9\ud574 \ucda9\ubd84\ud788 \ub9ce\uc740 \uc57d\uc2e4(chamber)\uc744 \uc900\ube44\ud560 \uac81\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \uc784\uc758\uc758 \uc57d\uc2e4\uc744 \uc120\ud0dd\ud558\ub294 select_chamber \ub97c \uc544\ub798\uc640 \uac19\uc774 \uc815\uc758\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } \uacbd\uc6b0\uc5d0 \ub530\ub77c\uc11c\ub294 \uc778\uc790\ub97c \ubc1b\uc544 \uc0c1\ud669\uc5d0 \ub530\ub77c \uc57d\uc2e4\uc744 \uc120\ud0dd\ud560\uc9c0 \ubaa8\ub974\uc9c0\ub9cc, \uc774 \uc608\uc2dc\uc5d0\uc11c\ub294 \uac00\uc7a5 \ub2e8\uc21c\ud55c \ubc29\ubc95(\ubb34\uc791\uc704)\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc57d\uc2e4\uc774 \uc788\uc73c\ub2c8 \uc774\uc81c \ubc29\uc544\uc1e0(trigger)\ub97c \uc900\ube44\ud574\uc57c\uaca0\uad70\uc694. \ubc29\uc544\uc1e0\ub294 \ub2f9\uae38( pull ) \uc218 \uc788\uc73c\uba70, \ud604\uc7ac \uacf5\uc774\uac00 \ub9de\ubb3c\ub9b0 \uc57d\uc2e4( current )\uacfc \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud574\uc11c \uc54c\uace0 \uc788\uc2b5\ub2c8\ub2e4. \ud55c\ubc88 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uba74 \uc57d\uc2e4\uc774 \ud68c\uc804\ud560\ud14c\ub2c8, \uc5ec\uae30\uc11c\ub294 \uac04\ub2e8\ud788 chamber_t \uc758 \uac12\uc744 1 \uac10\uc18c \uc2dc\ud0a4\ub294 \uac83\uc73c\ub85c \uc57d\uc2e4\uc744 \ud68c\uc804\uc2dc\ud0a4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... };","title":"\ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 1: \uc57d\uc2e4/\ubc29\uc544\uc1e0"},{"location":"articles/russian-roulette-kor/#_1","text":"\uc5ec\uae30\uc11c \ubc29\uc544\uc1e0\ub294 Awaitable \ud0c0\uc785\uc73c\ub85c \uc815\uc758\ud574\uc11c, \uac8c\uc784 \ucc38\uac00\uc790\ub4e4\uc774 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae34 \ud6c4 \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\ub3c4\ub85d \ub9cc\ub4e4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; \uc774\ub807\uac8c \uc815\uc758\ud55c \uc774\uc720\ub294 \ucc38\uac00\uc790(player)\ub4e4\uc774 3\uac00\uc9c0 \uc0c1\ud0dc\ub97c \uac00\uc9c0\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4. \ubc29\uc544\uc1e0\ub97c \ub2f9\uacbc\uc9c0\ub9cc, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc9c0 \uc54a\uc558\ub2e4 (\uc0b4\uc558\ub2e4!) \ubc29\uc544\uc1e0\ub97c \ub2f9\uaca8\uc11c, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc5c8\ub2e4 (X\ub97c \ub20c\ub7ec \uc870\uc758\ub97c \ud45c\ud558\uc2ed\uc2dc\uc624.) \ucc28\ub840\ub97c \uae30\ub2e4\ub9ac\ub358 \uc911 \ub2e4\ub978 \uc0ac\ub78c\uc774 \uc774\ubbf8 \ucd1d\uc54c\uc744 \ubc1b\uc558\ub2e4 \ucf54\ub4dc\ub85c \ud45c\ud604\ud558\uc790\uba74 \uc544\ub798\uc640 \uac19\uc2b5\ub2c8\ub2e4. index \ub97c \uc0ac\uc6a9\ud574 \uac01 player \ub4e4\uc744 \uad6c\ubd84\ud558\uace0, \ucf54\ub8e8\ud2f4 \uc678\ubd80\uc5d0 \uc704\uce58\ud55c fired (\ubd88\uc774\uc57c!)\uc758 \uac12\uc744 \ubcc0\uacbd\ud558\ub294 \ubc29\ubc95\uc73c\ub85c \ucd1d\uc54c\uc774 \ubc1c\uc0ac\ub418\uc5c8\uc744 \ub54c \ub2e4\ub978 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \uc774\ub97c \ud655\uc778\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. \ubaa8\ub450\uac00 \uac19\uc740 \ub9ac\ubcfc\ubc84\uc758 \ubc29\uc544\uc1e0\ub97c \uc0ac\uc6a9\ud558\ubbc0\ub85c, trigger \ub294 \ucc38\uc870\ub97c \uc0ac\uc6a9\ud558\uc600\uc2b5\ub2c8\ub2e4. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } \uc774\ub807\uac8c \ud558\uba74 \uc2e4\uc81c\ub85c\ub294 \ubaa8\ub4e0 \ucc38\uac00\uc790 \ucf54\ub8e8\ud2f4\ub4e4\uc740 \ubc29\uc544\uc1e0\ub97c \ubbf8\ub9ac \ub2f9\uaca8\ub193\uace0 \uae30\ub2e4\ub9ac\uac8c(suspend) \ub429\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \ubc29\uc544\uc1e0\ub97c \ud55c\ubc88\uc529 \ub2f9\uae30\uba74\uc11c \ucc28\ub840\ub300\ub85c \uae68\uc6cc\ubcf4\ub294(resume) \uac83\uc774\uc8e0. \ucc28\ub840\uac00 \ub418\uba74(resumed) trigger_t \uc740 await_resume \uc758 \ubc18\ud658\uac12\uc744 \ud1b5\ud574 \uacb0\uacfc( fired )\ub97c \uc804\ub2ec\ud560 \uac83\uc774\uace0 \uadf8 \uac12\uc5d0 \ub530\ub77c\uc11c player \uc758 \ub3d9\uc791\uc774 \ub2ec\ub77c\uc9c0\uac8c \ub429\ub2c8\ub2e4.","title":"\ucc38\uac00\uc790 \ud589\ub3d9 \uc815\uc758\ud558\uae30"},{"location":"articles/russian-roulette-kor/#2","text":"\uc774\uc81c \ub9ac\ubcfc\ubc84\ub97c \ub9c8\uc800 \uc644\uc131\ud558\uace0, user_behavior_t \uc5d0 \ub300\ud574 \uc124\uba85\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc774\ubbf8 \uc704\uc5d0\uc11c trigger_t \ub97c \uc815\uc758 \ud588\uc73c\ubbc0\ub85c, revolver_t \ub294 1\uac1c\uc758 \ubc29\uc544\uc1e0\uc640 \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud55c \uc815\ubcf4\ub97c \uac00\uc9c0\uace0 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; \ubb3c\ub860 \ub204\uad70\uac00\ub294 \ub2f9\ucca8 \ub418\uc5b4\uc57c \ud558\uae30 \ub54c\ubb38\uc5d0, \ubaa8\ub4c8\ub85c \uc5f0\uc0b0\uc744 \ud558\ub294 \uac83\ub3c4 \uc78a\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4.","title":"\ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 2"},{"location":"articles/russian-roulette-kor/#_2","text":"\uc774\uc81c \ucc38\uac00\uc790\uc640 \ub3c4\uad6c(\ub9ac\ubcfc\ubc84)\uac00 \ubaa8\ub450 \uc815\uc758\ub418\uc5c8\uc73c\ub2c8, \uac8c\uc784 \uc9c4\ud589\uacfc\uc815\uc744 \ud45c\ud604\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \uc774 \uac8c\uc784\uc5d0\uc11c\ub294 \ucd1d 6\uba85\uc758 \ucc38\uac00\uc790\uac00 \uc788\ub2e4\uace0 \uac00\uc815\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } \ucc38\uac00\uc790\uc640 \ub3c4\uad6c\uac00 \uc900\ube44\ub418\uba74, russian_roulette \uc744 \ud638\ucd9c\ud558\uc5ec \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. GSL(C++ \ud575\uc2ec \uac00\uc774\ub4dc\ub77c\uc778 \uc9c0\uc6d0 \ub77c\uc774\ube0c\ub7ec\ub9ac)\uc5d0 \uc775\uc219\ud558\uc9c0 \uc54a\uc73c\uc2dc\ub354\ub77c\ub3c4 \uc77d\ub294\ub370 \ubb38\uc81c\ub294 \uc5c6\uc744 \uac83\uc785\ub2c8\ub2e4. \ubaa8\ub974\ub294 \ubd84\ub4e4\uc744 \uc704\ud574 \uc124\uba85\ud558\uc790\uba74, gsl::span \uc740 \ubc94\uc704\ub97c \ud45c\ud604\ud558\uc5ec range- for \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\uace0, gsl::finally \ub294 \uac1c\uccb4\uac00 \uc18c\uba78\ud558\ub294 \uc2dc\uc810\uc5d0 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uae30\ub2a5\uc744 \ud569\ub2c8\ub2e4. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } \ubaa8\ub4e0 player \ub4e4\uc774 fired \uc640 revolver \ub97c \uacf5\uc720\ud558\uba70 \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. \uc774\ub4e4\uc758 \ud589\ub3d9\uc740 \ucf54\ub8e8\ud2f4\uc73c\ub85c \uc815\uc758\ud558\uc600\uc2b5\ub2c8\ub2e4. \ucc38\uac00\uc790\ub4e4\uc758 \uc218\uc640 \ubb34\uad00\ud558\uac8c, russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc740 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uac00 \ub418\uc5b4 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \ucc28\ub840\ub300\ub85c \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uac8c \ub9cc\ub4e4\uac83\uc785\ub2c8\ub2e4. \uc774\ub294 task.resume() \uc744 \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9d1\ub2c8\ub2e4. \uac8c\uc784\uc740 fired \uac00 true \uac00 \ub420 \ub54c\uae4c\uc9c0 \uacc4\uc18d\ub429\ub2c8\ub2e4. \uac8c\uc784\uc774 \ub05d\ub098\uba74 on_finish \uac1c\uccb4\uac00 \ubaa8\ub4e0 \ucc38\uac00\uc790\ub4e4\uc774 \uc0ac\uc6a9\ud55c \uba54\ubaa8\ub9ac(\ucf54\ub8e8\ud2f4 \ud504\ub808\uc784)\ub97c \ud68c\uc218\ud560 \uac83\uc785\ub2c8\ub2e4. \uac04\ub2e8\ud788 frame.destroy() \ud558\ub294 \uac83\uc73c\ub85c \uc774\ub97c \ucc98\ub9ac\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.","title":"\uac8c\uc784 \uc9c4\ud589\uacfc\uc815"},{"location":"articles/russian-roulette-kor/#player","text":"C++ 20 Coroutines\uc5d0\uc11c \ucf54\ub8e8\ud2f4\uc744 \uc815\uc758\ud558\ub824\uba74, Coroutine Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294 \ubc18\ud658 \ud0c0\uc785\uc744 \uac00\uc838\uc57c \ud569\ub2c8\ub2e4. \uc774 \uc870\uac74\uc5d0 \ub9de\ucdb0\uc11c user_behavior_t \ub97c \uc815\uc758\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. Promise\uc5d0 \ub300\ud55c \uc0c1\uc138\ud55c \uc124\uba85\uc740 Lewiss Baker\uac00 \ub2e4\ub8ec \ubc14 \uc788\uc2b5\ub2c8\ub2e4 . \ud55c\uae00 \uc790\ub8cc\ub294 C++ Korea 5\ud68c \uc138\ubbf8\ub098\uc758 \ubc1c\ud45c\uc790\ub8cc \ub97c \ucc38\uace0\ud574\uc8fc\uc2dc\uae38 \ubc14\ub78d\ub2c8\ub2e4. \uc6b0\uc120 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc744 \uad00\ub9ac\ud558\ub294 user_behavior_t::promise_type \uc744 \uc815\uc758\ud574\uc57c \ud569\ub2c8\ub2e4. \uc5c4\ubc00\ud558\uac8c\ub294 coroutine_traits<user_behavior_t, ...>::promise_type \uc774\uc9c0\ub9cc, \uc5ec\uae30\uc11c\ub294 \uac00\uc7a5 \uac04\ub2e8\ud55c \ubc29\ubc95\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; \uac01 \ud568\uc218\ub4e4\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4. initial_suspend : \ucf54\ub8e8\ud2f4\uc774 \ud638\ucd9c(invoke)\ub418\uc5b4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc774 \uc0dd\uc131\ub41c \uc9c1\ud6c4 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 final_suspend : \ucf54\ub8e8\ud2f4\uc774 \ubc18\ud658( co_return )\ub41c \uc774\ud6c4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 unhandled_exception : \ucf54\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ucc98\ub9ac\ub418\uc9c0 \ubabb\ud55c Exception\uc774 \ubc1c\uc0dd\ud560\ub54c \ud638\ucd9c suspend_always \ud0c0\uc785 \uac1c\uccb4\ub97c \ubc18\ud658\ud558\ub294 \ud589\uc704\ub294 \ub2e8\uc21c\ud788 \ud604\uc7ac \ucf54\ub8e8\ud2f4\uc744 \uc911\ub2e8\ud558\uaca0\ub2e4\ub294 \uc758\ubbf8\uc785\ub2c8\ub2e4. \ub9cc\uc57d \uc911\ub2e8\ud558\uc9c0 \uc54a\uace0 \ubc14\ub85c \uc9c4\ud589\ud55c\ub2e4\uba74 suspend_never \ub97c \ubc18\ud658\ud558\uba74 \ub429\ub2c8\ub2e4. \uc704\uc5d0\uc11c \uc791\uc131\ud55c \uc608\uc2dc\uc5d0\uc11c player \ucf54\ub8e8\ud2f4\ub4e4\uc758 \uc9c4\ud589(suspend, resume) \uc5ec\ubd80\ub294 \ubaa8\ub450 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uc778 russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uad00\ub9ac\ud558\ubbc0\ub85c \ub450 \uacbd\uc6b0 \ubaa8\ub450 suspend_always \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4.","title":"Player \ucf54\ub8e8\ud2f4\uc744 \uc704\ud55c \ubc18\ud658 \ud0c0\uc785"},{"location":"articles/russian-roulette-kor/#player_1","text":"user_behavior_t::promise_type \ub294 promise_manual_control \ub97c \uc0c1\uc18d\ubc1b\uc73c\uba74\uc11c, 2\uac00\uc9c0 \uba64\ubc84 \ud568\uc218\ub97c \uc815\uc758\ud569\ub2c8\ub2e4. return_void : co_return \uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4 get_return_object : \ucf54\ub8e8\ud2f4\uc758 \ubc18\ud658\ud0c0\uc785\uc744 \uc0dd\uc131\ud560 \uc218 \uc788\ub3c4\ub85d \uc784\uc758\uc758 \uac1c\uccb4\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4. \uc774 \uacbd\uc6b0\ub294 user_behavior_t \ub97c \ubc14\ub85c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; user_behavior_t \ub294 coroutine_handle<void> \ub97c \uc0c1\uc18d \ubc1b\uc544 resume , done , destroy \uc640 \uac19\uc774 \ucf54\ub8e8\ud2f4\uc744 \uc81c\uc5b4\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. \uc774\ub97c \uc704\ud574\uc11c\ub294 promise_type \uc73c\ub85c\ubd80\ud130 coroutine_handle<void> \ub97c \uc5bb\uc744 \ubc29\ubc95\uc774 \ud544\uc694\ud55c\ub370, \uc774\ub294 coroutine_handle<promise_type> \uc744 \uc0ac\uc6a9\ud558\uc5ec \ud574\uacb0\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc81c\uc5b4\ub294 russian_roulette \uc5d0\uc11c \uc9c1\uc811 \uc774\ub8e8\uc5b4\uc9c0\ubbc0\ub85c \uc9c0\uae08\uacfc \uac19\uc740 \ucf54\ub4dc\ub85c\ub3c4 \ubb38\uc81c\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. \ud558\uc9c0\ub9cc coroutine_handle<void> \ub294 \ub9c8\uce58 void* \ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0, \ubd80\uc8fc\uc758\ud55c \uc2e4\uc218\ub97c \uc608\ubc29\ud558\ub824\uba74 \ubcf5\uc0ac/\uc774\ub3d9 \uc0dd\uc131\uc790, \ubcf5\uc0ac/\uc774\ub3d9 \ub300\uc785 \uc5f0\uc0b0\uc790, \uc18c\uba78\uc790\ub97c \ucd94\uac00\ub85c \uc815\uc758\ud574\uc57c \ud560 \uac83\uc785\ub2c8\ub2e4.","title":"Player \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc811\uadfc"},{"location":"articles/russian-roulette-kor/#_3","text":"All-in-one \ucf54\ub4dc\ub294 Compiler Explorer\uc5d0\uc11c \uc2e4\ud589\ud574\ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4. https://github.com/Naios/continuable \ucc98\ub7fc future<T> \ub97c \ub354 \ud3b8\ub9ac\ud558\uac8c \uc0ac\uc6a9\ud558\uae30 \uc704\ud574 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560\uc218\ub3c4 \uc788\uc9c0\ub9cc, \uc774\ub294 \ud55c\uac00\uc9c0 \ubc29\ubc95\uc77c \ubfd0\uc785\ub2c8\ub2e4. \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc911\ub2e8 \uc9c0\uc810\uc5d0 \ub300\ud55c \uc815\ubcf4(index)\uac00 \uc788\uae30 \ub54c\ubb38\uc5d0 \uad6c\ud604\ub808\ubca8\uc5d0\uc11c\ub294 \uc0c1\ud0dc \ud328\ud134\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ub2e4\ub9cc \ucc28\uc774\uc810\uc774 \uc788\ub2e4\uba74 \uc0c1\ud0dc \ud328\ud134\uc774 \ucd94\uac00\uc801\uc778 \ud0c0\uc785\uc744 \uc791\uc131\ud574\uc57c \ud558\uc9c0\ub9cc, \ucf54\ub8e8\ud2f4\uc5d0\uc11c\ub294 \uc911\ub2e8(suspend)\uacfc \uc7ac\uac1c(resume)\ub97c \uc790\uc5f0\uc2a4\ub7fd\uac8c \uae30\uc220\ud558\ub294\ub370 \uc880 \ub354 \ucd08\uc810\uc744 \ub458 \uc218 \uc788\uc8e0. \uc774\ub294 \uc911\ub2e8\uacfc \uc7ac\uac1c\ud558\ub294 \uacfc\uc815\uc774 \ucf54\ub4dc\uc758 \uad6c\uc870\uc5d0 \uc601\ud5a5\uc744 \uc8fc\ub294 \uc77c\uc774 \uc904\uc5b4\ub4e0\ub2e4\uace0 \uc694\uc57d\ud560 \uc218 \uc788\uaca0\uc2b5\ub2c8\ub2e4.","title":"\uacb0\ub860"},{"location":"articles/russian-roulette/","text":"Russian Roulette and C++ Coroutines \u00b6 \ud55c\uad6d\uc5b4 In this post, I'd like to show an example which separates definition of a behavior and its execution. For the example, the Russian Roulette is used. Following its famous rule, the players' behavior are defined using the coroutine and a game with those players will written be written in an ordinary subroutine. Making a revolver 1: Chamber/Trigger \u00b6 Let's start with makeing a revolver. Since we don't know how many players are going to join, uint32_t will be used to define the value space for the chamber. And we need an additional function, select_chamber , to select one chamber value. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } This is indeed the most simple implementation. It might be more complex for the real case, but let's use it anyway. We need a trigger now. Of course it can be pull ed, and it knows which chamber is loaded and which chamber is going to be fired for the moment( current ). After pull operation, simply decreasing 1 from the chamber_t 's value. Remind that we are going to use a revolver! // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... }; Defining the players' behavior \u00b6 In addition to that, let's make the trigger to an awaitable type. So all players can wait for the bullet after pulling it. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; By doing so, each player will be in one of the 3 state. Pulled the trigger, and not fired. (Alive!) Pulled the trigger, and fired. (Hold X to pay respect) Waiting for its turn, and another player received the bullet. In the 'code' form, it will be like the following. index is for distinguishing each player instance. fired should be non-local since the other player will monitor its value. Also trigger is passed by reference because all players share 1 revolver. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } What a short function! Remind that trigger_t is an awaitable type. So each player will suspend immediately after pulling the trigger. After all players become suspended, then we will resume them one by one. When a player is resumed, it will check the return value of the await_resume and notify the resule( fired ) by storing the result. Of course the player behavior branches with it. Making a revolver 2 \u00b6 Let me explain about the user_behavior_t after finishing the definition of the revolver and the game. 1 revolver owns 1 trigger. The point will be expressed through the implementation inheritance. In addition to that, revolver_t must be aware of the loaded chamber. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; Because someone must win the prize, we didn't forget to apply modular arithmetic. Progress of the game \u00b6 Now it's time to define a execution of the game. I already told you it's an ordinay subroutine. Assume that we have 6 players for 1 game. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } The game, russian_roulette is invoked with the resources. You may not aware of the the GSL(C++ Core G uideline S upport L ibrary), but don't take it so hard. gsl::span is a pair of the pointer and length to support range- for statement, gsl::finally invokes a given funcion object in its destuction phase. Here, by using it we can guarantee clean up of the coroutine frame. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } Like I said all player s share fired variable and revolver instance. Their behavior is defined using the coroutine. russian_roulette subroutine becomes the moderator of the game with the control flow. It's task is to continue this turn-based game by resuming each player coroutine. When they are resumed through task.resume() first time, they will pull the trigger and suspend again. The game continues (by resume) until fired becomes true . When there is a victim, the subroutine will return and on_finish object will destroy all players' coroutine frame. Simply using frame.destroy() will do the work. Return type for the player coroutine \u00b6 In C++ 20 Coroutines, the return type of the coroutine must fulfill the Coroutine Promise Requirement. user_behavior_t is such kind of the type. You can see the Lewiss Baker's post about it The first thing we have to do is to define user_behavior_t::promise_type which manages the coroutine frame. We can use coroutine_traits<user_behavior_t, ...>::promise_type to do the work, but let's go through the easy way :) #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; Each function's role is like the following. initial_suspend : Decide whether to suspend after the coroutine functions is invoked. At this moment the coroutine's frame is allocated. final_suspend : Decide whether to suspend after the coroutine function is returned( co_return ). unhandled_exception : Invoked when an exception is thrown in the coroutine function's body Returning suspend_always type means that the coroutine is willing to suspend for the defined moment. If you don't want to suspend and continue the flow, you should return suspend_never . For this example, player coroutine's creation, progress(suspend/resume), destruction is fully managed by the subroutine russian_roulette . So we will return suspend_always type and forget about the other concerns. Exposing the player coroutine's frame \u00b6 user_behavior_t::promise_type inherits promise_manual_control and add 2 funtion to meet the requirement. return_void : invoked just after co_return get_return_object : the function's return becomes the return type of the coroutine function. Here, we will return user_behavior_t directly. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; The inheritance is public . So it exposes those member functions which controls the coroutine. ( resume , done , and destroy ) After its base class construction, coroutine_handle<void> is in the empty state. Here, I used the simplest way to translate promise_type to its matching coroutine_handle<void> . You can see that from_promise of the coroutine_handle<promise_type> is doing the work. Unless we trust the execution manager, russian_roulette , such exposure won't matter. Remind that coroutine_handle<void> follows the semantics of void* . So if you want to prevent some mistakes for future extenstion, you had better define or delete copy/move functions and its destructor. Conclusion \u00b6 You can run the all-in-one code with the Compiler Explorer. Like https://github.com/Naios/continuable, C++ Coroutines can be used like a sugar for the future<T> . But that's the not only usage. Since the coroutine frame contains an index to distinguish its suspension points, we can't tell it is totaly different from the state pattern. We need to define awaitable type and the return types for our logic, but by doing so the point of suspension and continuation can be written more naturally. For my perspective this gives more resilience to the code.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette/#russian-roulette-and-c-coroutines","text":"\ud55c\uad6d\uc5b4 In this post, I'd like to show an example which separates definition of a behavior and its execution. For the example, the Russian Roulette is used. Following its famous rule, the players' behavior are defined using the coroutine and a game with those players will written be written in an ordinary subroutine.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette/#making-a-revolver-1-chambertrigger","text":"Let's start with makeing a revolver. Since we don't know how many players are going to join, uint32_t will be used to define the value space for the chamber. And we need an additional function, select_chamber , to select one chamber value. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } This is indeed the most simple implementation. It might be more complex for the real case, but let's use it anyway. We need a trigger now. Of course it can be pull ed, and it knows which chamber is loaded and which chamber is going to be fired for the moment( current ). After pull operation, simply decreasing 1 from the chamber_t 's value. Remind that we are going to use a revolver! // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... };","title":"Making a revolver 1: Chamber/Trigger"},{"location":"articles/russian-roulette/#defining-the-players-behavior","text":"In addition to that, let's make the trigger to an awaitable type. So all players can wait for the bullet after pulling it. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; By doing so, each player will be in one of the 3 state. Pulled the trigger, and not fired. (Alive!) Pulled the trigger, and fired. (Hold X to pay respect) Waiting for its turn, and another player received the bullet. In the 'code' form, it will be like the following. index is for distinguishing each player instance. fired should be non-local since the other player will monitor its value. Also trigger is passed by reference because all players share 1 revolver. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } What a short function! Remind that trigger_t is an awaitable type. So each player will suspend immediately after pulling the trigger. After all players become suspended, then we will resume them one by one. When a player is resumed, it will check the return value of the await_resume and notify the resule( fired ) by storing the result. Of course the player behavior branches with it.","title":"Defining the players' behavior"},{"location":"articles/russian-roulette/#making-a-revolver-2","text":"Let me explain about the user_behavior_t after finishing the definition of the revolver and the game. 1 revolver owns 1 trigger. The point will be expressed through the implementation inheritance. In addition to that, revolver_t must be aware of the loaded chamber. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; Because someone must win the prize, we didn't forget to apply modular arithmetic.","title":"Making a revolver 2"},{"location":"articles/russian-roulette/#progress-of-the-game","text":"Now it's time to define a execution of the game. I already told you it's an ordinay subroutine. Assume that we have 6 players for 1 game. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } The game, russian_roulette is invoked with the resources. You may not aware of the the GSL(C++ Core G uideline S upport L ibrary), but don't take it so hard. gsl::span is a pair of the pointer and length to support range- for statement, gsl::finally invokes a given funcion object in its destuction phase. Here, by using it we can guarantee clean up of the coroutine frame. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } Like I said all player s share fired variable and revolver instance. Their behavior is defined using the coroutine. russian_roulette subroutine becomes the moderator of the game with the control flow. It's task is to continue this turn-based game by resuming each player coroutine. When they are resumed through task.resume() first time, they will pull the trigger and suspend again. The game continues (by resume) until fired becomes true . When there is a victim, the subroutine will return and on_finish object will destroy all players' coroutine frame. Simply using frame.destroy() will do the work.","title":"Progress of the game"},{"location":"articles/russian-roulette/#return-type-for-the-player-coroutine","text":"In C++ 20 Coroutines, the return type of the coroutine must fulfill the Coroutine Promise Requirement. user_behavior_t is such kind of the type. You can see the Lewiss Baker's post about it The first thing we have to do is to define user_behavior_t::promise_type which manages the coroutine frame. We can use coroutine_traits<user_behavior_t, ...>::promise_type to do the work, but let's go through the easy way :) #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; Each function's role is like the following. initial_suspend : Decide whether to suspend after the coroutine functions is invoked. At this moment the coroutine's frame is allocated. final_suspend : Decide whether to suspend after the coroutine function is returned( co_return ). unhandled_exception : Invoked when an exception is thrown in the coroutine function's body Returning suspend_always type means that the coroutine is willing to suspend for the defined moment. If you don't want to suspend and continue the flow, you should return suspend_never . For this example, player coroutine's creation, progress(suspend/resume), destruction is fully managed by the subroutine russian_roulette . So we will return suspend_always type and forget about the other concerns.","title":"Return type for the player coroutine"},{"location":"articles/russian-roulette/#exposing-the-player-coroutines-frame","text":"user_behavior_t::promise_type inherits promise_manual_control and add 2 funtion to meet the requirement. return_void : invoked just after co_return get_return_object : the function's return becomes the return type of the coroutine function. Here, we will return user_behavior_t directly. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; The inheritance is public . So it exposes those member functions which controls the coroutine. ( resume , done , and destroy ) After its base class construction, coroutine_handle<void> is in the empty state. Here, I used the simplest way to translate promise_type to its matching coroutine_handle<void> . You can see that from_promise of the coroutine_handle<promise_type> is doing the work. Unless we trust the execution manager, russian_roulette , such exposure won't matter. Remind that coroutine_handle<void> follows the semantics of void* . So if you want to prevent some mistakes for future extenstion, you had better define or delete copy/move functions and its destructor.","title":"Exposing the player coroutine's frame"},{"location":"articles/russian-roulette/#conclusion","text":"You can run the all-in-one code with the Compiler Explorer. Like https://github.com/Naios/continuable, C++ Coroutines can be used like a sugar for the future<T> . But that's the not only usage. Since the coroutine frame contains an index to distinguish its suspension points, we can't tell it is totaly different from the state pattern. We need to define awaitable type and the return types for our logic, but by doing so the point of suspension and continuation can be written more naturally. For my perspective this gives more resilience to the code.","title":"Conclusion"},{"location":"articles/windll-linking-issues/","text":"Work In Progress ... :o","title":"Windll linking issues"},{"location":"features/channel-overview/","text":"Overview: Coroutine based channel \u00b6 This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutines libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible. See Also \u00b6 Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way. Example \u00b6 test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp Channel with a Lockable \u00b6 When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader . Template Parameters \u00b6 T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type Default Operations \u00b6 As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception. Member Variables \u00b6 Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; Functions \u00b6 Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Overview: Coroutine based channel"},{"location":"features/channel-overview/#overview-coroutine-based-channel","text":"This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutines libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible.","title":"Overview: Coroutine based channel"},{"location":"features/channel-overview/#see-also","text":"Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way.","title":"See Also"},{"location":"features/channel-overview/#example","text":"test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp","title":"Example"},{"location":"features/channel-overview/#channel-with-a-lockable","text":"When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader .","title":"Channel with a Lockable"},{"location":"features/channel-overview/#template-parameters","text":"T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type","title":"Template Parameters"},{"location":"features/channel-overview/#default-operations","text":"As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception.","title":"Default Operations"},{"location":"features/channel-overview/#member-variables","text":"Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Member Variables"},{"location":"features/channel-overview/#functions","text":"Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Functions"},{"location":"features/channel-read_write/","text":"Current version uses helper types to use channel in a designed manner. The types implements awaitable interface that is required by co_await operator. namespace coro { template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro See Also \u00b6 Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" Example \u00b6 test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp Awaitable Channel Read \u00b6 Short Example \u00b6 using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Type: reader<T, M> \u00b6 The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed). Awaitable Channel Write \u00b6 Short Example \u00b6 using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Type: writer<T, M> \u00b6 The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"Channel read write"},{"location":"features/channel-read_write/#see-also","text":"Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\"","title":"See Also"},{"location":"features/channel-read_write/#example","text":"test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp","title":"Example"},{"location":"features/channel-read_write/#awaitable-channel-read","text":"","title":"Awaitable Channel Read"},{"location":"features/channel-read_write/#short-example","text":"using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"features/channel-read_write/#type-readerltt-mgt","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed).","title":"Type: reader&lt;T, M&gt;"},{"location":"features/channel-read_write/#awaitable-channel-write","text":"","title":"Awaitable Channel Write"},{"location":"features/channel-read_write/#short-example_1","text":"using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"features/channel-read_write/#type-writerltt-mgt","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"Type: writer&lt;T, M&gt;"},{"location":"features/channel-select/","text":"Current version uses helper types to use channel in a designed manner. namespace coro { template < typename T , typename M > class channel ; template < typename T , typename M > class peeker ; } // namespace coro See Also \u00b6 Channel Concept Channel Read/Write Example \u00b6 test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp Channel Non-blocking Select \u00b6 Short Example \u00b6 using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); } Selecting a pair from arguments \u00b6 To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro Channel Peek Operation \u00b6 peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"Channel select"},{"location":"features/channel-select/#see-also","text":"Channel Concept Channel Read/Write","title":"See Also"},{"location":"features/channel-select/#example","text":"test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp","title":"Example"},{"location":"features/channel-select/#channel-non-blocking-select","text":"","title":"Channel Non-blocking Select"},{"location":"features/channel-select/#short-example","text":"using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); }","title":"Short Example"},{"location":"features/channel-select/#selecting-a-pair-from-arguments","text":"To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro","title":"Selecting a pair from arguments"},{"location":"features/channel-select/#channel-peek-operation","text":"peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"Channel Peek Operation"},{"location":"features/concrt-latch/","text":"See Also \u00b6 Go Language: sync.WaitGroup C++ Concurrency TS: Latch latch \u00b6 The type is used for synchronization in fork-join scenario. It will be removed when it C++ Concurrency TS becomes available. Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of the concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt Definition (Windows) \u00b6 The implementation uses Win32 Event object and a counter using <atomic> . The win32_event here doesn't support co_await expression. namespace concrt { class latch { atomic_uint64_t ref {}; mutable win32_event ev {}; // ... }; } // namespace concrt Definiton (POSIX) \u00b6 The implementation uses pthread_cond_t and pthread_mutex_t . It checks spurious wake-up so it can wait without timeout like the concurrency TS. namespace concrt { class latch { atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; // ... }; } // namespace concrt Example \u00b6 Wait for multiple times Throws exception when counter becomes negative test/channel_race_no_leak.cpp test/net_echo_tcp.cpp","title":"Concrt latch"},{"location":"features/concrt-latch/#see-also","text":"Go Language: sync.WaitGroup C++ Concurrency TS: Latch","title":"See Also"},{"location":"features/concrt-latch/#latch","text":"The type is used for synchronization in fork-join scenario. It will be removed when it C++ Concurrency TS becomes available. Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of the concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt","title":"latch"},{"location":"features/concrt-latch/#definition-windows","text":"The implementation uses Win32 Event object and a counter using <atomic> . The win32_event here doesn't support co_await expression. namespace concrt { class latch { atomic_uint64_t ref {}; mutable win32_event ev {}; // ... }; } // namespace concrt","title":"Definition (Windows)"},{"location":"features/concrt-latch/#definiton-posix","text":"The implementation uses pthread_cond_t and pthread_mutex_t . It checks spurious wake-up so it can wait without timeout like the concurrency TS. namespace concrt { class latch { atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; // ... }; } // namespace concrt","title":"Definiton (POSIX)"},{"location":"features/concrt-latch/#example","text":"Wait for multiple times Throws exception when counter becomes negative test/channel_race_no_leak.cpp test/net_echo_tcp.cpp","title":"Example"},{"location":"features/concrt-overview/","text":"#include <coroutine/concrt.h> using namespace concrt ; References \u00b6 C++ Reference: Extensions for concurrency Background \u00b6 When I requested for the explanation about the coroutine concept, I mostly start with notifing that the coroutine is irrelevent with the thread (see page 6) . What I explain is, in short: The coroutine is about the routine's design The thread is about the processor abstraction (CPU in general) Therefore, all program with the coroutine must be able to run on (only) 1 thread. Just notice that using a thread is an issue of the implementation, and using a C++ 20 coroutine is an issue of the design. Indeed you can use both together and they can work in harmony. What I want you to know here is that they have a different domain. Contents \u00b6 #include <coroutine/concrt.h> using namespace concrt ; There are 2 family. For Windows and for non-Windows. Shared \u00b6 section latch Windows \u00b6 ptp_work ptp_event Linux + Darwin (POSIX + System API) \u00b6 event and signaled_event_tasks TBA: implementation note for the Darwin","title":"Concrt overview"},{"location":"features/concrt-overview/#references","text":"C++ Reference: Extensions for concurrency","title":"References"},{"location":"features/concrt-overview/#background","text":"When I requested for the explanation about the coroutine concept, I mostly start with notifing that the coroutine is irrelevent with the thread (see page 6) . What I explain is, in short: The coroutine is about the routine's design The thread is about the processor abstraction (CPU in general) Therefore, all program with the coroutine must be able to run on (only) 1 thread. Just notice that using a thread is an issue of the implementation, and using a C++ 20 coroutine is an issue of the design. Indeed you can use both together and they can work in harmony. What I want you to know here is that they have a different domain.","title":"Background"},{"location":"features/concrt-overview/#contents","text":"#include <coroutine/concrt.h> using namespace concrt ; There are 2 family. For Windows and for non-Windows.","title":"Contents"},{"location":"features/concrt-overview/#shared","text":"section latch","title":"Shared"},{"location":"features/concrt-overview/#windows","text":"ptp_work ptp_event","title":"Windows"},{"location":"features/concrt-overview/#linux-darwin-posix-system-api","text":"event and signaled_event_tasks TBA: implementation note for the Darwin","title":"Linux + Darwin (POSIX + System API)"},{"location":"features/concrt-posix_event/","text":"","title":"Concrt posix event"},{"location":"features/concrt-ptp_event/","text":"Win32 Event Object + Coroutine \u00b6 See Also \u00b6 MSDN: Using Event Objects ptp_event \u00b6 Awaitable event with the Windows Thread Pool API. Allows mutliple usage with 1 instance. But only 1 co_await is possible each time. Example \u00b6 Wait until signal Cancel #include <coroutine/concrt.h> #include <coroutine/return.h> using namespace concrt ; using namespace coro ; auto wait_an_event ( ptp_event & wo , atomic_flag & flag ) -> no_return { // wait for set or cancel // `co_await` will forward `GetLastError` if canceled. if ( DWORD ec = co_await wo ) { FAIL_WITH_MESSAGE ( system_category (). message ( ec )); co_return ; } flag . test_and_set (); } auto ptp_event_set_test () { // Notice that the Event Object is managed separately. HANDLE ev = CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , // EVENT_ALL_ACCESS ); auto on_return = gsl :: finally ([ ev ]() { CloseHandle ( ev ); }); ptp_event waitable { ev }; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_an_event ( waitable , flag ); SetEvent ( ev ); SleepEx ( 3 , true ); // give time to the waiting threas set the `flag` REQUIRE ( flag . test_and_set ()); } Definition \u00b6 modules/windows/concrt.cpp class ptp_event final : no_copy_move { HANDLE wo {}; private : // WAITORTIMERCALLBACK static void __stdcall wait_on_thread_pool ( PVOID , BOOLEAN ); public : explicit ptp_event ( HANDLE target ) noexcept ( false ); ~ ptp_event () noexcept ; void cancel () noexcept ; bool await_ready () noexcept ; void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ); uint32_t await_resume () noexcept ; }; Since it uses INFINITE wait, user must make sure one of SetEvent or cancel will happen on the object. Default Operations \u00b6 The type is not copyable and movable. Functions \u00b6 Function Description cancel Cancel the waiting ptp_event . The waiting coroutine will be resumed automatically by the Win32 thread. await_ready Always returns false ( suspend_always ) await_suspend Attach a background thread work to wait the SetEvent await_resume Unregister the wait operation so it can be used again.","title":"Win32 Event Object + Coroutine"},{"location":"features/concrt-ptp_event/#win32-event-object-coroutine","text":"","title":"Win32 Event Object + Coroutine"},{"location":"features/concrt-ptp_event/#see-also","text":"MSDN: Using Event Objects","title":"See Also"},{"location":"features/concrt-ptp_event/#ptp_event","text":"Awaitable event with the Windows Thread Pool API. Allows mutliple usage with 1 instance. But only 1 co_await is possible each time.","title":"ptp_event"},{"location":"features/concrt-ptp_event/#example","text":"Wait until signal Cancel #include <coroutine/concrt.h> #include <coroutine/return.h> using namespace concrt ; using namespace coro ; auto wait_an_event ( ptp_event & wo , atomic_flag & flag ) -> no_return { // wait for set or cancel // `co_await` will forward `GetLastError` if canceled. if ( DWORD ec = co_await wo ) { FAIL_WITH_MESSAGE ( system_category (). message ( ec )); co_return ; } flag . test_and_set (); } auto ptp_event_set_test () { // Notice that the Event Object is managed separately. HANDLE ev = CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , // EVENT_ALL_ACCESS ); auto on_return = gsl :: finally ([ ev ]() { CloseHandle ( ev ); }); ptp_event waitable { ev }; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_an_event ( waitable , flag ); SetEvent ( ev ); SleepEx ( 3 , true ); // give time to the waiting threas set the `flag` REQUIRE ( flag . test_and_set ()); }","title":"Example"},{"location":"features/concrt-ptp_event/#definition","text":"modules/windows/concrt.cpp class ptp_event final : no_copy_move { HANDLE wo {}; private : // WAITORTIMERCALLBACK static void __stdcall wait_on_thread_pool ( PVOID , BOOLEAN ); public : explicit ptp_event ( HANDLE target ) noexcept ( false ); ~ ptp_event () noexcept ; void cancel () noexcept ; bool await_ready () noexcept ; void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ); uint32_t await_resume () noexcept ; }; Since it uses INFINITE wait, user must make sure one of SetEvent or cancel will happen on the object.","title":"Definition"},{"location":"features/concrt-ptp_event/#default-operations","text":"The type is not copyable and movable.","title":"Default Operations"},{"location":"features/concrt-ptp_event/#functions","text":"Function Description cancel Cancel the waiting ptp_event . The waiting coroutine will be resumed automatically by the Win32 thread. await_ready Always returns false ( suspend_always ) await_suspend Attach a background thread work to wait the SetEvent await_resume Unregister the wait operation so it can be used again.","title":"Functions"},{"location":"features/concrt-ptp_work/","text":"Win32 Thread Pool Work + Coroutine \u00b6 See Also \u00b6 CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions MSDN: CreateThreadpoolWork WandBox example: A function that selects its thread ptp_work \u00b6 Change current coroutine's execution thread to background thread in the windows thread pool. Example \u00b6 #include <coroutine/return.h> // for `no_return` #include <coroutine/concrt.h> using namespace coro ; // for `no_return` using namespace concrt ; // the example might fail because of the constant folding auto switch_to_background () -> no_return { auto before = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread in the pool auto after = GetCurrentThreadId (); Assert :: IsTrue ( before != after ); } Like the example, it is recommended to use it as a temporary object. Definition \u00b6 modules/windows/concrt.cpp namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt Default Operations \u00b6 The type doesn't require memory (0-byte size). And it is a regular type. Functions \u00b6 Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"Win32 Thread Pool Work + Coroutine"},{"location":"features/concrt-ptp_work/#win32-thread-pool-work-coroutine","text":"","title":"Win32 Thread Pool Work + Coroutine"},{"location":"features/concrt-ptp_work/#see-also","text":"CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions MSDN: CreateThreadpoolWork WandBox example: A function that selects its thread","title":"See Also"},{"location":"features/concrt-ptp_work/#ptp_work","text":"Change current coroutine's execution thread to background thread in the windows thread pool.","title":"ptp_work"},{"location":"features/concrt-ptp_work/#example","text":"#include <coroutine/return.h> // for `no_return` #include <coroutine/concrt.h> using namespace coro ; // for `no_return` using namespace concrt ; // the example might fail because of the constant folding auto switch_to_background () -> no_return { auto before = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread in the pool auto after = GetCurrentThreadId (); Assert :: IsTrue ( before != after ); } Like the example, it is recommended to use it as a temporary object.","title":"Example"},{"location":"features/concrt-ptp_work/#definition","text":"modules/windows/concrt.cpp namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt","title":"Definition"},{"location":"features/concrt-ptp_work/#default-operations","text":"The type doesn't require memory (0-byte size). And it is a regular type.","title":"Default Operations"},{"location":"features/concrt-ptp_work/#functions","text":"Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"Functions"},{"location":"features/concrt-section/","text":"See Also \u00b6 Concept: BasicLockable section : Critical Section \u00b6 A basic lockable type with System API. The type is not copyable and movable. The purpose of this type is to provide a thin wrapper to use a lockable type in this library's test codes . namespace concrt { class section final : no_copy_move { // ... public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt Definition (Windows) \u00b6 With Win32 API, It uses CRITICAL_SECTION instead of SRWLock . Even though SRWLock doesn't require deallocation and possibly good for performance reason, CRITICAL_SECTION is used since the type is for test code. namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { // ... }; } // namepace concrt Definition (POSIX) \u00b6 With POSIX API, it uses pthread_rwlock_t . The type's existance is only for platform compatibility of test codes. The type was written with pthread_mutex_t to replace std::mutex in test code. The reason was that some test codes required different setting like PTHREAD_PRIO_NONE . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; // ... }; } // namepace concrt Example \u00b6 #include <coroutine/concrt.h> using namespace concrt ; void perform_with_lock ( section & m ){ std :: lock_guard lck { m }; // do some work... } In this library: test/channel_race_no_leak.cpp","title":"Concrt section"},{"location":"features/concrt-section/#see-also","text":"Concept: BasicLockable","title":"See Also"},{"location":"features/concrt-section/#section-critical-section","text":"A basic lockable type with System API. The type is not copyable and movable. The purpose of this type is to provide a thin wrapper to use a lockable type in this library's test codes . namespace concrt { class section final : no_copy_move { // ... public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt","title":"section: Critical Section"},{"location":"features/concrt-section/#definition-windows","text":"With Win32 API, It uses CRITICAL_SECTION instead of SRWLock . Even though SRWLock doesn't require deallocation and possibly good for performance reason, CRITICAL_SECTION is used since the type is for test code. namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { // ... }; } // namepace concrt","title":"Definition (Windows)"},{"location":"features/concrt-section/#definition-posix","text":"With POSIX API, it uses pthread_rwlock_t . The type's existance is only for platform compatibility of test codes. The type was written with pthread_mutex_t to replace std::mutex in test code. The reason was that some test codes required different setting like PTHREAD_PRIO_NONE . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; // ... }; } // namepace concrt","title":"Definition (POSIX)"},{"location":"features/concrt-section/#example","text":"#include <coroutine/concrt.h> using namespace concrt ; void perform_with_lock ( section & m ){ std :: lock_guard lck { m }; // do some work... } In this library: test/channel_race_no_leak.cpp","title":"Example"},{"location":"features/frame-compiler_specific/","text":"This document covers compiler specific issues. See Also \u00b6 <coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo Compiler Awareness \u00b6 The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ... Compiler Intrinsic \u00b6 For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); Coroutine Frame Prefix \u00b6 The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Frame compiler specific"},{"location":"features/frame-compiler_specific/#see-also","text":"<coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo","title":"See Also"},{"location":"features/frame-compiler_specific/#compiler-awareness","text":"The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ...","title":"Compiler Awareness"},{"location":"features/frame-compiler_specific/#compiler-intrinsic","text":"For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * );","title":"Compiler Intrinsic"},{"location":"features/frame-compiler_specific/#coroutine-frame-prefix","text":"The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Coroutine Frame Prefix"},{"location":"features/frame-coroutine_handle/","text":"See Also \u00b6 n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later Library Issues \u00b6 https://github.com/luncliff/coroutine/issues/23 Coroutine Handle (Standard) \u00b6 ToDo: Summarize the standard docs Coroutine Handle (Custom) \u00b6 Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; } Template Parameters \u00b6 PromiseType must fulfills the Coroutine Promise Requirement. Default Operations \u00b6 The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... } With Void \u00b6 Mostly the type will be used with void as its promise type( coroutine_handle<void> ). In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; } With Promise \u00b6 When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; } Non-Member Functions \u00b6 Compare Operators \u00b6 namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"Frame coroutine handle"},{"location":"features/frame-coroutine_handle/#see-also","text":"n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later","title":"See Also"},{"location":"features/frame-coroutine_handle/#library-issues","text":"https://github.com/luncliff/coroutine/issues/23","title":"Library Issues"},{"location":"features/frame-coroutine_handle/#coroutine-handle-standard","text":"ToDo: Summarize the standard docs","title":"Coroutine Handle (Standard)"},{"location":"features/frame-coroutine_handle/#coroutine-handle-custom","text":"Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; }","title":"Coroutine Handle (Custom)"},{"location":"features/frame-coroutine_handle/#template-parameters","text":"PromiseType must fulfills the Coroutine Promise Requirement.","title":"Template Parameters"},{"location":"features/frame-coroutine_handle/#default-operations","text":"The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... }","title":"Default Operations"},{"location":"features/frame-coroutine_handle/#with-void","text":"Mostly the type will be used with void as its promise type( coroutine_handle<void> ). In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; }","title":"With Void"},{"location":"features/frame-coroutine_handle/#with-promise","text":"When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; }","title":"With Promise"},{"location":"features/frame-coroutine_handle/#non-member-functions","text":"","title":"Non-Member Functions"},{"location":"features/frame-coroutine_handle/#compare-operators","text":"namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"Compare Operators"},{"location":"features/frame-coroutine_traits/","text":"This document covers coroutine_traits<R, P...> . Coroutine Traits (Standard) \u00b6 TBA Coroutine Traits (Custom) \u00b6 Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"Frame coroutine traits"},{"location":"features/frame-coroutine_traits/#coroutine-traits-standard","text":"TBA","title":"Coroutine Traits (Standard)"},{"location":"features/frame-coroutine_traits/#coroutine-traits-custom","text":"Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"Coroutine Traits (Custom)"},{"location":"features/frame-overview/","text":"#include <coroutine/frame.h> using namespace std :: experimental ; References \u00b6 http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0664r0.html ToDo organize list in this issue add list for the latest ones Background \u00b6 C++ Coroutines is so compiler specific that we can't compile VC++'s <experimental/coroutine> with Clang compiler, and vice versa. Because this is an example project, I believe I have a duty to show people how to configure projects under those envionments. The start was clang-cl on Windows, and I solved some problems related to the difference between 2 compilers. For that, there was no way but to add a wrapper header file. <coroutine/frame.h> file is an adapter to handle coroutine frame's difference between compilers. (For now, they are MSVC and Clang ). Notice that the file imports <experimental/coroutine> . Just like below, <coroutine/frame.h> activates custom implementation only for specific environments. // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) // C++ 20 # include <coroutine> # elif __has_include(<experimental/coroutine>) // C++ 17 # include <experimental/coroutine> # endif #endif // ... So in general you don't have to care. Think of <coroutine/frame.h> as <coroutine> in the future. #if __has_include(<coroutine>) # include <coroutine> #else # include <coroutine/frame.h> #endif If you're really curious, read the file and please review my approach. :) Contents \u00b6 I'm going to cover both the standard and my implementation in this section. You can think these items are the supplement of https://en.cppreference.com/w/cpp . #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> coroutine_traits<R, P...> suspend_never and suspend_always Note: Compiler Specific Issues","title":"Frame overview"},{"location":"features/frame-overview/#references","text":"http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0664r0.html ToDo organize list in this issue add list for the latest ones","title":"References"},{"location":"features/frame-overview/#background","text":"C++ Coroutines is so compiler specific that we can't compile VC++'s <experimental/coroutine> with Clang compiler, and vice versa. Because this is an example project, I believe I have a duty to show people how to configure projects under those envionments. The start was clang-cl on Windows, and I solved some problems related to the difference between 2 compilers. For that, there was no way but to add a wrapper header file. <coroutine/frame.h> file is an adapter to handle coroutine frame's difference between compilers. (For now, they are MSVC and Clang ). Notice that the file imports <experimental/coroutine> . Just like below, <coroutine/frame.h> activates custom implementation only for specific environments. // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) // C++ 20 # include <coroutine> # elif __has_include(<experimental/coroutine>) // C++ 17 # include <experimental/coroutine> # endif #endif // ... So in general you don't have to care. Think of <coroutine/frame.h> as <coroutine> in the future. #if __has_include(<coroutine>) # include <coroutine> #else # include <coroutine/frame.h> #endif If you're really curious, read the file and please review my approach. :)","title":"Background"},{"location":"features/frame-overview/#contents","text":"I'm going to cover both the standard and my implementation in this section. You can think these items are the supplement of https://en.cppreference.com/w/cpp . #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> coroutine_traits<R, P...> suspend_never and suspend_always Note: Compiler Specific Issues","title":"Contents"},{"location":"features/frame-suspend_types/","text":"Coroutine Promise Requirement requires some awaitable type for the initial_suspend and final_suspend member functions for promise_type . suspend_never \u00b6 Awaitable type that never suspend. The control flows through ready - resume . Definition Example \u00b6 namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // Since the class won't suspend, this function won't be invoked } }; } // namespace std::experimental Known Usages \u00b6 In this library: Type enumerable<T> Type no_return TBA: external references suspend_always \u00b6 Awaitable type that always suspend. The control flows through ready - suspend - resume . Definition Example \u00b6 namespace std :: experimental { class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // The routine will suspend but the class ignores the given handle } }; } // namespace std::experimental Known Usages \u00b6 In this library: Type frame TBA: external references","title":"Frame suspend types"},{"location":"features/frame-suspend_types/#suspend_never","text":"Awaitable type that never suspend. The control flows through ready - resume .","title":"suspend_never"},{"location":"features/frame-suspend_types/#definition-example","text":"namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // Since the class won't suspend, this function won't be invoked } }; } // namespace std::experimental","title":"Definition Example"},{"location":"features/frame-suspend_types/#known-usages","text":"In this library: Type enumerable<T> Type no_return TBA: external references","title":"Known Usages"},{"location":"features/frame-suspend_types/#suspend_always","text":"Awaitable type that always suspend. The control flows through ready - suspend - resume .","title":"suspend_always"},{"location":"features/frame-suspend_types/#definition-example_1","text":"namespace std :: experimental { class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // The routine will suspend but the class ignores the given handle } }; } // namespace std::experimental","title":"Definition Example"},{"location":"features/frame-suspend_types/#known-usages_1","text":"In this library: Type frame TBA: external references","title":"Known Usages"},{"location":"features/net-implementation-epoll/","text":"This document is under progress ... Epoll \u00b6 For Linux platform, it uses epoll . modules/linux/net.cpp Expect & Ensures \u00b6 Socket \u00b6 Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); } Control Flow and Data \u00b6 The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close Concurrent I/O control \u00b6 I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request \u00b6 This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } Progress Check \u00b6 fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; } Suspend \u00b6 coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails } Polling and Resume \u00b6 Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; } Limitations \u00b6 Current version doesn't provide interface for I/O cancel.","title":"Net implementation epoll"},{"location":"features/net-implementation-epoll/#epoll","text":"For Linux platform, it uses epoll . modules/linux/net.cpp","title":"Epoll"},{"location":"features/net-implementation-epoll/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"features/net-implementation-epoll/#socket","text":"Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); }","title":"Socket"},{"location":"features/net-implementation-epoll/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close","title":"Control Flow and Data"},{"location":"features/net-implementation-epoll/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"features/net-implementation-epoll/#request","text":"This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); }","title":"Request"},{"location":"features/net-implementation-epoll/#progress-check","text":"fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; }","title":"Progress Check"},{"location":"features/net-implementation-epoll/#suspend","text":"coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails }","title":"Suspend"},{"location":"features/net-implementation-epoll/#polling-and-resume","text":"Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; }","title":"Polling and Resume"},{"location":"features/net-implementation-epoll/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"features/net-implementation-kqueue/","text":"This document is under progress ... KQueue \u00b6 For Mac OS(Darwin) platform, it uses kqueue . modules/darwin/net.cpp Expect & Ensures \u00b6 Socket \u00b6 All expectations for socket object are same with epoll based implementation . Control Flow and Data \u00b6 The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close Concurrent I/O control \u00b6 I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request \u00b6 It performs argument copy(packing) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } Progress Check \u00b6 The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; } Suspend \u00b6 Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } Polling and Resume \u00b6 wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; } Limitations \u00b6 Current version doesn't provide interface for I/O cancel.","title":"Net implementation kqueue"},{"location":"features/net-implementation-kqueue/#kqueue","text":"For Mac OS(Darwin) platform, it uses kqueue . modules/darwin/net.cpp","title":"KQueue"},{"location":"features/net-implementation-kqueue/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"features/net-implementation-kqueue/#socket","text":"All expectations for socket object are same with epoll based implementation .","title":"Socket"},{"location":"features/net-implementation-kqueue/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close","title":"Control Flow and Data"},{"location":"features/net-implementation-kqueue/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"features/net-implementation-kqueue/#request","text":"It performs argument copy(packing) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); }","title":"Request"},{"location":"features/net-implementation-kqueue/#progress-check","text":"The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; }","title":"Progress Check"},{"location":"features/net-implementation-kqueue/#suspend","text":"Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; }","title":"Suspend"},{"location":"features/net-implementation-kqueue/#polling-and-resume","text":"wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; }","title":"Polling and Resume"},{"location":"features/net-implementation-kqueue/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"features/net-implementation-winsock2/","text":"This document is under progress ... Coroutine + Socket Overlapped I/O + Completion Routine See Also \u00b6 CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Winsock Overlapped I/O \u00b6 modules/windows/net.cpp Remarks \u00b6 The library never invoke WSAStartup and WSACleanup . User must do it. Socket \u00b6 socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); } Control Flow and Data \u00b6 The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; io_buffer_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ; Concurrent I/O control \u00b6 I/O Request I/O Progress Check I/O Suspend I/O Resume Request \u00b6 The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); } Progress Check \u00b6 Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` } Suspend \u00b6 Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); } Resume (by Completion Routine) \u00b6 Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it. Limitations \u00b6 Current version doesn't provide interface for I/O cancel.","title":"Net implementation winsock2"},{"location":"features/net-implementation-winsock2/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"See Also"},{"location":"features/net-implementation-winsock2/#winsock-overlapped-io","text":"modules/windows/net.cpp","title":"Winsock Overlapped I/O"},{"location":"features/net-implementation-winsock2/#remarks","text":"The library never invoke WSAStartup and WSACleanup . User must do it.","title":"Remarks"},{"location":"features/net-implementation-winsock2/#socket","text":"socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); }","title":"Socket"},{"location":"features/net-implementation-winsock2/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; io_buffer_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ;","title":"Control Flow and Data"},{"location":"features/net-implementation-winsock2/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Resume","title":"Concurrent I/O control"},{"location":"features/net-implementation-winsock2/#request","text":"The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); }","title":"Request"},{"location":"features/net-implementation-winsock2/#progress-check","text":"Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` }","title":"Progress Check"},{"location":"features/net-implementation-winsock2/#suspend","text":"Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); }","title":"Suspend"},{"location":"features/net-implementation-winsock2/#resume-by-completion-routine","text":"Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it.","title":"Resume (by Completion Routine)"},{"location":"features/net-implementation-winsock2/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"features/net-overview/","text":"The interface contains socket I/O functions with coroutine. See Also \u00b6 CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" Dependency \u00b6 The interface uses GSL(Guideline Support Library) and some of this library's features. For GSL itself, please see the GSL section in the C++ Core Guidelines . #include <coroutine/yield.hpp> #include <gsl/gsl> Variables \u00b6 constexpr \u00b6 The header defines 2 constexpr variable. static constexpr bool is_winsock = /* true or false */ ; static constexpr bool is_netinet = /* true or false */ ; Types \u00b6 io_control_block \u00b6 This is an alias of OVERLAPPED struct. For netinet, it's struct follows the OVERLAPPED . // follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc; int32_t flag; uint64_t internal_high ; union { struct { int32_t offset ; // socklen_t addrlen; int32_t offset_high ; }; void * ptr ; }; int64_t handle ; // int64_t sd; }; endpoint_t \u00b6 Helper type for socket address usage. Notice that the type contains sockaddr_storage . union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; }; io_task_t \u00b6 This is an alias of coroutine_handle<void> . The coroutine frame becomes an user data in the underlying system's API // 1 task item == 1 resumable function using io_task_t = std :: experimental :: coroutine_handle < void > ; io_buffer_t \u00b6 The type is a view to the bytes(storage for read/write operation). Be aware that it doesn't have ownership. See gsl::span<T> for its usage. using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); io_work_t \u00b6 It is a struct to describe 1 I/O request to the underlying system's API class io_work_t : public io_control_block { io_task_t task {}; io_buffer_t buffer {}; endpoint_t * ep {}; public : bool ready () const noexcept ; uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 64 ); After co_await , error() returns the stored error from I/O operation. For its usage, see the examples in I/O operation functions. Operations \u00b6 Remarks \u00b6 The library doesn't use cancel/scatter/gather operations. The library doesn't provide create/destroy/option for the socket. Such an abstraction is tedious and distracts to understand both interface design and internal codes. It just expects that the given socket is non-block and async one, and it works as designed only for the case. Test helper codes below contain socket functions. You can copy-and-paste them :) test/test_network.h test/test_network.cpp wait_io_tasks \u00b6 Acquires currently resumable I/O coroutines. This function is for non-windows platform. Over Windows API, the implementation resumes I/O coroutines automatically. So it always yields nothing . Also, the library does not guarantee that all coroutines(I/O tasks) will be fetched at once. Therefore it is strongly recommended for user to have another method to detect that watching I/O coroutines are returned. User must repeat the resuming loop without break so that there is no leak of event. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > ; Example \u00b6 Use it with the constexpr variables . void io_polling_example () { if constexpr ( is_winsock == false ) { // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } } send_to \u00b6 Request to internal API to send a buffer to specific endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_send_to final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in6 & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; Params \u00b6 sd : a bound socket descriptor remote : remote address to send buf buf : data(span of std::byte ) to send work : I/O request holder. Down-casted to io_send_to Return \u00b6 send_to : lvalue reference to an awaitable type( io_send_to ) await_resume : success: the length of sent bytes in int64_t failure: the error code will be stored to given work Example \u00b6 The following code shows how send_to can be used. auto example ( uint64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz == storage . size ()); } recv_from \u00b6 Request to internal API to receive through a socket from the unspecified endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_recv_from final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; Params \u00b6 sd : a bound socket descriptor remote : memory to store sender's address buf : data(span of std::byte ) to receive work : I/O request holder. Down-casted to io_recv_from Return \u00b6 recv_from : lvalue reference to an awaitable type( io_recv_from ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example \u00b6 The following code shows how recv_from can be used. auto example ( uint64_t sd , sockaddr_in & remote , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); } send_stream \u00b6 Request to internal API to send to the connected peer and return a refernce of concrete io_work_t that can be used for co_await . class io_send final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ; Params \u00b6 sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_send Return \u00b6 send_stream : lvalue reference to an awaitable type( io_send ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example \u00b6 The following code shows how send_stream can be used. auto example ( int64_t sd , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz > 0 ); } recv_stream \u00b6 Request to internal API to receive through the connected socket and return a refernce of concrete io_work_t that can be used for co_await . class io_recv final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ; Params \u00b6 sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_recv Return \u00b6 recv_stream : lvalue reference to an awaitable type( io_recv ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example \u00b6 The following code shows how recv_stream can be used. auto example ( int64_t sd , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); } Usage Pattern \u00b6 User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine 1 I/O Reqeust == 1 Coroutine \u00b6 Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( uint64_t socket ) -> some_return_type { io_work_t work {}; // control block object io_buffer_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // ec is updated after the request auto ec = work . error (); // ... } // ... } The request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer Continuation of I/O Coroutines \u00b6 User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... } Examples \u00b6 resolve IPv6 Multicast TCPv6 Connect UDPv6 v4 mapped send_stream / recv_stream ( wait_io_tasks ) send_to / recv_from ( wait_io_tasks )","title":"Net overview"},{"location":"features/net-overview/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\"","title":"See Also"},{"location":"features/net-overview/#dependency","text":"The interface uses GSL(Guideline Support Library) and some of this library's features. For GSL itself, please see the GSL section in the C++ Core Guidelines . #include <coroutine/yield.hpp> #include <gsl/gsl>","title":"Dependency"},{"location":"features/net-overview/#variables","text":"","title":"Variables"},{"location":"features/net-overview/#constexpr","text":"The header defines 2 constexpr variable. static constexpr bool is_winsock = /* true or false */ ; static constexpr bool is_netinet = /* true or false */ ;","title":"constexpr"},{"location":"features/net-overview/#types","text":"","title":"Types"},{"location":"features/net-overview/#io_control_block","text":"This is an alias of OVERLAPPED struct. For netinet, it's struct follows the OVERLAPPED . // follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc; int32_t flag; uint64_t internal_high ; union { struct { int32_t offset ; // socklen_t addrlen; int32_t offset_high ; }; void * ptr ; }; int64_t handle ; // int64_t sd; };","title":"io_control_block"},{"location":"features/net-overview/#endpoint_t","text":"Helper type for socket address usage. Notice that the type contains sockaddr_storage . union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; };","title":"endpoint_t"},{"location":"features/net-overview/#io_task_t","text":"This is an alias of coroutine_handle<void> . The coroutine frame becomes an user data in the underlying system's API // 1 task item == 1 resumable function using io_task_t = std :: experimental :: coroutine_handle < void > ;","title":"io_task_t"},{"location":"features/net-overview/#io_buffer_t","text":"The type is a view to the bytes(storage for read/write operation). Be aware that it doesn't have ownership. See gsl::span<T> for its usage. using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 );","title":"io_buffer_t"},{"location":"features/net-overview/#io_work_t","text":"It is a struct to describe 1 I/O request to the underlying system's API class io_work_t : public io_control_block { io_task_t task {}; io_buffer_t buffer {}; endpoint_t * ep {}; public : bool ready () const noexcept ; uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 64 ); After co_await , error() returns the stored error from I/O operation. For its usage, see the examples in I/O operation functions.","title":"io_work_t"},{"location":"features/net-overview/#operations","text":"","title":"Operations"},{"location":"features/net-overview/#remarks","text":"The library doesn't use cancel/scatter/gather operations. The library doesn't provide create/destroy/option for the socket. Such an abstraction is tedious and distracts to understand both interface design and internal codes. It just expects that the given socket is non-block and async one, and it works as designed only for the case. Test helper codes below contain socket functions. You can copy-and-paste them :) test/test_network.h test/test_network.cpp","title":"Remarks"},{"location":"features/net-overview/#wait_io_tasks","text":"Acquires currently resumable I/O coroutines. This function is for non-windows platform. Over Windows API, the implementation resumes I/O coroutines automatically. So it always yields nothing . Also, the library does not guarantee that all coroutines(I/O tasks) will be fetched at once. Therefore it is strongly recommended for user to have another method to detect that watching I/O coroutines are returned. User must repeat the resuming loop without break so that there is no leak of event. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > ;","title":"wait_io_tasks"},{"location":"features/net-overview/#example","text":"Use it with the constexpr variables . void io_polling_example () { if constexpr ( is_winsock == false ) { // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } }","title":"Example"},{"location":"features/net-overview/#send_to","text":"Request to internal API to send a buffer to specific endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_send_to final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in6 & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ;","title":"send_to"},{"location":"features/net-overview/#params","text":"sd : a bound socket descriptor remote : remote address to send buf buf : data(span of std::byte ) to send work : I/O request holder. Down-casted to io_send_to","title":"Params"},{"location":"features/net-overview/#return","text":"send_to : lvalue reference to an awaitable type( io_send_to ) await_resume : success: the length of sent bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_1","text":"The following code shows how send_to can be used. auto example ( uint64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz == storage . size ()); }","title":"Example"},{"location":"features/net-overview/#recv_from","text":"Request to internal API to receive through a socket from the unspecified endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_recv_from final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ;","title":"recv_from"},{"location":"features/net-overview/#params_1","text":"sd : a bound socket descriptor remote : memory to store sender's address buf : data(span of std::byte ) to receive work : I/O request holder. Down-casted to io_recv_from","title":"Params"},{"location":"features/net-overview/#return_1","text":"recv_from : lvalue reference to an awaitable type( io_recv_from ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_2","text":"The following code shows how recv_from can be used. auto example ( uint64_t sd , sockaddr_in & remote , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); }","title":"Example"},{"location":"features/net-overview/#send_stream","text":"Request to internal API to send to the connected peer and return a refernce of concrete io_work_t that can be used for co_await . class io_send final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ;","title":"send_stream"},{"location":"features/net-overview/#params_2","text":"sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_send","title":"Params"},{"location":"features/net-overview/#return_2","text":"send_stream : lvalue reference to an awaitable type( io_send ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_3","text":"The following code shows how send_stream can be used. auto example ( int64_t sd , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz > 0 ); }","title":"Example"},{"location":"features/net-overview/#recv_stream","text":"Request to internal API to receive through the connected socket and return a refernce of concrete io_work_t that can be used for co_await . class io_recv final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ;","title":"recv_stream"},{"location":"features/net-overview/#params_3","text":"sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_recv","title":"Params"},{"location":"features/net-overview/#return_3","text":"recv_stream : lvalue reference to an awaitable type( io_recv ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_4","text":"The following code shows how recv_stream can be used. auto example ( int64_t sd , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); }","title":"Example"},{"location":"features/net-overview/#usage-pattern","text":"User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine","title":"Usage Pattern"},{"location":"features/net-overview/#1-io-reqeust-1-coroutine","text":"Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( uint64_t socket ) -> some_return_type { io_work_t work {}; // control block object io_buffer_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // ec is updated after the request auto ec = work . error (); // ... } // ... } The request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer","title":"1 I/O Reqeust == 1 Coroutine"},{"location":"features/net-overview/#continuation-of-io-coroutines","text":"User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... }","title":"Continuation of I/O Coroutines"},{"location":"features/net-overview/#examples","text":"resolve IPv6 Multicast TCPv6 Connect UDPv6 v4 mapped send_stream / recv_stream ( wait_io_tasks ) send_to / recv_from ( wait_io_tasks )","title":"Examples"},{"location":"features/return-frame/","text":"See Also \u00b6 C++ Coroutines: Understanding the promise type Exploring The C++ Coroutine Coroutine Promise Requirements (N4736) frame as a ReturnType \u00b6 When user wants to (or have to) manage the destruction of coroutine frame, frame opens a way to acquire the coroutine_handle<void> . Basically, this type is a shallow extension of coroutine_handle<void> . Example \u00b6 The type can be empty. In the case, using done() member function will access to nullptr . #include <coroutine/return.h> using namespace coro ; auto coro_frame_empty_test () -> void { frame fh {}; auto coro = static_cast < coroutine_handle < void >> ( fh ); REQUIRE ( coro . address () == nullptr ); } When the coroutine frame's destuction need to be controlled manually, just suspend( co_await ) or return( co_return , the final suspend) in the function. #include <coroutine/return.h> using namespace coro ; auto invoke_and_suspend () -> frame { co_await suspend_always {}; co_return ; }; auto coro_frame_first_suspend_test () -> void { auto frame = invoke_and_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done () == false ); // it is susepended, but not return. frame . destroy (); } Remarks \u00b6 The coroutine's frame will remain 'final suspended' after co_return . See the final_suspend in the definiton below. Like no_return , the type doesn't allows co_return; . Definition (Promise) \u00b6 The type's size is equal to that of coroutine_handle<void> . namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; // !!!!! } void return_void () noexcept ; void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * ; static auto get_return_object_on_allocation_failure () noexcept -> promise_type * ; }; public : void await_suspend ( coroutine_handle < void > coro ) noexcept ; frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro frame as an Awaitable \u00b6 The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this harms the SRP(Single Responsibility Principle), but writing another type for the purpose will make the code tedious. Remark \u00b6 The following example shows frame doesn't guarantee it's target(coroutine's frame) is alive. See the following example. In the co_await expression, it must be used by reference . Example \u00b6 Please, be cautious. #include <gsl/gsl> #include <coroutine/return.h> using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame type as an awaitable. status = 2 ; co_await fh ; co_return ; } auto coro_frame_awaitable_test () -> void { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); // `frame` inherits `coroutine_handle<void>` coro . resume (); REQUIRE ( status == 2 ); // coroutine reached end. // so `defer` in the routine will change status coro . resume (); REQUIRE ( status == 3 ); // however, `no_return` destroyed the coroutine's frame. // so `destroy` through `coro` will be undefined behavior... } Definition (Awaitable) \u00b6 It inherits await_ready and await_resume from the suspend_always type. However, it overrides await_suspend to save given handle. namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final ; public : // override `suspend_always::await_suspend` // assumed to be used as an argument of `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept ; }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Return frame"},{"location":"features/return-frame/#see-also","text":"C++ Coroutines: Understanding the promise type Exploring The C++ Coroutine Coroutine Promise Requirements (N4736)","title":"See Also"},{"location":"features/return-frame/#frame-as-a-returntype","text":"When user wants to (or have to) manage the destruction of coroutine frame, frame opens a way to acquire the coroutine_handle<void> . Basically, this type is a shallow extension of coroutine_handle<void> .","title":"frame as a ReturnType"},{"location":"features/return-frame/#example","text":"The type can be empty. In the case, using done() member function will access to nullptr . #include <coroutine/return.h> using namespace coro ; auto coro_frame_empty_test () -> void { frame fh {}; auto coro = static_cast < coroutine_handle < void >> ( fh ); REQUIRE ( coro . address () == nullptr ); } When the coroutine frame's destuction need to be controlled manually, just suspend( co_await ) or return( co_return , the final suspend) in the function. #include <coroutine/return.h> using namespace coro ; auto invoke_and_suspend () -> frame { co_await suspend_always {}; co_return ; }; auto coro_frame_first_suspend_test () -> void { auto frame = invoke_and_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done () == false ); // it is susepended, but not return. frame . destroy (); }","title":"Example"},{"location":"features/return-frame/#remarks","text":"The coroutine's frame will remain 'final suspended' after co_return . See the final_suspend in the definiton below. Like no_return , the type doesn't allows co_return; .","title":"Remarks"},{"location":"features/return-frame/#definition-promise","text":"The type's size is equal to that of coroutine_handle<void> . namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; // !!!!! } void return_void () noexcept ; void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * ; static auto get_return_object_on_allocation_failure () noexcept -> promise_type * ; }; public : void await_suspend ( coroutine_handle < void > coro ) noexcept ; frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Definition (Promise)"},{"location":"features/return-frame/#frame-as-an-awaitable","text":"The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this harms the SRP(Single Responsibility Principle), but writing another type for the purpose will make the code tedious.","title":"frame as an Awaitable"},{"location":"features/return-frame/#remark","text":"The following example shows frame doesn't guarantee it's target(coroutine's frame) is alive. See the following example. In the co_await expression, it must be used by reference .","title":"Remark"},{"location":"features/return-frame/#example_1","text":"Please, be cautious. #include <gsl/gsl> #include <coroutine/return.h> using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame type as an awaitable. status = 2 ; co_await fh ; co_return ; } auto coro_frame_awaitable_test () -> void { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); // `frame` inherits `coroutine_handle<void>` coro . resume (); REQUIRE ( status == 2 ); // coroutine reached end. // so `defer` in the routine will change status coro . resume (); REQUIRE ( status == 3 ); // however, `no_return` destroyed the coroutine's frame. // so `destroy` through `coro` will be undefined behavior... }","title":"Example"},{"location":"features/return-frame/#definition-awaitable","text":"It inherits await_ready and await_resume from the suspend_always type. However, it overrides await_suspend to save given handle. namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final ; public : // override `suspend_always::await_suspend` // assumed to be used as an argument of `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept ; }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Definition (Awaitable)"},{"location":"features/return-no_return/","text":"See Also \u00b6 C++ coroutiness: Understanding the promise type Exploring The C++ coroutines Coroutine Promise Requirements (N4736) no_return \u00b6 This is a void return type for the general coroutine functions. Since a coroutine might suspend without return, it is not recommended to rely heavily on co_return from its caller/resumer. If the return can be ignored, class no_return can do the work. Remarks \u00b6 Since the promise_type does not final suspend, a frame of the coroutine that return no_return type will be destroyed immediately . Example \u00b6 If you doesn't care about coroutine's life cycle, use no_return . At least the routine will be resumed(continued) properly, co_return will destroy the frame #include <coroutine/return.h> using namespace coro ; auto fire_and_forget () -> no_return { co_await suspend_never {}; co_return ; }; auto example_caller () -> void { fire_and_forget (); // spawn a new coroutine frame. // the routine will be finished somehow // and destroy the frame. // do some other works ... } Definition \u00b6 It's definition is in the <coroutine/return.h> namespace coro { // General `void` return for the coroutine functions class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : no_return ( const promise_type * ) noexcept { // the type truncates all given info about its frame } }; } // namespace coro Possible customization points are ... unhandled_exception : We can throw the exception again and handle it , but mostly it depends on the scenario. This version assumes it's a somthing irrecoverable. get_return_object_on_allocation_failure : with operator new and operator delete , you can customise memory management for the coroutine frames.","title":"Return no return"},{"location":"features/return-no_return/#see-also","text":"C++ coroutiness: Understanding the promise type Exploring The C++ coroutines Coroutine Promise Requirements (N4736)","title":"See Also"},{"location":"features/return-no_return/#no_return","text":"This is a void return type for the general coroutine functions. Since a coroutine might suspend without return, it is not recommended to rely heavily on co_return from its caller/resumer. If the return can be ignored, class no_return can do the work.","title":"no_return"},{"location":"features/return-no_return/#remarks","text":"Since the promise_type does not final suspend, a frame of the coroutine that return no_return type will be destroyed immediately .","title":"Remarks"},{"location":"features/return-no_return/#example","text":"If you doesn't care about coroutine's life cycle, use no_return . At least the routine will be resumed(continued) properly, co_return will destroy the frame #include <coroutine/return.h> using namespace coro ; auto fire_and_forget () -> no_return { co_await suspend_never {}; co_return ; }; auto example_caller () -> void { fire_and_forget (); // spawn a new coroutine frame. // the routine will be finished somehow // and destroy the frame. // do some other works ... }","title":"Example"},{"location":"features/return-no_return/#definition","text":"It's definition is in the <coroutine/return.h> namespace coro { // General `void` return for the coroutine functions class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : no_return ( const promise_type * ) noexcept { // the type truncates all given info about its frame } }; } // namespace coro Possible customization points are ... unhandled_exception : We can throw the exception again and handle it , but mostly it depends on the scenario. This version assumes it's a somthing irrecoverable. get_return_object_on_allocation_failure : with operator new and operator delete , you can customise memory management for the coroutine frames.","title":"Definition"},{"location":"features/return-overview/","text":"#include <coroutine/return.h> using namespace coro ; References \u00b6 N4820 Working Draft N4736 Working Draft Background \u00b6 One of the entry barriers for the coroutine function is to write a return type. The return type's promise_type must fulfills the Coroutine Promise Requirement (Actually it's coroutine_traits<R>::promise_type , but just let me skip the detail for now). To save your time, start with the article of Lewiss Baker . I also wrote about it with N4402 , and with my talk in C++ Korea (see the page 60) . In my opinion, N4402 was short enough and explains well about the role of those requirements. Contents \u00b6 Currently, this library provides 2 types. #include <coroutine/return.h> using namespace coro ; no_return frame You may noticed that there is no task<T> . I don't have a plan to support the type for 2 reasons. To encourage use of https://github.com/lewissbaker/cppcoro which already implemented it To encourage use of the suspension( co_await and co_yield ) insead of the return( co_return ) In my perspective, the coroutine is a routine with multiple entry points and multiple suspend points. Therefore we should be familiar with the suspension and have concern about its usage rather than just using return(the last suspension).","title":"Return overview"},{"location":"features/return-overview/#references","text":"N4820 Working Draft N4736 Working Draft","title":"References"},{"location":"features/return-overview/#background","text":"One of the entry barriers for the coroutine function is to write a return type. The return type's promise_type must fulfills the Coroutine Promise Requirement (Actually it's coroutine_traits<R>::promise_type , but just let me skip the detail for now). To save your time, start with the article of Lewiss Baker . I also wrote about it with N4402 , and with my talk in C++ Korea (see the page 60) . In my opinion, N4402 was short enough and explains well about the role of those requirements.","title":"Background"},{"location":"features/return-overview/#contents","text":"Currently, this library provides 2 types. #include <coroutine/return.h> using namespace coro ; no_return frame You may noticed that there is no task<T> . I don't have a plan to support the type for 2 reasons. To encourage use of https://github.com/lewissbaker/cppcoro which already implemented it To encourage use of the suspension( co_await and co_yield ) insead of the return( co_return ) In my perspective, the coroutine is a routine with multiple entry points and multiple suspend points. Therefore we should be familiar with the suspension and have concern about its usage rather than just using return(the last suspension).","title":"Contents"},{"location":"features/yield-enumerable/","text":"Generator with the coroutine See Also \u00b6 <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck enumerable<T> \u00b6 This is an implementation of the 'Coroutine-based Generator' concept. However, because of some known implementations, the name can be considered as a reserved one. In this library, the impl is is named as enumerable . Even though there are existing implementations like the generator of VC++, I had to write my own one to test coroutine_handle<void> because the type is compiler-dependent. If you're clang/libc++ user, you can use mine or generator of the cppcoro . template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters \u00b6 T : The type of element in the enumerable. Default Operations \u00b6 Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator follows RAII. So it will destroy its handle in destructor. Functions \u00b6 The type supports ranged- for statment. Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Type: promise_type \u00b6 The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it Remark \u00b6 It only takes lvalue reference( T& ) for the operand of co_yield . template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Type: iterator \u00b6 Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent misusage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; }; Examples \u00b6 You can see the usage with test codes. Use of co_yield What if the function yields 0-time? Move Semantics Iteration std::accumulate std::max_element","title":"Yield enumerable"},{"location":"features/yield-enumerable/#see-also","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"See Also"},{"location":"features/yield-enumerable/#enumerablelttgt","text":"This is an implementation of the 'Coroutine-based Generator' concept. However, because of some known implementations, the name can be considered as a reserved one. In this library, the impl is is named as enumerable . Even though there are existing implementations like the generator of VC++, I had to write my own one to test coroutine_handle<void> because the type is compiler-dependent. If you're clang/libc++ user, you can use mine or generator of the cppcoro . template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"enumerable&lt;T&gt;"},{"location":"features/yield-enumerable/#template-parameters","text":"T : The type of element in the enumerable.","title":"Template Parameters"},{"location":"features/yield-enumerable/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator follows RAII. So it will destroy its handle in destructor.","title":"Default Operations"},{"location":"features/yield-enumerable/#functions","text":"The type supports ranged- for statment. Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"features/yield-enumerable/#type-promise_type","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it","title":"Type: promise_type"},{"location":"features/yield-enumerable/#remark","text":"It only takes lvalue reference( T& ) for the operand of co_yield . template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Remark"},{"location":"features/yield-enumerable/#type-iterator","text":"Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent misusage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Type: iterator"},{"location":"features/yield-enumerable/#examples","text":"You can see the usage with test codes. Use of co_yield What if the function yields 0-time? Move Semantics Iteration std::accumulate std::max_element","title":"Examples"},{"location":"features/yield-overview/","text":"#include <coroutine/yield.hpp> using namespace coro ; References \u00b6 <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck Background \u00b6 I strongly recomment the last two materials. Andreas Reischuck's explanation will be a good time saver for you. ToDo: The essense of co_yield ? Contents \u00b6 enumerable<T> sequence<T>","title":"Yield overview"},{"location":"features/yield-overview/#references","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"References"},{"location":"features/yield-overview/#background","text":"I strongly recomment the last two materials. Andreas Reischuck's explanation will be a good time saver for you. ToDo: The essense of co_yield ?","title":"Background"},{"location":"features/yield-overview/#contents","text":"enumerable<T> sequence<T>","title":"Contents"},{"location":"features/yield-sequence/","text":"Generator + Async Iterator See Also \u00b6 <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck sequence<T> \u00b6 sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. This type should be used carefully . It is not recommended in general, and there might be a bug(failure) on release mode with clang compiler . Contrary to that, MSVC works well with the optimization flag . template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters \u00b6 T : the type of element in the sequence. Default Operations \u00b6 Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... } Functions \u00b6 Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Type: promise_type \u00b6 The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Type: iterator \u00b6 Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; }; Examples \u00b6 You can see the usage with test codes. Use of co_yield with awaitable What if the function yields 0-time? Destruction Frame's status Iteration Suspend with co_await Suspend with co_yield See Also \u00b6 In this library: Type frame","title":"Yield sequence"},{"location":"features/yield-sequence/#see-also","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"See Also"},{"location":"features/yield-sequence/#sequencelttgt","text":"sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. This type should be used carefully . It is not recommended in general, and there might be a bug(failure) on release mode with clang compiler . Contrary to that, MSVC works well with the optimization flag . template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"sequence&lt;T&gt;"},{"location":"features/yield-sequence/#template-parameters","text":"T : the type of element in the sequence.","title":"Template Parameters"},{"location":"features/yield-sequence/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... }","title":"Default Operations"},{"location":"features/yield-sequence/#functions","text":"Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"features/yield-sequence/#type-promise_type","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Type: promise_type"},{"location":"features/yield-sequence/#type-iterator","text":"Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Type: iterator"},{"location":"features/yield-sequence/#examples","text":"You can see the usage with test codes. Use of co_yield with awaitable What if the function yields 0-time? Destruction Frame's status Iteration Suspend with co_await Suspend with co_yield","title":"Examples"},{"location":"features/yield-sequence/#see-also_1","text":"In this library: Type frame","title":"See Also"},{"location":"howto/build-using-cmake/","text":"How To Build: CMake Project \u00b6 Known Configurations? \u00b6 This library relies on various CI services. I'm testing the build with the multiple config files. Just follow those files and compare with the build log. It won't be that hard :) You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue! Ubuntu Linux \u00b6 Travis CI : dist: xenial Azure Pipelines : ubuntu-16.04 AppVeyor : Ubuntu 18.04 I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions. Installing libc++ \u00b6 By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ; Android \u00b6 Travis CI : language: android I'm considering to deprecate Android build with NDK because of the CMake version in it :( Mac OS \u00b6 Azure Pipelines : macos-latest iPhone OS \u00b6 Travis CI : osx_image: xcode10.1 Special thanks to https://github.com/leetal/ios-cmake !!! Windows \u00b6 Azure Pipelines : Visual Studio 2017 AppVeyor : Visual Studio 2017, 2019 You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build. Visual Studio \u00b6 Just set the Generator as Visual Studio. git clone https : // github . com / luncliff / coroutine Push-Location coroutine ; cmake .. -G \"Visual Studio 15 2017 Win64\" -DUSE_PORTABLE_HEADER = \"true\" Pop-Location ; LLVM Clang-cl \u00b6 Currently, I recommend static build for clang-cl . But the DLL build is also available for current master branch. To do so, please reference the AppVeyor build steps . Install Chocolatey & Required Packages \u00b6 Chocolatey can be installed easily. Follow guide of the official page . We need 2 packages. choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... The clang-cl will invoke the clang appropriately . So if clang-cl works well, then all setup is done correctly. $ clang-cl --version ...","title":"How To Build: CMake Project"},{"location":"howto/build-using-cmake/#how-to-build-cmake-project","text":"","title":"How To Build: CMake Project"},{"location":"howto/build-using-cmake/#known-configurations","text":"This library relies on various CI services. I'm testing the build with the multiple config files. Just follow those files and compare with the build log. It won't be that hard :) You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue!","title":"Known Configurations?"},{"location":"howto/build-using-cmake/#ubuntu-linux","text":"Travis CI : dist: xenial Azure Pipelines : ubuntu-16.04 AppVeyor : Ubuntu 18.04 I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions.","title":"Ubuntu Linux"},{"location":"howto/build-using-cmake/#installing-libc","text":"By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ;","title":"Installing libc++"},{"location":"howto/build-using-cmake/#android","text":"Travis CI : language: android I'm considering to deprecate Android build with NDK because of the CMake version in it :(","title":"Android"},{"location":"howto/build-using-cmake/#mac-os","text":"Azure Pipelines : macos-latest","title":"Mac OS"},{"location":"howto/build-using-cmake/#iphone-os","text":"Travis CI : osx_image: xcode10.1 Special thanks to https://github.com/leetal/ios-cmake !!!","title":"iPhone OS"},{"location":"howto/build-using-cmake/#windows","text":"Azure Pipelines : Visual Studio 2017 AppVeyor : Visual Studio 2017, 2019 You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build.","title":"Windows"},{"location":"howto/build-using-cmake/#visual-studio","text":"Just set the Generator as Visual Studio. git clone https : // github . com / luncliff / coroutine Push-Location coroutine ; cmake .. -G \"Visual Studio 15 2017 Win64\" -DUSE_PORTABLE_HEADER = \"true\" Pop-Location ;","title":"Visual Studio"},{"location":"howto/build-using-cmake/#llvm-clang-cl","text":"Currently, I recommend static build for clang-cl . But the DLL build is also available for current master branch. To do so, please reference the AppVeyor build steps .","title":"LLVM Clang-cl"},{"location":"howto/build-using-cmake/#install-chocolatey-required-packages","text":"Chocolatey can be installed easily. Follow guide of the official page . We need 2 packages. choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... The clang-cl will invoke the clang appropriately . So if clang-cl works well, then all setup is done correctly. $ clang-cl --version ...","title":"Install Chocolatey &amp; Required Packages"},{"location":"howto/build-using-visualstudio/","text":"How To Build: Visual Studio \u00b6 Before Build ... \u00b6 Check the Windows SDK and Visual Studio \u00b6 Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration . Follow the steps! \u00b6 Clone the repo and submodules \u00b6 Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' Open the Visual Studio \u00b6 Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now. Review the modules/windows.vcxproj \u00b6 Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!) Try The Build/Test! \u00b6 Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"How To Build: Visual Studio"},{"location":"howto/build-using-visualstudio/#how-to-build-visual-studio","text":"","title":"How To Build: Visual Studio"},{"location":"howto/build-using-visualstudio/#before-build","text":"","title":"Before Build ..."},{"location":"howto/build-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration .","title":"Check the Windows SDK and Visual Studio"},{"location":"howto/build-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"howto/build-using-visualstudio/#clone-the-repo-and-submodules","text":"Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a'","title":"Clone the repo and submodules"},{"location":"howto/build-using-visualstudio/#open-the-visual-studio","text":"Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Open the Visual Studio"},{"location":"howto/build-using-visualstudio/#review-the-moduleswindowsvcxproj","text":"Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!)","title":"Review the modules/windows.vcxproj"},{"location":"howto/build-using-visualstudio/#try-the-buildtest","text":"Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"Try The Build/Test!"},{"location":"howto/import-using-cmake/","text":"How To Import: CMake Project \u00b6 Package Support? \u00b6 Does this library support any package manager? \u00b6 Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well! Try with the Vcpkg \u00b6 This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine) Follow the steps! \u00b6 Check your environment \u00b6 If you didn't checked your project's configuration, please do review this document first . Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD . You don't have to check yourself since CMake will do that. Just be aware of it. cmake_minimum_required ( VERSION 3.8 ) Installing GSL(Guideline Support Library) \u00b6 The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include Call add_subdirectory \u00b6 Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine ) Test will be skipped automatically \u00b6 The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif () Call target_link_libraries \u00b6 The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine ) Questions & Trouble Shooting \u00b6 Report your troubles!","title":"How To Import: CMake Project"},{"location":"howto/import-using-cmake/#how-to-import-cmake-project","text":"","title":"How To Import: CMake Project"},{"location":"howto/import-using-cmake/#package-support","text":"","title":"Package Support?"},{"location":"howto/import-using-cmake/#does-this-library-support-any-package-manager","text":"Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well!","title":"Does this library support any package manager?"},{"location":"howto/import-using-cmake/#try-with-the-vcpkg","text":"This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine)","title":"Try with the Vcpkg"},{"location":"howto/import-using-cmake/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"howto/import-using-cmake/#check-your-environment","text":"If you didn't checked your project's configuration, please do review this document first . Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD . You don't have to check yourself since CMake will do that. Just be aware of it. cmake_minimum_required ( VERSION 3.8 )","title":"Check your environment"},{"location":"howto/import-using-cmake/#installing-gslguideline-support-library","text":"The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include","title":"Installing GSL(Guideline Support Library)"},{"location":"howto/import-using-cmake/#call-add_subdirectory","text":"Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine )","title":"Call add_subdirectory"},{"location":"howto/import-using-cmake/#test-will-be-skipped-automatically","text":"The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif ()","title":"Test will be skipped automatically"},{"location":"howto/import-using-cmake/#call-target_link_libraries","text":"The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine )","title":"Call target_link_libraries"},{"location":"howto/import-using-cmake/#questions-trouble-shooting","text":"Report your troubles!","title":"Questions &amp; Trouble Shooting"},{"location":"howto/import-using-visualstudio/","text":"How To Import: Visual Studio \u00b6 Before Import ... \u00b6 Check the Windows SDK and Visual Studio ! \u00b6 The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ... Follow the steps! \u00b6 Create a new C++ Solution/Project \u00b6 Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :) Import VC++ Project \u00b6 We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now. Add Existing Project \u00b6 If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters. Add Reference \u00b6 Now, change the reference of the ConsoleApplication1 project. Adjustment for the modules/windows.vcxproj \u00b6 Include Directories \u00b6 With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option. MSVC Compier Options \u00b6 To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image. Linker Options \u00b6 Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you. Try this example \u00b6 So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include <iostream> #include <gsl/gsl> #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using namespace coro ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> forget_frame { co_await suspend_never {}; std :: cout << \"C++ Coroutines! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } You can run the code with the Compiler Explorer . Questions & Trouble Shooting \u00b6 Report your troubles! Build with the Clang-cl ? \u00b6 Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"How To Import: Visual Studio"},{"location":"howto/import-using-visualstudio/#how-to-import-visual-studio","text":"","title":"How To Import: Visual Studio"},{"location":"howto/import-using-visualstudio/#before-import","text":"","title":"Before Import ..."},{"location":"howto/import-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ...","title":"Check the Windows SDK and Visual Studio !"},{"location":"howto/import-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"howto/import-using-visualstudio/#create-a-new-c-solutionproject","text":"Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :)","title":"Create a new C++ Solution/Project"},{"location":"howto/import-using-visualstudio/#import-vc-project","text":"We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Import VC++ Project"},{"location":"howto/import-using-visualstudio/#add-existing-project","text":"If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters.","title":"Add Existing Project"},{"location":"howto/import-using-visualstudio/#add-reference","text":"Now, change the reference of the ConsoleApplication1 project.","title":"Add Reference"},{"location":"howto/import-using-visualstudio/#adjustment-for-the-moduleswindowsvcxproj","text":"","title":"Adjustment for the modules/windows.vcxproj"},{"location":"howto/import-using-visualstudio/#include-directories","text":"With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option.","title":"Include Directories"},{"location":"howto/import-using-visualstudio/#msvc-compier-options","text":"To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image.","title":"MSVC Compier Options"},{"location":"howto/import-using-visualstudio/#linker-options","text":"Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you.","title":"Linker Options"},{"location":"howto/import-using-visualstudio/#try-this-example","text":"So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include <iostream> #include <gsl/gsl> #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using namespace coro ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> forget_frame { co_await suspend_never {}; std :: cout << \"C++ Coroutines! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } You can run the code with the Compiler Explorer .","title":"Try this example"},{"location":"howto/import-using-visualstudio/#questions-trouble-shooting","text":"Report your troubles!","title":"Questions &amp; Trouble Shooting"},{"location":"howto/import-using-visualstudio/#build-with-the-clang-cl","text":"Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"Build with the Clang-cl ?"},{"location":"howto/start-using-cmake/","text":"How To Start: CMake \u00b6 Welcome! Well, this part is not about CMake's usage, nor setup of the CMake for your environment. I'd like to give the minimum CMake example for your project here. CMake's Version ? \u00b6 At this moment(2019), I recommend you to use at least CMake 3.8 or later. The version is allows you to specify 17 for the CXX_STANDARD property(It will be commented). But that's not the necessary step . Indeed the key part not the cmake but the compiler itself! If you already aware of your developer environment, forget about that recommendation! For the examples below, I will keep specifing flags related to C++ standard. Unless you are in some complicated situation, just 3.x will be fine. Library: Header-Only \u00b6 coroutine_portable is the only interface target in this example project. If you prefer to write header-only style codes, simply designating the path and flags will be enough. cmake_minimum_requried ( VERSION 3.6 ) # start a project. # defines cmake variables like PROJECT_NAME and PROJECT_SOURCE_DIR project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_headers INTERFACE ) set_target_properties ( my_coroutine_headers PROPERTIES # macro defintions INTERFACE_COMPILE_DEFINITIONS \"${CMAKE_SYSTEM_NAME}\" ) message ( STATUS \"macro defined: ${CMAKE_SYSTEM_NAME}\" ) # header include path target_include_directories ( my_coroutine_headers INTERFACE # path for `add_subdirectoy` $< BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include > # path after installation ( cmake --build . --target install ) $< INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include > ) Dealing with the compilers and their flags \u00b6 I strongly recommend to define compile options together so CMake can propagate them and reduce redundant compile option definitons in 'CMakeLists.txt' or '*.cmake' files. To do that, you have to check compiler. if ( ${ CMAKE_CXX_COMPILER_ID } MATCHES Clang ) if ( WIN32 ) # clang-cl for windows target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest -fms-compatibility -Xclang -fcoroutines-ts ) # for multiple definitions, you can do like this set_target_properties ( my_coroutine_headers PROPERTIES INTERFACE_COMPILE_DEFINITIONS \"CLANG_CL;_RESUMABLE_FUNCTIONS_SUPPORTED\" ) elseif ( UNIX OR APPLE ) # Clang or AppleClang target_compile_options ( my_coroutine_headers INTERFACE -std=c++2a -stdlib=libc++ -fcoroutines-ts ) endif () elseif ( MSVC ) target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest /await ) elseif ( ${ CMAKE_CXX_COMPILER_ID } MATCHES GNU ) target_compile_options ( my_coroutine_headers INTERFACE -std=gnu++2a -fcoroutines -fno-exceptions ) endif () Notice that I placed Clang ahead of MSVC. Even though clang-cl is specified with CMAKE_CXX_COMPILER , the CMake branch into the MSVC scope. In ohter words, it behaves like it's reusing WIN32 for the variable. So to be precise you always have to check the compiler familiy is clang. Library \u00b6 The only difference is that you have to list your source/header files in add_libary . cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_lib # ... list of source files in relative path ... # ... libmain.cpp ) set_target_properties ( my_coroutine_lib PROPERTIES CXX_STANDARD 14 # for CMake 3.8, you can use '17' here # for CMake 3.14, it can be '20' ) If some source files are platform dependent or requires some condition, use target_source function. if ( WIN32 ) target_source ( my_coroutine_lib PRIVATE impl_windows.cpp ) elseif ( APPLE ) target_source ( my_coroutine_lib PRIVATE impl_darwin.cpp ) elseif ( UNIX ) target_source ( my_coroutine_lib PRIVATE impl_unix.cpp ) endif () Since I already showed how to use compiler flags for C++ Coroutines, you can just copy & paste the part. The other way is to use target_link_libraries function, and inherit those 'interface' or 'public' compiler options. # PUBLIC: propagate these library dependencies # PRIVATE: consume and hide those dependencies target_link_libraries ( my_coroutine_lib PUBLIC my_coroutine_headers ) Isn't it simple? In this project, coroutine_event is defined like this. Executable \u00b6 If you already created some targets with add_library , the only thing you have to do is define an executable and to link it with the library. cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_executable ( my_coroutine_exe # ... list of source files in relative path ... # ... main.cpp ) target_link_libraries ( my_coroutine_exe PRIVATE my_coroutine_headers my_coroutine_lib ) That's all ! \u00b6 If you want to know more about the CMake and its usage, I recommend these materials. https://github.com/ruslo/CGold https://cliutils.gitlab.io/modern-cmake/","title":"How To Start: CMake"},{"location":"howto/start-using-cmake/#how-to-start-cmake","text":"Welcome! Well, this part is not about CMake's usage, nor setup of the CMake for your environment. I'd like to give the minimum CMake example for your project here.","title":"How To Start: CMake"},{"location":"howto/start-using-cmake/#cmakes-version","text":"At this moment(2019), I recommend you to use at least CMake 3.8 or later. The version is allows you to specify 17 for the CXX_STANDARD property(It will be commented). But that's not the necessary step . Indeed the key part not the cmake but the compiler itself! If you already aware of your developer environment, forget about that recommendation! For the examples below, I will keep specifing flags related to C++ standard. Unless you are in some complicated situation, just 3.x will be fine.","title":"CMake's Version ?"},{"location":"howto/start-using-cmake/#library-header-only","text":"coroutine_portable is the only interface target in this example project. If you prefer to write header-only style codes, simply designating the path and flags will be enough. cmake_minimum_requried ( VERSION 3.6 ) # start a project. # defines cmake variables like PROJECT_NAME and PROJECT_SOURCE_DIR project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_headers INTERFACE ) set_target_properties ( my_coroutine_headers PROPERTIES # macro defintions INTERFACE_COMPILE_DEFINITIONS \"${CMAKE_SYSTEM_NAME}\" ) message ( STATUS \"macro defined: ${CMAKE_SYSTEM_NAME}\" ) # header include path target_include_directories ( my_coroutine_headers INTERFACE # path for `add_subdirectoy` $< BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include > # path after installation ( cmake --build . --target install ) $< INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include > )","title":"Library: Header-Only"},{"location":"howto/start-using-cmake/#dealing-with-the-compilers-and-their-flags","text":"I strongly recommend to define compile options together so CMake can propagate them and reduce redundant compile option definitons in 'CMakeLists.txt' or '*.cmake' files. To do that, you have to check compiler. if ( ${ CMAKE_CXX_COMPILER_ID } MATCHES Clang ) if ( WIN32 ) # clang-cl for windows target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest -fms-compatibility -Xclang -fcoroutines-ts ) # for multiple definitions, you can do like this set_target_properties ( my_coroutine_headers PROPERTIES INTERFACE_COMPILE_DEFINITIONS \"CLANG_CL;_RESUMABLE_FUNCTIONS_SUPPORTED\" ) elseif ( UNIX OR APPLE ) # Clang or AppleClang target_compile_options ( my_coroutine_headers INTERFACE -std=c++2a -stdlib=libc++ -fcoroutines-ts ) endif () elseif ( MSVC ) target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest /await ) elseif ( ${ CMAKE_CXX_COMPILER_ID } MATCHES GNU ) target_compile_options ( my_coroutine_headers INTERFACE -std=gnu++2a -fcoroutines -fno-exceptions ) endif () Notice that I placed Clang ahead of MSVC. Even though clang-cl is specified with CMAKE_CXX_COMPILER , the CMake branch into the MSVC scope. In ohter words, it behaves like it's reusing WIN32 for the variable. So to be precise you always have to check the compiler familiy is clang.","title":"Dealing with the compilers and their flags"},{"location":"howto/start-using-cmake/#library","text":"The only difference is that you have to list your source/header files in add_libary . cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_lib # ... list of source files in relative path ... # ... libmain.cpp ) set_target_properties ( my_coroutine_lib PROPERTIES CXX_STANDARD 14 # for CMake 3.8, you can use '17' here # for CMake 3.14, it can be '20' ) If some source files are platform dependent or requires some condition, use target_source function. if ( WIN32 ) target_source ( my_coroutine_lib PRIVATE impl_windows.cpp ) elseif ( APPLE ) target_source ( my_coroutine_lib PRIVATE impl_darwin.cpp ) elseif ( UNIX ) target_source ( my_coroutine_lib PRIVATE impl_unix.cpp ) endif () Since I already showed how to use compiler flags for C++ Coroutines, you can just copy & paste the part. The other way is to use target_link_libraries function, and inherit those 'interface' or 'public' compiler options. # PUBLIC: propagate these library dependencies # PRIVATE: consume and hide those dependencies target_link_libraries ( my_coroutine_lib PUBLIC my_coroutine_headers ) Isn't it simple? In this project, coroutine_event is defined like this.","title":"Library"},{"location":"howto/start-using-cmake/#executable","text":"If you already created some targets with add_library , the only thing you have to do is define an executable and to link it with the library. cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_executable ( my_coroutine_exe # ... list of source files in relative path ... # ... main.cpp ) target_link_libraries ( my_coroutine_exe PRIVATE my_coroutine_headers my_coroutine_lib )","title":"Executable"},{"location":"howto/start-using-cmake/#thats-all","text":"If you want to know more about the CMake and its usage, I recommend these materials. https://github.com/ruslo/CGold https://cliutils.gitlab.io/modern-cmake/","title":"That's all !"},{"location":"ppt/Exploring-the-Cpp-Coroutine/","text":"Exploring the C++ Coroutine: Approach, Compiler, and Issues \u00b6 Note \u00b6 I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :) Links \u00b6 PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"C++ Korea 5th Seminar"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#exploring-the-c-coroutine-approach-compiler-and-issues","text":"","title":"Exploring the C++ Coroutine: Approach, Compiler, and Issues"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#note","text":"I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :)","title":"Note"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#links","text":"PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"Links"}]}