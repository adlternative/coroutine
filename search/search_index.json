{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Home/","text":"The document follows master branch Welcome to the luncliff/coroutine wiki! Please explore the pages with this link(GitHub Pages) If you have opinion for the docs, please create an issue and suggest your idea. Let me hear you and write more helpful contents. :D First with the C++ 20 Coroutines? \u00b6 If you're longing for the good references , visit the MattPD's collection ! If you want to run it now , there is a little example(Compiler Explorer) Developer Note \u00b6 This example project started with the post in 2017.02 . Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here! Articles Awaitable event using coroutine, epoll , and eventfd Designing the coroutine channel Combining C++ coroutines and pthread_create Russian Roulette and C++ Coroutines Windows DLL linking issues(WIP) Library Features \u00b6 Please check the navigation tab to explore the features. You can run them using the test codes in this repo. Clone the master branch and start your dive! :)","title":"Home"},{"location":"Home/#first-with-the-c-20-coroutines","text":"If you're longing for the good references , visit the MattPD's collection ! If you want to run it now , there is a little example(Compiler Explorer)","title":"First with the C++ 20 Coroutines?"},{"location":"Home/#developer-note","text":"This example project started with the post in 2017.02 . Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here! Articles Awaitable event using coroutine, epoll , and eventfd Designing the coroutine channel Combining C++ coroutines and pthread_create Russian Roulette and C++ Coroutines Windows DLL linking issues(WIP)","title":"Developer Note"},{"location":"Home/#library-features","text":"Please check the navigation tab to explore the features. You can run them using the test codes in this repo. Clone the master branch and start your dive! :)","title":"Library Features"},{"location":"_Footer/","text":"This work is licensed under a Creative Commons Attribution 4.0 International License .","title":" Footer"},{"location":"_c_make_c_x_x_compiler_id_8cpp/","text":"File CMakeCXXCompilerId.cpp \u00b6 File List > 3.16.1 > CompilerIdCXX > CMakeCXXCompilerId.cpp Go to the source code of this file. Public Attributes \u00b6 Type Name char const * info_arch = = \"INFO\" \":\" \"arch[\" ARCHITECTURE_ID \"]\" char const * info_compiler = = \"INFO\" \":\" \"compiler[\" COMPILER_ID \"]\" const char * info_language_dialect_default = = \"INFO\" \":\" \"dialect_default[\" \"98\" \"]\" | | char const * | info_platform = = \"INFO\" \":\" \"platform[\" PLATFORM_ID \"]\" | Public Functions \u00b6 Type Name int main (int argc, char * argv) Macros \u00b6 Type Name define ARCHITECTURE_ID define COMPILER_ID \"\" define CXX_STD __cplusplus define DEC (n) define HEX (n) define PLATFORM_ID define STRINGIFY (X) STRINGIFY_HELPER(X) define STRINGIFY_HELPER (X) #X Public Attributes Documentation \u00b6 variable info_arch \u00b6 char const * info_arch ; variable info_compiler \u00b6 char const * info_compiler ; variable info_language_dialect_default \u00b6 const char * info_language_dialect_default ; variable info_platform \u00b6 char const * info_platform ; Public Functions Documentation \u00b6 function main \u00b6 int main ( int argc , char * argv ) Macro Definition Documentation \u00b6 define ARCHITECTURE_ID \u00b6 #define ARCHITECTURE_ID define COMPILER_ID \u00b6 #define COMPILER_ID \"\" define CXX_STD \u00b6 #define CXX_STD __cplusplus define DEC \u00b6 #define DEC ( n ) ( '0' + ((( n ) / 10000000 ) % 10 )), \\ ( '0' + ((( n ) / 1000000 ) % 10 )), \\ ( '0' + ((( n ) / 100000 ) % 10 )), \\ ( '0' + ((( n ) / 10000 ) % 10 )), \\ ( '0' + ((( n ) / 1000 ) % 10 )), \\ ( '0' + ((( n ) / 100 ) % 10 )), \\ ( '0' + ((( n ) / 10 ) % 10 )), \\ ( '0' + (( n ) % 10 )) define HEX \u00b6 #define HEX ( n ) ( '0' + (( n ) >> 28 & 0xF )), \\ ( '0' + (( n ) >> 24 & 0xF )), \\ ( '0' + (( n ) >> 20 & 0xF )), \\ ( '0' + (( n ) >> 16 & 0xF )), \\ ( '0' + (( n ) >> 12 & 0xF )), \\ ( '0' + (( n ) >> 8 & 0xF )), \\ ( '0' + (( n ) >> 4 & 0xF )), \\ ( '0' + (( n ) & 0xF )) define PLATFORM_ID \u00b6 #define PLATFORM_ID define STRINGIFY \u00b6 #define STRINGIFY ( X ) STRINGIFY_HELPER ( X ) define STRINGIFY_HELPER \u00b6 #define STRINGIFY_HELPER ( X ) # X The documentation for this class was generated from the following file CMakeFiles/3.16.1/CompilerIdCXX/CMakeCXXCompilerId.cpp","title":"File CMakeCXXCompilerId.cpp"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#file-cmakecxxcompileridcpp","text":"File List > 3.16.1 > CompilerIdCXX > CMakeCXXCompilerId.cpp Go to the source code of this file.","title":"File CMakeCXXCompilerId.cpp"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#public-attributes","text":"Type Name char const * info_arch = = \"INFO\" \":\" \"arch[\" ARCHITECTURE_ID \"]\" char const * info_compiler = = \"INFO\" \":\" \"compiler[\" COMPILER_ID \"]\" const char * info_language_dialect_default = = \"INFO\" \":\" \"dialect_default[\" \"98\" \"]\" | | char const * | info_platform = = \"INFO\" \":\" \"platform[\" PLATFORM_ID \"]\" |","title":"Public Attributes"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#public-functions","text":"Type Name int main (int argc, char * argv)","title":"Public Functions"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#macros","text":"Type Name define ARCHITECTURE_ID define COMPILER_ID \"\" define CXX_STD __cplusplus define DEC (n) define HEX (n) define PLATFORM_ID define STRINGIFY (X) STRINGIFY_HELPER(X) define STRINGIFY_HELPER (X) #X","title":"Macros"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#variable-info95arch","text":"char const * info_arch ;","title":"variable info_arch"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#variable-info95compiler","text":"char const * info_compiler ;","title":"variable info_compiler"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#variable-info95language95dialect95default","text":"const char * info_language_dialect_default ;","title":"variable info_language_dialect_default"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#variable-info95platform","text":"char const * info_platform ;","title":"variable info_platform"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#function-main","text":"int main ( int argc , char * argv )","title":"function main"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#define-architecture95id","text":"#define ARCHITECTURE_ID","title":"define ARCHITECTURE_ID"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#define-compiler95id","text":"#define COMPILER_ID \"\"","title":"define COMPILER_ID"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#define-cxx95std","text":"#define CXX_STD __cplusplus","title":"define CXX_STD"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#define-dec","text":"#define DEC ( n ) ( '0' + ((( n ) / 10000000 ) % 10 )), \\ ( '0' + ((( n ) / 1000000 ) % 10 )), \\ ( '0' + ((( n ) / 100000 ) % 10 )), \\ ( '0' + ((( n ) / 10000 ) % 10 )), \\ ( '0' + ((( n ) / 1000 ) % 10 )), \\ ( '0' + ((( n ) / 100 ) % 10 )), \\ ( '0' + ((( n ) / 10 ) % 10 )), \\ ( '0' + (( n ) % 10 ))","title":"define DEC"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#define-hex","text":"#define HEX ( n ) ( '0' + (( n ) >> 28 & 0xF )), \\ ( '0' + (( n ) >> 24 & 0xF )), \\ ( '0' + (( n ) >> 20 & 0xF )), \\ ( '0' + (( n ) >> 16 & 0xF )), \\ ( '0' + (( n ) >> 12 & 0xF )), \\ ( '0' + (( n ) >> 8 & 0xF )), \\ ( '0' + (( n ) >> 4 & 0xF )), \\ ( '0' + (( n ) & 0xF ))","title":"define HEX"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#define-platform95id","text":"#define PLATFORM_ID","title":"define PLATFORM_ID"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#define-stringify","text":"#define STRINGIFY ( X ) STRINGIFY_HELPER ( X )","title":"define STRINGIFY"},{"location":"_c_make_c_x_x_compiler_id_8cpp/#define-stringify95helper","text":"#define STRINGIFY_HELPER ( X ) # X The documentation for this class was generated from the following file CMakeFiles/3.16.1/CompilerIdCXX/CMakeCXXCompilerId.cpp","title":"define STRINGIFY_HELPER"},{"location":"_c_make_c_x_x_compiler_id_8cpp_source/","text":"File CMakeCXXCompilerId.cpp \u00b6 File List > 3.16.1 > CompilerIdCXX > CMakeCXXCompilerId.cpp Go to the documentation of this file. /* This source file must have a .cpp extension so that all C++ compilers recognize the extension without flags. Borland does not know .cxx for example. */ #ifndef __cplusplus # error \"A C compiler has been selected for C++.\" #endif /* Version number components: V=Version, R=Revision, P=Patch Version date components: YYYY=Year, MM=Month, DD=Day */ #if defined(__COMO__) # define COMPILER_ID \"Comeau\" /* __COMO_VERSION__ = VRR */ # define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100) # define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100) #elif defined(__INTEL_COMPILER) || defined(__ICC) # define COMPILER_ID \"Intel\" # if defined(_MSC_VER) # define SIMULATE_ID \"MSVC\" # endif # if defined(__GNUC__) # define SIMULATE_ID \"GNU\" # endif /* __INTEL_COMPILER = VRP */ # define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100) # define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10) # if defined(__INTEL_COMPILER_UPDATE) # define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE) # else # define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER % 10) # endif # if defined(__INTEL_COMPILER_BUILD_DATE) /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */ # define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE) # endif # if defined(_MSC_VER) /* _MSC_VER = VVRR */ # define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100) # define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100) # endif # if defined(__GNUC__) # define SIMULATE_VERSION_MAJOR DEC(__GNUC__) # elif defined(__GNUG__) # define SIMULATE_VERSION_MAJOR DEC(__GNUG__) # endif # if defined(__GNUC_MINOR__) # define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__) # endif # if defined(__GNUC_PATCHLEVEL__) # define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__) # endif #elif defined(__PATHCC__) # define COMPILER_ID \"PathScale\" # define COMPILER_VERSION_MAJOR DEC(__PATHCC__) # define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__) # if defined(__PATHCC_PATCHLEVEL__) # define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__) # endif #elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__) # define COMPILER_ID \"Embarcadero\" # define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF) # define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF) # define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__ & 0xFFFF) #elif defined(__BORLANDC__) # define COMPILER_ID \"Borland\" /* __BORLANDC__ = 0xVRR */ # define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8) # define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF) #elif defined(__WATCOMC__) && __WATCOMC__ < 1200 # define COMPILER_ID \"Watcom\" /* __WATCOMC__ = VVRR */ # define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100) # define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10) # if (__WATCOMC__ % 10) > 0 # define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10) # endif #elif defined(__WATCOMC__) # define COMPILER_ID \"OpenWatcom\" /* __WATCOMC__ = VVRP + 1100 */ # define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100) # define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10) # if (__WATCOMC__ % 10) > 0 # define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10) # endif #elif defined(__SUNPRO_CC) # define COMPILER_ID \"SunPro\" # if __SUNPRO_CC >= 0x5100 /* __SUNPRO_CC = 0xVRRP */ # define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12) # define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF) # define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC & 0xF) # else /* __SUNPRO_CC = 0xVRP */ # define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8) # define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF) # define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC & 0xF) # endif #elif defined(__HP_aCC) # define COMPILER_ID \"HP\" /* __HP_aCC = VVRRPP */ # define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000) # define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100) # define COMPILER_VERSION_PATCH DEC(__HP_aCC % 100) #elif defined(__DECCXX) # define COMPILER_ID \"Compaq\" /* __DECCXX_VER = VVRRTPPPP */ # define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000) # define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000 % 100) # define COMPILER_VERSION_PATCH DEC(__DECCXX_VER % 10000) #elif defined(__IBMCPP__) && defined(__COMPILER_VER__) # define COMPILER_ID \"zOS\" /* __IBMCPP__ = VRP */ # define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100) # define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10) # define COMPILER_VERSION_PATCH DEC(__IBMCPP__ % 10) #elif defined(__ibmxl__) && defined(__clang__) # define COMPILER_ID \"XLClang\" # define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__) # define COMPILER_VERSION_MINOR DEC(__ibmxl_release__) # define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__) # define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__) #elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800 # define COMPILER_ID \"XL\" /* __IBMCPP__ = VRP */ # define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100) # define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10) # define COMPILER_VERSION_PATCH DEC(__IBMCPP__ % 10) #elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800 # define COMPILER_ID \"VisualAge\" /* __IBMCPP__ = VRP */ # define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100) # define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10) # define COMPILER_VERSION_PATCH DEC(__IBMCPP__ % 10) #elif defined(__PGI) # define COMPILER_ID \"PGI\" # define COMPILER_VERSION_MAJOR DEC(__PGIC__) # define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__) # if defined(__PGIC_PATCHLEVEL__) # define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__) # endif #elif defined(_CRAYC) # define COMPILER_ID \"Cray\" # define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR) # define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR) #elif defined(__TI_COMPILER_VERSION__) # define COMPILER_ID \"TI\" /* __TI_COMPILER_VERSION__ = VVVRRRPPP */ # define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000) # define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000 % 1000) # define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__ % 1000) #elif defined(__FUJITSU) || defined(__FCC_VERSION) || defined(__fcc_version) # define COMPILER_ID \"Fujitsu\" #elif defined(__ghs__) # define COMPILER_ID \"GHS\" /* __GHS_VERSION_NUMBER = VVVVRP */ # ifdef __GHS_VERSION_NUMBER # define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100) # define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10) # define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER % 10) # endif #elif defined(__SCO_VERSION__) # define COMPILER_ID \"SCO\" #elif defined(__ARMCC_VERSION) && !defined(__clang__) # define COMPILER_ID \"ARMCC\" #if __ARMCC_VERSION >= 1000000 /* __ARMCC_VERSION = VRRPPPP */ # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000) # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100) # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION % 10000) #else /* __ARMCC_VERSION = VRPPPP */ # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000) # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10) # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION % 10000) #endif #elif defined(__clang__) && defined(__apple_build_version__) # define COMPILER_ID \"AppleClang\" # if defined(_MSC_VER) # define SIMULATE_ID \"MSVC\" # endif # define COMPILER_VERSION_MAJOR DEC(__clang_major__) # define COMPILER_VERSION_MINOR DEC(__clang_minor__) # define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__) # if defined(_MSC_VER) /* _MSC_VER = VVRR */ # define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100) # define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100) # endif # define COMPILER_VERSION_TWEAK DEC(__apple_build_version__) #elif defined(__clang__) && defined(__ARMCOMPILER_VERSION) # define COMPILER_ID \"ARMClang\" # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000) # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100) # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION % 10000) # define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION) #elif defined(__clang__) # define COMPILER_ID \"Clang\" # if defined(_MSC_VER) # define SIMULATE_ID \"MSVC\" # endif # define COMPILER_VERSION_MAJOR DEC(__clang_major__) # define COMPILER_VERSION_MINOR DEC(__clang_minor__) # define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__) # if defined(_MSC_VER) /* _MSC_VER = VVRR */ # define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100) # define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100) # endif #elif defined(__GNUC__) || defined(__GNUG__) # define COMPILER_ID \"GNU\" # if defined(__GNUC__) # define COMPILER_VERSION_MAJOR DEC(__GNUC__) # else # define COMPILER_VERSION_MAJOR DEC(__GNUG__) # endif # if defined(__GNUC_MINOR__) # define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__) # endif # if defined(__GNUC_PATCHLEVEL__) # define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__) # endif #elif defined(_MSC_VER) # define COMPILER_ID \"MSVC\" /* _MSC_VER = VVRR */ # define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100) # define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100) # if defined(_MSC_FULL_VER) # if _MSC_VER >= 1400 /* _MSC_FULL_VER = VVRRPPPPP */ # define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000) # else /* _MSC_FULL_VER = VVRRPPPP */ # define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000) # endif # endif # if defined(_MSC_BUILD) # define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD) # endif #elif defined(__VISUALDSPVERSION__) || defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__) # define COMPILER_ID \"ADSP\" #if defined(__VISUALDSPVERSION__) /* __VISUALDSPVERSION__ = 0xVVRRPP00 */ # define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24) # define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF) # define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8 & 0xFF) #endif #elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC) # define COMPILER_ID \"IAR\" # if defined(__VER__) && defined(__ICCARM__) # define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000) # define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000) # define COMPILER_VERSION_PATCH DEC((__VER__) % 1000) # define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__) # elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__)) # define COMPILER_VERSION_MAJOR DEC((__VER__) / 100) # define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100)) # define COMPILER_VERSION_PATCH DEC(__SUBVERSION__) # define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__) # endif /* These compilers are either not known or too old to define an identification macro. Try to identify the platform and guess that it is the native compiler. */ #elif defined(__hpux) || defined(__hpua) # define COMPILER_ID \"HP\" #else /* unknown compiler */ # define COMPILER_ID \"\" #endif /* Construct the string literal in pieces to prevent the source from getting matched. Store it in a pointer rather than an array because some compilers will just produce instructions to fill the array rather than assigning a pointer to a static array. */ char const * info_compiler = \"INFO\" \":\" \"compiler[\" COMPILER_ID \"]\" ; #ifdef SIMULATE_ID char const * info_simulate = \"INFO\" \":\" \"simulate[\" SIMULATE_ID \"]\" ; #endif #ifdef __QNXNTO__ char const * qnxnto = \"INFO\" \":\" \"qnxnto[]\" ; #endif #if defined(__CRAYXE) || defined(__CRAYXC) char const * info_cray = \"INFO\" \":\" \"compiler_wrapper[CrayPrgEnv]\" ; #endif #define STRINGIFY_HELPER(X) #X #define STRINGIFY(X) STRINGIFY_HELPER(X) /* Identify known platforms by name. */ #if defined(__linux) || defined(__linux__) || defined(linux) # define PLATFORM_ID \"Linux\" #elif defined(__CYGWIN__) # define PLATFORM_ID \"Cygwin\" #elif defined(__MINGW32__) # define PLATFORM_ID \"MinGW\" #elif defined(__APPLE__) # define PLATFORM_ID \"Darwin\" #elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32) # define PLATFORM_ID \"Windows\" #elif defined(__FreeBSD__) || defined(__FreeBSD) # define PLATFORM_ID \"FreeBSD\" #elif defined(__NetBSD__) || defined(__NetBSD) # define PLATFORM_ID \"NetBSD\" #elif defined(__OpenBSD__) || defined(__OPENBSD) # define PLATFORM_ID \"OpenBSD\" #elif defined(__sun) || defined(sun) # define PLATFORM_ID \"SunOS\" #elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__) # define PLATFORM_ID \"AIX\" #elif defined(__hpux) || defined(__hpux__) # define PLATFORM_ID \"HP-UX\" #elif defined(__HAIKU__) # define PLATFORM_ID \"Haiku\" #elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS) # define PLATFORM_ID \"BeOS\" #elif defined(__QNX__) || defined(__QNXNTO__) # define PLATFORM_ID \"QNX\" #elif defined(__tru64) || defined(_tru64) || defined(__TRU64__) # define PLATFORM_ID \"Tru64\" #elif defined(__riscos) || defined(__riscos__) # define PLATFORM_ID \"RISCos\" #elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__) # define PLATFORM_ID \"SINIX\" #elif defined(__UNIX_SV__) # define PLATFORM_ID \"UNIX_SV\" #elif defined(__bsdos__) # define PLATFORM_ID \"BSDOS\" #elif defined(_MPRAS) || defined(MPRAS) # define PLATFORM_ID \"MP-RAS\" #elif defined(__osf) || defined(__osf__) # define PLATFORM_ID \"OSF1\" #elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv) # define PLATFORM_ID \"SCO_SV\" #elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX) # define PLATFORM_ID \"ULTRIX\" #elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX) # define PLATFORM_ID \"Xenix\" #elif defined(__WATCOMC__) # if defined(__LINUX__) # define PLATFORM_ID \"Linux\" # elif defined(__DOS__) # define PLATFORM_ID \"DOS\" # elif defined(__OS2__) # define PLATFORM_ID \"OS2\" # elif defined(__WINDOWS__) # define PLATFORM_ID \"Windows3x\" # else /* unknown platform */ # define PLATFORM_ID # endif #elif defined(__INTEGRITY) # if defined(INT_178B) # define PLATFORM_ID \"Integrity178\" # else /* regular Integrity */ # define PLATFORM_ID \"Integrity\" # endif #else /* unknown platform */ # define PLATFORM_ID #endif /* For windows compilers MSVC and Intel we can determine the architecture of the compiler being used. This is because the compilers do not have flags that can change the architecture, but rather depend on which compiler is being used */ #if defined(_WIN32) && defined(_MSC_VER) # if defined(_M_IA64) # define ARCHITECTURE_ID \"IA64\" # elif defined(_M_X64) || defined(_M_AMD64) # define ARCHITECTURE_ID \"x64\" # elif defined(_M_IX86) # define ARCHITECTURE_ID \"X86\" # elif defined(_M_ARM64) # define ARCHITECTURE_ID \"ARM64\" # elif defined(_M_ARM) # if _M_ARM == 4 # define ARCHITECTURE_ID \"ARMV4I\" # elif _M_ARM == 5 # define ARCHITECTURE_ID \"ARMV5I\" # else # define ARCHITECTURE_ID \"ARMV\" STRINGIFY(_M_ARM) # endif # elif defined(_M_MIPS) # define ARCHITECTURE_ID \"MIPS\" # elif defined(_M_SH) # define ARCHITECTURE_ID \"SHx\" # else /* unknown architecture */ # define ARCHITECTURE_ID \"\" # endif #elif defined(__WATCOMC__) # if defined(_M_I86) # define ARCHITECTURE_ID \"I86\" # elif defined(_M_IX86) # define ARCHITECTURE_ID \"X86\" # else /* unknown architecture */ # define ARCHITECTURE_ID \"\" # endif #elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC) # if defined(__ICCARM__) # define ARCHITECTURE_ID \"ARM\" # elif defined(__ICCRX__) # define ARCHITECTURE_ID \"RX\" # elif defined(__ICCRH850__) # define ARCHITECTURE_ID \"RH850\" # elif defined(__ICCRL78__) # define ARCHITECTURE_ID \"RL78\" # elif defined(__ICCRISCV__) # define ARCHITECTURE_ID \"RISCV\" # elif defined(__ICCAVR__) # define ARCHITECTURE_ID \"AVR\" # elif defined(__ICC430__) # define ARCHITECTURE_ID \"MSP430\" # elif defined(__ICCV850__) # define ARCHITECTURE_ID \"V850\" # elif defined(__ICC8051__) # define ARCHITECTURE_ID \"8051\" # else /* unknown architecture */ # define ARCHITECTURE_ID \"\" # endif #elif defined(__ghs__) # if defined(__PPC64__) # define ARCHITECTURE_ID \"PPC64\" # elif defined(__ppc__) # define ARCHITECTURE_ID \"PPC\" # elif defined(__ARM__) # define ARCHITECTURE_ID \"ARM\" # elif defined(__x86_64__) # define ARCHITECTURE_ID \"x64\" # elif defined(__i386__) # define ARCHITECTURE_ID \"X86\" # else /* unknown architecture */ # define ARCHITECTURE_ID \"\" # endif #else # define ARCHITECTURE_ID #endif /* Convert integer to decimal digit literals. */ #define DEC(n) \\ ('0' + (((n) / 10000000)%10)), \\ ('0' + (((n) / 1000000)%10)), \\ ('0' + (((n) / 100000)%10)), \\ ('0' + (((n) / 10000)%10)), \\ ('0' + (((n) / 1000)%10)), \\ ('0' + (((n) / 100)%10)), \\ ('0' + (((n) / 10)%10)), \\ ('0' + ((n) % 10)) /* Convert integer to hex digit literals. */ #define HEX(n) \\ ('0' + ((n)>>28 & 0xF)), \\ ('0' + ((n)>>24 & 0xF)), \\ ('0' + ((n)>>20 & 0xF)), \\ ('0' + ((n)>>16 & 0xF)), \\ ('0' + ((n)>>12 & 0xF)), \\ ('0' + ((n)>>8 & 0xF)), \\ ('0' + ((n)>>4 & 0xF)), \\ ('0' + ((n) & 0xF)) /* Construct a string literal encoding the version number components. */ #ifdef COMPILER_VERSION_MAJOR char const info_version [] = { 'I' , 'N' , 'F' , 'O' , ':' , 'c' , 'o' , 'm' , 'p' , 'i' , 'l' , 'e' , 'r' , '_' , 'v' , 'e' , 'r' , 's' , 'i' , 'o' , 'n' , '[' , COMPILER_VERSION_MAJOR , # ifdef COMPILER_VERSION_MINOR '.' , COMPILER_VERSION_MINOR , # ifdef COMPILER_VERSION_PATCH '.' , COMPILER_VERSION_PATCH , # ifdef COMPILER_VERSION_TWEAK '.' , COMPILER_VERSION_TWEAK , # endif # endif # endif ']' , '\\0' }; #endif /* Construct a string literal encoding the internal version number. */ #ifdef COMPILER_VERSION_INTERNAL char const info_version_internal [] = { 'I' , 'N' , 'F' , 'O' , ':' , 'c' , 'o' , 'm' , 'p' , 'i' , 'l' , 'e' , 'r' , '_' , 'v' , 'e' , 'r' , 's' , 'i' , 'o' , 'n' , '_' , 'i' , 'n' , 't' , 'e' , 'r' , 'n' , 'a' , 'l' , '[' , COMPILER_VERSION_INTERNAL , ']' , '\\0' }; #endif /* Construct a string literal encoding the version number components. */ #ifdef SIMULATE_VERSION_MAJOR char const info_simulate_version [] = { 'I' , 'N' , 'F' , 'O' , ':' , 's' , 'i' , 'm' , 'u' , 'l' , 'a' , 't' , 'e' , '_' , 'v' , 'e' , 'r' , 's' , 'i' , 'o' , 'n' , '[' , SIMULATE_VERSION_MAJOR , # ifdef SIMULATE_VERSION_MINOR '.' , SIMULATE_VERSION_MINOR , # ifdef SIMULATE_VERSION_PATCH '.' , SIMULATE_VERSION_PATCH , # ifdef SIMULATE_VERSION_TWEAK '.' , SIMULATE_VERSION_TWEAK , # endif # endif # endif ']' , '\\0' }; #endif /* Construct the string literal in pieces to prevent the source from getting matched. Store it in a pointer rather than an array because some compilers will just produce instructions to fill the array rather than assigning a pointer to a static array. */ char const * info_platform = \"INFO\" \":\" \"platform[\" PLATFORM_ID \"]\" ; char const * info_arch = \"INFO\" \":\" \"arch[\" ARCHITECTURE_ID \"]\" ; #if defined(__INTEL_COMPILER) && defined(_MSVC_LANG) && _MSVC_LANG < 201403L # if defined(__INTEL_CXX11_MODE__) # if defined(__cpp_aggregate_nsdmi) # define CXX_STD 201402L # else # define CXX_STD 201103L # endif # else # define CXX_STD 199711L # endif #elif defined(_MSC_VER) && defined(_MSVC_LANG) # define CXX_STD _MSVC_LANG #else # define CXX_STD __cplusplus #endif const char * info_language_dialect_default = \"INFO\" \":\" \"dialect_default[\" #if CXX_STD > 201703L \"20\" #elif CXX_STD >= 201703L \"17\" #elif CXX_STD >= 201402L \"14\" #elif CXX_STD >= 201103L \"11\" #else \"98\" #endif \"]\" ; /*--------------------------------------------------------------------------*/ int main ( int argc , char * argv []) { int require = 0 ; require += info_compiler [ argc ]; require += info_platform [ argc ]; #ifdef COMPILER_VERSION_MAJOR require += info_version [ argc ]; #endif #ifdef COMPILER_VERSION_INTERNAL require += info_version_internal [ argc ]; #endif #ifdef SIMULATE_ID require += info_simulate [ argc ]; #endif #ifdef SIMULATE_VERSION_MAJOR require += info_simulate_version [ argc ]; #endif #if defined(__CRAYXE) || defined(__CRAYXC) require += info_cray [ argc ]; #endif require += info_language_dialect_default [ argc ]; ( void ) argv ; return require ; }","title":"File CMakeCXXCompilerId.cpp"},{"location":"_c_make_c_x_x_compiler_id_8cpp_source/#file-cmakecxxcompileridcpp","text":"File List > 3.16.1 > CompilerIdCXX > CMakeCXXCompilerId.cpp Go to the documentation of this file. /* This source file must have a .cpp extension so that all C++ compilers recognize the extension without flags. Borland does not know .cxx for example. */ #ifndef __cplusplus # error \"A C compiler has been selected for C++.\" #endif /* Version number components: V=Version, R=Revision, P=Patch Version date components: YYYY=Year, MM=Month, DD=Day */ #if defined(__COMO__) # define COMPILER_ID \"Comeau\" /* __COMO_VERSION__ = VRR */ # define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100) # define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100) #elif defined(__INTEL_COMPILER) || defined(__ICC) # define COMPILER_ID \"Intel\" # if defined(_MSC_VER) # define SIMULATE_ID \"MSVC\" # endif # if defined(__GNUC__) # define SIMULATE_ID \"GNU\" # endif /* __INTEL_COMPILER = VRP */ # define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100) # define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10) # if defined(__INTEL_COMPILER_UPDATE) # define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE) # else # define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER % 10) # endif # if defined(__INTEL_COMPILER_BUILD_DATE) /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */ # define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE) # endif # if defined(_MSC_VER) /* _MSC_VER = VVRR */ # define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100) # define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100) # endif # if defined(__GNUC__) # define SIMULATE_VERSION_MAJOR DEC(__GNUC__) # elif defined(__GNUG__) # define SIMULATE_VERSION_MAJOR DEC(__GNUG__) # endif # if defined(__GNUC_MINOR__) # define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__) # endif # if defined(__GNUC_PATCHLEVEL__) # define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__) # endif #elif defined(__PATHCC__) # define COMPILER_ID \"PathScale\" # define COMPILER_VERSION_MAJOR DEC(__PATHCC__) # define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__) # if defined(__PATHCC_PATCHLEVEL__) # define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__) # endif #elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__) # define COMPILER_ID \"Embarcadero\" # define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF) # define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF) # define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__ & 0xFFFF) #elif defined(__BORLANDC__) # define COMPILER_ID \"Borland\" /* __BORLANDC__ = 0xVRR */ # define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8) # define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF) #elif defined(__WATCOMC__) && __WATCOMC__ < 1200 # define COMPILER_ID \"Watcom\" /* __WATCOMC__ = VVRR */ # define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100) # define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10) # if (__WATCOMC__ % 10) > 0 # define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10) # endif #elif defined(__WATCOMC__) # define COMPILER_ID \"OpenWatcom\" /* __WATCOMC__ = VVRP + 1100 */ # define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100) # define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10) # if (__WATCOMC__ % 10) > 0 # define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10) # endif #elif defined(__SUNPRO_CC) # define COMPILER_ID \"SunPro\" # if __SUNPRO_CC >= 0x5100 /* __SUNPRO_CC = 0xVRRP */ # define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12) # define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF) # define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC & 0xF) # else /* __SUNPRO_CC = 0xVRP */ # define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8) # define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF) # define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC & 0xF) # endif #elif defined(__HP_aCC) # define COMPILER_ID \"HP\" /* __HP_aCC = VVRRPP */ # define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000) # define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100) # define COMPILER_VERSION_PATCH DEC(__HP_aCC % 100) #elif defined(__DECCXX) # define COMPILER_ID \"Compaq\" /* __DECCXX_VER = VVRRTPPPP */ # define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000) # define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000 % 100) # define COMPILER_VERSION_PATCH DEC(__DECCXX_VER % 10000) #elif defined(__IBMCPP__) && defined(__COMPILER_VER__) # define COMPILER_ID \"zOS\" /* __IBMCPP__ = VRP */ # define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100) # define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10) # define COMPILER_VERSION_PATCH DEC(__IBMCPP__ % 10) #elif defined(__ibmxl__) && defined(__clang__) # define COMPILER_ID \"XLClang\" # define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__) # define COMPILER_VERSION_MINOR DEC(__ibmxl_release__) # define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__) # define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__) #elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800 # define COMPILER_ID \"XL\" /* __IBMCPP__ = VRP */ # define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100) # define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10) # define COMPILER_VERSION_PATCH DEC(__IBMCPP__ % 10) #elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800 # define COMPILER_ID \"VisualAge\" /* __IBMCPP__ = VRP */ # define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100) # define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10) # define COMPILER_VERSION_PATCH DEC(__IBMCPP__ % 10) #elif defined(__PGI) # define COMPILER_ID \"PGI\" # define COMPILER_VERSION_MAJOR DEC(__PGIC__) # define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__) # if defined(__PGIC_PATCHLEVEL__) # define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__) # endif #elif defined(_CRAYC) # define COMPILER_ID \"Cray\" # define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR) # define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR) #elif defined(__TI_COMPILER_VERSION__) # define COMPILER_ID \"TI\" /* __TI_COMPILER_VERSION__ = VVVRRRPPP */ # define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000) # define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000 % 1000) # define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__ % 1000) #elif defined(__FUJITSU) || defined(__FCC_VERSION) || defined(__fcc_version) # define COMPILER_ID \"Fujitsu\" #elif defined(__ghs__) # define COMPILER_ID \"GHS\" /* __GHS_VERSION_NUMBER = VVVVRP */ # ifdef __GHS_VERSION_NUMBER # define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100) # define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10) # define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER % 10) # endif #elif defined(__SCO_VERSION__) # define COMPILER_ID \"SCO\" #elif defined(__ARMCC_VERSION) && !defined(__clang__) # define COMPILER_ID \"ARMCC\" #if __ARMCC_VERSION >= 1000000 /* __ARMCC_VERSION = VRRPPPP */ # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000) # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100) # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION % 10000) #else /* __ARMCC_VERSION = VRPPPP */ # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000) # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10) # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION % 10000) #endif #elif defined(__clang__) && defined(__apple_build_version__) # define COMPILER_ID \"AppleClang\" # if defined(_MSC_VER) # define SIMULATE_ID \"MSVC\" # endif # define COMPILER_VERSION_MAJOR DEC(__clang_major__) # define COMPILER_VERSION_MINOR DEC(__clang_minor__) # define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__) # if defined(_MSC_VER) /* _MSC_VER = VVRR */ # define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100) # define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100) # endif # define COMPILER_VERSION_TWEAK DEC(__apple_build_version__) #elif defined(__clang__) && defined(__ARMCOMPILER_VERSION) # define COMPILER_ID \"ARMClang\" # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000) # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100) # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION % 10000) # define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION) #elif defined(__clang__) # define COMPILER_ID \"Clang\" # if defined(_MSC_VER) # define SIMULATE_ID \"MSVC\" # endif # define COMPILER_VERSION_MAJOR DEC(__clang_major__) # define COMPILER_VERSION_MINOR DEC(__clang_minor__) # define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__) # if defined(_MSC_VER) /* _MSC_VER = VVRR */ # define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100) # define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100) # endif #elif defined(__GNUC__) || defined(__GNUG__) # define COMPILER_ID \"GNU\" # if defined(__GNUC__) # define COMPILER_VERSION_MAJOR DEC(__GNUC__) # else # define COMPILER_VERSION_MAJOR DEC(__GNUG__) # endif # if defined(__GNUC_MINOR__) # define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__) # endif # if defined(__GNUC_PATCHLEVEL__) # define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__) # endif #elif defined(_MSC_VER) # define COMPILER_ID \"MSVC\" /* _MSC_VER = VVRR */ # define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100) # define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100) # if defined(_MSC_FULL_VER) # if _MSC_VER >= 1400 /* _MSC_FULL_VER = VVRRPPPPP */ # define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000) # else /* _MSC_FULL_VER = VVRRPPPP */ # define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000) # endif # endif # if defined(_MSC_BUILD) # define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD) # endif #elif defined(__VISUALDSPVERSION__) || defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__) # define COMPILER_ID \"ADSP\" #if defined(__VISUALDSPVERSION__) /* __VISUALDSPVERSION__ = 0xVVRRPP00 */ # define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24) # define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF) # define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8 & 0xFF) #endif #elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC) # define COMPILER_ID \"IAR\" # if defined(__VER__) && defined(__ICCARM__) # define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000) # define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000) # define COMPILER_VERSION_PATCH DEC((__VER__) % 1000) # define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__) # elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__)) # define COMPILER_VERSION_MAJOR DEC((__VER__) / 100) # define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100)) # define COMPILER_VERSION_PATCH DEC(__SUBVERSION__) # define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__) # endif /* These compilers are either not known or too old to define an identification macro. Try to identify the platform and guess that it is the native compiler. */ #elif defined(__hpux) || defined(__hpua) # define COMPILER_ID \"HP\" #else /* unknown compiler */ # define COMPILER_ID \"\" #endif /* Construct the string literal in pieces to prevent the source from getting matched. Store it in a pointer rather than an array because some compilers will just produce instructions to fill the array rather than assigning a pointer to a static array. */ char const * info_compiler = \"INFO\" \":\" \"compiler[\" COMPILER_ID \"]\" ; #ifdef SIMULATE_ID char const * info_simulate = \"INFO\" \":\" \"simulate[\" SIMULATE_ID \"]\" ; #endif #ifdef __QNXNTO__ char const * qnxnto = \"INFO\" \":\" \"qnxnto[]\" ; #endif #if defined(__CRAYXE) || defined(__CRAYXC) char const * info_cray = \"INFO\" \":\" \"compiler_wrapper[CrayPrgEnv]\" ; #endif #define STRINGIFY_HELPER(X) #X #define STRINGIFY(X) STRINGIFY_HELPER(X) /* Identify known platforms by name. */ #if defined(__linux) || defined(__linux__) || defined(linux) # define PLATFORM_ID \"Linux\" #elif defined(__CYGWIN__) # define PLATFORM_ID \"Cygwin\" #elif defined(__MINGW32__) # define PLATFORM_ID \"MinGW\" #elif defined(__APPLE__) # define PLATFORM_ID \"Darwin\" #elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32) # define PLATFORM_ID \"Windows\" #elif defined(__FreeBSD__) || defined(__FreeBSD) # define PLATFORM_ID \"FreeBSD\" #elif defined(__NetBSD__) || defined(__NetBSD) # define PLATFORM_ID \"NetBSD\" #elif defined(__OpenBSD__) || defined(__OPENBSD) # define PLATFORM_ID \"OpenBSD\" #elif defined(__sun) || defined(sun) # define PLATFORM_ID \"SunOS\" #elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__) # define PLATFORM_ID \"AIX\" #elif defined(__hpux) || defined(__hpux__) # define PLATFORM_ID \"HP-UX\" #elif defined(__HAIKU__) # define PLATFORM_ID \"Haiku\" #elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS) # define PLATFORM_ID \"BeOS\" #elif defined(__QNX__) || defined(__QNXNTO__) # define PLATFORM_ID \"QNX\" #elif defined(__tru64) || defined(_tru64) || defined(__TRU64__) # define PLATFORM_ID \"Tru64\" #elif defined(__riscos) || defined(__riscos__) # define PLATFORM_ID \"RISCos\" #elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__) # define PLATFORM_ID \"SINIX\" #elif defined(__UNIX_SV__) # define PLATFORM_ID \"UNIX_SV\" #elif defined(__bsdos__) # define PLATFORM_ID \"BSDOS\" #elif defined(_MPRAS) || defined(MPRAS) # define PLATFORM_ID \"MP-RAS\" #elif defined(__osf) || defined(__osf__) # define PLATFORM_ID \"OSF1\" #elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv) # define PLATFORM_ID \"SCO_SV\" #elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX) # define PLATFORM_ID \"ULTRIX\" #elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX) # define PLATFORM_ID \"Xenix\" #elif defined(__WATCOMC__) # if defined(__LINUX__) # define PLATFORM_ID \"Linux\" # elif defined(__DOS__) # define PLATFORM_ID \"DOS\" # elif defined(__OS2__) # define PLATFORM_ID \"OS2\" # elif defined(__WINDOWS__) # define PLATFORM_ID \"Windows3x\" # else /* unknown platform */ # define PLATFORM_ID # endif #elif defined(__INTEGRITY) # if defined(INT_178B) # define PLATFORM_ID \"Integrity178\" # else /* regular Integrity */ # define PLATFORM_ID \"Integrity\" # endif #else /* unknown platform */ # define PLATFORM_ID #endif /* For windows compilers MSVC and Intel we can determine the architecture of the compiler being used. This is because the compilers do not have flags that can change the architecture, but rather depend on which compiler is being used */ #if defined(_WIN32) && defined(_MSC_VER) # if defined(_M_IA64) # define ARCHITECTURE_ID \"IA64\" # elif defined(_M_X64) || defined(_M_AMD64) # define ARCHITECTURE_ID \"x64\" # elif defined(_M_IX86) # define ARCHITECTURE_ID \"X86\" # elif defined(_M_ARM64) # define ARCHITECTURE_ID \"ARM64\" # elif defined(_M_ARM) # if _M_ARM == 4 # define ARCHITECTURE_ID \"ARMV4I\" # elif _M_ARM == 5 # define ARCHITECTURE_ID \"ARMV5I\" # else # define ARCHITECTURE_ID \"ARMV\" STRINGIFY(_M_ARM) # endif # elif defined(_M_MIPS) # define ARCHITECTURE_ID \"MIPS\" # elif defined(_M_SH) # define ARCHITECTURE_ID \"SHx\" # else /* unknown architecture */ # define ARCHITECTURE_ID \"\" # endif #elif defined(__WATCOMC__) # if defined(_M_I86) # define ARCHITECTURE_ID \"I86\" # elif defined(_M_IX86) # define ARCHITECTURE_ID \"X86\" # else /* unknown architecture */ # define ARCHITECTURE_ID \"\" # endif #elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC) # if defined(__ICCARM__) # define ARCHITECTURE_ID \"ARM\" # elif defined(__ICCRX__) # define ARCHITECTURE_ID \"RX\" # elif defined(__ICCRH850__) # define ARCHITECTURE_ID \"RH850\" # elif defined(__ICCRL78__) # define ARCHITECTURE_ID \"RL78\" # elif defined(__ICCRISCV__) # define ARCHITECTURE_ID \"RISCV\" # elif defined(__ICCAVR__) # define ARCHITECTURE_ID \"AVR\" # elif defined(__ICC430__) # define ARCHITECTURE_ID \"MSP430\" # elif defined(__ICCV850__) # define ARCHITECTURE_ID \"V850\" # elif defined(__ICC8051__) # define ARCHITECTURE_ID \"8051\" # else /* unknown architecture */ # define ARCHITECTURE_ID \"\" # endif #elif defined(__ghs__) # if defined(__PPC64__) # define ARCHITECTURE_ID \"PPC64\" # elif defined(__ppc__) # define ARCHITECTURE_ID \"PPC\" # elif defined(__ARM__) # define ARCHITECTURE_ID \"ARM\" # elif defined(__x86_64__) # define ARCHITECTURE_ID \"x64\" # elif defined(__i386__) # define ARCHITECTURE_ID \"X86\" # else /* unknown architecture */ # define ARCHITECTURE_ID \"\" # endif #else # define ARCHITECTURE_ID #endif /* Convert integer to decimal digit literals. */ #define DEC(n) \\ ('0' + (((n) / 10000000)%10)), \\ ('0' + (((n) / 1000000)%10)), \\ ('0' + (((n) / 100000)%10)), \\ ('0' + (((n) / 10000)%10)), \\ ('0' + (((n) / 1000)%10)), \\ ('0' + (((n) / 100)%10)), \\ ('0' + (((n) / 10)%10)), \\ ('0' + ((n) % 10)) /* Convert integer to hex digit literals. */ #define HEX(n) \\ ('0' + ((n)>>28 & 0xF)), \\ ('0' + ((n)>>24 & 0xF)), \\ ('0' + ((n)>>20 & 0xF)), \\ ('0' + ((n)>>16 & 0xF)), \\ ('0' + ((n)>>12 & 0xF)), \\ ('0' + ((n)>>8 & 0xF)), \\ ('0' + ((n)>>4 & 0xF)), \\ ('0' + ((n) & 0xF)) /* Construct a string literal encoding the version number components. */ #ifdef COMPILER_VERSION_MAJOR char const info_version [] = { 'I' , 'N' , 'F' , 'O' , ':' , 'c' , 'o' , 'm' , 'p' , 'i' , 'l' , 'e' , 'r' , '_' , 'v' , 'e' , 'r' , 's' , 'i' , 'o' , 'n' , '[' , COMPILER_VERSION_MAJOR , # ifdef COMPILER_VERSION_MINOR '.' , COMPILER_VERSION_MINOR , # ifdef COMPILER_VERSION_PATCH '.' , COMPILER_VERSION_PATCH , # ifdef COMPILER_VERSION_TWEAK '.' , COMPILER_VERSION_TWEAK , # endif # endif # endif ']' , '\\0' }; #endif /* Construct a string literal encoding the internal version number. */ #ifdef COMPILER_VERSION_INTERNAL char const info_version_internal [] = { 'I' , 'N' , 'F' , 'O' , ':' , 'c' , 'o' , 'm' , 'p' , 'i' , 'l' , 'e' , 'r' , '_' , 'v' , 'e' , 'r' , 's' , 'i' , 'o' , 'n' , '_' , 'i' , 'n' , 't' , 'e' , 'r' , 'n' , 'a' , 'l' , '[' , COMPILER_VERSION_INTERNAL , ']' , '\\0' }; #endif /* Construct a string literal encoding the version number components. */ #ifdef SIMULATE_VERSION_MAJOR char const info_simulate_version [] = { 'I' , 'N' , 'F' , 'O' , ':' , 's' , 'i' , 'm' , 'u' , 'l' , 'a' , 't' , 'e' , '_' , 'v' , 'e' , 'r' , 's' , 'i' , 'o' , 'n' , '[' , SIMULATE_VERSION_MAJOR , # ifdef SIMULATE_VERSION_MINOR '.' , SIMULATE_VERSION_MINOR , # ifdef SIMULATE_VERSION_PATCH '.' , SIMULATE_VERSION_PATCH , # ifdef SIMULATE_VERSION_TWEAK '.' , SIMULATE_VERSION_TWEAK , # endif # endif # endif ']' , '\\0' }; #endif /* Construct the string literal in pieces to prevent the source from getting matched. Store it in a pointer rather than an array because some compilers will just produce instructions to fill the array rather than assigning a pointer to a static array. */ char const * info_platform = \"INFO\" \":\" \"platform[\" PLATFORM_ID \"]\" ; char const * info_arch = \"INFO\" \":\" \"arch[\" ARCHITECTURE_ID \"]\" ; #if defined(__INTEL_COMPILER) && defined(_MSVC_LANG) && _MSVC_LANG < 201403L # if defined(__INTEL_CXX11_MODE__) # if defined(__cpp_aggregate_nsdmi) # define CXX_STD 201402L # else # define CXX_STD 201103L # endif # else # define CXX_STD 199711L # endif #elif defined(_MSC_VER) && defined(_MSVC_LANG) # define CXX_STD _MSVC_LANG #else # define CXX_STD __cplusplus #endif const char * info_language_dialect_default = \"INFO\" \":\" \"dialect_default[\" #if CXX_STD > 201703L \"20\" #elif CXX_STD >= 201703L \"17\" #elif CXX_STD >= 201402L \"14\" #elif CXX_STD >= 201103L \"11\" #else \"98\" #endif \"]\" ; /*--------------------------------------------------------------------------*/ int main ( int argc , char * argv []) { int require = 0 ; require += info_compiler [ argc ]; require += info_platform [ argc ]; #ifdef COMPILER_VERSION_MAJOR require += info_version [ argc ]; #endif #ifdef COMPILER_VERSION_INTERNAL require += info_version_internal [ argc ]; #endif #ifdef SIMULATE_ID require += info_simulate [ argc ]; #endif #ifdef SIMULATE_VERSION_MAJOR require += info_simulate_version [ argc ]; #endif #if defined(__CRAYXE) || defined(__CRAYXC) require += info_cray [ argc ]; #endif require += info_language_dialect_default [ argc ]; ( void ) argv ; return require ; }","title":"File CMakeCXXCompilerId.cpp"},{"location":"algorithm__tests_8cpp/","text":"File algorithm_tests.cpp \u00b6 File List > external > guideline > tests > algorithm_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_algorithm> #include <gsl/span> #include <array> #include <cstddef> Namespaces \u00b6 Type Name namespace gsl Public Functions \u00b6 Type Name GSL_SUPPRESS (bounds. 4) TEST_CASE (\"small_destination_span\") Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( bounds . 4 ) function TEST_CASE \u00b6 TEST_CASE ( \"small_destination_span\" ) The documentation for this class was generated from the following file external/guideline/tests/algorithm_tests.cpp","title":"File algorithm\\_tests.cpp"},{"location":"algorithm__tests_8cpp/#file-algorithm95testscpp","text":"File List > external > guideline > tests > algorithm_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_algorithm> #include <gsl/span> #include <array> #include <cstddef>","title":"File algorithm_tests.cpp"},{"location":"algorithm__tests_8cpp/#namespaces","text":"Type Name namespace gsl","title":"Namespaces"},{"location":"algorithm__tests_8cpp/#public-functions","text":"Type Name GSL_SUPPRESS (bounds. 4) TEST_CASE (\"small_destination_span\")","title":"Public Functions"},{"location":"algorithm__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"algorithm__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( bounds . 4 )","title":"function GSL_SUPPRESS"},{"location":"algorithm__tests_8cpp/#function-test95case","text":"TEST_CASE ( \"small_destination_span\" ) The documentation for this class was generated from the following file external/guideline/tests/algorithm_tests.cpp","title":"function TEST_CASE"},{"location":"algorithm__tests_8cpp_source/","text":"File algorithm_tests.cpp \u00b6 File List > external > guideline > tests > algorithm_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, CHE... #include <gsl/gsl_algorithm> // for copy #include <gsl/span> // for span #include <array> // for array #include <cstddef> // for size_t namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"same_type\" ) { // dynamic source and destination span { std :: array < int , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < int > src_span ( src ); const span < int > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // static source and dynamic destination span { std :: array < int , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < int , 5 > src_span ( src ); const span < int > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // dynamic source and static destination span { std :: array < int , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < int > src_span ( src ); const span < int , 10 > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // static source and destination span { std :: array < int , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < int , 5 > src_span ( src ); const span < int , 10 > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"compatible_type\" ) { // dynamic source and destination span { std :: array < short , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < short > src_span ( src ); const span < int > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // static source and dynamic destination span { std :: array < short , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < short , 5 > src_span ( src ); const span < int > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // dynamic source and static destination span { std :: array < short , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < short > src_span ( src ); const span < int , 10 > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // static source and destination span { std :: array < short , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < short , 5 > src_span ( src ); const span < int , 10 > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } } #ifdef CONFIRM_COMPILATION_ERRORS TEST_CASE ( \"incompatible_type\" ) { std :: array < int , 4 > src { 1 , 2 , 3 , 4 }; std :: array < int * , 12 > dst {}; span < int > src_span_dyn ( src ); span < int , 4 > src_span_static ( src ); span < int *> dst_span_dyn ( dst ); span < int * , 4 > dst_span_static ( dst ); // every line should produce a compilation error copy ( src_span_dyn , dst_span_dyn ); copy ( src_span_dyn , dst_span_static ); copy ( src_span_static , dst_span_dyn ); copy ( src_span_static , dst_span_static ); } #endif TEST_CASE ( \"small_destination_span\" ) { std :: array < int , 12 > src { 1 , 2 , 3 , 4 }; std :: array < int , 4 > dst {}; const span < int > src_span_dyn ( src ); const span < int , 12 > src_span_static ( src ); const span < int > dst_span_dyn ( dst ); const span < int , 4 > dst_span_static ( dst ); CHECK_THROWS_AS ( copy ( src_span_dyn , dst_span_dyn ), fail_fast ); CHECK_THROWS_AS ( copy ( src_span_dyn , dst_span_static ), fail_fast ); CHECK_THROWS_AS ( copy ( src_span_static , dst_span_dyn ), fail_fast ); #ifdef CONFIRM_COMPILATION_ERRORS copy ( src_span_static , dst_span_static ); #endif }","title":"File algorithm\\_tests.cpp"},{"location":"algorithm__tests_8cpp_source/#file-algorithm95testscpp","text":"File List > external > guideline > tests > algorithm_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, CHE... #include <gsl/gsl_algorithm> // for copy #include <gsl/span> // for span #include <array> // for array #include <cstddef> // for size_t namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"same_type\" ) { // dynamic source and destination span { std :: array < int , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < int > src_span ( src ); const span < int > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // static source and dynamic destination span { std :: array < int , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < int , 5 > src_span ( src ); const span < int > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // dynamic source and static destination span { std :: array < int , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < int > src_span ( src ); const span < int , 10 > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // static source and destination span { std :: array < int , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < int , 5 > src_span ( src ); const span < int , 10 > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"compatible_type\" ) { // dynamic source and destination span { std :: array < short , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < short > src_span ( src ); const span < int > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // static source and dynamic destination span { std :: array < short , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < short , 5 > src_span ( src ); const span < int > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // dynamic source and static destination span { std :: array < short , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < short > src_span ( src ); const span < int , 10 > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } // static source and destination span { std :: array < short , 5 > src { 1 , 2 , 3 , 4 , 5 }; std :: array < int , 10 > dst {}; const span < short , 5 > src_span ( src ); const span < int , 10 > dst_span ( dst ); copy ( src_span , dst_span ); copy ( src_span , dst_span . subspan ( src_span . size ())); for ( std :: size_t i = 0 ; i < src . size (); ++ i ) { CHECK ( dst [ i ] == src [ i ]); CHECK ( dst [ i + src . size ()] == src [ i ]); } } } #ifdef CONFIRM_COMPILATION_ERRORS TEST_CASE ( \"incompatible_type\" ) { std :: array < int , 4 > src { 1 , 2 , 3 , 4 }; std :: array < int * , 12 > dst {}; span < int > src_span_dyn ( src ); span < int , 4 > src_span_static ( src ); span < int *> dst_span_dyn ( dst ); span < int * , 4 > dst_span_static ( dst ); // every line should produce a compilation error copy ( src_span_dyn , dst_span_dyn ); copy ( src_span_dyn , dst_span_static ); copy ( src_span_static , dst_span_dyn ); copy ( src_span_static , dst_span_static ); } #endif TEST_CASE ( \"small_destination_span\" ) { std :: array < int , 12 > src { 1 , 2 , 3 , 4 }; std :: array < int , 4 > dst {}; const span < int > src_span_dyn ( src ); const span < int , 12 > src_span_static ( src ); const span < int > dst_span_dyn ( dst ); const span < int , 4 > dst_span_static ( dst ); CHECK_THROWS_AS ( copy ( src_span_dyn , dst_span_dyn ), fail_fast ); CHECK_THROWS_AS ( copy ( src_span_dyn , dst_span_static ), fail_fast ); CHECK_THROWS_AS ( copy ( src_span_static , dst_span_dyn ), fail_fast ); #ifdef CONFIRM_COMPILATION_ERRORS copy ( src_span_static , dst_span_static ); #endif }","title":"File algorithm_tests.cpp"},{"location":"annotated/","text":"Class List \u00b6 Here are the classes, structs, unions and interfaces with brief descriptions: namespace @11 namespace @13 namespace @4 namespace @5 namespace @6 struct CustomPtr struct MyBase struct MyDerived struct NonCopyableNonMovable struct RefCounted struct Unrelated struct clang_frame_prefix namespace coro struct bypass_lock class channel struct darwin_event class enumerable class iterator class promise_type struct event_poll_t class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type namespace internal class list class io_recv class io_recv_from class io_send class io_send_to class io_work_t struct kernel_queue_t class peeker class promise_aa class promise_an class promise_na class promise_nn class reader class writer struct gcc_frame_prefix namespace generic namespace gsl struct msvc_frame_prefix namespace std namespace experimental class coroutine_handle class coroutine_handle< noop_coroutine_promise > class coroutine_handle< void > union prefix_t struct coroutine_traits struct noop_coroutine_promise class suspend_always class suspend_never namespace chrono","title":"Class List"},{"location":"annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: namespace @11 namespace @13 namespace @4 namespace @5 namespace @6 struct CustomPtr struct MyBase struct MyDerived struct NonCopyableNonMovable struct RefCounted struct Unrelated struct clang_frame_prefix namespace coro struct bypass_lock class channel struct darwin_event class enumerable class iterator class promise_type struct event_poll_t class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type namespace internal class list class io_recv class io_recv_from class io_send class io_send_to class io_work_t struct kernel_queue_t class peeker class promise_aa class promise_an class promise_na class promise_nn class reader class writer struct gcc_frame_prefix namespace generic namespace gsl struct msvc_frame_prefix namespace std namespace experimental class coroutine_handle class coroutine_handle< noop_coroutine_promise > class coroutine_handle< void > union prefix_t struct coroutine_traits struct noop_coroutine_promise class suspend_always class suspend_never namespace chrono","title":"Class List"},{"location":"assertion__tests_8cpp/","text":"File assertion_tests.cpp \u00b6 File List > external > guideline > tests > assertion_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_assert> Public Functions \u00b6 Type Name TEST_CASE (\"expects\") TEST_CASE (\"ensures\") int f (int i) int g (int i) Public Functions Documentation \u00b6 function TEST_CASE \u00b6 TEST_CASE ( \"expects\" ) function TEST_CASE \u00b6 TEST_CASE ( \"ensures\" ) function f \u00b6 int f ( int i ) function g \u00b6 int g ( int i ) The documentation for this class was generated from the following file external/guideline/tests/assertion_tests.cpp","title":"File assertion\\_tests.cpp"},{"location":"assertion__tests_8cpp/#file-assertion95testscpp","text":"File List > external > guideline > tests > assertion_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_assert>","title":"File assertion_tests.cpp"},{"location":"assertion__tests_8cpp/#public-functions","text":"Type Name TEST_CASE (\"expects\") TEST_CASE (\"ensures\") int f (int i) int g (int i)","title":"Public Functions"},{"location":"assertion__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"assertion__tests_8cpp/#function-test95case","text":"TEST_CASE ( \"expects\" )","title":"function TEST_CASE"},{"location":"assertion__tests_8cpp/#function-test95case_1","text":"TEST_CASE ( \"ensures\" )","title":"function TEST_CASE"},{"location":"assertion__tests_8cpp/#function-f","text":"int f ( int i )","title":"function f"},{"location":"assertion__tests_8cpp/#function-g","text":"int g ( int i ) The documentation for this class was generated from the following file external/guideline/tests/assertion_tests.cpp","title":"function g"},{"location":"assertion__tests_8cpp_source/","text":"File assertion_tests.cpp \u00b6 File List > external > guideline > tests > assertion_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, CHECK... #include <gsl/gsl_assert> // for fail_fast (ptr only), Ensures, Expects using namespace gsl ; int f ( int i ) { Expects ( i > 0 && i < 10 ); return i ; } TEST_CASE ( \"expects\" ) { CHECK ( f ( 2 ) == 2 ); CHECK_THROWS_AS ( f ( 10 ), fail_fast ); } int g ( int i ) { i ++ ; Ensures ( i > 0 && i < 10 ); return i ; } TEST_CASE ( \"ensures\" ) { CHECK ( g ( 2 ) == 3 ); CHECK_THROWS_AS ( g ( 9 ), fail_fast ); }","title":"File assertion\\_tests.cpp"},{"location":"assertion__tests_8cpp_source/#file-assertion95testscpp","text":"File List > external > guideline > tests > assertion_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, CHECK... #include <gsl/gsl_assert> // for fail_fast (ptr only), Ensures, Expects using namespace gsl ; int f ( int i ) { Expects ( i > 0 && i < 10 ); return i ; } TEST_CASE ( \"expects\" ) { CHECK ( f ( 2 ) == 2 ); CHECK_THROWS_AS ( f ( 10 ), fail_fast ); } int g ( int i ) { i ++ ; Ensures ( i > 0 && i < 10 ); return i ; } TEST_CASE ( \"ensures\" ) { CHECK ( g ( 2 ) == 3 ); CHECK_THROWS_AS ( g ( 9 ), fail_fast ); }","title":"File assertion_tests.cpp"},{"location":"at__tests_8cpp/","text":"File at_tests.cpp \u00b6 File List > external > guideline > tests > at_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_util> #include <array> #include <cstddef> #include <initializer_list> #include <vector> Namespaces \u00b6 Type Name namespace gsl Public Functions \u00b6 Type Name GSL_SUPPRESS (bounds. 4) Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( bounds . 4 ) The documentation for this class was generated from the following file external/guideline/tests/at_tests.cpp","title":"File at\\_tests.cpp"},{"location":"at__tests_8cpp/#file-at95testscpp","text":"File List > external > guideline > tests > at_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_util> #include <array> #include <cstddef> #include <initializer_list> #include <vector>","title":"File at_tests.cpp"},{"location":"at__tests_8cpp/#namespaces","text":"Type Name namespace gsl","title":"Namespaces"},{"location":"at__tests_8cpp/#public-functions","text":"Type Name GSL_SUPPRESS (bounds. 4)","title":"Public Functions"},{"location":"at__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"at__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( bounds . 4 ) The documentation for this class was generated from the following file external/guideline/tests/at_tests.cpp","title":"function GSL_SUPPRESS"},{"location":"at__tests_8cpp_source/","text":"File at_tests.cpp \u00b6 File List > external > guideline > tests > at_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK_THROW... #include <gsl/gsl_util> // for at #include <array> // for array #include <cstddef> // for size_t #include <initializer_list> // for initializer_list #include <vector> // for vector namespace gsl { struct fail_fast ; } // namespace gsl using gsl :: fail_fast ; GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"static_array\" ) { int a [ 4 ] = { 1 , 2 , 3 , 4 }; const int ( & c_a )[ 4 ] = a ; for ( int i = 0 ; i < 4 ; ++ i ) { CHECK ( & gsl :: at ( a , i ) == & a [ i ]); CHECK ( & gsl :: at ( c_a , i ) == & a [ i ]); } CHECK_THROWS_AS ( gsl :: at ( a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( a , 4 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , 4 ), fail_fast ); } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"std_array\" ) { std :: array < int , 4 > a = { 1 , 2 , 3 , 4 }; const std :: array < int , 4 >& c_a = a ; for ( int i = 0 ; i < 4 ; ++ i ) { CHECK ( & gsl :: at ( a , i ) == & a [ static_cast < std :: size_t > ( i )]); CHECK ( & gsl :: at ( c_a , i ) == & a [ static_cast < std :: size_t > ( i )]); } CHECK_THROWS_AS ( gsl :: at ( a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( a , 4 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , 4 ), fail_fast ); } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"StdVector\" ) { std :: vector < int > a = { 1 , 2 , 3 , 4 }; const std :: vector < int >& c_a = a ; for ( int i = 0 ; i < 4 ; ++ i ) { CHECK ( & gsl :: at ( a , i ) == & a [ static_cast < std :: size_t > ( i )]); CHECK ( & gsl :: at ( c_a , i ) == & a [ static_cast < std :: size_t > ( i )]); } CHECK_THROWS_AS ( gsl :: at ( a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( a , 4 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , 4 ), fail_fast ); } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"InitializerList\" ) { const std :: initializer_list < int > a = { 1 , 2 , 3 , 4 }; for ( int i = 0 ; i < 4 ; ++ i ) { CHECK ( gsl :: at ( a , i ) == i + 1 ); CHECK ( gsl :: at ({ 1 , 2 , 3 , 4 }, i ) == i + 1 ); } CHECK_THROWS_AS ( gsl :: at ( a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( a , 4 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ({ 1 , 2 , 3 , 4 }, - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ({ 1 , 2 , 3 , 4 }, 4 ), fail_fast ); } #if !defined(_MSC_VER) || defined(__clang__) || _MSC_VER >= 1910 GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute static constexpr bool test_constexpr () { int a1 [ 4 ] = { 1 , 2 , 3 , 4 }; const int ( & c_a1 )[ 4 ] = a1 ; std :: array < int , 4 > a2 = { 1 , 2 , 3 , 4 }; const std :: array < int , 4 >& c_a2 = a2 ; for ( int i = 0 ; i < 4 ; ++ i ) { if ( & gsl :: at ( a1 , i ) != & a1 [ i ]) return false ; if ( & gsl :: at ( c_a1 , i ) != & a1 [ i ]) return false ; // requires C++17: // if (&gsl::at(a2, i) != &a2[static_cast<std::size_t>(i)]) return false; if ( & gsl :: at ( c_a2 , i ) != & c_a2 [ static_cast < std :: size_t > ( i )]) return false ; if ( gsl :: at ({ 1 , 2 , 3 , 4 }, i ) != i + 1 ) return false ; } return true ; } static_assert ( test_constexpr (), \"FAIL\" ); #endif","title":"File at\\_tests.cpp"},{"location":"at__tests_8cpp_source/#file-at95testscpp","text":"File List > external > guideline > tests > at_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK_THROW... #include <gsl/gsl_util> // for at #include <array> // for array #include <cstddef> // for size_t #include <initializer_list> // for initializer_list #include <vector> // for vector namespace gsl { struct fail_fast ; } // namespace gsl using gsl :: fail_fast ; GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"static_array\" ) { int a [ 4 ] = { 1 , 2 , 3 , 4 }; const int ( & c_a )[ 4 ] = a ; for ( int i = 0 ; i < 4 ; ++ i ) { CHECK ( & gsl :: at ( a , i ) == & a [ i ]); CHECK ( & gsl :: at ( c_a , i ) == & a [ i ]); } CHECK_THROWS_AS ( gsl :: at ( a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( a , 4 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , 4 ), fail_fast ); } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"std_array\" ) { std :: array < int , 4 > a = { 1 , 2 , 3 , 4 }; const std :: array < int , 4 >& c_a = a ; for ( int i = 0 ; i < 4 ; ++ i ) { CHECK ( & gsl :: at ( a , i ) == & a [ static_cast < std :: size_t > ( i )]); CHECK ( & gsl :: at ( c_a , i ) == & a [ static_cast < std :: size_t > ( i )]); } CHECK_THROWS_AS ( gsl :: at ( a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( a , 4 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , 4 ), fail_fast ); } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"StdVector\" ) { std :: vector < int > a = { 1 , 2 , 3 , 4 }; const std :: vector < int >& c_a = a ; for ( int i = 0 ; i < 4 ; ++ i ) { CHECK ( & gsl :: at ( a , i ) == & a [ static_cast < std :: size_t > ( i )]); CHECK ( & gsl :: at ( c_a , i ) == & a [ static_cast < std :: size_t > ( i )]); } CHECK_THROWS_AS ( gsl :: at ( a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( a , 4 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( c_a , 4 ), fail_fast ); } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"InitializerList\" ) { const std :: initializer_list < int > a = { 1 , 2 , 3 , 4 }; for ( int i = 0 ; i < 4 ; ++ i ) { CHECK ( gsl :: at ( a , i ) == i + 1 ); CHECK ( gsl :: at ({ 1 , 2 , 3 , 4 }, i ) == i + 1 ); } CHECK_THROWS_AS ( gsl :: at ( a , - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ( a , 4 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ({ 1 , 2 , 3 , 4 }, - 1 ), fail_fast ); CHECK_THROWS_AS ( gsl :: at ({ 1 , 2 , 3 , 4 }, 4 ), fail_fast ); } #if !defined(_MSC_VER) || defined(__clang__) || _MSC_VER >= 1910 GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute static constexpr bool test_constexpr () { int a1 [ 4 ] = { 1 , 2 , 3 , 4 }; const int ( & c_a1 )[ 4 ] = a1 ; std :: array < int , 4 > a2 = { 1 , 2 , 3 , 4 }; const std :: array < int , 4 >& c_a2 = a2 ; for ( int i = 0 ; i < 4 ; ++ i ) { if ( & gsl :: at ( a1 , i ) != & a1 [ i ]) return false ; if ( & gsl :: at ( c_a1 , i ) != & a1 [ i ]) return false ; // requires C++17: // if (&gsl::at(a2, i) != &a2[static_cast<std::size_t>(i)]) return false; if ( & gsl :: at ( c_a2 , i ) != & c_a2 [ static_cast < std :: size_t > ( i )]) return false ; if ( gsl :: at ({ 1 , 2 , 3 , 4 }, i ) != i + 1 ) return false ; } return true ; } static_assert ( test_constexpr (), \"FAIL\" ); #endif","title":"File at_tests.cpp"},{"location":"bounds__tests_8cpp/","text":"File bounds_tests.cpp \u00b6 File List > external > guideline > tests > bounds_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/multi_span> #include <cstddef> Namespaces \u00b6 Type Name namespace gsl Public Functions \u00b6 Type Name GSL_SUPPRESS (type. 1) GSL_SUPPRESS (f. 4) GSL_SUPPRESS (con. 4) Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( type . 1 ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( f . 4 ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( con . 4 ) The documentation for this class was generated from the following file external/guideline/tests/bounds_tests.cpp","title":"File bounds\\_tests.cpp"},{"location":"bounds__tests_8cpp/#file-bounds95testscpp","text":"File List > external > guideline > tests > bounds_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/multi_span> #include <cstddef>","title":"File bounds_tests.cpp"},{"location":"bounds__tests_8cpp/#namespaces","text":"Type Name namespace gsl","title":"Namespaces"},{"location":"bounds__tests_8cpp/#public-functions","text":"Type Name GSL_SUPPRESS (type. 1) GSL_SUPPRESS (f. 4) GSL_SUPPRESS (con. 4)","title":"Public Functions"},{"location":"bounds__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"bounds__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( type . 1 )","title":"function GSL_SUPPRESS"},{"location":"bounds__tests_8cpp/#function-gsl95suppress_1","text":"GSL_SUPPRESS ( f . 4 )","title":"function GSL_SUPPRESS"},{"location":"bounds__tests_8cpp/#function-gsl95suppress_2","text":"GSL_SUPPRESS ( con . 4 ) The documentation for this class was generated from the following file external/guideline/tests/bounds_tests.cpp","title":"function GSL_SUPPRESS"},{"location":"bounds__tests_8cpp_source/","text":"File bounds_tests.cpp \u00b6 File List > external > guideline > tests > bounds_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #pragma warning(disable : 4996) // use of function or classes marked [[deprecated]] #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\" #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, TEST_CASE #include <gsl/multi_span> // for static_bounds, static_bounds_dynamic_range_t #include <cstddef> // for ptrdiff_t, size_t namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; namespace { void use ( std :: ptrdiff_t & ) {} } GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute TEST_CASE ( \"basic_bounds\" ) { for ( auto point : static_bounds < dynamic_range , 3 , 4 > { 2 }) { for ( decltype ( point ) :: size_type j = 0 ; j < static_cast < decltype ( point ) :: size_type > ( decltype ( point ) :: rank ); j ++ ) { use ( j ); use ( point [ static_cast < std :: size_t > ( j )]); } } } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"bounds_basic\" ) { static_bounds < 3 , 4 , 5 > b ; const auto a = b . slice (); ( void ) a ; static_bounds < 4 , dynamic_range , 2 > x { 4 }; x . slice (). slice (); } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"arrayview_iterator\" ) { static_bounds < 4 , dynamic_range , 2 > bounds { 3 }; const auto itr = bounds . begin (); ( void ) itr ; #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 4 , dynamic_range , 2 > av ( nullptr , bounds ); auto itr2 = av . cbegin (); for ( auto & v : av ) { v = 4 ; } fill ( av . begin (), av . end (), 0 ); #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"bounds_convertible\" ) { static_bounds < 7 , 4 , 2 > b1 ; static_bounds < 7 , dynamic_range , 2 > b2 = b1 ; ( void ) b2 ; #ifdef CONFIRM_COMPILATION_ERRORS static_bounds < 7 , dynamic_range , 1 > b4 = b2 ; #endif static_bounds < dynamic_range , dynamic_range , dynamic_range > b3 = b1 ; static_bounds < 7 , 4 , 2 > b4 = b3 ; ( void ) b4 ; static_bounds < dynamic_range > b11 ; static_bounds < dynamic_range > b5 ; static_bounds < 34 > b6 ; b5 = static_bounds < 20 > (); CHECK_THROWS_AS ( b6 = b5 , fail_fast ); b5 = static_bounds < 34 > (); b6 = b5 ; CHECK ( b5 == b6 ); CHECK ( b5 . size () == b6 . size ()); } #ifdef CONFIRM_COMPILATION_ERRORS copy ( src_span_static , dst_span_static ); #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic pop #endif","title":"File bounds\\_tests.cpp"},{"location":"bounds__tests_8cpp_source/#file-bounds95testscpp","text":"File List > external > guideline > tests > bounds_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #pragma warning(disable : 4996) // use of function or classes marked [[deprecated]] #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\" #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, TEST_CASE #include <gsl/multi_span> // for static_bounds, static_bounds_dynamic_range_t #include <cstddef> // for ptrdiff_t, size_t namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; namespace { void use ( std :: ptrdiff_t & ) {} } GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute TEST_CASE ( \"basic_bounds\" ) { for ( auto point : static_bounds < dynamic_range , 3 , 4 > { 2 }) { for ( decltype ( point ) :: size_type j = 0 ; j < static_cast < decltype ( point ) :: size_type > ( decltype ( point ) :: rank ); j ++ ) { use ( j ); use ( point [ static_cast < std :: size_t > ( j )]); } } } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"bounds_basic\" ) { static_bounds < 3 , 4 , 5 > b ; const auto a = b . slice (); ( void ) a ; static_bounds < 4 , dynamic_range , 2 > x { 4 }; x . slice (). slice (); } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"arrayview_iterator\" ) { static_bounds < 4 , dynamic_range , 2 > bounds { 3 }; const auto itr = bounds . begin (); ( void ) itr ; #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 4 , dynamic_range , 2 > av ( nullptr , bounds ); auto itr2 = av . cbegin (); for ( auto & v : av ) { v = 4 ; } fill ( av . begin (), av . end (), 0 ); #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"bounds_convertible\" ) { static_bounds < 7 , 4 , 2 > b1 ; static_bounds < 7 , dynamic_range , 2 > b2 = b1 ; ( void ) b2 ; #ifdef CONFIRM_COMPILATION_ERRORS static_bounds < 7 , dynamic_range , 1 > b4 = b2 ; #endif static_bounds < dynamic_range , dynamic_range , dynamic_range > b3 = b1 ; static_bounds < 7 , 4 , 2 > b4 = b3 ; ( void ) b4 ; static_bounds < dynamic_range > b11 ; static_bounds < dynamic_range > b5 ; static_bounds < 34 > b6 ; b5 = static_bounds < 20 > (); CHECK_THROWS_AS ( b6 = b5 , fail_fast ); b5 = static_bounds < 34 > (); b6 = b5 ; CHECK ( b5 == b6 ); CHECK ( b5 . size () == b6 . size ()); } #ifdef CONFIRM_COMPILATION_ERRORS copy ( src_span_static , dst_span_static ); #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic pop #endif","title":"File bounds_tests.cpp"},{"location":"byte__tests_8cpp/","text":"File byte_tests.cpp \u00b6 File List > external > guideline > tests > byte_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_byte> The documentation for this class was generated from the following file external/guideline/tests/byte_tests.cpp","title":"File byte\\_tests.cpp"},{"location":"byte__tests_8cpp/#file-byte95testscpp","text":"File List > external > guideline > tests > byte_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_byte> The documentation for this class was generated from the following file external/guideline/tests/byte_tests.cpp","title":"File byte_tests.cpp"},{"location":"byte__tests_8cpp_source/","text":"File byte_tests.cpp \u00b6 File List > external > guideline > tests > byte_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/gsl_byte> // for to_byte, to_integer, byte, operator&, ope... using namespace std ; using namespace gsl ; namespace { TEST_CASE ( \"construction\" ) { { const byte b = static_cast < byte > ( 4 ); CHECK ( static_cast < unsigned char > ( b ) == 4 ); } GSL_SUPPRESS ( es .49 ) { const byte b = byte ( 12 ); CHECK ( static_cast < unsigned char > ( b ) == 12 ); } { const byte b = to_byte < 12 > (); CHECK ( static_cast < unsigned char > ( b ) == 12 ); } { const unsigned char uc = 12 ; const byte b = to_byte ( uc ); CHECK ( static_cast < unsigned char > ( b ) == 12 ); } #if defined(__cplusplus) && (__cplusplus >= 201703L) { const byte b { 14 }; CHECK ( static_cast < unsigned char > ( b ) == 14 ); } #endif } TEST_CASE ( \"bitwise_operations\" ) { const byte b = to_byte < 0xFF > (); byte a = to_byte < 0x00 > (); CHECK (( b | a ) == to_byte < 0xFF > ()); CHECK ( a == to_byte < 0x00 > ()); a |= b ; CHECK ( a == to_byte < 0xFF > ()); a = to_byte < 0x01 > (); CHECK (( b & a ) == to_byte < 0x01 > ()); a &= b ; CHECK ( a == to_byte < 0x01 > ()); CHECK (( b ^ a ) == to_byte < 0xFE > ()); CHECK ( a == to_byte < 0x01 > ()); a ^= b ; CHECK ( a == to_byte < 0xFE > ()); a = to_byte < 0x01 > (); CHECK ( ~ a == to_byte < 0xFE > ()); a = to_byte < 0xFF > (); CHECK (( a << 4 ) == to_byte < 0xF0 > ()); CHECK (( a >> 4 ) == to_byte < 0x0F > ()); a <<= 4 ; CHECK ( a == to_byte < 0xF0 > ()); a >>= 4 ; CHECK ( a == to_byte < 0x0F > ()); } TEST_CASE ( \"to_integer\" ) { const byte b = to_byte < 0x12 > (); CHECK ( 0x12 == gsl :: to_integer < char > ( b )); CHECK ( 0x12 == gsl :: to_integer < short > ( b )); CHECK ( 0x12 == gsl :: to_integer < long > ( b )); CHECK ( 0x12 == gsl :: to_integer < long long > ( b )); CHECK ( 0x12 == gsl :: to_integer < unsigned char > ( b )); CHECK ( 0x12 == gsl :: to_integer < unsigned short > ( b )); CHECK ( 0x12 == gsl :: to_integer < unsigned long > ( b )); CHECK ( 0x12 == gsl :: to_integer < unsigned long long > ( b )); // CHECK(0x12 == gsl::to_integer<float>(b)); // expect compile-time error // CHECK(0x12 == gsl::to_integer<double>(b)); // expect compile-time error } int modify_both ( gsl :: byte & b , int & i ) { i = 10 ; b = to_byte < 5 > (); return i ; } GSL_SUPPRESS ( type .1 ) TEST_CASE ( \"aliasing\" ) { int i { 0 }; const int res = modify_both ( reinterpret_cast < byte &> ( i ), i ); CHECK ( res == i ); } } #ifdef CONFIRM_COMPILATION_ERRORS copy ( src_span_static , dst_span_static ); #endif","title":"File byte\\_tests.cpp"},{"location":"byte__tests_8cpp_source/#file-byte95testscpp","text":"File List > external > guideline > tests > byte_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/gsl_byte> // for to_byte, to_integer, byte, operator&, ope... using namespace std ; using namespace gsl ; namespace { TEST_CASE ( \"construction\" ) { { const byte b = static_cast < byte > ( 4 ); CHECK ( static_cast < unsigned char > ( b ) == 4 ); } GSL_SUPPRESS ( es .49 ) { const byte b = byte ( 12 ); CHECK ( static_cast < unsigned char > ( b ) == 12 ); } { const byte b = to_byte < 12 > (); CHECK ( static_cast < unsigned char > ( b ) == 12 ); } { const unsigned char uc = 12 ; const byte b = to_byte ( uc ); CHECK ( static_cast < unsigned char > ( b ) == 12 ); } #if defined(__cplusplus) && (__cplusplus >= 201703L) { const byte b { 14 }; CHECK ( static_cast < unsigned char > ( b ) == 14 ); } #endif } TEST_CASE ( \"bitwise_operations\" ) { const byte b = to_byte < 0xFF > (); byte a = to_byte < 0x00 > (); CHECK (( b | a ) == to_byte < 0xFF > ()); CHECK ( a == to_byte < 0x00 > ()); a |= b ; CHECK ( a == to_byte < 0xFF > ()); a = to_byte < 0x01 > (); CHECK (( b & a ) == to_byte < 0x01 > ()); a &= b ; CHECK ( a == to_byte < 0x01 > ()); CHECK (( b ^ a ) == to_byte < 0xFE > ()); CHECK ( a == to_byte < 0x01 > ()); a ^= b ; CHECK ( a == to_byte < 0xFE > ()); a = to_byte < 0x01 > (); CHECK ( ~ a == to_byte < 0xFE > ()); a = to_byte < 0xFF > (); CHECK (( a << 4 ) == to_byte < 0xF0 > ()); CHECK (( a >> 4 ) == to_byte < 0x0F > ()); a <<= 4 ; CHECK ( a == to_byte < 0xF0 > ()); a >>= 4 ; CHECK ( a == to_byte < 0x0F > ()); } TEST_CASE ( \"to_integer\" ) { const byte b = to_byte < 0x12 > (); CHECK ( 0x12 == gsl :: to_integer < char > ( b )); CHECK ( 0x12 == gsl :: to_integer < short > ( b )); CHECK ( 0x12 == gsl :: to_integer < long > ( b )); CHECK ( 0x12 == gsl :: to_integer < long long > ( b )); CHECK ( 0x12 == gsl :: to_integer < unsigned char > ( b )); CHECK ( 0x12 == gsl :: to_integer < unsigned short > ( b )); CHECK ( 0x12 == gsl :: to_integer < unsigned long > ( b )); CHECK ( 0x12 == gsl :: to_integer < unsigned long long > ( b )); // CHECK(0x12 == gsl::to_integer<float>(b)); // expect compile-time error // CHECK(0x12 == gsl::to_integer<double>(b)); // expect compile-time error } int modify_both ( gsl :: byte & b , int & i ) { i = 10 ; b = to_byte < 5 > (); return i ; } GSL_SUPPRESS ( type .1 ) TEST_CASE ( \"aliasing\" ) { int i { 0 }; const int res = modify_both ( reinterpret_cast < byte &> ( i ), i ); CHECK ( res == i ); } } #ifdef CONFIRM_COMPILATION_ERRORS copy ( src_span_static , dst_span_static ); #endif","title":"File byte_tests.cpp"},{"location":"channel_8hpp/","text":"File channel.hpp \u00b6 File List > coroutine > channel.hpp Go to the source code of this file. #include <mutex> #include <tuple> Namespaces \u00b6 Type Name namespace coro namespace internal Classes \u00b6 Type Name struct bypass_lock class channel <typename T, typename M> class channel <typename T, typename M> class list <T> class peeker <typename T, typename M> class peeker <typename T, typename M> class reader <typename T, typename M> class reader <typename T, typename M> class writer <typename T, typename M> class writer <typename T, typename M> Macros \u00b6 Type Name define LUNCLIFF_COROUTINE_CHANNEL_HPP Macro Definition Documentation \u00b6 define LUNCLIFF_COROUTINE_CHANNEL_HPP \u00b6 #define LUNCLIFF_COROUTINE_CHANNEL_HPP The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"File channel.hpp"},{"location":"channel_8hpp/#file-channelhpp","text":"File List > coroutine > channel.hpp Go to the source code of this file. #include <mutex> #include <tuple>","title":"File channel.hpp"},{"location":"channel_8hpp/#namespaces","text":"Type Name namespace coro namespace internal","title":"Namespaces"},{"location":"channel_8hpp/#classes","text":"Type Name struct bypass_lock class channel <typename T, typename M> class channel <typename T, typename M> class list <T> class peeker <typename T, typename M> class peeker <typename T, typename M> class reader <typename T, typename M> class reader <typename T, typename M> class writer <typename T, typename M> class writer <typename T, typename M>","title":"Classes"},{"location":"channel_8hpp/#macros","text":"Type Name define LUNCLIFF_COROUTINE_CHANNEL_HPP","title":"Macros"},{"location":"channel_8hpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"channel_8hpp/#define-luncliff95coroutine95channel95hpp","text":"#define LUNCLIFF_COROUTINE_CHANNEL_HPP The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"define LUNCLIFF_COROUTINE_CHANNEL_HPP"},{"location":"channel_8hpp_source/","text":"File channel.hpp \u00b6 File List > coroutine > channel.hpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // Note // Coroutine based channel // This is a simplified form of channel in The Go Language // #pragma once #ifndef LUNCLIFF_COROUTINE_CHANNEL_HPP #define LUNCLIFF_COROUTINE_CHANNEL_HPP #if __has_include(<coroutine>) // C++ 20 #include <coroutine> #elif __has_include(<coroutine/frame.h>) #include <coroutine/frame.h> #elif __has_include(<experimental/coroutine>) // C++ 17 #include <experimental/coroutine> #else #error \"expect header <experimental/coroutine> or <coroutine/frame.h>\" #endif #include <mutex> #include <tuple> namespace coro { using namespace std ; using namespace std :: experimental ; // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } }; namespace internal { // A non-null address that leads access violation static inline void * poison () noexcept ( false ) { return reinterpret_cast < void *> ( 0xFADE ' 03 8 C ' BCFA ' 9E64 ); } // Linked list without allocation template < typename T > class list { using node_type = T ; node_type * head {}; node_type * tail {}; public : list () noexcept = default ; public : bool is_empty () const noexcept ( false ) { return head == nullptr ; } void push ( node_type * node ) noexcept ( false ) { if ( tail ) { tail -> next = node ; tail = node ; } else head = tail = node ; } auto pop () noexcept ( false ) -> node_type * { node_type * node = head ; if ( head == tail ) // empty or 1 head = tail = nullptr ; else // 2 or more head = head -> next ; return node ; // this can be nullptr } }; } // namespace internal template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class peeker ; // Awaitable for channel's read operation template < typename T , typename M > class reader { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader_list = typename channel_type :: reader_list ; using writer = typename channel_type :: writer ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend writer ; friend peeker ; friend reader_list ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ) : ptr {}, frame { nullptr }, chan { addressof ( ch )} { } reader ( const reader & ) noexcept = delete ; reader & operator = ( const reader & ) noexcept = delete ; reader ( reader && ) noexcept = delete ; reader & operator = ( reader && ) noexcept = delete ; public : ~ reader () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> writer_list :: is_empty ()) // await_suspend will unlock in the case return false ; writer * w = chan -> writer_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . reader_list :: push ( this ); // push to channel ch . mtx . unlock (); } auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; // Awaitable for channel's write operation template < typename T , typename M > class writer final { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader = typename channel_type :: reader ; using reader_list = typename channel_type :: reader_list ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend reader ; friend peeker ; friend writer_list ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ) : ptr { pv }, frame { nullptr }, chan { addressof ( ch )} { } writer ( const writer & ) noexcept = delete ; writer & operator = ( const writer & ) noexcept = delete ; writer ( writer && ) noexcept = delete ; writer & operator = ( writer && ) noexcept = delete ; public : ~ writer () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> reader_list :: is_empty ()) // await_suspend will unlock in the case return false ; reader * r = chan -> reader_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , r -> ptr ); swap ( this -> frame , r -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . writer_list :: push ( this ); // push to channel ch . mtx . unlock (); } bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); public : using value_type = T ; using pointer = value_type * ; using reference = value_type & ; using mutex_type = M ; private : using reader = reader < value_type , mutex_type > ; using reader_list = internal :: list < reader > ; using writer = writer < value_type , mutex_type > ; using writer_list = internal :: list < writer > ; using peeker = peeker < value_type , mutex_type > ; friend reader ; friend writer ; friend peeker ; private : mutex_type mtx {}; private : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; public : channel () noexcept ( false ) : reader_list {}, writer_list {}, mtx {} { // initialized 2 linked list and given mutex } ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; // // If the channel is raced hardly, some coroutines can be // enqueued into list just after this destructor unlocks mutex. // // Unfortunately, this can't be detected at once since // we have 2 list (readers/writers) in the channel. // // Current implementation allows checking repeatedly to reduce the // probability of such interleaving. // Increase the repeat count below if the situation occurs. // But notice that it is NOT zero. // size_t repeat = 1 ; // author experienced 5'000+ for hazard usage while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); coro . resume (); } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); } } } public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; using reader = typename channel_type :: reader ; using writer = typename channel_type :: writer ; private : peeker ( const peeker & ) noexcept ( false ) = delete ; peeker ( peeker && ) noexcept ( false ) = delete ; peeker & operator = ( const peeker & ) noexcept ( false ) = delete ; peeker & operator = ( peeker && ) noexcept ( false ) = delete ; public : explicit peeker ( channel_type & ch ) noexcept ( false ) : reader { ch } { } ~ peeker () noexcept = default ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { select ( ch , forward < FuncType &&> ( fn )); // evaluate return select ( forward < Args &&> ( args )...); // try next pair } } // namespace coro #endif // LUNCLIFF_COROUTINE_CHANNEL_HPP","title":"File channel.hpp"},{"location":"channel_8hpp_source/#file-channelhpp","text":"File List > coroutine > channel.hpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // Note // Coroutine based channel // This is a simplified form of channel in The Go Language // #pragma once #ifndef LUNCLIFF_COROUTINE_CHANNEL_HPP #define LUNCLIFF_COROUTINE_CHANNEL_HPP #if __has_include(<coroutine>) // C++ 20 #include <coroutine> #elif __has_include(<coroutine/frame.h>) #include <coroutine/frame.h> #elif __has_include(<experimental/coroutine>) // C++ 17 #include <experimental/coroutine> #else #error \"expect header <experimental/coroutine> or <coroutine/frame.h>\" #endif #include <mutex> #include <tuple> namespace coro { using namespace std ; using namespace std :: experimental ; // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } }; namespace internal { // A non-null address that leads access violation static inline void * poison () noexcept ( false ) { return reinterpret_cast < void *> ( 0xFADE ' 03 8 C ' BCFA ' 9E64 ); } // Linked list without allocation template < typename T > class list { using node_type = T ; node_type * head {}; node_type * tail {}; public : list () noexcept = default ; public : bool is_empty () const noexcept ( false ) { return head == nullptr ; } void push ( node_type * node ) noexcept ( false ) { if ( tail ) { tail -> next = node ; tail = node ; } else head = tail = node ; } auto pop () noexcept ( false ) -> node_type * { node_type * node = head ; if ( head == tail ) // empty or 1 head = tail = nullptr ; else // 2 or more head = head -> next ; return node ; // this can be nullptr } }; } // namespace internal template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class peeker ; // Awaitable for channel's read operation template < typename T , typename M > class reader { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader_list = typename channel_type :: reader_list ; using writer = typename channel_type :: writer ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend writer ; friend peeker ; friend reader_list ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ) : ptr {}, frame { nullptr }, chan { addressof ( ch )} { } reader ( const reader & ) noexcept = delete ; reader & operator = ( const reader & ) noexcept = delete ; reader ( reader && ) noexcept = delete ; reader & operator = ( reader && ) noexcept = delete ; public : ~ reader () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> writer_list :: is_empty ()) // await_suspend will unlock in the case return false ; writer * w = chan -> writer_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . reader_list :: push ( this ); // push to channel ch . mtx . unlock (); } auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; // Awaitable for channel's write operation template < typename T , typename M > class writer final { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader = typename channel_type :: reader ; using reader_list = typename channel_type :: reader_list ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend reader ; friend peeker ; friend writer_list ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ) : ptr { pv }, frame { nullptr }, chan { addressof ( ch )} { } writer ( const writer & ) noexcept = delete ; writer & operator = ( const writer & ) noexcept = delete ; writer ( writer && ) noexcept = delete ; writer & operator = ( writer && ) noexcept = delete ; public : ~ writer () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> reader_list :: is_empty ()) // await_suspend will unlock in the case return false ; reader * r = chan -> reader_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , r -> ptr ); swap ( this -> frame , r -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . writer_list :: push ( this ); // push to channel ch . mtx . unlock (); } bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); public : using value_type = T ; using pointer = value_type * ; using reference = value_type & ; using mutex_type = M ; private : using reader = reader < value_type , mutex_type > ; using reader_list = internal :: list < reader > ; using writer = writer < value_type , mutex_type > ; using writer_list = internal :: list < writer > ; using peeker = peeker < value_type , mutex_type > ; friend reader ; friend writer ; friend peeker ; private : mutex_type mtx {}; private : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; public : channel () noexcept ( false ) : reader_list {}, writer_list {}, mtx {} { // initialized 2 linked list and given mutex } ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; // // If the channel is raced hardly, some coroutines can be // enqueued into list just after this destructor unlocks mutex. // // Unfortunately, this can't be detected at once since // we have 2 list (readers/writers) in the channel. // // Current implementation allows checking repeatedly to reduce the // probability of such interleaving. // Increase the repeat count below if the situation occurs. // But notice that it is NOT zero. // size_t repeat = 1 ; // author experienced 5'000+ for hazard usage while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); coro . resume (); } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); } } } public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; using reader = typename channel_type :: reader ; using writer = typename channel_type :: writer ; private : peeker ( const peeker & ) noexcept ( false ) = delete ; peeker ( peeker && ) noexcept ( false ) = delete ; peeker & operator = ( const peeker & ) noexcept ( false ) = delete ; peeker & operator = ( peeker && ) noexcept ( false ) = delete ; public : explicit peeker ( channel_type & ch ) noexcept ( false ) : reader { ch } { } ~ peeker () noexcept = default ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { select ( ch , forward < FuncType &&> ( fn )); // evaluate return select ( forward < Args &&> ( args )...); // try next pair } } // namespace coro #endif // LUNCLIFF_COROUTINE_CHANNEL_HPP","title":"File channel.hpp"},{"location":"class_member_enums/","text":"Class Member Enums \u00b6","title":"Class Member Enums"},{"location":"class_member_enums/#class-member-enums","text":"","title":"Class Member Enums"},{"location":"class_member_functions/","text":"Class Member Functions \u00b6 a \u00b6 await_ready ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) acquire ( coro::peeker ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) b \u00b6 begin ( coro::enumerable ) c \u00b6 CustomPtr ( CustomPtr ) channel ( coro::channel ) close ( coro::darwin_event ) change ( coro::kernel_queue_t ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) d \u00b6 darwin_event ( coro::darwin_event ) destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) e \u00b6 end ( coro::enumerable ) enumerable ( coro::enumerable ) event_poll_t ( coro::event_poll_t ) error ( coro::io_work_t ) f \u00b6 final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle ) g \u00b6 get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type ) i \u00b6 is_signaled ( coro::darwin_event ) iterator ( coro::enumerable::iterator ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn ) k \u00b6 kernel_queue_t ( coro::kernel_queue_t ) l \u00b6 lock ( coro::bypass_lock ) list ( coro::internal::list ) n \u00b6 NonCopyableNonMovable ( NonCopyableNonMovable ) o \u00b6 operator T* ( CustomPtr , RefCounted ) operator!= ( CustomPtr , coro::enumerable::iterator ) operator= ( NonCopyableNonMovable , coro::channel , coro::darwin_event , coro::enumerable , coro::peeker , coro::reader , coro::writer , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > ) p \u00b6 pop ( coro::internal::list ) push ( coro::internal::list ) peek ( coro::peeker ) peeker ( coro::peeker ) promise ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > ) r \u00b6 RefCounted ( RefCounted ) read ( coro::channel ) reset ( coro::darwin_event ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type ) remove ( coro::event_poll_t ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) reader ( coro::reader ) s \u00b6 signal ( coro::darwin_event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to ) t \u00b6 try_lock ( coro::bypass_lock ) try_add ( coro::event_poll_t ) u \u00b6 unlock ( coro::bypass_lock ) unhandled_exception ( coro::frame_t::promise_type ) w \u00b6 write ( coro::channel ) wait ( coro::event_poll_t , coro::kernel_queue_t ) writer ( coro::writer ) y \u00b6 yield_value ( coro::enumerable::promise_type ) ~ \u00b6 ~channel ( coro::channel ) ~darwin_event ( coro::darwin_event ) ~enumerable ( coro::enumerable ) ~event_poll_t ( coro::event_poll_t ) ~kernel_queue_t ( coro::kernel_queue_t ) ~peeker ( coro::peeker ) ~reader ( coro::reader ) ~writer ( coro::writer ) ~coroutine_handle ( std::experimental::coroutine_handle< void > )","title":"Class Member Functions"},{"location":"class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"class_member_functions/#a","text":"await_ready ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) acquire ( coro::peeker ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"a"},{"location":"class_member_functions/#b","text":"begin ( coro::enumerable )","title":"b"},{"location":"class_member_functions/#c","text":"CustomPtr ( CustomPtr ) channel ( coro::channel ) close ( coro::darwin_event ) change ( coro::kernel_queue_t ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"c"},{"location":"class_member_functions/#d","text":"darwin_event ( coro::darwin_event ) destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"d"},{"location":"class_member_functions/#e","text":"end ( coro::enumerable ) enumerable ( coro::enumerable ) event_poll_t ( coro::event_poll_t ) error ( coro::io_work_t )","title":"e"},{"location":"class_member_functions/#f","text":"final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle )","title":"f"},{"location":"class_member_functions/#g","text":"get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type )","title":"g"},{"location":"class_member_functions/#i","text":"is_signaled ( coro::darwin_event ) iterator ( coro::enumerable::iterator ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn )","title":"i"},{"location":"class_member_functions/#k","text":"kernel_queue_t ( coro::kernel_queue_t )","title":"k"},{"location":"class_member_functions/#l","text":"lock ( coro::bypass_lock ) list ( coro::internal::list )","title":"l"},{"location":"class_member_functions/#n","text":"NonCopyableNonMovable ( NonCopyableNonMovable )","title":"n"},{"location":"class_member_functions/#o","text":"operator T* ( CustomPtr , RefCounted ) operator!= ( CustomPtr , coro::enumerable::iterator ) operator= ( NonCopyableNonMovable , coro::channel , coro::darwin_event , coro::enumerable , coro::peeker , coro::reader , coro::writer , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"o"},{"location":"class_member_functions/#p","text":"pop ( coro::internal::list ) push ( coro::internal::list ) peek ( coro::peeker ) peeker ( coro::peeker ) promise ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"p"},{"location":"class_member_functions/#r","text":"RefCounted ( RefCounted ) read ( coro::channel ) reset ( coro::darwin_event ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type ) remove ( coro::event_poll_t ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) reader ( coro::reader )","title":"r"},{"location":"class_member_functions/#s","text":"signal ( coro::darwin_event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to )","title":"s"},{"location":"class_member_functions/#t","text":"try_lock ( coro::bypass_lock ) try_add ( coro::event_poll_t )","title":"t"},{"location":"class_member_functions/#u","text":"unlock ( coro::bypass_lock ) unhandled_exception ( coro::frame_t::promise_type )","title":"u"},{"location":"class_member_functions/#w","text":"write ( coro::channel ) wait ( coro::event_poll_t , coro::kernel_queue_t ) writer ( coro::writer )","title":"w"},{"location":"class_member_functions/#y","text":"yield_value ( coro::enumerable::promise_type )","title":"y"},{"location":"class_member_functions/#_1","text":"~channel ( coro::channel ) ~darwin_event ( coro::darwin_event ) ~enumerable ( coro::enumerable ) ~event_poll_t ( coro::event_poll_t ) ~kernel_queue_t ( coro::kernel_queue_t ) ~peeker ( coro::peeker ) ~reader ( coro::reader ) ~writer ( coro::writer ) ~coroutine_handle ( std::experimental::coroutine_handle< void > )","title":"~"},{"location":"class_member_typedefs/","text":"Class Member Typedefs \u00b6 c \u00b6 channel_type ( coro::peeker , coro::reader , coro::writer ) d \u00b6 difference_type ( coro::enumerable::iterator ) i \u00b6 iterator_category ( coro::enumerable::iterator ) m \u00b6 mutex_type ( coro::channel ) n \u00b6 node_type ( coro::internal::list ) p \u00b6 peeker ( coro::channel , coro::reader , coro::writer ) pointer ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits ) r \u00b6 reader ( coro::channel , coro::peeker , coro::writer ) reader_list ( coro::channel , coro::reader , coro::writer ) reference ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) v \u00b6 value_type ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::peeker , coro::reader , coro::writer ) w \u00b6 writer ( coro::channel , coro::peeker , coro::reader ) writer_list ( coro::channel , coro::reader , coro::writer )","title":"Class Member Typedefs"},{"location":"class_member_typedefs/#class-member-typedefs","text":"","title":"Class Member Typedefs"},{"location":"class_member_typedefs/#c","text":"channel_type ( coro::peeker , coro::reader , coro::writer )","title":"c"},{"location":"class_member_typedefs/#d","text":"difference_type ( coro::enumerable::iterator )","title":"d"},{"location":"class_member_typedefs/#i","text":"iterator_category ( coro::enumerable::iterator )","title":"i"},{"location":"class_member_typedefs/#m","text":"mutex_type ( coro::channel )","title":"m"},{"location":"class_member_typedefs/#n","text":"node_type ( coro::internal::list )","title":"n"},{"location":"class_member_typedefs/#p","text":"peeker ( coro::channel , coro::reader , coro::writer ) pointer ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits )","title":"p"},{"location":"class_member_typedefs/#r","text":"reader ( coro::channel , coro::peeker , coro::writer ) reader_list ( coro::channel , coro::reader , coro::writer ) reference ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer )","title":"r"},{"location":"class_member_typedefs/#v","text":"value_type ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::peeker , coro::reader , coro::writer )","title":"v"},{"location":"class_member_typedefs/#w","text":"writer ( coro::channel , coro::peeker , coro::reader ) writer_list ( coro::channel , coro::reader , coro::writer )","title":"w"},{"location":"class_member_variables/","text":"Class Member Variables \u00b6 b \u00b6 buffer ( coro::io_work_t ) c \u00b6 coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) capacity ( coro::event_poll_t , coro::kernel_queue_t ) chan ( coro::reader , coro::writer ) channel_type ( coro::reader , coro::writer ) e \u00b6 epfd ( coro::event_poll_t ) events ( coro::event_poll_t , coro::kernel_queue_t ) f \u00b6 factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) frame ( coro::reader , coro::writer ) flag ( msvc_frame_prefix ) h \u00b6 head ( coro::internal::list ) i \u00b6 index ( msvc_frame_prefix ) k \u00b6 kqfd ( coro::kernel_queue_t ) l \u00b6 local ( coro::darwin_event ) m \u00b6 mtx ( coro::channel ) msg ( coro::darwin_event ) n \u00b6 next ( coro::reader , coro::writer ) p \u00b6 p_ ( CustomPtr , RefCounted ) peeker ( coro::channel , coro::reader , coro::writer ) ptr ( coro::reader , coro::writer ) prefix ( std::experimental::coroutine_handle< void > ) r \u00b6 reader ( coro::channel , coro::writer ) reader_list ( coro::reader ) s \u00b6 sd ( coro::darwin_event ) t \u00b6 tail ( coro::internal::list ) task ( coro::io_work_t ) w \u00b6 writer ( coro::channel , coro::reader ) writer_list ( coro::writer ) _ \u00b6 _unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix ) @ \u00b6 @1 ( coro::reader ) @3 ( coro::writer )","title":"Class Member Variables"},{"location":"class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"class_member_variables/#b","text":"buffer ( coro::io_work_t )","title":"b"},{"location":"class_member_variables/#c","text":"coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) capacity ( coro::event_poll_t , coro::kernel_queue_t ) chan ( coro::reader , coro::writer ) channel_type ( coro::reader , coro::writer )","title":"c"},{"location":"class_member_variables/#e","text":"epfd ( coro::event_poll_t ) events ( coro::event_poll_t , coro::kernel_queue_t )","title":"e"},{"location":"class_member_variables/#f","text":"factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) frame ( coro::reader , coro::writer ) flag ( msvc_frame_prefix )","title":"f"},{"location":"class_member_variables/#h","text":"head ( coro::internal::list )","title":"h"},{"location":"class_member_variables/#i","text":"index ( msvc_frame_prefix )","title":"i"},{"location":"class_member_variables/#k","text":"kqfd ( coro::kernel_queue_t )","title":"k"},{"location":"class_member_variables/#l","text":"local ( coro::darwin_event )","title":"l"},{"location":"class_member_variables/#m","text":"mtx ( coro::channel ) msg ( coro::darwin_event )","title":"m"},{"location":"class_member_variables/#n","text":"next ( coro::reader , coro::writer )","title":"n"},{"location":"class_member_variables/#p","text":"p_ ( CustomPtr , RefCounted ) peeker ( coro::channel , coro::reader , coro::writer ) ptr ( coro::reader , coro::writer ) prefix ( std::experimental::coroutine_handle< void > )","title":"p"},{"location":"class_member_variables/#r","text":"reader ( coro::channel , coro::writer ) reader_list ( coro::reader )","title":"r"},{"location":"class_member_variables/#s","text":"sd ( coro::darwin_event )","title":"s"},{"location":"class_member_variables/#t","text":"tail ( coro::internal::list ) task ( coro::io_work_t )","title":"t"},{"location":"class_member_variables/#w","text":"writer ( coro::channel , coro::reader ) writer_list ( coro::writer )","title":"w"},{"location":"class_member_variables/#_","text":"_unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix )","title":"_"},{"location":"class_member_variables/#_1","text":"@1 ( coro::reader ) @3 ( coro::writer )","title":"@"},{"location":"class_members/","text":"Class Members \u00b6 a \u00b6 await_ready ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) acquire ( coro::peeker ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) b \u00b6 begin ( coro::enumerable ) buffer ( coro::io_work_t ) c \u00b6 CustomPtr ( CustomPtr ) channel ( coro::channel ) close ( coro::darwin_event ) coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) capacity ( coro::event_poll_t , coro::kernel_queue_t ) change ( coro::kernel_queue_t ) channel_type ( coro::peeker , coro::reader , coro::writer ) chan ( coro::reader , coro::writer ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) d \u00b6 darwin_event ( coro::darwin_event ) difference_type ( coro::enumerable::iterator ) destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) e \u00b6 end ( coro::enumerable ) enumerable ( coro::enumerable ) epfd ( coro::event_poll_t ) event_poll_t ( coro::event_poll_t ) events ( coro::event_poll_t , coro::kernel_queue_t ) error ( coro::io_work_t ) f \u00b6 factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn ) frame ( coro::reader , coro::writer ) flag ( msvc_frame_prefix ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle ) g \u00b6 get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type ) h \u00b6 head ( coro::internal::list ) i \u00b6 is_signaled ( coro::darwin_event ) iterator ( coro::enumerable::iterator ) iterator_category ( coro::enumerable::iterator ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn ) index ( msvc_frame_prefix ) k \u00b6 kernel_queue_t ( coro::kernel_queue_t ) kqfd ( coro::kernel_queue_t ) l \u00b6 lock ( coro::bypass_lock ) local ( coro::darwin_event ) list ( coro::internal::list ) m \u00b6 mtx ( coro::channel ) mutex_type ( coro::channel ) msg ( coro::darwin_event ) n \u00b6 NonCopyableNonMovable ( NonCopyableNonMovable ) node_type ( coro::internal::list ) next ( coro::reader , coro::writer ) o \u00b6 operator T* ( CustomPtr , RefCounted ) operator!= ( CustomPtr , coro::enumerable::iterator ) operator= ( NonCopyableNonMovable , coro::channel , coro::darwin_event , coro::enumerable , coro::peeker , coro::reader , coro::writer , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > ) p \u00b6 p_ ( CustomPtr , RefCounted ) peeker ( coro::channel , coro::peeker , coro::reader , coro::writer ) pointer ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) pop ( coro::internal::list ) push ( coro::internal::list ) peek ( coro::peeker ) ptr ( coro::reader , coro::writer ) promise ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits ) prefix ( std::experimental::coroutine_handle< void > ) r \u00b6 RefCounted ( RefCounted ) read ( coro::channel ) reader ( coro::channel , coro::peeker , coro::reader , coro::writer ) reader_list ( coro::channel , coro::reader , coro::writer ) reference ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) reset ( coro::darwin_event ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type ) remove ( coro::event_poll_t ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) s \u00b6 sd ( coro::darwin_event ) signal ( coro::darwin_event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to ) t \u00b6 try_lock ( coro::bypass_lock ) try_add ( coro::event_poll_t ) tail ( coro::internal::list ) task ( coro::io_work_t ) u \u00b6 unlock ( coro::bypass_lock ) unhandled_exception ( coro::frame_t::promise_type ) v \u00b6 value_type ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::peeker , coro::reader , coro::writer ) w \u00b6 write ( coro::channel ) writer ( coro::channel , coro::peeker , coro::reader , coro::writer ) writer_list ( coro::channel , coro::reader , coro::writer ) wait ( coro::event_poll_t , coro::kernel_queue_t ) y \u00b6 yield_value ( coro::enumerable::promise_type ) ~ \u00b6 ~channel ( coro::channel ) ~darwin_event ( coro::darwin_event ) ~enumerable ( coro::enumerable ) ~event_poll_t ( coro::event_poll_t ) ~kernel_queue_t ( coro::kernel_queue_t ) ~peeker ( coro::peeker ) ~reader ( coro::reader ) ~writer ( coro::writer ) ~coroutine_handle ( std::experimental::coroutine_handle< void > ) _ \u00b6 _unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix ) @ \u00b6 @1 ( coro::reader ) @3 ( coro::writer )","title":"Class Members"},{"location":"class_members/#class-members","text":"","title":"Class Members"},{"location":"class_members/#a","text":"await_ready ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::reader , coro::writer , std::experimental::suspend_always , std::experimental::suspend_never ) acquire ( coro::peeker ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"a"},{"location":"class_members/#b","text":"begin ( coro::enumerable ) buffer ( coro::io_work_t )","title":"b"},{"location":"class_members/#c","text":"CustomPtr ( CustomPtr ) channel ( coro::channel ) close ( coro::darwin_event ) coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) capacity ( coro::event_poll_t , coro::kernel_queue_t ) change ( coro::kernel_queue_t ) channel_type ( coro::peeker , coro::reader , coro::writer ) chan ( coro::reader , coro::writer ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"c"},{"location":"class_members/#d","text":"darwin_event ( coro::darwin_event ) difference_type ( coro::enumerable::iterator ) destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"d"},{"location":"class_members/#e","text":"end ( coro::enumerable ) enumerable ( coro::enumerable ) epfd ( coro::event_poll_t ) event_poll_t ( coro::event_poll_t ) events ( coro::event_poll_t , coro::kernel_queue_t ) error ( coro::io_work_t )","title":"e"},{"location":"class_members/#f","text":"factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn ) frame ( coro::reader , coro::writer ) flag ( msvc_frame_prefix ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle )","title":"f"},{"location":"class_members/#g","text":"get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type )","title":"g"},{"location":"class_members/#h","text":"head ( coro::internal::list )","title":"h"},{"location":"class_members/#i","text":"is_signaled ( coro::darwin_event ) iterator ( coro::enumerable::iterator ) iterator_category ( coro::enumerable::iterator ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn ) index ( msvc_frame_prefix )","title":"i"},{"location":"class_members/#k","text":"kernel_queue_t ( coro::kernel_queue_t ) kqfd ( coro::kernel_queue_t )","title":"k"},{"location":"class_members/#l","text":"lock ( coro::bypass_lock ) local ( coro::darwin_event ) list ( coro::internal::list )","title":"l"},{"location":"class_members/#m","text":"mtx ( coro::channel ) mutex_type ( coro::channel ) msg ( coro::darwin_event )","title":"m"},{"location":"class_members/#n","text":"NonCopyableNonMovable ( NonCopyableNonMovable ) node_type ( coro::internal::list ) next ( coro::reader , coro::writer )","title":"n"},{"location":"class_members/#o","text":"operator T* ( CustomPtr , RefCounted ) operator!= ( CustomPtr , coro::enumerable::iterator ) operator= ( NonCopyableNonMovable , coro::channel , coro::darwin_event , coro::enumerable , coro::peeker , coro::reader , coro::writer , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"o"},{"location":"class_members/#p","text":"p_ ( CustomPtr , RefCounted ) peeker ( coro::channel , coro::peeker , coro::reader , coro::writer ) pointer ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) pop ( coro::internal::list ) push ( coro::internal::list ) peek ( coro::peeker ) ptr ( coro::reader , coro::writer ) promise ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits ) prefix ( std::experimental::coroutine_handle< void > )","title":"p"},{"location":"class_members/#r","text":"RefCounted ( RefCounted ) read ( coro::channel ) reader ( coro::channel , coro::peeker , coro::reader , coro::writer ) reader_list ( coro::channel , coro::reader , coro::writer ) reference ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::reader , coro::writer ) reset ( coro::darwin_event ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type ) remove ( coro::event_poll_t ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t )","title":"r"},{"location":"class_members/#s","text":"sd ( coro::darwin_event ) signal ( coro::darwin_event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to )","title":"s"},{"location":"class_members/#t","text":"try_lock ( coro::bypass_lock ) try_add ( coro::event_poll_t ) tail ( coro::internal::list ) task ( coro::io_work_t )","title":"t"},{"location":"class_members/#u","text":"unlock ( coro::bypass_lock ) unhandled_exception ( coro::frame_t::promise_type )","title":"u"},{"location":"class_members/#v","text":"value_type ( coro::channel , coro::enumerable::iterator , coro::enumerable , coro::peeker , coro::reader , coro::writer )","title":"v"},{"location":"class_members/#w","text":"write ( coro::channel ) writer ( coro::channel , coro::peeker , coro::reader , coro::writer ) writer_list ( coro::channel , coro::reader , coro::writer ) wait ( coro::event_poll_t , coro::kernel_queue_t )","title":"w"},{"location":"class_members/#y","text":"yield_value ( coro::enumerable::promise_type )","title":"y"},{"location":"class_members/#_1","text":"~channel ( coro::channel ) ~darwin_event ( coro::darwin_event ) ~enumerable ( coro::enumerable ) ~event_poll_t ( coro::event_poll_t ) ~kernel_queue_t ( coro::kernel_queue_t ) ~peeker ( coro::peeker ) ~reader ( coro::reader ) ~writer ( coro::writer ) ~coroutine_handle ( std::experimental::coroutine_handle< void > )","title":"~"},{"location":"class_members/#_","text":"_unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix )","title":"_"},{"location":"class_members/#_2","text":"@1 ( coro::reader ) @3 ( coro::writer )","title":"@"},{"location":"classcoro_1_1channel/","text":"Class coro::channel \u00b6 template <typename T typename T, typename M typename M> Class List > coro > channel Inherits the following classes: coro::internal::list , coro::internal::list Public Types \u00b6 Type Name typedef M mutex_type typedef value_type * pointer typedef value_type & reference typedef T value_type Public Functions \u00b6 Type Name channel () noexcept decltype(auto) read () noexcept decltype(auto) write (reference ref) noexcept ~channel () noexcept Public Functions inherited from coro::internal::list \u00b6 See coro::internal::list Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept Public Functions inherited from coro::internal::list \u00b6 See coro::internal::list Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept Public Types Documentation \u00b6 typedef mutex_type \u00b6 using coro :: channel < T , M >:: mutex_type = M ; typedef pointer \u00b6 using coro :: channel < T , M >:: pointer = value_type * ; typedef reference \u00b6 using coro :: channel < T , M >:: reference = value_type & ; typedef value_type \u00b6 using coro :: channel < T , M >:: value_type = T ; Public Functions Documentation \u00b6 function channel [3/3] \u00b6 inline coro :: channel :: channel () noexcept function read \u00b6 inline decltype ( auto ) coro :: channel :: read () noexcept function write \u00b6 inline decltype ( auto ) coro :: channel :: write ( reference ref ) noexcept function ~channel \u00b6 inline coro :: channel ::~ channel () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::channel"},{"location":"classcoro_1_1channel/#class-corochannel","text":"template <typename T typename T, typename M typename M> Class List > coro > channel Inherits the following classes: coro::internal::list , coro::internal::list","title":"Class coro::channel"},{"location":"classcoro_1_1channel/#public-types","text":"Type Name typedef M mutex_type typedef value_type * pointer typedef value_type & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1channel/#public-functions","text":"Type Name channel () noexcept decltype(auto) read () noexcept decltype(auto) write (reference ref) noexcept ~channel () noexcept","title":"Public Functions"},{"location":"classcoro_1_1channel/#public-functions-inherited-from-corointernallist","text":"See coro::internal::list Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept","title":"Public Functions inherited from coro::internal::list"},{"location":"classcoro_1_1channel/#public-functions-inherited-from-corointernallist_1","text":"See coro::internal::list Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept","title":"Public Functions inherited from coro::internal::list"},{"location":"classcoro_1_1channel/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1channel/#typedef-mutex95type","text":"using coro :: channel < T , M >:: mutex_type = M ;","title":"typedef mutex_type"},{"location":"classcoro_1_1channel/#typedef-pointer","text":"using coro :: channel < T , M >:: pointer = value_type * ;","title":"typedef pointer"},{"location":"classcoro_1_1channel/#typedef-reference","text":"using coro :: channel < T , M >:: reference = value_type & ;","title":"typedef reference"},{"location":"classcoro_1_1channel/#typedef-value95type","text":"using coro :: channel < T , M >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1channel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1channel/#function-channel-33","text":"inline coro :: channel :: channel () noexcept","title":"function channel [3/3]"},{"location":"classcoro_1_1channel/#function-read","text":"inline decltype ( auto ) coro :: channel :: read () noexcept","title":"function read"},{"location":"classcoro_1_1channel/#function-write","text":"inline decltype ( auto ) coro :: channel :: write ( reference ref ) noexcept","title":"function write"},{"location":"classcoro_1_1channel/#function-channel","text":"inline coro :: channel ::~ channel () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function ~channel"},{"location":"classcoro_1_1enumerable/","text":"Class coro::enumerable \u00b6 template <typename T> Class List > coro > enumerable Classes \u00b6 Type Name class iterator class promise_type Public Types \u00b6 Type Name typedef value_type * pointer typedef value_type & reference typedef T value_type Public Functions \u00b6 Type Name iterator begin () noexcept iterator end () noexcept enumerable (const enumerable &) = delete enumerable ( enumerable && rhs) noexcept enumerable () noexcept enumerable ( promise_type * ptr) noexcept enumerable & operator= (const enumerable &) = delete enumerable & operator= ( enumerable && rhs) noexcept ~enumerable () noexcept Public Types Documentation \u00b6 typedef pointer \u00b6 using coro :: enumerable < T >:: pointer = value_type * ; typedef reference \u00b6 using coro :: enumerable < T >:: reference = value_type & ; typedef value_type \u00b6 using coro :: enumerable < T >:: value_type = T ; Public Functions Documentation \u00b6 function begin \u00b6 inline iterator coro :: enumerable :: begin () noexcept function end \u00b6 inline iterator coro :: enumerable :: end () noexcept function enumerable [1/4] \u00b6 coro :: enumerable :: enumerable ( const enumerable & ) = delete function enumerable [2/4] \u00b6 inline coro :: enumerable :: enumerable ( enumerable && rhs ) noexcept function enumerable [3/4] \u00b6 coro :: enumerable :: enumerable () noexcept function enumerable [4/4] \u00b6 inline coro :: enumerable :: enumerable ( promise_type * ptr ) noexcept function operator= \u00b6 enumerable & coro :: enumerable :: operator = ( const enumerable & ) = delete function operator= \u00b6 inline enumerable & coro :: enumerable :: operator = ( enumerable && rhs ) noexcept function ~enumerable \u00b6 inline coro :: enumerable ::~ enumerable () noexcept The documentation for this class was generated from the following file interface/coroutine/yield.hpp","title":"Class coro::enumerable"},{"location":"classcoro_1_1enumerable/#class-coroenumerable","text":"template <typename T> Class List > coro > enumerable","title":"Class coro::enumerable"},{"location":"classcoro_1_1enumerable/#classes","text":"Type Name class iterator class promise_type","title":"Classes"},{"location":"classcoro_1_1enumerable/#public-types","text":"Type Name typedef value_type * pointer typedef value_type & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1enumerable/#public-functions","text":"Type Name iterator begin () noexcept iterator end () noexcept enumerable (const enumerable &) = delete enumerable ( enumerable && rhs) noexcept enumerable () noexcept enumerable ( promise_type * ptr) noexcept enumerable & operator= (const enumerable &) = delete enumerable & operator= ( enumerable && rhs) noexcept ~enumerable () noexcept","title":"Public Functions"},{"location":"classcoro_1_1enumerable/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1enumerable/#typedef-pointer","text":"using coro :: enumerable < T >:: pointer = value_type * ;","title":"typedef pointer"},{"location":"classcoro_1_1enumerable/#typedef-reference","text":"using coro :: enumerable < T >:: reference = value_type & ;","title":"typedef reference"},{"location":"classcoro_1_1enumerable/#typedef-value95type","text":"using coro :: enumerable < T >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1enumerable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1enumerable/#function-begin","text":"inline iterator coro :: enumerable :: begin () noexcept","title":"function begin"},{"location":"classcoro_1_1enumerable/#function-end","text":"inline iterator coro :: enumerable :: end () noexcept","title":"function end"},{"location":"classcoro_1_1enumerable/#function-enumerable-14","text":"coro :: enumerable :: enumerable ( const enumerable & ) = delete","title":"function enumerable [1/4]"},{"location":"classcoro_1_1enumerable/#function-enumerable-24","text":"inline coro :: enumerable :: enumerable ( enumerable && rhs ) noexcept","title":"function enumerable [2/4]"},{"location":"classcoro_1_1enumerable/#function-enumerable-34","text":"coro :: enumerable :: enumerable () noexcept","title":"function enumerable [3/4]"},{"location":"classcoro_1_1enumerable/#function-enumerable-44","text":"inline coro :: enumerable :: enumerable ( promise_type * ptr ) noexcept","title":"function enumerable [4/4]"},{"location":"classcoro_1_1enumerable/#function-operator","text":"enumerable & coro :: enumerable :: operator = ( const enumerable & ) = delete","title":"function operator="},{"location":"classcoro_1_1enumerable/#function-operator_1","text":"inline enumerable & coro :: enumerable :: operator = ( enumerable && rhs ) noexcept","title":"function operator="},{"location":"classcoro_1_1enumerable/#function-enumerable","text":"inline coro :: enumerable ::~ enumerable () noexcept The documentation for this class was generated from the following file interface/coroutine/yield.hpp","title":"function ~enumerable"},{"location":"classcoro_1_1enumerable_1_1iterator/","text":"Class coro::enumerable::iterator \u00b6 Class List > coro > enumerable > iterator Public Types \u00b6 Type Name typedef ptrdiff_t difference_type typedef std::forward_iterator_tag iterator_category typedef value_type * pointer typedef value_type & reference typedef T value_type Public Attributes \u00b6 Type Name coroutine_handle < promise_type > coro Public Functions \u00b6 Type Name iterator (std::nullptr_t) noexcept iterator ( coroutine_handle < promise_type > handle) noexcept bool operator!= (const iterator & rhs) noexcept const reference operator* () noexcept iterator & operator++ (int) = delete iterator & operator++ () noexcept pointer operator-> () noexcept bool operator== (const iterator & rhs) noexcept const Public Types Documentation \u00b6 typedef difference_type \u00b6 using coro :: enumerable < T >:: iterator :: difference_type = ptrdiff_t ; typedef iterator_category \u00b6 using coro :: enumerable < T >:: iterator :: iterator_category = std :: forward_iterator_tag ; typedef pointer \u00b6 using coro :: enumerable < T >:: iterator :: pointer = value_type * ; typedef reference \u00b6 using coro :: enumerable < T >:: iterator :: reference = value_type & ; typedef value_type \u00b6 using coro :: enumerable < T >:: iterator :: value_type = T ; Public Attributes Documentation \u00b6 variable coro \u00b6 coroutine_handle < promise_type > coro :: enumerable < T >:: iterator :: coro ; Public Functions Documentation \u00b6 function iterator [1/2] \u00b6 inline explicit coro :: enumerable :: iterator :: iterator ( std :: nullptr_t ) noexcept function iterator [2/2] \u00b6 inline explicit coro :: enumerable :: iterator :: iterator ( coroutine_handle < promise_type > handle ) noexcept function operator!= \u00b6 inline bool coro :: enumerable :: iterator :: operator != ( const iterator & rhs ) noexcept const function operator* \u00b6 inline reference coro :: enumerable :: iterator :: operator * () noexcept function operator++ \u00b6 iterator & coro :: enumerable :: iterator :: operator ++ ( int ) = delete function operator++ \u00b6 inline iterator & coro :: enumerable :: iterator :: operator ++ () noexcept function operator-> \u00b6 inline pointer coro :: enumerable :: iterator :: operator -> () noexcept function operator== \u00b6 inline bool coro :: enumerable :: iterator :: operator == ( const iterator & rhs ) noexcept const The documentation for this class was generated from the following file interface/coroutine/yield.hpp","title":"Class coro::enumerable::iterator"},{"location":"classcoro_1_1enumerable_1_1iterator/#class-coroenumerableiterator","text":"Class List > coro > enumerable > iterator","title":"Class coro::enumerable::iterator"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-types","text":"Type Name typedef ptrdiff_t difference_type typedef std::forward_iterator_tag iterator_category typedef value_type * pointer typedef value_type & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-attributes","text":"Type Name coroutine_handle < promise_type > coro","title":"Public Attributes"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-functions","text":"Type Name iterator (std::nullptr_t) noexcept iterator ( coroutine_handle < promise_type > handle) noexcept bool operator!= (const iterator & rhs) noexcept const reference operator* () noexcept iterator & operator++ (int) = delete iterator & operator++ () noexcept pointer operator-> () noexcept bool operator== (const iterator & rhs) noexcept const","title":"Public Functions"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-difference95type","text":"using coro :: enumerable < T >:: iterator :: difference_type = ptrdiff_t ;","title":"typedef difference_type"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-iterator95category","text":"using coro :: enumerable < T >:: iterator :: iterator_category = std :: forward_iterator_tag ;","title":"typedef iterator_category"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-pointer","text":"using coro :: enumerable < T >:: iterator :: pointer = value_type * ;","title":"typedef pointer"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-reference","text":"using coro :: enumerable < T >:: iterator :: reference = value_type & ;","title":"typedef reference"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-value95type","text":"using coro :: enumerable < T >:: iterator :: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1enumerable_1_1iterator/#variable-coro","text":"coroutine_handle < promise_type > coro :: enumerable < T >:: iterator :: coro ;","title":"variable coro"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-iterator-12","text":"inline explicit coro :: enumerable :: iterator :: iterator ( std :: nullptr_t ) noexcept","title":"function iterator [1/2]"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-iterator-22","text":"inline explicit coro :: enumerable :: iterator :: iterator ( coroutine_handle < promise_type > handle ) noexcept","title":"function iterator [2/2]"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator","text":"inline bool coro :: enumerable :: iterator :: operator != ( const iterator & rhs ) noexcept const","title":"function operator!="},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator42","text":"inline reference coro :: enumerable :: iterator :: operator * () noexcept","title":"function operator*"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_1","text":"iterator & coro :: enumerable :: iterator :: operator ++ ( int ) = delete","title":"function operator++"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_2","text":"inline iterator & coro :: enumerable :: iterator :: operator ++ () noexcept","title":"function operator++"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator-","text":"inline pointer coro :: enumerable :: iterator :: operator -> () noexcept","title":"function operator-&gt;"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_3","text":"inline bool coro :: enumerable :: iterator :: operator == ( const iterator & rhs ) noexcept const The documentation for this class was generated from the following file interface/coroutine/yield.hpp","title":"function operator=="},{"location":"classcoro_1_1enumerable_1_1promise__type/","text":"Class coro::enumerable::promise_type \u00b6 Class List > coro > enumerable > promise_type Inherits the following classes: promise_manual_control Public Functions \u00b6 Type Name promise_type * get_return_object () noexcept void return_void () noexcept auto yield_value (reference ref) noexcept auto yield_value (value_type && v) noexcept Public Functions Documentation \u00b6 function get_return_object \u00b6 inline promise_type * coro :: enumerable :: promise_type :: get_return_object () noexcept function return_void \u00b6 inline void coro :: enumerable :: promise_type :: return_void () noexcept function yield_value [1/2] \u00b6 inline auto coro :: enumerable :: promise_type :: yield_value ( reference ref ) noexcept function yield_value [2/2] \u00b6 inline auto coro :: enumerable :: promise_type :: yield_value ( value_type && v ) noexcept The documentation for this class was generated from the following file interface/coroutine/yield.hpp","title":"Class coro::enumerable::promise\\_type"},{"location":"classcoro_1_1enumerable_1_1promise__type/#class-coroenumerablepromise95type","text":"Class List > coro > enumerable > promise_type Inherits the following classes: promise_manual_control","title":"Class coro::enumerable::promise_type"},{"location":"classcoro_1_1enumerable_1_1promise__type/#public-functions","text":"Type Name promise_type * get_return_object () noexcept void return_void () noexcept auto yield_value (reference ref) noexcept auto yield_value (value_type && v) noexcept","title":"Public Functions"},{"location":"classcoro_1_1enumerable_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-get95return95object","text":"inline promise_type * coro :: enumerable :: promise_type :: get_return_object () noexcept","title":"function get_return_object"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-return95void","text":"inline void coro :: enumerable :: promise_type :: return_void () noexcept","title":"function return_void"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-yield95value-12","text":"inline auto coro :: enumerable :: promise_type :: yield_value ( reference ref ) noexcept","title":"function yield_value [1/2]"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-yield95value-22","text":"inline auto coro :: enumerable :: promise_type :: yield_value ( value_type && v ) noexcept The documentation for this class was generated from the following file interface/coroutine/yield.hpp","title":"function yield_value [2/2]"},{"location":"classcoro_1_1frame__t/","text":"Class coro::frame_t \u00b6 Class List > coro > frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. More... #include <return.h> Inherits the following classes: std::experimental::coroutine_handle< void > Classes \u00b6 Type Name class promise_type Public Types inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name union prefix_t Public Attributes inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name prefix_t prefix Public Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept Public Static Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept Detailed Description \u00b6 See also: coroutine_handle<void> The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::frame\\_t"},{"location":"classcoro_1_1frame__t/#class-coroframe95t","text":"Class List > coro > frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. More... #include <return.h> Inherits the following classes: std::experimental::coroutine_handle< void >","title":"Class coro::frame_t"},{"location":"classcoro_1_1frame__t/#classes","text":"Type Name class promise_type","title":"Classes"},{"location":"classcoro_1_1frame__t/#public-types-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name union prefix_t","title":"Public Types inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#public-attributes-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name prefix_t prefix","title":"Public Attributes inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#public-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept","title":"Public Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#public-static-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept","title":"Public Static Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#detailed-description","text":"See also: coroutine_handle<void> The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Detailed Description"},{"location":"classcoro_1_1frame__t_1_1promise__type/","text":"Class coro::frame_t::promise_type \u00b6 Class List > coro > frame_t > promise_type Inherits the following classes: coro::promise_aa Public Functions \u00b6 Type Name auto get_return_object () noexcept void return_void () noexcept this is a void return for the coroutines void unhandled_exception () noexcept The coroutine with the frame_t will do nothing for exception handling. Public Functions inherited from coro::promise_aa \u00b6 See coro::promise_aa Type Name auto final_suspend () noexcept auto initial_suspend () noexcept Public Functions Documentation \u00b6 function get_return_object \u00b6 inline auto coro :: frame_t :: promise_type :: get_return_object () noexcept function return_void \u00b6 inline void coro :: frame_t :: promise_type :: return_void () noexcept function unhandled_exception \u00b6 inline void coro :: frame_t :: promise_type :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::frame\\_t::promise\\_type"},{"location":"classcoro_1_1frame__t_1_1promise__type/#class-coroframe95tpromise95type","text":"Class List > coro > frame_t > promise_type Inherits the following classes: coro::promise_aa","title":"Class coro::frame_t::promise_type"},{"location":"classcoro_1_1frame__t_1_1promise__type/#public-functions","text":"Type Name auto get_return_object () noexcept void return_void () noexcept this is a void return for the coroutines void unhandled_exception () noexcept The coroutine with the frame_t will do nothing for exception handling.","title":"Public Functions"},{"location":"classcoro_1_1frame__t_1_1promise__type/#public-functions-inherited-from-coropromise_aa","text":"See coro::promise_aa Type Name auto final_suspend () noexcept auto initial_suspend () noexcept","title":"Public Functions inherited from coro::promise_aa"},{"location":"classcoro_1_1frame__t_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1frame__t_1_1promise__type/#function-get95return95object","text":"inline auto coro :: frame_t :: promise_type :: get_return_object () noexcept","title":"function get_return_object"},{"location":"classcoro_1_1frame__t_1_1promise__type/#function-return95void","text":"inline void coro :: frame_t :: promise_type :: return_void () noexcept","title":"function return_void"},{"location":"classcoro_1_1frame__t_1_1promise__type/#function-unhandled95exception","text":"inline void coro :: frame_t :: promise_type :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function unhandled_exception"},{"location":"classcoro_1_1internal_1_1list/","text":"Class coro::internal::list \u00b6 template <typename T> Class List > coro > internal > list Public Functions \u00b6 Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept Public Functions Documentation \u00b6 function is_empty \u00b6 inline bool coro :: internal :: list :: is_empty () noexcept const function list \u00b6 coro :: internal :: list :: list () noexcept function pop \u00b6 inline auto coro :: internal :: list :: pop () noexcept function push \u00b6 inline void coro :: internal :: list :: push ( node_type * node ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::internal::list"},{"location":"classcoro_1_1internal_1_1list/#class-corointernallist","text":"template <typename T> Class List > coro > internal > list","title":"Class coro::internal::list"},{"location":"classcoro_1_1internal_1_1list/#public-functions","text":"Type Name bool is_empty () noexcept const list () noexcept auto pop () noexcept void push (node_type * node) noexcept","title":"Public Functions"},{"location":"classcoro_1_1internal_1_1list/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1internal_1_1list/#function-is95empty","text":"inline bool coro :: internal :: list :: is_empty () noexcept const","title":"function is_empty"},{"location":"classcoro_1_1internal_1_1list/#function-list","text":"coro :: internal :: list :: list () noexcept","title":"function list"},{"location":"classcoro_1_1internal_1_1list/#function-pop","text":"inline auto coro :: internal :: list :: pop () noexcept","title":"function pop"},{"location":"classcoro_1_1internal_1_1list/#function-push","text":"inline void coro :: internal :: list :: push ( node_type * node ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function push"},{"location":"classcoro_1_1io__recv/","text":"Class coro::io_recv \u00b6 Class List > coro > io_recv Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} io_task_t task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( io_task_t t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name _INTERFACE_ uint32_t error () noexcept const Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name _INTERFACE_ bool ready () noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_recv :: await_ready () noexcept const function await_resume \u00b6 inline auto coro :: io_recv :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_recv :: await_suspend ( io_task_t t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_recv"},{"location":"classcoro_1_1io__recv/#class-coroio95recv","text":"Class List > coro > io_recv Inherits the following classes: coro::io_work_t","title":"Class coro::io_recv"},{"location":"classcoro_1_1io__recv/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} io_task_t task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv/#public-functions","text":"Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( io_task_t t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__recv/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name _INTERFACE_ uint32_t error () noexcept const","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name _INTERFACE_ bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__recv/#function-await95ready","text":"inline bool coro :: io_recv :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__recv/#function-await95resume","text":"inline auto coro :: io_recv :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__recv/#function-await95suspend","text":"inline void coro :: io_recv :: await_suspend ( io_task_t t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__recv__from/","text":"Class coro::io_recv_from \u00b6 Class List > coro > io_recv_from Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} io_task_t task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( io_task_t t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name _INTERFACE_ uint32_t error () noexcept const Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name _INTERFACE_ bool ready () noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_recv_from :: await_ready () noexcept const function await_resume \u00b6 inline auto coro :: io_recv_from :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_recv_from :: await_suspend ( io_task_t t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_recv\\_from"},{"location":"classcoro_1_1io__recv__from/#class-coroio95recv95from","text":"Class List > coro > io_recv_from Inherits the following classes: coro::io_work_t","title":"Class coro::io_recv_from"},{"location":"classcoro_1_1io__recv__from/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} io_task_t task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv__from/#public-functions","text":"Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( io_task_t t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__recv__from/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name _INTERFACE_ uint32_t error () noexcept const","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv__from/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name _INTERFACE_ bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv__from/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__recv__from/#function-await95ready","text":"inline bool coro :: io_recv_from :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__recv__from/#function-await95resume","text":"inline auto coro :: io_recv_from :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__recv__from/#function-await95suspend","text":"inline void coro :: io_recv_from :: await_suspend ( io_task_t t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__send/","text":"Class coro::io_send \u00b6 Class List > coro > io_send Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} io_task_t task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( io_task_t t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name _INTERFACE_ uint32_t error () noexcept const Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name _INTERFACE_ bool ready () noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_send :: await_ready () noexcept const function await_resume \u00b6 inline auto coro :: io_send :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_send :: await_suspend ( io_task_t t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_send"},{"location":"classcoro_1_1io__send/#class-coroio95send","text":"Class List > coro > io_send Inherits the following classes: coro::io_work_t","title":"Class coro::io_send"},{"location":"classcoro_1_1io__send/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} io_task_t task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send/#public-functions","text":"Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( io_task_t t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__send/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name _INTERFACE_ uint32_t error () noexcept const","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name _INTERFACE_ bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__send/#function-await95ready","text":"inline bool coro :: io_send :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__send/#function-await95resume","text":"inline auto coro :: io_send :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__send/#function-await95suspend","text":"inline void coro :: io_send :: await_suspend ( io_task_t t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__send__to/","text":"Class coro::io_send_to \u00b6 Class List > coro > io_send_to Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} io_task_t task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( io_task_t t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name _INTERFACE_ uint32_t error () noexcept const Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name _INTERFACE_ bool ready () noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_send_to :: await_ready () noexcept const function await_resume \u00b6 inline auto coro :: io_send_to :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_send_to :: await_suspend ( io_task_t t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_send\\_to"},{"location":"classcoro_1_1io__send__to/#class-coroio95send95to","text":"Class List > coro > io_send_to Inherits the following classes: coro::io_work_t","title":"Class coro::io_send_to"},{"location":"classcoro_1_1io__send__to/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} io_task_t task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send__to/#public-functions","text":"Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( io_task_t t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__send__to/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name _INTERFACE_ uint32_t error () noexcept const","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send__to/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name _INTERFACE_ bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send__to/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__send__to/#function-await95ready","text":"inline bool coro :: io_send_to :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__send__to/#function-await95resume","text":"inline auto coro :: io_send_to :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__send__to/#function-await95suspend","text":"inline void coro :: io_send_to :: await_suspend ( io_task_t t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__work__t/","text":"Class coro::io_work_t \u00b6 Class List > coro > io_work_t Inherits the following classes: io_control_block Inherited by the following classes: coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to Public Attributes \u00b6 Type Name io_buffer_t buffer = {} io_task_t task = {} Public Functions \u00b6 Type Name _INTERFACE_ uint32_t error () noexcept const Protected Functions \u00b6 Type Name _INTERFACE_ bool ready () noexcept const Public Attributes Documentation \u00b6 variable buffer \u00b6 io_buffer_t coro :: io_work_t :: buffer ; variable task \u00b6 io_task_t coro :: io_work_t :: task ; Public Functions Documentation \u00b6 function error \u00b6 _INTERFACE_ uint32_t coro :: io_work_t :: error () noexcept const Protected Functions Documentation \u00b6 function ready \u00b6 _INTERFACE_ bool coro :: io_work_t :: ready () noexcept const The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_work\\_t"},{"location":"classcoro_1_1io__work__t/#class-coroio95work95t","text":"Class List > coro > io_work_t Inherits the following classes: io_control_block Inherited by the following classes: coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to","title":"Class coro::io_work_t"},{"location":"classcoro_1_1io__work__t/#public-attributes","text":"Type Name io_buffer_t buffer = {} io_task_t task = {}","title":"Public Attributes"},{"location":"classcoro_1_1io__work__t/#public-functions","text":"Type Name _INTERFACE_ uint32_t error () noexcept const","title":"Public Functions"},{"location":"classcoro_1_1io__work__t/#protected-functions","text":"Type Name _INTERFACE_ bool ready () noexcept const","title":"Protected Functions"},{"location":"classcoro_1_1io__work__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1io__work__t/#variable-buffer","text":"io_buffer_t coro :: io_work_t :: buffer ;","title":"variable buffer"},{"location":"classcoro_1_1io__work__t/#variable-task","text":"io_task_t coro :: io_work_t :: task ;","title":"variable task"},{"location":"classcoro_1_1io__work__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__work__t/#function-error","text":"_INTERFACE_ uint32_t coro :: io_work_t :: error () noexcept const","title":"function error"},{"location":"classcoro_1_1io__work__t/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"classcoro_1_1io__work__t/#function-ready","text":"_INTERFACE_ bool coro :: io_work_t :: ready () noexcept const The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function ready"},{"location":"classcoro_1_1peeker/","text":"Class coro::peeker \u00b6 template <typename T typename T, typename M typename M> Class List > coro > peeker Inherits the following classes: coro::reader Public Types inherited from coro::reader \u00b6 See coro::reader Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type Public Attributes inherited from coro::reader \u00b6 See coro::reader Type Name channel_type * chan reader * next = = nullptr Public Functions \u00b6 Type Name bool acquire (value_type & storage) noexcept void peek () noexcept const peeker ( channel_type & ch) noexcept ~peeker () noexcept Public Functions inherited from coro::reader \u00b6 See coro::reader Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~reader () noexcept Protected Attributes inherited from coro::reader \u00b6 See coro::reader Type Name union coro::reader::@0 @1 void * frame pointer ptr Public Functions Documentation \u00b6 function acquire \u00b6 inline bool coro :: peeker :: acquire ( value_type & storage ) noexcept function peek \u00b6 inline void coro :: peeker :: peek () noexcept const function peeker [3/3] \u00b6 inline explicit coro :: peeker :: peeker ( channel_type & ch ) noexcept function ~peeker \u00b6 coro :: peeker ::~ peeker () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::peeker"},{"location":"classcoro_1_1peeker/#class-coropeeker","text":"template <typename T typename T, typename M typename M> Class List > coro > peeker Inherits the following classes: coro::reader","title":"Class coro::peeker"},{"location":"classcoro_1_1peeker/#public-types-inherited-from-cororeader","text":"See coro::reader Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type","title":"Public Types inherited from coro::reader"},{"location":"classcoro_1_1peeker/#public-attributes-inherited-from-cororeader","text":"See coro::reader Type Name channel_type * chan reader * next = = nullptr","title":"Public Attributes inherited from coro::reader"},{"location":"classcoro_1_1peeker/#public-functions","text":"Type Name bool acquire (value_type & storage) noexcept void peek () noexcept const peeker ( channel_type & ch) noexcept ~peeker () noexcept","title":"Public Functions"},{"location":"classcoro_1_1peeker/#public-functions-inherited-from-cororeader","text":"See coro::reader Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~reader () noexcept","title":"Public Functions inherited from coro::reader"},{"location":"classcoro_1_1peeker/#protected-attributes-inherited-from-cororeader","text":"See coro::reader Type Name union coro::reader::@0 @1 void * frame pointer ptr","title":"Protected Attributes inherited from coro::reader"},{"location":"classcoro_1_1peeker/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1peeker/#function-acquire","text":"inline bool coro :: peeker :: acquire ( value_type & storage ) noexcept","title":"function acquire"},{"location":"classcoro_1_1peeker/#function-peek","text":"inline void coro :: peeker :: peek () noexcept const","title":"function peek"},{"location":"classcoro_1_1peeker/#function-peeker-33","text":"inline explicit coro :: peeker :: peeker ( channel_type & ch ) noexcept","title":"function peeker [3/3]"},{"location":"classcoro_1_1peeker/#function-peeker","text":"coro :: peeker ::~ peeker () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function ~peeker"},{"location":"classcoro_1_1promise__aa/","text":"Class coro::promise_aa \u00b6 Class List > coro > promise_aa Inherited by the following classes: coro::frame_t::promise_type Public Functions \u00b6 Type Name auto final_suspend () noexcept auto initial_suspend () noexcept Public Functions Documentation \u00b6 function final_suspend \u00b6 inline auto coro :: promise_aa :: final_suspend () noexcept function initial_suspend \u00b6 inline auto coro :: promise_aa :: initial_suspend () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_aa"},{"location":"classcoro_1_1promise__aa/#class-coropromise95aa","text":"Class List > coro > promise_aa Inherited by the following classes: coro::frame_t::promise_type","title":"Class coro::promise_aa"},{"location":"classcoro_1_1promise__aa/#public-functions","text":"Type Name auto final_suspend () noexcept auto initial_suspend () noexcept","title":"Public Functions"},{"location":"classcoro_1_1promise__aa/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__aa/#function-final95suspend","text":"inline auto coro :: promise_aa :: final_suspend () noexcept","title":"function final_suspend"},{"location":"classcoro_1_1promise__aa/#function-initial95suspend","text":"inline auto coro :: promise_aa :: initial_suspend () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1promise__an/","text":"Class coro::promise_an \u00b6 Class List > coro > promise_an Public Functions \u00b6 Type Name auto final_suspend () noexcept auto initial_suspend () noexcept Public Functions Documentation \u00b6 function final_suspend \u00b6 inline auto coro :: promise_an :: final_suspend () noexcept function initial_suspend \u00b6 inline auto coro :: promise_an :: initial_suspend () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_an"},{"location":"classcoro_1_1promise__an/#class-coropromise95an","text":"Class List > coro > promise_an","title":"Class coro::promise_an"},{"location":"classcoro_1_1promise__an/#public-functions","text":"Type Name auto final_suspend () noexcept auto initial_suspend () noexcept","title":"Public Functions"},{"location":"classcoro_1_1promise__an/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__an/#function-final95suspend","text":"inline auto coro :: promise_an :: final_suspend () noexcept","title":"function final_suspend"},{"location":"classcoro_1_1promise__an/#function-initial95suspend","text":"inline auto coro :: promise_an :: initial_suspend () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1promise__na/","text":"Class coro::promise_na \u00b6 Class List > coro > promise_na Public Functions \u00b6 Type Name auto final_suspend () noexcept auto initial_suspend () noexcept Public Functions Documentation \u00b6 function final_suspend \u00b6 inline auto coro :: promise_na :: final_suspend () noexcept function initial_suspend \u00b6 inline auto coro :: promise_na :: initial_suspend () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_na"},{"location":"classcoro_1_1promise__na/#class-coropromise95na","text":"Class List > coro > promise_na","title":"Class coro::promise_na"},{"location":"classcoro_1_1promise__na/#public-functions","text":"Type Name auto final_suspend () noexcept auto initial_suspend () noexcept","title":"Public Functions"},{"location":"classcoro_1_1promise__na/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__na/#function-final95suspend","text":"inline auto coro :: promise_na :: final_suspend () noexcept","title":"function final_suspend"},{"location":"classcoro_1_1promise__na/#function-initial95suspend","text":"inline auto coro :: promise_na :: initial_suspend () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1promise__nn/","text":"Class coro::promise_nn \u00b6 Class List > coro > promise_nn Public Functions \u00b6 Type Name auto final_suspend () noexcept auto initial_suspend () noexcept Public Functions Documentation \u00b6 function final_suspend \u00b6 inline auto coro :: promise_nn :: final_suspend () noexcept function initial_suspend \u00b6 inline auto coro :: promise_nn :: initial_suspend () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_nn"},{"location":"classcoro_1_1promise__nn/#class-coropromise95nn","text":"Class List > coro > promise_nn","title":"Class coro::promise_nn"},{"location":"classcoro_1_1promise__nn/#public-functions","text":"Type Name auto final_suspend () noexcept auto initial_suspend () noexcept","title":"Public Functions"},{"location":"classcoro_1_1promise__nn/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__nn/#function-final95suspend","text":"inline auto coro :: promise_nn :: final_suspend () noexcept","title":"function final_suspend"},{"location":"classcoro_1_1promise__nn/#function-initial95suspend","text":"inline auto coro :: promise_nn :: initial_suspend () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1reader/","text":"Class coro::reader \u00b6 template <typename T typename T, typename M typename M> Class List > coro > reader Inherited by the following classes: coro::peeker Public Types \u00b6 Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type Public Attributes \u00b6 Type Name channel_type * chan reader * next = = nullptr Public Functions \u00b6 Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~reader () noexcept Protected Attributes \u00b6 Type Name union coro::reader::@0 @1 void * frame pointer ptr Public Types Documentation \u00b6 typedef channel_type [1/2] \u00b6 using coro :: reader < T , M >:: channel_type = channel < T , M > ; typedef pointer \u00b6 using coro :: reader < T , M >:: pointer = T * ; typedef reference \u00b6 using coro :: reader < T , M >:: reference = T & ; typedef value_type \u00b6 using coro :: reader < T , M >:: value_type = T ; Public Attributes Documentation \u00b6 variable chan \u00b6 channel_type * coro :: reader < T , M >:: chan ; variable next \u00b6 reader * coro :: reader < T , M >:: next ; Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: reader :: await_ready () noexcept const function await_resume \u00b6 inline auto coro :: reader :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: reader :: await_suspend ( coroutine_handle < void > coro ) noexcept function ~reader \u00b6 coro :: reader ::~ reader () noexcept Protected Attributes Documentation \u00b6 variable @1 \u00b6 union coro :: reader :: @ 0 coro :: reader < T , M >:: @ 1 ; variable frame \u00b6 void * coro :: reader < T , M >:: frame ; variable ptr \u00b6 pointer coro :: reader < T , M >:: ptr ; The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::reader"},{"location":"classcoro_1_1reader/#class-cororeader","text":"template <typename T typename T, typename M typename M> Class List > coro > reader Inherited by the following classes: coro::peeker","title":"Class coro::reader"},{"location":"classcoro_1_1reader/#public-types","text":"Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1reader/#public-attributes","text":"Type Name channel_type * chan reader * next = = nullptr","title":"Public Attributes"},{"location":"classcoro_1_1reader/#public-functions","text":"Type Name bool await_ready () noexcept const auto await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~reader () noexcept","title":"Public Functions"},{"location":"classcoro_1_1reader/#protected-attributes","text":"Type Name union coro::reader::@0 @1 void * frame pointer ptr","title":"Protected Attributes"},{"location":"classcoro_1_1reader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1reader/#typedef-channel95type-12","text":"using coro :: reader < T , M >:: channel_type = channel < T , M > ;","title":"typedef channel_type [1/2]"},{"location":"classcoro_1_1reader/#typedef-pointer","text":"using coro :: reader < T , M >:: pointer = T * ;","title":"typedef pointer"},{"location":"classcoro_1_1reader/#typedef-reference","text":"using coro :: reader < T , M >:: reference = T & ;","title":"typedef reference"},{"location":"classcoro_1_1reader/#typedef-value95type","text":"using coro :: reader < T , M >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1reader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1reader/#variable-chan","text":"channel_type * coro :: reader < T , M >:: chan ;","title":"variable chan"},{"location":"classcoro_1_1reader/#variable-next","text":"reader * coro :: reader < T , M >:: next ;","title":"variable next"},{"location":"classcoro_1_1reader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1reader/#function-await95ready","text":"inline bool coro :: reader :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1reader/#function-await95resume","text":"inline auto coro :: reader :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1reader/#function-await95suspend","text":"inline void coro :: reader :: await_suspend ( coroutine_handle < void > coro ) noexcept","title":"function await_suspend"},{"location":"classcoro_1_1reader/#function-reader","text":"coro :: reader ::~ reader () noexcept","title":"function ~reader"},{"location":"classcoro_1_1reader/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"classcoro_1_1reader/#variable-1","text":"union coro :: reader :: @ 0 coro :: reader < T , M >:: @ 1 ;","title":"variable @1"},{"location":"classcoro_1_1reader/#variable-frame","text":"void * coro :: reader < T , M >:: frame ;","title":"variable frame"},{"location":"classcoro_1_1reader/#variable-ptr","text":"pointer coro :: reader < T , M >:: ptr ; The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"variable ptr"},{"location":"classcoro_1_1writer/","text":"Class coro::writer \u00b6 template <typename T typename T, typename M typename M> Class List > coro > writer Public Types \u00b6 Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type Public Attributes \u00b6 Type Name channel_type * chan writer * next = = nullptr Public Functions \u00b6 Type Name bool await_ready () noexcept const bool await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~writer () noexcept Public Types Documentation \u00b6 typedef channel_type [1/2] \u00b6 using coro :: writer < T , M >:: channel_type = channel < T , M > ; typedef pointer \u00b6 using coro :: writer < T , M >:: pointer = T * ; typedef reference \u00b6 using coro :: writer < T , M >:: reference = T & ; typedef value_type \u00b6 using coro :: writer < T , M >:: value_type = T ; Public Attributes Documentation \u00b6 variable chan \u00b6 channel_type * coro :: writer < T , M >:: chan ; variable next \u00b6 writer * coro :: writer < T , M >:: next ; Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: writer :: await_ready () noexcept const function await_resume \u00b6 inline bool coro :: writer :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: writer :: await_suspend ( coroutine_handle < void > coro ) noexcept function ~writer \u00b6 coro :: writer ::~ writer () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::writer"},{"location":"classcoro_1_1writer/#class-corowriter","text":"template <typename T typename T, typename M typename M> Class List > coro > writer","title":"Class coro::writer"},{"location":"classcoro_1_1writer/#public-types","text":"Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1writer/#public-attributes","text":"Type Name channel_type * chan writer * next = = nullptr","title":"Public Attributes"},{"location":"classcoro_1_1writer/#public-functions","text":"Type Name bool await_ready () noexcept const bool await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept ~writer () noexcept","title":"Public Functions"},{"location":"classcoro_1_1writer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1writer/#typedef-channel95type-12","text":"using coro :: writer < T , M >:: channel_type = channel < T , M > ;","title":"typedef channel_type [1/2]"},{"location":"classcoro_1_1writer/#typedef-pointer","text":"using coro :: writer < T , M >:: pointer = T * ;","title":"typedef pointer"},{"location":"classcoro_1_1writer/#typedef-reference","text":"using coro :: writer < T , M >:: reference = T & ;","title":"typedef reference"},{"location":"classcoro_1_1writer/#typedef-value95type","text":"using coro :: writer < T , M >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1writer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1writer/#variable-chan","text":"channel_type * coro :: writer < T , M >:: chan ;","title":"variable chan"},{"location":"classcoro_1_1writer/#variable-next","text":"writer * coro :: writer < T , M >:: next ;","title":"variable next"},{"location":"classcoro_1_1writer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1writer/#function-await95ready","text":"inline bool coro :: writer :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1writer/#function-await95resume","text":"inline bool coro :: writer :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1writer/#function-await95suspend","text":"inline void coro :: writer :: await_suspend ( coroutine_handle < void > coro ) noexcept","title":"function await_suspend"},{"location":"classcoro_1_1writer/#function-writer","text":"coro :: writer ::~ writer () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function ~writer"},{"location":"classes/","text":"Class Index \u00b6 b \u00b6 bypass_lock ( coro ) c \u00b6 channel ( coro ) coroutine_handle ( std::experimental ) coroutine_handle< noop_coroutine_promise > ( std::experimental ) coroutine_handle< void > ( std::experimental ) CustomPtr clang_frame_prefix coroutine_traits ( std::experimental ) d \u00b6 darwin_event ( coro ) e \u00b6 enumerable ( coro ) event_poll_t ( coro ) f \u00b6 frame_t ( coro ) g \u00b6 gcc_frame_prefix i \u00b6 iterator ( coro::enumerable ) io_recv ( coro ) io_recv_from ( coro ) io_send ( coro ) io_send_to ( coro ) io_work_t ( coro ) k \u00b6 kernel_queue_t ( coro ) l \u00b6 list ( coro::internal ) m \u00b6 MyBase MyDerived msvc_frame_prefix n \u00b6 NonCopyableNonMovable noop_coroutine_promise ( std::experimental ) p \u00b6 promise_type ( coro::enumerable ) promise_type ( coro::frame_t ) peeker ( coro ) promise_aa ( coro ) promise_an ( coro ) promise_na ( coro ) promise_nn ( coro ) r \u00b6 reader ( coro ) RefCounted s \u00b6 suspend_always ( std::experimental ) suspend_never ( std::experimental ) u \u00b6 Unrelated w \u00b6 writer ( coro )","title":"Classes"},{"location":"classes/#class-index","text":"","title":"Class Index"},{"location":"classes/#b","text":"bypass_lock ( coro )","title":"b"},{"location":"classes/#c","text":"channel ( coro ) coroutine_handle ( std::experimental ) coroutine_handle< noop_coroutine_promise > ( std::experimental ) coroutine_handle< void > ( std::experimental ) CustomPtr clang_frame_prefix coroutine_traits ( std::experimental )","title":"c"},{"location":"classes/#d","text":"darwin_event ( coro )","title":"d"},{"location":"classes/#e","text":"enumerable ( coro ) event_poll_t ( coro )","title":"e"},{"location":"classes/#f","text":"frame_t ( coro )","title":"f"},{"location":"classes/#g","text":"gcc_frame_prefix","title":"g"},{"location":"classes/#i","text":"iterator ( coro::enumerable ) io_recv ( coro ) io_recv_from ( coro ) io_send ( coro ) io_send_to ( coro ) io_work_t ( coro )","title":"i"},{"location":"classes/#k","text":"kernel_queue_t ( coro )","title":"k"},{"location":"classes/#l","text":"list ( coro::internal )","title":"l"},{"location":"classes/#m","text":"MyBase MyDerived msvc_frame_prefix","title":"m"},{"location":"classes/#n","text":"NonCopyableNonMovable noop_coroutine_promise ( std::experimental )","title":"n"},{"location":"classes/#p","text":"promise_type ( coro::enumerable ) promise_type ( coro::frame_t ) peeker ( coro ) promise_aa ( coro ) promise_an ( coro ) promise_na ( coro ) promise_nn ( coro )","title":"p"},{"location":"classes/#r","text":"reader ( coro ) RefCounted","title":"r"},{"location":"classes/#s","text":"suspend_always ( std::experimental ) suspend_never ( std::experimental )","title":"s"},{"location":"classes/#u","text":"Unrelated","title":"u"},{"location":"classes/#w","text":"writer ( coro )","title":"w"},{"location":"classstd_1_1experimental_1_1coroutine__handle/","text":"Class std::experimental::coroutine_handle \u00b6 template <typename PromiseType> Class List > std > experimental > coroutine_handle Public Types \u00b6 Type Name typedef PromiseType promise_type Public Functions \u00b6 Type Name coroutine_handle & operator= (nullptr_t) noexcept auto promise () noexcept const auto promise () noexcept Public Static Functions \u00b6 Type Name coroutine_handle from_address (void * addr) noexcept coroutine_handle from_promise (promise_type & prom) noexcept Public Types Documentation \u00b6 typedef promise_type \u00b6 using std :: experimental :: coroutine_handle < PromiseType >:: promise_type = PromiseType ; Public Functions Documentation \u00b6 function operator= \u00b6 inline coroutine_handle & std :: experimental :: coroutine_handle :: operator = ( nullptr_t ) noexcept function promise [1/2] \u00b6 inline auto std :: experimental :: coroutine_handle :: promise () noexcept const function promise [2/2] \u00b6 inline auto std :: experimental :: coroutine_handle :: promise () noexcept Public Static Functions Documentation \u00b6 function from_address \u00b6 static inline coroutine_handle std :: experimental :: coroutine_handle :: from_address ( void * addr ) noexcept function from_promise \u00b6 static inline coroutine_handle std :: experimental :: coroutine_handle :: from_promise ( promise_type & prom ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::coroutine\\_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#class-stdexperimentalcoroutine95handle","text":"template <typename PromiseType> Class List > std > experimental > coroutine_handle","title":"Class std::experimental::coroutine_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-types","text":"Type Name typedef PromiseType promise_type","title":"Public Types"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-functions","text":"Type Name coroutine_handle & operator= (nullptr_t) noexcept auto promise () noexcept const auto promise () noexcept","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-static-functions","text":"Type Name coroutine_handle from_address (void * addr) noexcept coroutine_handle from_promise (promise_type & prom) noexcept","title":"Public Static Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#typedef-promise95type","text":"using std :: experimental :: coroutine_handle < PromiseType >:: promise_type = PromiseType ;","title":"typedef promise_type"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-operator","text":"inline coroutine_handle & std :: experimental :: coroutine_handle :: operator = ( nullptr_t ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-promise-12","text":"inline auto std :: experimental :: coroutine_handle :: promise () noexcept const","title":"function promise [1/2]"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-promise-22","text":"inline auto std :: experimental :: coroutine_handle :: promise () noexcept","title":"function promise [2/2]"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-from95address","text":"static inline coroutine_handle std :: experimental :: coroutine_handle :: from_address ( void * addr ) noexcept","title":"function from_address"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-from95promise","text":"static inline coroutine_handle std :: experimental :: coroutine_handle :: from_promise ( promise_type & prom ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function from_promise"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/","text":"Class std::experimental::coroutine_handle< noop_coroutine_promise > \u00b6 template <> Class List > std > experimental > coroutine_handle< noop_coroutine_promise > Inherits the following classes: std::experimental::coroutine_handle< void > Public Types inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name union prefix_t Public Attributes inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name prefix_t prefix Public Functions \u00b6 Type Name constexpr void * address () noexcept const coroutine_handle () noexcept constexpr void destroy () noexcept const constexpr bool done () noexcept const constexpr operator bool () noexcept const constexpr void operator() () noexcept const noop_coroutine_promise & promise () noexcept const constexpr void resume () noexcept const Public Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept Public Static Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept Public Functions Documentation \u00b6 function address \u00b6 inline constexpr void * std :: experimental :: coroutine_handle < noop_coroutine_promise >:: address () noexcept const function coroutine_handle \u00b6 inline std :: experimental :: coroutine_handle < noop_coroutine_promise >:: coroutine_handle () noexcept function destroy \u00b6 inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: destroy () noexcept const function done \u00b6 inline constexpr bool std :: experimental :: coroutine_handle < noop_coroutine_promise >:: done () noexcept const function operator bool \u00b6 inline explicit constexpr std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator bool () noexcept const function operator() \u00b6 inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator () () noexcept const function promise \u00b6 inline noop_coroutine_promise & std :: experimental :: coroutine_handle < noop_coroutine_promise >:: promise () noexcept const function resume \u00b6 inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: resume () noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::coroutine\\_handle&lt; noop\\_coroutine\\_promise &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#class-stdexperimentalcoroutine95handle-noop95coroutine95promise","text":"template <> Class List > std > experimental > coroutine_handle< noop_coroutine_promise > Inherits the following classes: std::experimental::coroutine_handle< void >","title":"Class std::experimental::coroutine_handle&lt; noop_coroutine_promise &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-types-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name union prefix_t","title":"Public Types inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-attributes-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name prefix_t prefix","title":"Public Attributes inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-functions","text":"Type Name constexpr void * address () noexcept const coroutine_handle () noexcept constexpr void destroy () noexcept const constexpr bool done () noexcept const constexpr operator bool () noexcept const constexpr void operator() () noexcept const noop_coroutine_promise & promise () noexcept const constexpr void resume () noexcept const","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept","title":"Public Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-static-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept","title":"Public Static Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-address","text":"inline constexpr void * std :: experimental :: coroutine_handle < noop_coroutine_promise >:: address () noexcept const","title":"function address"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-coroutine95handle","text":"inline std :: experimental :: coroutine_handle < noop_coroutine_promise >:: coroutine_handle () noexcept","title":"function coroutine_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-destroy","text":"inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: destroy () noexcept const","title":"function destroy"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-done","text":"inline constexpr bool std :: experimental :: coroutine_handle < noop_coroutine_promise >:: done () noexcept const","title":"function done"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-operator-bool","text":"inline explicit constexpr std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator bool () noexcept const","title":"function operator bool"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-operator","text":"inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator () () noexcept const","title":"function operator()"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-promise","text":"inline noop_coroutine_promise & std :: experimental :: coroutine_handle < noop_coroutine_promise >:: promise () noexcept const","title":"function promise"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-resume","text":"inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: resume () noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function resume"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/","text":"Class std::experimental::coroutine_handle< void > \u00b6 template <> Class List > std > experimental > coroutine_handle< void > Inherited by the following classes: coro::frame_t , std::experimental::coroutine_handle< noop_coroutine_promise > Public Types \u00b6 Type Name union prefix_t Public Attributes \u00b6 Type Name prefix_t prefix Public Functions \u00b6 Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept Public Static Functions \u00b6 Type Name coroutine_handle from_address (void * addr) noexcept Public Types Documentation \u00b6 union prefix_t \u00b6 Public Attributes Documentation \u00b6 variable prefix \u00b6 prefix_t std :: experimental :: coroutine_handle < void >:: prefix ; Public Functions Documentation \u00b6 function address \u00b6 inline constexpr void * std :: experimental :: coroutine_handle < void >:: address () noexcept const function coroutine_handle [1/4] \u00b6 std :: experimental :: coroutine_handle < void >:: coroutine_handle () noexcept function coroutine_handle [2/4] \u00b6 std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle const & ) noexcept function coroutine_handle [3/4] \u00b6 std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle && rhs ) noexcept function coroutine_handle [4/4] \u00b6 inline std :: experimental :: coroutine_handle < void >:: coroutine_handle ( std :: nullptr_t ) noexcept function destroy \u00b6 inline void std :: experimental :: coroutine_handle < void >:: destroy () noexcept function done \u00b6 inline bool std :: experimental :: coroutine_handle < void >:: done () noexcept const function operator bool \u00b6 inline explicit std :: experimental :: coroutine_handle < void >:: operator bool () noexcept const function operator= \u00b6 coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle const & ) noexcept function operator= \u00b6 coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle && rhs ) noexcept function operator= \u00b6 inline coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( nullptr_t ) noexcept function resume \u00b6 inline void std :: experimental :: coroutine_handle < void >:: resume () noexcept function ~coroutine_handle \u00b6 std :: experimental :: coroutine_handle < void >::~ coroutine_handle () noexcept Public Static Functions Documentation \u00b6 function from_address \u00b6 static inline coroutine_handle std :: experimental :: coroutine_handle < void >:: from_address ( void * addr ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::coroutine\\_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#class-stdexperimentalcoroutine95handle-void","text":"template <> Class List > std > experimental > coroutine_handle< void > Inherited by the following classes: coro::frame_t , std::experimental::coroutine_handle< noop_coroutine_promise >","title":"Class std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-types","text":"Type Name union prefix_t","title":"Public Types"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-attributes","text":"Type Name prefix_t prefix","title":"Public Attributes"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-functions","text":"Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-static-functions","text":"Type Name coroutine_handle from_address (void * addr) noexcept","title":"Public Static Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#union-prefix95t","text":"","title":"union prefix_t"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#variable-prefix","text":"prefix_t std :: experimental :: coroutine_handle < void >:: prefix ;","title":"variable prefix"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-address","text":"inline constexpr void * std :: experimental :: coroutine_handle < void >:: address () noexcept const","title":"function address"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle-14","text":"std :: experimental :: coroutine_handle < void >:: coroutine_handle () noexcept","title":"function coroutine_handle [1/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle-24","text":"std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle const & ) noexcept","title":"function coroutine_handle [2/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle-34","text":"std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle && rhs ) noexcept","title":"function coroutine_handle [3/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle-44","text":"inline std :: experimental :: coroutine_handle < void >:: coroutine_handle ( std :: nullptr_t ) noexcept","title":"function coroutine_handle [4/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-destroy","text":"inline void std :: experimental :: coroutine_handle < void >:: destroy () noexcept","title":"function destroy"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-done","text":"inline bool std :: experimental :: coroutine_handle < void >:: done () noexcept const","title":"function done"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator-bool","text":"inline explicit std :: experimental :: coroutine_handle < void >:: operator bool () noexcept const","title":"function operator bool"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator","text":"coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle const & ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator_1","text":"coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle && rhs ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator_2","text":"inline coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( nullptr_t ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-resume","text":"inline void std :: experimental :: coroutine_handle < void >:: resume () noexcept","title":"function resume"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine95handle","text":"std :: experimental :: coroutine_handle < void >::~ coroutine_handle () noexcept","title":"function ~coroutine_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-from95address","text":"static inline coroutine_handle std :: experimental :: coroutine_handle < void >:: from_address ( void * addr ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function from_address"},{"location":"classstd_1_1experimental_1_1suspend__always/","text":"Class std::experimental::suspend_always \u00b6 Class List > std > experimental > suspend_always Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool std :: experimental :: suspend_always :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void std :: experimental :: suspend_always :: await_resume () noexcept const function await_suspend \u00b6 inline void std :: experimental :: suspend_always :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::suspend\\_always"},{"location":"classstd_1_1experimental_1_1suspend__always/#class-stdexperimentalsuspend95always","text":"Class List > std > experimental > suspend_always","title":"Class std::experimental::suspend_always"},{"location":"classstd_1_1experimental_1_1suspend__always/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1suspend__always/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1suspend__always/#function-await95ready","text":"inline constexpr bool std :: experimental :: suspend_always :: await_ready () noexcept const","title":"function await_ready"},{"location":"classstd_1_1experimental_1_1suspend__always/#function-await95resume","text":"inline constexpr void std :: experimental :: suspend_always :: await_resume () noexcept const","title":"function await_resume"},{"location":"classstd_1_1experimental_1_1suspend__always/#function-await95suspend","text":"inline void std :: experimental :: suspend_always :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function await_suspend"},{"location":"classstd_1_1experimental_1_1suspend__never/","text":"Class std::experimental::suspend_never \u00b6 Class List > std > experimental > suspend_never Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool std :: experimental :: suspend_never :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void std :: experimental :: suspend_never :: await_resume () noexcept const function await_suspend \u00b6 inline void std :: experimental :: suspend_never :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::suspend\\_never"},{"location":"classstd_1_1experimental_1_1suspend__never/#class-stdexperimentalsuspend95never","text":"Class List > std > experimental > suspend_never","title":"Class std::experimental::suspend_never"},{"location":"classstd_1_1experimental_1_1suspend__never/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1suspend__never/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1suspend__never/#function-await95ready","text":"inline constexpr bool std :: experimental :: suspend_never :: await_ready () noexcept const","title":"function await_ready"},{"location":"classstd_1_1experimental_1_1suspend__never/#function-await95resume","text":"inline constexpr void std :: experimental :: suspend_never :: await_resume () noexcept const","title":"function await_resume"},{"location":"classstd_1_1experimental_1_1suspend__never/#function-await95suspend","text":"inline void std :: experimental :: suspend_never :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function await_suspend"},{"location":"concurrency__helper_8h/","text":"File concurrency_helper.h \u00b6 File List > concrt > concurrency_helper.h Go to the source code of this file. #include <atomic> #include <chrono> #include <future> Macros \u00b6 Type Name define CONCURRENCY_HELPER_H Macro Definition Documentation \u00b6 define CONCURRENCY_HELPER_H \u00b6 #define CONCURRENCY_HELPER_H The documentation for this class was generated from the following file modules/concrt/concurrency_helper.h","title":"File concurrency\\_helper.h"},{"location":"concurrency__helper_8h/#file-concurrency95helperh","text":"File List > concrt > concurrency_helper.h Go to the source code of this file. #include <atomic> #include <chrono> #include <future>","title":"File concurrency_helper.h"},{"location":"concurrency__helper_8h/#macros","text":"Type Name define CONCURRENCY_HELPER_H","title":"Macros"},{"location":"concurrency__helper_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"concurrency__helper_8h/#define-concurrency95helper95h","text":"#define CONCURRENCY_HELPER_H The documentation for this class was generated from the following file modules/concrt/concurrency_helper.h","title":"define CONCURRENCY_HELPER_H"},{"location":"concurrency__helper_8h_source/","text":"File concurrency_helper.h \u00b6 File List > concrt > concurrency_helper.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once // clang-format off #if defined(FORCE_STATIC_LINK) # define _INTERFACE_ # define _HIDDEN_ #elif defined(_MSC_VER) // MSVC or clang-cl # define _HIDDEN_ # ifdef _WINDLL # define _INTERFACE_ __declspec(dllexport) # else # define _INTERFACE_ __declspec(dllimport) # endif #elif defined(__GNUC__) || defined(__clang__) # define _INTERFACE_ __attribute__((visibility(\"default\"))) # define _HIDDEN_ __attribute__((visibility(\"hidden\"))) #else # error \"unexpected linking configuration\" #endif // clang-format on #ifndef CONCURRENCY_HELPER_H #define CONCURRENCY_HELPER_H #include <atomic> #include <chrono> #include <future> #if __has_include(<Windows.h>) #include <Windows.h> #include <synchapi.h> // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION { section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; static_assert ( sizeof ( section ) == sizeof ( CRITICAL_SECTION )); // An `std::experimental::latch` for fork-join scenario. // Its interface might slightly with that of Concurrency TS class latch final { mutable HANDLE ev {}; std :: atomic_uint64_t ref {}; public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; #elif __has_include(<pthread.h>) #include <pthread.h> // Standard lockable with pthread reader writer lock class section final { pthread_rwlock_t rwlock ; public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; // An `std::experimental::latch` for fork-join scenario. // Its interface might slightly with that of Concurrency TS class latch final { std :: atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; private : int timed_wait ( std :: chrono :: nanoseconds timeout ) noexcept ; public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; #endif #endif // CONCURRENCY_HELPER_H","title":"File concurrency\\_helper.h"},{"location":"concurrency__helper_8h_source/#file-concurrency95helperh","text":"File List > concrt > concurrency_helper.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once // clang-format off #if defined(FORCE_STATIC_LINK) # define _INTERFACE_ # define _HIDDEN_ #elif defined(_MSC_VER) // MSVC or clang-cl # define _HIDDEN_ # ifdef _WINDLL # define _INTERFACE_ __declspec(dllexport) # else # define _INTERFACE_ __declspec(dllimport) # endif #elif defined(__GNUC__) || defined(__clang__) # define _INTERFACE_ __attribute__((visibility(\"default\"))) # define _HIDDEN_ __attribute__((visibility(\"hidden\"))) #else # error \"unexpected linking configuration\" #endif // clang-format on #ifndef CONCURRENCY_HELPER_H #define CONCURRENCY_HELPER_H #include <atomic> #include <chrono> #include <future> #if __has_include(<Windows.h>) #include <Windows.h> #include <synchapi.h> // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION { section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; static_assert ( sizeof ( section ) == sizeof ( CRITICAL_SECTION )); // An `std::experimental::latch` for fork-join scenario. // Its interface might slightly with that of Concurrency TS class latch final { mutable HANDLE ev {}; std :: atomic_uint64_t ref {}; public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; #elif __has_include(<pthread.h>) #include <pthread.h> // Standard lockable with pthread reader writer lock class section final { pthread_rwlock_t rwlock ; public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; // An `std::experimental::latch` for fork-join scenario. // Its interface might slightly with that of Concurrency TS class latch final { std :: atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; private : int timed_wait ( std :: chrono :: nanoseconds timeout ) noexcept ; public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; #endif #endif // CONCURRENCY_HELPER_H","title":"File concurrency_helper.h"},{"location":"dir_017ad5e908c41501f6a06b5119b37293/","text":"Dir CMakeFiles \u00b6 File List > CMakeFiles Directories \u00b6 Type Name dir 3.16.1 The documentation for this class was generated from the following file CMakeFiles/","title":"Dir CMakeFiles"},{"location":"dir_017ad5e908c41501f6a06b5119b37293/#dir-cmakefiles","text":"File List > CMakeFiles","title":"Dir CMakeFiles"},{"location":"dir_017ad5e908c41501f6a06b5119b37293/#directories","text":"Type Name dir 3.16.1 The documentation for this class was generated from the following file CMakeFiles/","title":"Directories"},{"location":"dir_397d9aeee4af8edecac90968d93b57df/","text":"Dir external \u00b6 File List > external Directories \u00b6 Type Name dir guideline The documentation for this class was generated from the following file external/","title":"Dir external"},{"location":"dir_397d9aeee4af8edecac90968d93b57df/#dir-external","text":"File List > external","title":"Dir external"},{"location":"dir_397d9aeee4af8edecac90968d93b57df/#directories","text":"Type Name dir guideline The documentation for this class was generated from the following file external/","title":"Directories"},{"location":"dir_4f62ca89e6e2b2dab0d5f15908e4b9e4/","text":"Dir modules/event \u00b6 File List > event Files \u00b6 Type Name file event_darwin.cpp file event_linux.cpp file event_poll.cpp file event_poll.h file event_windows.cpp file kernel_queue.cpp file kernel_queue.h file libmain.cpp The documentation for this class was generated from the following file modules/event/","title":"Dir modules/event"},{"location":"dir_4f62ca89e6e2b2dab0d5f15908e4b9e4/#dir-modulesevent","text":"File List > event","title":"Dir modules/event"},{"location":"dir_4f62ca89e6e2b2dab0d5f15908e4b9e4/#files","text":"Type Name file event_darwin.cpp file event_linux.cpp file event_poll.cpp file event_poll.h file event_windows.cpp file kernel_queue.cpp file kernel_queue.h file libmain.cpp The documentation for this class was generated from the following file modules/event/","title":"Files"},{"location":"dir_898e359a3b1c0c35c95190e719ce85a7/","text":"Dir external/guideline \u00b6 File List > external > guideline Directories \u00b6 Type Name dir tests The documentation for this class was generated from the following file external/guideline/","title":"Dir external/guideline"},{"location":"dir_898e359a3b1c0c35c95190e719ce85a7/#dir-externalguideline","text":"File List > external > guideline","title":"Dir external/guideline"},{"location":"dir_898e359a3b1c0c35c95190e719ce85a7/#directories","text":"Type Name dir tests The documentation for this class was generated from the following file external/guideline/","title":"Directories"},{"location":"dir_923c80758d00fd62f29a99e232049d19/","text":"Dir modules/net \u00b6 File List > modules > net Files \u00b6 Type Name file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp The documentation for this class was generated from the following file modules/net/","title":"Dir modules/net"},{"location":"dir_923c80758d00fd62f29a99e232049d19/#dir-modulesnet","text":"File List > modules > net","title":"Dir modules/net"},{"location":"dir_923c80758d00fd62f29a99e232049d19/#files","text":"Type Name file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp The documentation for this class was generated from the following file modules/net/","title":"Files"},{"location":"dir_9b61234ab8cba81e3caae75634773f62/","text":"Dir interface/coroutine \u00b6 File List > coroutine Files \u00b6 Type Name file channel.hpp file event.h file frame.h file net.h file return.h Utility to define return types for coroutine. file thread.h file yield.hpp The documentation for this class was generated from the following file interface/coroutine/","title":"Dir interface/coroutine"},{"location":"dir_9b61234ab8cba81e3caae75634773f62/#dir-interfacecoroutine","text":"File List > coroutine","title":"Dir interface/coroutine"},{"location":"dir_9b61234ab8cba81e3caae75634773f62/#files","text":"Type Name file channel.hpp file event.h file frame.h file net.h file return.h Utility to define return types for coroutine. file thread.h file yield.hpp The documentation for this class was generated from the following file interface/coroutine/","title":"Files"},{"location":"dir_b31d54d5631803016a26f28213a41162/","text":"Dir interface \u00b6 File List > interface Directories \u00b6 Type Name dir coroutine The documentation for this class was generated from the following file interface/","title":"Dir interface"},{"location":"dir_b31d54d5631803016a26f28213a41162/#dir-interface","text":"File List > interface","title":"Dir interface"},{"location":"dir_b31d54d5631803016a26f28213a41162/#directories","text":"Type Name dir coroutine The documentation for this class was generated from the following file interface/","title":"Directories"},{"location":"dir_b599469a9c8999c9a06fd818dc911b93/","text":"Dir external/guideline/tests \u00b6 File List > external > guideline > tests Files \u00b6 Type Name file algorithm_tests.cpp file assertion_tests.cpp file at_tests.cpp file bounds_tests.cpp file byte_tests.cpp file multi_span_tests.cpp file no_exception_ensure_tests.cpp file no_exception_throw_tests.cpp file notnull_tests.cpp file owner_tests.cpp file span_tests.cpp file strict_notnull_tests.cpp file strided_span_tests.cpp file string_span_tests.cpp file test.cpp file utils_tests.cpp The documentation for this class was generated from the following file external/guideline/tests/","title":"Dir external/guideline/tests"},{"location":"dir_b599469a9c8999c9a06fd818dc911b93/#dir-externalguidelinetests","text":"File List > external > guideline > tests","title":"Dir external/guideline/tests"},{"location":"dir_b599469a9c8999c9a06fd818dc911b93/#files","text":"Type Name file algorithm_tests.cpp file assertion_tests.cpp file at_tests.cpp file bounds_tests.cpp file byte_tests.cpp file multi_span_tests.cpp file no_exception_ensure_tests.cpp file no_exception_throw_tests.cpp file notnull_tests.cpp file owner_tests.cpp file span_tests.cpp file strict_notnull_tests.cpp file strided_span_tests.cpp file string_span_tests.cpp file test.cpp file utils_tests.cpp The documentation for this class was generated from the following file external/guideline/tests/","title":"Files"},{"location":"dir_b914448c048576ce1ed2e0ee762ff30c/","text":"Dir CMakeFiles/3.16.1 \u00b6 File List > 3.16.1 Directories \u00b6 Type Name dir CompilerIdCXX The documentation for this class was generated from the following file CMakeFiles/3.16.1/","title":"Dir CMakeFiles/3.16.1"},{"location":"dir_b914448c048576ce1ed2e0ee762ff30c/#dir-cmakefiles3161","text":"File List > 3.16.1","title":"Dir CMakeFiles/3.16.1"},{"location":"dir_b914448c048576ce1ed2e0ee762ff30c/#directories","text":"Type Name dir CompilerIdCXX The documentation for this class was generated from the following file CMakeFiles/3.16.1/","title":"Directories"},{"location":"dir_ca2145c691e612cf00f5f2c7c7d8369b/","text":"Dir CMakeFiles/3.16.1/CompilerIdCXX \u00b6 File List > 3.16.1 > CompilerIdCXX Files \u00b6 Type Name file CMakeCXXCompilerId.cpp The documentation for this class was generated from the following file CMakeFiles/3.16.1/CompilerIdCXX/","title":"Dir CMakeFiles/3.16.1/CompilerIdCXX"},{"location":"dir_ca2145c691e612cf00f5f2c7c7d8369b/#dir-cmakefiles3161compileridcxx","text":"File List > 3.16.1 > CompilerIdCXX","title":"Dir CMakeFiles/3.16.1/CompilerIdCXX"},{"location":"dir_ca2145c691e612cf00f5f2c7c7d8369b/#files","text":"Type Name file CMakeCXXCompilerId.cpp The documentation for this class was generated from the following file CMakeFiles/3.16.1/CompilerIdCXX/","title":"Files"},{"location":"dir_cfce773df20e130ee7436b64bcb4a019/","text":"Dir modules/thread \u00b6 File List > modules > thread Files \u00b6 Type Name file libmain.cpp file pthread.cpp file win32_thread_pool.cpp The documentation for this class was generated from the following file modules/thread/","title":"Dir modules/thread"},{"location":"dir_cfce773df20e130ee7436b64bcb4a019/#dir-modulesthread","text":"File List > modules > thread","title":"Dir modules/thread"},{"location":"dir_cfce773df20e130ee7436b64bcb4a019/#files","text":"Type Name file libmain.cpp file pthread.cpp file win32_thread_pool.cpp The documentation for this class was generated from the following file modules/thread/","title":"Files"},{"location":"dir_e05d7e2b1ecd646af5bb94391405f3b5/","text":"Dir modules \u00b6 File List > modules Directories \u00b6 Type Name dir concrt dir event dir net dir thread The documentation for this class was generated from the following file modules/","title":"Dir modules"},{"location":"dir_e05d7e2b1ecd646af5bb94391405f3b5/#dir-modules","text":"File List > modules","title":"Dir modules"},{"location":"dir_e05d7e2b1ecd646af5bb94391405f3b5/#directories","text":"Type Name dir concrt dir event dir net dir thread The documentation for this class was generated from the following file modules/","title":"Directories"},{"location":"dir_efd85e361fabb3b869a38eac7e59b342/","text":"Dir modules/concrt \u00b6 File List > concrt Files \u00b6 Type Name file concurrency_helper.h file latch_pthread.cpp file latch_win32.cpp file section_pthread.cpp file section_win32.cpp The documentation for this class was generated from the following file modules/concrt/","title":"Dir modules/concrt"},{"location":"dir_efd85e361fabb3b869a38eac7e59b342/#dir-modulesconcrt","text":"File List > concrt","title":"Dir modules/concrt"},{"location":"dir_efd85e361fabb3b869a38eac7e59b342/#files","text":"Type Name file concurrency_helper.h file latch_pthread.cpp file latch_win32.cpp file section_pthread.cpp file section_win32.cpp The documentation for this class was generated from the following file modules/concrt/","title":"Files"},{"location":"event_2libmain_8cpp/","text":"File libmain.cpp \u00b6 File List > event > libmain.cpp Go to the source code of this file. Macros \u00b6 Type Name define EPILOGUE __attribute__((destructor)) define PROLOGUE __attribute__((constructor)) Macro Definition Documentation \u00b6 define EPILOGUE \u00b6 #define EPILOGUE __attribute__((destructor)) define PROLOGUE \u00b6 #define PROLOGUE __attribute__((constructor)) The documentation for this class was generated from the following file modules/event/libmain.cpp","title":"File libmain.cpp"},{"location":"event_2libmain_8cpp/#file-libmaincpp","text":"File List > event > libmain.cpp Go to the source code of this file.","title":"File libmain.cpp"},{"location":"event_2libmain_8cpp/#macros","text":"Type Name define EPILOGUE __attribute__((destructor)) define PROLOGUE __attribute__((constructor))","title":"Macros"},{"location":"event_2libmain_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"event_2libmain_8cpp/#define-epilogue","text":"#define EPILOGUE __attribute__((destructor))","title":"define EPILOGUE"},{"location":"event_2libmain_8cpp/#define-prologue","text":"#define PROLOGUE __attribute__((constructor)) The documentation for this class was generated from the following file modules/event/libmain.cpp","title":"define PROLOGUE"},{"location":"event_2libmain_8cpp_source/","text":"File libmain.cpp \u00b6 File List > event > libmain.cpp Go to the documentation of this file. #ifdef _WIN32 #define PROLOGUE #define EPILOGUE #else #define PROLOGUE __attribute__((constructor)) #define EPILOGUE __attribute__((destructor)) #endif #ifdef _WIN32 #include <Windows.h> // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx BOOL WINAPI DllMain ( HINSTANCE , DWORD , LPVOID ) noexcept { return TRUE ; } #endif","title":"File libmain.cpp"},{"location":"event_2libmain_8cpp_source/#file-libmaincpp","text":"File List > event > libmain.cpp Go to the documentation of this file. #ifdef _WIN32 #define PROLOGUE #define EPILOGUE #else #define PROLOGUE __attribute__((constructor)) #define EPILOGUE __attribute__((destructor)) #endif #ifdef _WIN32 #include <Windows.h> // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx BOOL WINAPI DllMain ( HINSTANCE , DWORD , LPVOID ) noexcept { return TRUE ; } #endif","title":"File libmain.cpp"},{"location":"event_8h/","text":"File event.h \u00b6 File List > coroutine > event.h Go to the source code of this file. Macros \u00b6 Type Name define COROUTINE_AWAITABLE_EVENT_H Macro Definition Documentation \u00b6 define COROUTINE_AWAITABLE_EVENT_H \u00b6 #define COROUTINE_AWAITABLE_EVENT_H The documentation for this class was generated from the following file interface/coroutine/event.h","title":"File event.h"},{"location":"event_8h/#file-eventh","text":"File List > coroutine > event.h Go to the source code of this file.","title":"File event.h"},{"location":"event_8h/#macros","text":"Type Name define COROUTINE_AWAITABLE_EVENT_H","title":"Macros"},{"location":"event_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"event_8h/#define-coroutine95awaitable95event95h","text":"#define COROUTINE_AWAITABLE_EVENT_H The documentation for this class was generated from the following file interface/coroutine/event.h","title":"define COROUTINE_AWAITABLE_EVENT_H"},{"location":"event_8h_source/","text":"File event.h \u00b6 File List > coroutine > event.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once // clang-format off #if defined(FORCE_STATIC_LINK) # define _INTERFACE_ # define _HIDDEN_ #elif defined(_MSC_VER) // MSVC or clang-cl # define _HIDDEN_ # ifdef _WINDLL # define _INTERFACE_ __declspec(dllexport) # else # define _INTERFACE_ __declspec(dllimport) # endif #elif defined(__GNUC__) || defined(__clang__) # define _INTERFACE_ __attribute__((visibility(\"default\"))) # define _HIDDEN_ __attribute__((visibility(\"hidden\"))) #else # error \"unexpected linking configuration\" #endif // clang-format on #ifndef COROUTINE_AWAITABLE_EVENT_H #define COROUTINE_AWAITABLE_EVENT_H #if __has_include(<Windows.h>) // ... activate VC++ based features ... #include <coroutine/return.h> namespace coro { using namespace std ; using namespace std :: experimental ; using win_handle_t = void * ; // Awaitable event type over Win32 thread pool // // Its object can be `co_await`ed only once. // The purpose of such design is to encourage use of short functions rather // than containing multiple objects in the function's body // // It uses INFINITE wait. So user must sure one of `SetEvent(hEvent)` // or `sc.cancel()` happens after `co_await`. // // set_or_cancel sc{hEvent}; // co_await sc; // class set_or_cancel final { win_handle_t hobject ; // object for wait register/unregister public : set_or_cancel ( const set_or_cancel & ) = delete ; set_or_cancel ( set_or_cancel && ) = delete ; set_or_cancel & operator = ( const set_or_cancel & ) = delete ; set_or_cancel & operator = ( set_or_cancel && ) = delete ; _INTERFACE_ explicit set_or_cancel ( win_handle_t target ) noexcept ( false ); _INTERFACE_ ~ set_or_cancel () noexcept ; private : _INTERFACE_ void on_suspend ( coroutine_handle < void > ) noexcept ( false ); _INTERFACE_ auto on_resume () noexcept -> uint32_t ; // error code public : _INTERFACE_ auto cancel () noexcept -> uint32_t ; constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return this -> on_suspend ( coro ); } auto await_resume () noexcept { return this -> on_resume (); } }; } // namespace coro #elif defined(__unix__) || defined(__linux__) || defined(__APPLE__) #include <coroutine/yield.hpp> namespace coro { using namespace std ; using namespace std :: experimental ; // Awaitable event type over `eventfd` & `epoll` // // For Darwin(Apple) platform, it uses UNIX domain socket and `kqueue` // Its object can be `co_await`ed multiple times // // If the object is signaled(`set`), the library will yield suspended coroutine // through `signaled_event_tasks` function. // // If it is signaled before `co_await`, // its `await_ready` will return `true` so the `co_await` can bypass the // suspension steps // class auto_reset_event final { uint64_t state ; // works with stateful implementation private : auto_reset_event ( const auto_reset_event & ) = delete ; auto_reset_event ( auto_reset_event && ) = delete ; auto_reset_event & operator = ( const auto_reset_event & ) = delete ; auto_reset_event & operator = ( auto_reset_event && ) = delete ; _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void on_suspend ( coroutine_handle < void > ) noexcept ( false ); _INTERFACE_ void reset () noexcept ( false ); public : _INTERFACE_ auto_reset_event () noexcept ( false ); _INTERFACE_ ~ auto_reset_event () noexcept ; _INTERFACE_ void set () noexcept ( false ); bool await_ready () const noexcept { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return this -> on_suspend ( coro ); } void await_resume () noexcept ( false ) { return this -> reset (); // automatically reset on resume } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () noexcept ( false ) -> enumerable < coroutine_handle < void >> ; } // namespace coro #endif #endif // COROUTINE_AWAITABLE_EVENT_H","title":"File event.h"},{"location":"event_8h_source/#file-eventh","text":"File List > coroutine > event.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once // clang-format off #if defined(FORCE_STATIC_LINK) # define _INTERFACE_ # define _HIDDEN_ #elif defined(_MSC_VER) // MSVC or clang-cl # define _HIDDEN_ # ifdef _WINDLL # define _INTERFACE_ __declspec(dllexport) # else # define _INTERFACE_ __declspec(dllimport) # endif #elif defined(__GNUC__) || defined(__clang__) # define _INTERFACE_ __attribute__((visibility(\"default\"))) # define _HIDDEN_ __attribute__((visibility(\"hidden\"))) #else # error \"unexpected linking configuration\" #endif // clang-format on #ifndef COROUTINE_AWAITABLE_EVENT_H #define COROUTINE_AWAITABLE_EVENT_H #if __has_include(<Windows.h>) // ... activate VC++ based features ... #include <coroutine/return.h> namespace coro { using namespace std ; using namespace std :: experimental ; using win_handle_t = void * ; // Awaitable event type over Win32 thread pool // // Its object can be `co_await`ed only once. // The purpose of such design is to encourage use of short functions rather // than containing multiple objects in the function's body // // It uses INFINITE wait. So user must sure one of `SetEvent(hEvent)` // or `sc.cancel()` happens after `co_await`. // // set_or_cancel sc{hEvent}; // co_await sc; // class set_or_cancel final { win_handle_t hobject ; // object for wait register/unregister public : set_or_cancel ( const set_or_cancel & ) = delete ; set_or_cancel ( set_or_cancel && ) = delete ; set_or_cancel & operator = ( const set_or_cancel & ) = delete ; set_or_cancel & operator = ( set_or_cancel && ) = delete ; _INTERFACE_ explicit set_or_cancel ( win_handle_t target ) noexcept ( false ); _INTERFACE_ ~ set_or_cancel () noexcept ; private : _INTERFACE_ void on_suspend ( coroutine_handle < void > ) noexcept ( false ); _INTERFACE_ auto on_resume () noexcept -> uint32_t ; // error code public : _INTERFACE_ auto cancel () noexcept -> uint32_t ; constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return this -> on_suspend ( coro ); } auto await_resume () noexcept { return this -> on_resume (); } }; } // namespace coro #elif defined(__unix__) || defined(__linux__) || defined(__APPLE__) #include <coroutine/yield.hpp> namespace coro { using namespace std ; using namespace std :: experimental ; // Awaitable event type over `eventfd` & `epoll` // // For Darwin(Apple) platform, it uses UNIX domain socket and `kqueue` // Its object can be `co_await`ed multiple times // // If the object is signaled(`set`), the library will yield suspended coroutine // through `signaled_event_tasks` function. // // If it is signaled before `co_await`, // its `await_ready` will return `true` so the `co_await` can bypass the // suspension steps // class auto_reset_event final { uint64_t state ; // works with stateful implementation private : auto_reset_event ( const auto_reset_event & ) = delete ; auto_reset_event ( auto_reset_event && ) = delete ; auto_reset_event & operator = ( const auto_reset_event & ) = delete ; auto_reset_event & operator = ( auto_reset_event && ) = delete ; _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void on_suspend ( coroutine_handle < void > ) noexcept ( false ); _INTERFACE_ void reset () noexcept ( false ); public : _INTERFACE_ auto_reset_event () noexcept ( false ); _INTERFACE_ ~ auto_reset_event () noexcept ; _INTERFACE_ void set () noexcept ( false ); bool await_ready () const noexcept { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return this -> on_suspend ( coro ); } void await_resume () noexcept ( false ) { return this -> reset (); // automatically reset on resume } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () noexcept ( false ) -> enumerable < coroutine_handle < void >> ; } // namespace coro #endif #endif // COROUTINE_AWAITABLE_EVENT_H","title":"File event.h"},{"location":"event__darwin_8cpp/","text":"File event_darwin.cpp \u00b6 File List > event > event_darwin.cpp Go to the source code of this file. #include <coroutine/event.h> #include <cstdlib> #include <cstring> #include <system_error> #include <sys/socket.h> #include <sys/un.h> #include \"kernel_queue.h\" Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name struct darwin_event The documentation for this class was generated from the following file modules/event/event_darwin.cpp","title":"File event\\_darwin.cpp"},{"location":"event__darwin_8cpp/#file-event95darwincpp","text":"File List > event > event_darwin.cpp Go to the source code of this file. #include <coroutine/event.h> #include <cstdlib> #include <cstring> #include <system_error> #include <sys/socket.h> #include <sys/un.h> #include \"kernel_queue.h\"","title":"File event_darwin.cpp"},{"location":"event__darwin_8cpp/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"event__darwin_8cpp/#classes","text":"Type Name struct darwin_event The documentation for this class was generated from the following file modules/event/event_darwin.cpp","title":"Classes"},{"location":"event__darwin_8cpp_source/","text":"File event_darwin.cpp \u00b6 File List > event > event_darwin.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/event.h> #include <cstdlib> #include <cstring> #include <system_error> #include <sys/socket.h> #include <sys/un.h> #include \"kernel_queue.h\" using namespace std ; namespace coro { // see also: `event_linux.cpp` kernel_queue_t selist {}; int32_t render_temp_name ( char * buffer ) noexcept { constexpr const char pattern [] = \"/tmp/coro_ev_XXXXXX\" ; // 19 char + 1 static_assert ( sizeof ( pattern ) == 20 ); static_assert ( sizeof ( pattern ) < sizeof ( sockaddr_un :: sun_path )); :: strncpy ( buffer , pattern , 19 ); // ::strnlen(pattern, sizeof(pattern)) const auto sd = :: mkstemp ( buffer ); // ensure the path exists using 'mkstemp' if ( sd == - 1 ) return errno ; if ( :: close ( sd )) return errno ; if ( :: remove ( buffer )) return errno ; return 0 ; } // mock eventfd using pimpl // instead of `eventfd` in linux, we are going to use 'unix domain socket' // possible alternative is `fifo`, but it also requires path management. struct darwin_event final { int64_t sd ; int64_t msg ; sockaddr_un local ; private : darwin_event ( const darwin_event & ) = delete ; darwin_event ( darwin_event && ) = delete ; darwin_event & operator = ( const darwin_event & ) = delete ; darwin_event & operator = ( darwin_event && ) = delete ; public : darwin_event () noexcept ( false ) : sd { :: socket ( AF_UNIX , SOCK_DGRAM , 0 )}, msg {}, local {} { // prepared unix domain socket? if ( sd == - 1 ) throw system_error { errno , system_category (), \"socket\" }; local . sun_family = AF_UNIX ; if ( auto ec = render_temp_name ( local . sun_path )) throw system_error { errno , system_category (), \"render_temp_name\" }; if ( :: bind ( sd , ( sockaddr * ) & local , SUN_LEN ( & local ))) { // this throw will make the object not-constructed auto se = system_error { errno , system_category (), \"bind\" }; // so we have to make sure of the destruction this -> close (); throw se ; } } ~ darwin_event () noexcept { this -> close (); } void close () noexcept { :: close ( sd ); :: unlink ( local . sun_path ); // don't forget this! } bool is_signaled () noexcept { return msg != 0 ; } void signal () noexcept ( false ) { // send 8 byte (size of state) to buffer if ( :: sendto ( sd , & msg , sizeof ( msg ), 0 , // ( sockaddr * ) & local , SUN_LEN ( & local )) < 0 ) throw system_error { errno , system_category (), \"sendto\" }; msg = 1 ; // signaled } void reset () noexcept ( false ) { // socket buffer is limited. we must consume properly if ( :: recvfrom ( sd , & msg , sizeof ( msg ), 0 , // nullptr , nullptr ) < 0 ) throw system_error { errno , system_category (), \"recvfrom\" }; // by receiving message, it recovers non-signaled state // we are using assert since this is critical assert ( msg == 0 ); } }; auto_reset_event :: auto_reset_event () noexcept ( false ) : state {} { auto * impl = new ( std :: nothrow ) darwin_event {}; state = reinterpret_cast < uint64_t > ( impl ); } auto_reset_event ::~ auto_reset_event () noexcept { auto * impl = reinterpret_cast < darwin_event *> ( state ); delete impl ; } bool auto_reset_event :: is_ready () const noexcept { auto * impl = reinterpret_cast < darwin_event *> ( state ); return impl -> is_signaled (); } void auto_reset_event :: set () noexcept ( false ) { auto * impl = reinterpret_cast < darwin_event *> ( state ); if ( impl -> is_signaled () == false ) impl -> signal (); } void auto_reset_event :: on_suspend ( coroutine_handle < void > t ) noexcept ( false ) { auto * impl = reinterpret_cast < darwin_event *> ( state ); kevent64_s req {}; req . ident = impl -> sd ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( t . address ()); selist . change ( req ); } void auto_reset_event :: reset () noexcept ( false ) { auto * impl = reinterpret_cast < darwin_event *> ( state ); // throwing `system_error` is intended // since the function must ensure message consumption impl -> reset (); } auto signaled_event_tasks () noexcept ( false ) -> coro :: enumerable < coroutine_handle < void >> { coroutine_handle < void > t {}; timespec ts {}; // zero wait // notice that the timeout is zero for ( auto ev : selist . wait ( ts )) { auto ptr = reinterpret_cast < void *> ( ev . udata ); t = coroutine_handle < void >:: from_address ( ptr ); if ( t . done ()) // todo: check only for debug mode? throw runtime_error { \"coroutine_handle<void> is already done state\" }; co_yield t ; } co_return ; } } // namespace coro","title":"File event\\_darwin.cpp"},{"location":"event__darwin_8cpp_source/#file-event95darwincpp","text":"File List > event > event_darwin.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/event.h> #include <cstdlib> #include <cstring> #include <system_error> #include <sys/socket.h> #include <sys/un.h> #include \"kernel_queue.h\" using namespace std ; namespace coro { // see also: `event_linux.cpp` kernel_queue_t selist {}; int32_t render_temp_name ( char * buffer ) noexcept { constexpr const char pattern [] = \"/tmp/coro_ev_XXXXXX\" ; // 19 char + 1 static_assert ( sizeof ( pattern ) == 20 ); static_assert ( sizeof ( pattern ) < sizeof ( sockaddr_un :: sun_path )); :: strncpy ( buffer , pattern , 19 ); // ::strnlen(pattern, sizeof(pattern)) const auto sd = :: mkstemp ( buffer ); // ensure the path exists using 'mkstemp' if ( sd == - 1 ) return errno ; if ( :: close ( sd )) return errno ; if ( :: remove ( buffer )) return errno ; return 0 ; } // mock eventfd using pimpl // instead of `eventfd` in linux, we are going to use 'unix domain socket' // possible alternative is `fifo`, but it also requires path management. struct darwin_event final { int64_t sd ; int64_t msg ; sockaddr_un local ; private : darwin_event ( const darwin_event & ) = delete ; darwin_event ( darwin_event && ) = delete ; darwin_event & operator = ( const darwin_event & ) = delete ; darwin_event & operator = ( darwin_event && ) = delete ; public : darwin_event () noexcept ( false ) : sd { :: socket ( AF_UNIX , SOCK_DGRAM , 0 )}, msg {}, local {} { // prepared unix domain socket? if ( sd == - 1 ) throw system_error { errno , system_category (), \"socket\" }; local . sun_family = AF_UNIX ; if ( auto ec = render_temp_name ( local . sun_path )) throw system_error { errno , system_category (), \"render_temp_name\" }; if ( :: bind ( sd , ( sockaddr * ) & local , SUN_LEN ( & local ))) { // this throw will make the object not-constructed auto se = system_error { errno , system_category (), \"bind\" }; // so we have to make sure of the destruction this -> close (); throw se ; } } ~ darwin_event () noexcept { this -> close (); } void close () noexcept { :: close ( sd ); :: unlink ( local . sun_path ); // don't forget this! } bool is_signaled () noexcept { return msg != 0 ; } void signal () noexcept ( false ) { // send 8 byte (size of state) to buffer if ( :: sendto ( sd , & msg , sizeof ( msg ), 0 , // ( sockaddr * ) & local , SUN_LEN ( & local )) < 0 ) throw system_error { errno , system_category (), \"sendto\" }; msg = 1 ; // signaled } void reset () noexcept ( false ) { // socket buffer is limited. we must consume properly if ( :: recvfrom ( sd , & msg , sizeof ( msg ), 0 , // nullptr , nullptr ) < 0 ) throw system_error { errno , system_category (), \"recvfrom\" }; // by receiving message, it recovers non-signaled state // we are using assert since this is critical assert ( msg == 0 ); } }; auto_reset_event :: auto_reset_event () noexcept ( false ) : state {} { auto * impl = new ( std :: nothrow ) darwin_event {}; state = reinterpret_cast < uint64_t > ( impl ); } auto_reset_event ::~ auto_reset_event () noexcept { auto * impl = reinterpret_cast < darwin_event *> ( state ); delete impl ; } bool auto_reset_event :: is_ready () const noexcept { auto * impl = reinterpret_cast < darwin_event *> ( state ); return impl -> is_signaled (); } void auto_reset_event :: set () noexcept ( false ) { auto * impl = reinterpret_cast < darwin_event *> ( state ); if ( impl -> is_signaled () == false ) impl -> signal (); } void auto_reset_event :: on_suspend ( coroutine_handle < void > t ) noexcept ( false ) { auto * impl = reinterpret_cast < darwin_event *> ( state ); kevent64_s req {}; req . ident = impl -> sd ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( t . address ()); selist . change ( req ); } void auto_reset_event :: reset () noexcept ( false ) { auto * impl = reinterpret_cast < darwin_event *> ( state ); // throwing `system_error` is intended // since the function must ensure message consumption impl -> reset (); } auto signaled_event_tasks () noexcept ( false ) -> coro :: enumerable < coroutine_handle < void >> { coroutine_handle < void > t {}; timespec ts {}; // zero wait // notice that the timeout is zero for ( auto ev : selist . wait ( ts )) { auto ptr = reinterpret_cast < void *> ( ev . udata ); t = coroutine_handle < void >:: from_address ( ptr ); if ( t . done ()) // todo: check only for debug mode? throw runtime_error { \"coroutine_handle<void> is already done state\" }; co_yield t ; } co_return ; } } // namespace coro","title":"File event_darwin.cpp"},{"location":"event__linux_8cpp/","text":"File event_linux.cpp \u00b6 File List > event > event_linux.cpp Go to the source code of this file. #include <coroutine/event.h> #include <system_error> #include \"event_poll.h\" Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/event/event_linux.cpp","title":"File event\\_linux.cpp"},{"location":"event__linux_8cpp/#file-event95linuxcpp","text":"File List > event > event_linux.cpp Go to the source code of this file. #include <coroutine/event.h> #include <system_error> #include \"event_poll.h\"","title":"File event_linux.cpp"},{"location":"event__linux_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/event/event_linux.cpp","title":"Namespaces"},{"location":"event__linux_8cpp_source/","text":"File event_linux.cpp \u00b6 File List > event > event_linux.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/event.h> #include <system_error> #include \"event_poll.h\" namespace coro { // signaled event list. it's badly named to prevent possible collision event_poll_t selist {}; // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) noexcept { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) noexcept { return static_cast < int64_t > ( ~ emask & state ); } void notify_event ( int64_t efd ) noexcept ( false ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd if ( write ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"write\" }; } void consume_event ( int64_t efd ) noexcept ( false ) { if ( read ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"read\" }; } auto_reset_event :: auto_reset_event () noexcept ( false ) : state {} { const auto fd = :: eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } auto_reset_event ::~ auto_reset_event () noexcept { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } bool auto_reset_event :: is_ready () const noexcept { return is_signaled ( state ); } void auto_reset_event :: set () noexcept ( false ) { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); notify_event ( fd ); // if it didn't throwed state = emask | static_cast < uint64_t > ( fd ); // it's signaled state from now } void auto_reset_event :: reset () noexcept ( false ) { const auto fd = get_eventfd ( state ); // if already signaled. nothing to do... if ( is_signaled ( state )) consume_event ( fd ); // make unsignaled state this -> state = static_cast < uint64_t > ( fd ); } // Reference // https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/is_epollexclusive_available.cc void auto_reset_event :: on_suspend ( coroutine_handle < void > t ) noexcept ( false ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } auto signaled_event_tasks () noexcept ( false ) -> coro :: enumerable < coroutine_handle < void >> { coroutine_handle < void > t {}; // notice that the timeout is zero for ( auto e : selist . wait ( 0 )) { // see also: `notify_event`, `auto_reset_event::on_suspend` // we don't care about the internal counter. // just receive the coroutine handle t = coroutine_handle < void >:: from_address ( e . data . ptr ); // ensure we can resume it. if ( t . done ()) // todo: check only for debug mode? throw runtime_error { \"coroutine_handle<void> is already done state\" }; co_yield t ; } co_return ; } } // namespace coro","title":"File event\\_linux.cpp"},{"location":"event__linux_8cpp_source/#file-event95linuxcpp","text":"File List > event > event_linux.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/event.h> #include <system_error> #include \"event_poll.h\" namespace coro { // signaled event list. it's badly named to prevent possible collision event_poll_t selist {}; // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) noexcept { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) noexcept { return static_cast < int64_t > ( ~ emask & state ); } void notify_event ( int64_t efd ) noexcept ( false ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd if ( write ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"write\" }; } void consume_event ( int64_t efd ) noexcept ( false ) { if ( read ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"read\" }; } auto_reset_event :: auto_reset_event () noexcept ( false ) : state {} { const auto fd = :: eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } auto_reset_event ::~ auto_reset_event () noexcept { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } bool auto_reset_event :: is_ready () const noexcept { return is_signaled ( state ); } void auto_reset_event :: set () noexcept ( false ) { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); notify_event ( fd ); // if it didn't throwed state = emask | static_cast < uint64_t > ( fd ); // it's signaled state from now } void auto_reset_event :: reset () noexcept ( false ) { const auto fd = get_eventfd ( state ); // if already signaled. nothing to do... if ( is_signaled ( state )) consume_event ( fd ); // make unsignaled state this -> state = static_cast < uint64_t > ( fd ); } // Reference // https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/is_epollexclusive_available.cc void auto_reset_event :: on_suspend ( coroutine_handle < void > t ) noexcept ( false ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } auto signaled_event_tasks () noexcept ( false ) -> coro :: enumerable < coroutine_handle < void >> { coroutine_handle < void > t {}; // notice that the timeout is zero for ( auto e : selist . wait ( 0 )) { // see also: `notify_event`, `auto_reset_event::on_suspend` // we don't care about the internal counter. // just receive the coroutine handle t = coroutine_handle < void >:: from_address ( e . data . ptr ); // ensure we can resume it. if ( t . done ()) // todo: check only for debug mode? throw runtime_error { \"coroutine_handle<void> is already done state\" }; co_yield t ; } co_return ; } } // namespace coro","title":"File event_linux.cpp"},{"location":"event__poll_8cpp/","text":"File event_poll.cpp \u00b6 File List > event > event_poll.cpp Go to the source code of this file. #include \"event_poll.h\" #include <system_error> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/event/event_poll.cpp","title":"File event\\_poll.cpp"},{"location":"event__poll_8cpp/#file-event95pollcpp","text":"File List > event > event_poll.cpp Go to the source code of this file. #include \"event_poll.h\" #include <system_error>","title":"File event_poll.cpp"},{"location":"event__poll_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/event/event_poll.cpp","title":"Namespaces"},{"location":"event__poll_8cpp_source/","text":"File event_poll.cpp \u00b6 File List > event > event_poll.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include \"event_poll.h\" #include <system_error> using namespace std ; namespace coro { event_poll_t :: event_poll_t () noexcept ( false ) : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () noexcept { close ( epfd ); } void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input const auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl\" }; } auto event_poll_t :: wait ( int timeout ) noexcept ( false ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } } // namespace coro","title":"File event\\_poll.cpp"},{"location":"event__poll_8cpp_source/#file-event95pollcpp","text":"File List > event > event_poll.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include \"event_poll.h\" #include <system_error> using namespace std ; namespace coro { event_poll_t :: event_poll_t () noexcept ( false ) : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () noexcept { close ( epfd ); } void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input const auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl\" }; } auto event_poll_t :: wait ( int timeout ) noexcept ( false ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } } // namespace coro","title":"File event_poll.cpp"},{"location":"event__poll_8h/","text":"File event_poll.h \u00b6 File List > event > event_poll.h Go to the source code of this file. #include <coroutine/event.h> #include <memory> #include <fcntl.h> #include <sys/epoll.h> #include <sys/eventfd.h> #include <unistd.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name struct event_poll_t Macros \u00b6 Type Name define LINUX_EVENT_POLL_API_WRAPPER_H Macro Definition Documentation \u00b6 define LINUX_EVENT_POLL_API_WRAPPER_H \u00b6 #define LINUX_EVENT_POLL_API_WRAPPER_H The documentation for this class was generated from the following file modules/event/event_poll.h","title":"File event\\_poll.h"},{"location":"event__poll_8h/#file-event95pollh","text":"File List > event > event_poll.h Go to the source code of this file. #include <coroutine/event.h> #include <memory> #include <fcntl.h> #include <sys/epoll.h> #include <sys/eventfd.h> #include <unistd.h>","title":"File event_poll.h"},{"location":"event__poll_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"event__poll_8h/#classes","text":"Type Name struct event_poll_t","title":"Classes"},{"location":"event__poll_8h/#macros","text":"Type Name define LINUX_EVENT_POLL_API_WRAPPER_H","title":"Macros"},{"location":"event__poll_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"event__poll_8h/#define-linux95event95poll95api95wrapper95h","text":"#define LINUX_EVENT_POLL_API_WRAPPER_H The documentation for this class was generated from the following file modules/event/event_poll.h","title":"define LINUX_EVENT_POLL_API_WRAPPER_H"},{"location":"event__poll_8h_source/","text":"File event_poll.h \u00b6 File List > event > event_poll.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once #ifndef LINUX_EVENT_POLL_API_WRAPPER_H #define LINUX_EVENT_POLL_API_WRAPPER_H #include <coroutine/event.h> #include <memory> #include <fcntl.h> #include <sys/epoll.h> #include <sys/eventfd.h> #include <unistd.h> namespace coro { struct _INTERFACE_ event_poll_t final { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () noexcept ( false ); ~ event_poll_t () noexcept ; void try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ); void remove ( uint64_t fd ); auto wait ( int timeout ) noexcept ( false ) -> enumerable < epoll_event > ; }; } // namespace coro #endif // LINUX_EVENT_POLL_API_WRAPPER_H","title":"File event\\_poll.h"},{"location":"event__poll_8h_source/#file-event95pollh","text":"File List > event > event_poll.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once #ifndef LINUX_EVENT_POLL_API_WRAPPER_H #define LINUX_EVENT_POLL_API_WRAPPER_H #include <coroutine/event.h> #include <memory> #include <fcntl.h> #include <sys/epoll.h> #include <sys/eventfd.h> #include <unistd.h> namespace coro { struct _INTERFACE_ event_poll_t final { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () noexcept ( false ); ~ event_poll_t () noexcept ; void try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ); void remove ( uint64_t fd ); auto wait ( int timeout ) noexcept ( false ) -> enumerable < epoll_event > ; }; } // namespace coro #endif // LINUX_EVENT_POLL_API_WRAPPER_H","title":"File event_poll.h"},{"location":"event__windows_8cpp/","text":"File event_windows.cpp \u00b6 File List > event > event_windows.cpp Go to the source code of this file. #include <coroutine/event.h> #include <coroutine/frame.h> #include <gsl/gsl> #include <system_error> #include <Windows.h> #include <synchapi.h> #include <cassert> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/event/event_windows.cpp","title":"File event\\_windows.cpp"},{"location":"event__windows_8cpp/#file-event95windowscpp","text":"File List > event > event_windows.cpp Go to the source code of this file. #include <coroutine/event.h> #include <coroutine/frame.h> #include <gsl/gsl> #include <system_error> #include <Windows.h> #include <synchapi.h> #include <cassert>","title":"File event_windows.cpp"},{"location":"event__windows_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/event/event_windows.cpp","title":"Namespaces"},{"location":"event__windows_8cpp_source/","text":"File event_windows.cpp \u00b6 File List > event > event_windows.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/event.h> #include <coroutine/frame.h> #include <gsl/gsl> #include <system_error> #include <Windows.h> #include <synchapi.h> // Windows Concurrency Runtime's event is not alertible. //#include <concrt.h> #include <cassert> using namespace std ; using namespace gsl ; namespace coro { static_assert ( is_move_assignable_v < set_or_cancel > == false ); static_assert ( is_move_constructible_v < set_or_cancel > == false ); static_assert ( is_copy_assignable_v < set_or_cancel > == false ); static_assert ( is_copy_constructible_v < set_or_cancel > == false ); GSL_SUPPRESS ( con .4 ) void __stdcall wait_on_thread_pool ( PVOID ctx , BOOLEAN timedout ) { // we are using INFINITE UNREFERENCED_PARAMETER ( timedout ); auto coro = coroutine_handle < void >:: from_address ( ctx ); assert ( coro . done () == false ); coro . resume (); } set_or_cancel :: set_or_cancel ( HANDLE target_event ) noexcept ( false ) : hobject { target_event } { // wait object is used as a storage for the event handle // until it is going to suspend } set_or_cancel ::~ set_or_cancel () noexcept { this -> cancel (); } auto set_or_cancel :: cancel () noexcept -> uint32_t { // secondary cancel must has no effect if ( hobject == INVALID_HANDLE_VALUE ) return NO_ERROR ; UnregisterWait ( hobject ); hobject = INVALID_HANDLE_VALUE ; const auto ec = GetLastError (); if ( ec == ERROR_IO_PENDING ) { // this is expected since we are using INFINITE timeout return NO_ERROR ; } return ec ; } // https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-registerwaitforsingleobject // consider: can we use WT_EXECUTEINWAITTHREAD for this type? void set_or_cancel :: on_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // since this point, wo becomes a handle for the request // this is one-shot event. so use infinite timeout if ( RegisterWaitForSingleObject ( addressof ( hobject ), hobject , wait_on_thread_pool , coro . address (), INFINITE , WT_EXECUTEONLYONCE ) == FALSE ) { throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"RegisterWaitForSingleObject\" }; } } // https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-unregisterwait uint32_t set_or_cancel :: on_resume () noexcept { return this -> cancel (); } } // namespace coro","title":"File event\\_windows.cpp"},{"location":"event__windows_8cpp_source/#file-event95windowscpp","text":"File List > event > event_windows.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/event.h> #include <coroutine/frame.h> #include <gsl/gsl> #include <system_error> #include <Windows.h> #include <synchapi.h> // Windows Concurrency Runtime's event is not alertible. //#include <concrt.h> #include <cassert> using namespace std ; using namespace gsl ; namespace coro { static_assert ( is_move_assignable_v < set_or_cancel > == false ); static_assert ( is_move_constructible_v < set_or_cancel > == false ); static_assert ( is_copy_assignable_v < set_or_cancel > == false ); static_assert ( is_copy_constructible_v < set_or_cancel > == false ); GSL_SUPPRESS ( con .4 ) void __stdcall wait_on_thread_pool ( PVOID ctx , BOOLEAN timedout ) { // we are using INFINITE UNREFERENCED_PARAMETER ( timedout ); auto coro = coroutine_handle < void >:: from_address ( ctx ); assert ( coro . done () == false ); coro . resume (); } set_or_cancel :: set_or_cancel ( HANDLE target_event ) noexcept ( false ) : hobject { target_event } { // wait object is used as a storage for the event handle // until it is going to suspend } set_or_cancel ::~ set_or_cancel () noexcept { this -> cancel (); } auto set_or_cancel :: cancel () noexcept -> uint32_t { // secondary cancel must has no effect if ( hobject == INVALID_HANDLE_VALUE ) return NO_ERROR ; UnregisterWait ( hobject ); hobject = INVALID_HANDLE_VALUE ; const auto ec = GetLastError (); if ( ec == ERROR_IO_PENDING ) { // this is expected since we are using INFINITE timeout return NO_ERROR ; } return ec ; } // https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-registerwaitforsingleobject // consider: can we use WT_EXECUTEINWAITTHREAD for this type? void set_or_cancel :: on_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // since this point, wo becomes a handle for the request // this is one-shot event. so use infinite timeout if ( RegisterWaitForSingleObject ( addressof ( hobject ), hobject , wait_on_thread_pool , coro . address (), INFINITE , WT_EXECUTEONLYONCE ) == FALSE ) { throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"RegisterWaitForSingleObject\" }; } } // https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-unregisterwait uint32_t set_or_cancel :: on_resume () noexcept { return this -> cancel (); } } // namespace coro","title":"File event_windows.cpp"},{"location":"files/","text":"File List \u00b6 Here is a list of all files with brief descriptions: dir CMakeFiles dir 3.16.1 dir CompilerIdCXX file CMakeCXXCompilerId.cpp dir external dir guideline dir tests file algorithm_tests.cpp file assertion_tests.cpp file at_tests.cpp file bounds_tests.cpp file byte_tests.cpp file multi_span_tests.cpp file no_exception_ensure_tests.cpp file no_exception_throw_tests.cpp file notnull_tests.cpp file owner_tests.cpp file span_tests.cpp file strict_notnull_tests.cpp file strided_span_tests.cpp file string_span_tests.cpp file test.cpp file utils_tests.cpp dir interface dir coroutine file channel.hpp file event.h file frame.h file net.h file return.h Utility to define return types for coroutine. file thread.h file yield.hpp dir modules dir concrt file concurrency_helper.h file latch_pthread.cpp file latch_win32.cpp file section_pthread.cpp file section_win32.cpp dir event file event_darwin.cpp file event_linux.cpp file event_poll.cpp file event_poll.h file event_windows.cpp file kernel_queue.cpp file kernel_queue.h file libmain.cpp dir net file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp dir thread file libmain.cpp file pthread.cpp file win32_thread_pool.cpp","title":"Files"},{"location":"files/#file-list","text":"Here is a list of all files with brief descriptions: dir CMakeFiles dir 3.16.1 dir CompilerIdCXX file CMakeCXXCompilerId.cpp dir external dir guideline dir tests file algorithm_tests.cpp file assertion_tests.cpp file at_tests.cpp file bounds_tests.cpp file byte_tests.cpp file multi_span_tests.cpp file no_exception_ensure_tests.cpp file no_exception_throw_tests.cpp file notnull_tests.cpp file owner_tests.cpp file span_tests.cpp file strict_notnull_tests.cpp file strided_span_tests.cpp file string_span_tests.cpp file test.cpp file utils_tests.cpp dir interface dir coroutine file channel.hpp file event.h file frame.h file net.h file return.h Utility to define return types for coroutine. file thread.h file yield.hpp dir modules dir concrt file concurrency_helper.h file latch_pthread.cpp file latch_win32.cpp file section_pthread.cpp file section_win32.cpp dir event file event_darwin.cpp file event_linux.cpp file event_poll.cpp file event_poll.h file event_windows.cpp file kernel_queue.cpp file kernel_queue.h file libmain.cpp dir net file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp dir thread file libmain.cpp file pthread.cpp file win32_thread_pool.cpp","title":"File List"},{"location":"frame_8h/","text":"File frame.h \u00b6 File List > coroutine > frame.h Go to the source code of this file. #include <cstddef> #include <cstdint> #include <type_traits> Namespaces \u00b6 Type Name namespace std namespace experimental Classes \u00b6 Type Name struct clang_frame_prefix struct gcc_frame_prefix struct msvc_frame_prefix class coroutine_handle <PromiseType> class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never Public Types \u00b6 Type Name union prefix_t Public Attributes \u00b6 Type Name constexpr auto aligned_size_v = = ((sizeof(T) + 16u - 1u) & ~(16u - 1u)) Public Functions \u00b6 Type Name void __builtin_coro_destroy (void *) bool __builtin_coro_done (void *) void __builtin_coro_resume (void *) void _coro_destroy (void *) size_t _coro_done (void *) bool _coro_finished (const msvc_frame_prefix *) noexcept size_t _coro_resume (void *) Macros \u00b6 Type Name define COROUTINE_PORTABLE_FRAME_H Public Types Documentation \u00b6 union prefix_t \u00b6 Public Attributes Documentation \u00b6 variable aligned_size_v \u00b6 constexpr auto aligned_size_v ; Public Functions Documentation \u00b6 function __builtin_coro_destroy \u00b6 void __builtin_coro_destroy ( void * ) function __builtin_coro_done \u00b6 bool __builtin_coro_done ( void * ) function __builtin_coro_resume \u00b6 void __builtin_coro_resume ( void * ) function _coro_destroy \u00b6 void _coro_destroy ( void * ) function _coro_done \u00b6 size_t _coro_done ( void * ) function _coro_finished \u00b6 bool _coro_finished ( const msvc_frame_prefix * ) noexcept function _coro_resume \u00b6 size_t _coro_resume ( void * ) Macro Definition Documentation \u00b6 define COROUTINE_PORTABLE_FRAME_H \u00b6 #define COROUTINE_PORTABLE_FRAME_H The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"File frame.h"},{"location":"frame_8h/#file-frameh","text":"File List > coroutine > frame.h Go to the source code of this file. #include <cstddef> #include <cstdint> #include <type_traits>","title":"File frame.h"},{"location":"frame_8h/#namespaces","text":"Type Name namespace std namespace experimental","title":"Namespaces"},{"location":"frame_8h/#classes","text":"Type Name struct clang_frame_prefix struct gcc_frame_prefix struct msvc_frame_prefix class coroutine_handle <PromiseType> class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never","title":"Classes"},{"location":"frame_8h/#public-types","text":"Type Name union prefix_t","title":"Public Types"},{"location":"frame_8h/#public-attributes","text":"Type Name constexpr auto aligned_size_v = = ((sizeof(T) + 16u - 1u) & ~(16u - 1u))","title":"Public Attributes"},{"location":"frame_8h/#public-functions","text":"Type Name void __builtin_coro_destroy (void *) bool __builtin_coro_done (void *) void __builtin_coro_resume (void *) void _coro_destroy (void *) size_t _coro_done (void *) bool _coro_finished (const msvc_frame_prefix *) noexcept size_t _coro_resume (void *)","title":"Public Functions"},{"location":"frame_8h/#macros","text":"Type Name define COROUTINE_PORTABLE_FRAME_H","title":"Macros"},{"location":"frame_8h/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"frame_8h/#union-prefix95t","text":"","title":"union prefix_t"},{"location":"frame_8h/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"frame_8h/#variable-aligned95size95v","text":"constexpr auto aligned_size_v ;","title":"variable aligned_size_v"},{"location":"frame_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"frame_8h/#function-9595builtin95coro95destroy","text":"void __builtin_coro_destroy ( void * )","title":"function __builtin_coro_destroy"},{"location":"frame_8h/#function-9595builtin95coro95done","text":"bool __builtin_coro_done ( void * )","title":"function __builtin_coro_done"},{"location":"frame_8h/#function-9595builtin95coro95resume","text":"void __builtin_coro_resume ( void * )","title":"function __builtin_coro_resume"},{"location":"frame_8h/#function-95coro95destroy","text":"void _coro_destroy ( void * )","title":"function _coro_destroy"},{"location":"frame_8h/#function-95coro95done","text":"size_t _coro_done ( void * )","title":"function _coro_done"},{"location":"frame_8h/#function-95coro95finished","text":"bool _coro_finished ( const msvc_frame_prefix * ) noexcept","title":"function _coro_finished"},{"location":"frame_8h/#function-95coro95resume","text":"size_t _coro_resume ( void * )","title":"function _coro_resume"},{"location":"frame_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"frame_8h/#define-coroutine95portable95frame95h","text":"#define COROUTINE_PORTABLE_FRAME_H The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"define COROUTINE_PORTABLE_FRAME_H"},{"location":"frame_8h_source/","text":"File frame.h \u00b6 File List > coroutine > frame.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // Header to adjust the difference of coroutine frame between compilers // // Reference // <experimental/resumable> from Microsoft VC++ (since 2017 Feb.) // <experimental/coroutine> from LLVM libcxx (since 6.0) // https://github.com/iains/gcc-cxx-coroutines // #pragma once #include <cstddef> #include <cstdint> #if defined(__clang__) && defined(_MSC_VER) // use this header // // case: clang-cl, VC++ // In this case, override <experimental/resumable>. // Since msvc and clang++ uses differnet frame layout, // VC++ won't fit clang-cl's code generation. // see the implementation below // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #elif defined(USE_PORTABLE_COROUTINE_HANDLE) // use this header // // case: clang-cl, VC++ // case: msvc, VC++ // case: clang, libc++ // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #else // use default header // // case: msvc, VC++ // case: clang, libc++ // It is safe to use vendor's header. // by defining macro variable, user can prevent template redefinition // #if __has_include(<coroutine>) // C++ 20 standard #include <coroutine> #elif __has_include(<experimental/coroutine>) // C++ 17 experimetal #include <experimental/coroutine> // We don't need to use this portable one. // Disable the implementation below and use the default #define COROUTINE_PORTABLE_FRAME_H #endif #endif // <coroutine> header #if defined(__clang__) static constexpr auto is_clang = true ; static constexpr auto is_msvc = ! is_clang ; static constexpr auto is_gcc = ! is_clang ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(_MSC_VER) static constexpr auto is_msvc = true ; static constexpr auto is_clang = ! is_msvc ; static constexpr auto is_gcc = ! is_msvc ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(__GNUC__) static constexpr auto is_gcc = true ; static constexpr auto is_msvc = ! is_gcc ; static constexpr auto is_clang = ! is_gcc ; // gcc-10 failes when __cdecl is used. declare it without convention using procedure_t = void ( * )( void * ); #else #error \"unexpected compiler. please contact the author\" #endif template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16u - 1u ) & ~ ( 16u - 1u )); // - Note // MSVC coroutine frame's prefix // Reference <experimental/resumable> for the detail // - Layout // +------------+------------------+--------------------+ // | Promise(?) | Frame Prefix(16) | Local variables(?) | // +------------+------------------+--------------------+ struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); // - Note // Clang coroutine frame's prefix // - Layout // +------------------+------------+---+--------------------+ // | Frame Prefix(16) | Promise(?) | ? | Local variables(?) | // +------------------+------------+---+--------------------+ struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 ); // - Note // GCC coroutine frame's prefix // - Layout // Unknown struct gcc_frame_prefix final { void * _unknown1 ; void * _unknown2 ; }; static_assert ( aligned_size_v < gcc_frame_prefix > == 16 ); #ifndef COROUTINE_PORTABLE_FRAME_H #define COROUTINE_PORTABLE_FRAME_H #pragma warning(push, 4) #pragma warning(disable : 4455 4494 4577 4619 4643 4702 4984 4988) #pragma warning(disable : 26490 26481 26476 26429 26409) #include <type_traits> // Alternative of `_coro_done` of msvc for this library. // It is renamed to avoid redefinition bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; // // intrinsic: MSVC // extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // // intrinsic: Clang/GCC // extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); // void* __builtin_coro_promise(void* ptr, int align, bool p); namespace std { namespace experimental { // template <typename R, class = void> // struct coroutine_traits_sfinae {}; // // template <typename R> // struct coroutine_traits_sfinae<R, void_t<typename R::promise_type>> { // using promise_type = typename R::promise_type; // }; // traits to enforce `promise_type`, without sfinae consideration. template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; template < typename PromiseType = void > class coroutine_handle ; template <> class coroutine_handle < void > { public : // This type is exposed // to provide more information for the frame and // to prepare for future adaptation. (especially for gcc family) union prefix_t { void * v {}; msvc_frame_prefix * m ; clang_frame_prefix * c ; gcc_frame_prefix * g ; }; static_assert ( sizeof ( prefix_t ) == sizeof ( void * )); prefix_t prefix ; public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept : prefix { nullptr } { } coroutine_handle & operator = ( nullptr_t ) noexcept { prefix . v = nullptr ; return * this ; } explicit operator bool () const noexcept { return prefix . v != nullptr ; } void resume () noexcept ( false ) { if constexpr ( is_msvc ) { _coro_resume ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_resume ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_resume ( prefix . g ); } } void destroy () noexcept { if constexpr ( is_msvc ) { _coro_destroy ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_destroy ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_destroy ( prefix . g ); } } bool done () const noexcept { if constexpr ( is_msvc ) { return _coro_finished ( prefix . m ); } else if constexpr ( is_clang ) { return __builtin_coro_done ( prefix . c ); } else if constexpr ( is_gcc ) { return __builtin_coro_done ( prefix . g ); } else { return false ; } } public : constexpr void * address () const noexcept { return prefix . v ; } static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } }; template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; private : static promise_type * from_frame ( prefix_t addr ) noexcept { if constexpr ( is_clang ) { // calculate the location of the frame's prefix auto * prefix = addr . c ; // for clang, promise is placed just after frame prefix // so this line works like `__builtin_coro_promise`, auto * promise = reinterpret_cast < promise_type *> ( prefix + 1 ); return promise ; } else if constexpr ( is_msvc ) { auto * ptr = reinterpret_cast < char *> ( addr . m ); // for msvc, promise is placed before frame prefix auto * promise = reinterpret_cast < promise_type *> ( ptr - aligned_size_v < promise_type > ); return promise ; } else if constexpr ( is_gcc ) { void * ptr = __builtin_coro_promise ( addr . g , __alignof ( promise_type ), false ); return reinterpret_cast < promise_type *> ( ptr ); } // !!! crash !!! return nullptr ; } public : using coroutine_handle < void >:: coroutine_handle ; coroutine_handle & operator = ( nullptr_t ) noexcept { this -> prefix . v = nullptr ; return * this ; } auto promise () const noexcept -> const promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } auto promise () noexcept -> promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } public : static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } static coroutine_handle from_promise ( promise_type & prom ) noexcept { promise_type * promise = & prom ; // calculate the location of the coroutine frame prefix if constexpr ( is_clang ) { void * prefix = reinterpret_cast < char *> ( promise ) - sizeof ( clang_frame_prefix ); return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_msvc ) { void * prefix = reinterpret_cast < char *> ( promise ) + aligned_size_v < promise_type > ; return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_gcc ) { void * prefix = __builtin_coro_promise ( reinterpret_cast < char *> ( & prom ), __alignof ( promise_type ), true ); return coroutine_handle :: from_address ( prefix ); } return coroutine_handle {}; } }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); inline bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () == rhs . address (); } inline bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs == rhs ); } inline bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () < rhs . address (); } inline bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } inline bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs > rhs ); } inline bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } struct noop_coroutine_promise {}; using noop_coroutine_handle = coroutine_handle < noop_coroutine_promise > ; template <> class coroutine_handle < noop_coroutine_promise > : public coroutine_handle < void > { public : coroutine_handle () noexcept : coroutine_handle < void > {} { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) this -> prefix . v = __builtin_coro_noop (); #else auto & p = this -> promise (); this -> prefix . v = & p ; #endif } public : constexpr explicit operator bool () const noexcept { return true ; } constexpr bool done () const noexcept { return false ; } constexpr void operator ()() const noexcept { return ; } constexpr void resume () const noexcept { return ; } constexpr void destroy () const noexcept { return ; } noop_coroutine_promise & promise () const noexcept { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) return * static_cast < noop_coroutine_promise *> ( __builtin_coro_promise ( this -> prefix . v , __alignof ( noop_coroutine_promise ), false )); #else static noop_coroutine_promise p {}; return p ; #endif } constexpr void * address () const noexcept { return this -> prefix . v ; } }; inline noop_coroutine_handle noop_coroutine () noexcept { return {}; } class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function won't be invoked } }; class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function will ignore the given handle } }; } // namespace experimental } // namespace std #if defined(__clang__) // // Note // VC++ header expects msvc intrinsics. Redirect them to Clang intrinsics. // If the project uses libc++ header files, this code won't be a problem // because they wont't be used // Reference // https://clang.llvm.org/docs/LanguageExtensions.html#c-coroutines-support-builtins // https://llvm.org/docs/Coroutines.html#example // inline bool _coro_finished ( msvc_frame_prefix * m ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed auto * c = reinterpret_cast < clang_frame_prefix *> ( m ); return __builtin_coro_done ( c ) ? 1 : 0 ; } inline size_t _coro_resume ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_resume ( c ); return 0 ; } inline void _coro_destroy ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_destroy ( c ); } #elif defined(_MSC_VER) inline bool _coro_finished ( const msvc_frame_prefix * prefix ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed return prefix -> index == 0 ; } namespace std :: experimental { // Helper traits for MSVC's coroutine compilation. // The original code is in <experimental/resumable> template < typename _Ret , typename ... _Ts > struct _Resumable_helper_traits { using promise_type = typename coroutine_traits < _Ret , _Ts ... >:: promise_type ; using handle_type = coroutine_handle < promise_type > ; static promise_type * _Promise_from_frame ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); return & prom ; } static handle_type _Handle_from_frame ( void * _Addr ) noexcept { auto * p = _Promise_from_frame ( _Addr ); return handle_type :: from_promise ( * p ); } static void _Set_exception ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); prom -> set_exception ( std :: current_exception ()); } static void _ConstructPromise ( void * addr , void * func , int _HeapElision ) noexcept ( false ) { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); prefix -> factivate = static_cast < procedure_t > ( func ); uint32_t * ptr = reinterpret_cast < uint32_t *> ( reinterpret_cast < uintptr_t > ( prefix ) + sizeof ( void * )); * ptr = 2 + ( _HeapElision ? 0 : 0x10000 ); auto * prom = _Promise_from_frame ( prefix ); :: new ( prom ) promise_type (); } static void _DestructPromise ( void * addr ) noexcept { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); _Promise_from_frame ( prefix ) ->~ promise_type (); } }; } // namespace std::experimental #elif defined(__GNUC__) inline bool is_suspended ( gcc_frame_prefix * g ) noexcept { return __builtin_coro_is_suspended ( g ); } #endif // __clang__ || _MSC_VER || __GNUC__ #pragma warning(pop) #endif // COROUTINE_PORTABLE_FRAME_H","title":"File frame.h"},{"location":"frame_8h_source/#file-frameh","text":"File List > coroutine > frame.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // Header to adjust the difference of coroutine frame between compilers // // Reference // <experimental/resumable> from Microsoft VC++ (since 2017 Feb.) // <experimental/coroutine> from LLVM libcxx (since 6.0) // https://github.com/iains/gcc-cxx-coroutines // #pragma once #include <cstddef> #include <cstdint> #if defined(__clang__) && defined(_MSC_VER) // use this header // // case: clang-cl, VC++ // In this case, override <experimental/resumable>. // Since msvc and clang++ uses differnet frame layout, // VC++ won't fit clang-cl's code generation. // see the implementation below // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #elif defined(USE_PORTABLE_COROUTINE_HANDLE) // use this header // // case: clang-cl, VC++ // case: msvc, VC++ // case: clang, libc++ // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #else // use default header // // case: msvc, VC++ // case: clang, libc++ // It is safe to use vendor's header. // by defining macro variable, user can prevent template redefinition // #if __has_include(<coroutine>) // C++ 20 standard #include <coroutine> #elif __has_include(<experimental/coroutine>) // C++ 17 experimetal #include <experimental/coroutine> // We don't need to use this portable one. // Disable the implementation below and use the default #define COROUTINE_PORTABLE_FRAME_H #endif #endif // <coroutine> header #if defined(__clang__) static constexpr auto is_clang = true ; static constexpr auto is_msvc = ! is_clang ; static constexpr auto is_gcc = ! is_clang ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(_MSC_VER) static constexpr auto is_msvc = true ; static constexpr auto is_clang = ! is_msvc ; static constexpr auto is_gcc = ! is_msvc ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(__GNUC__) static constexpr auto is_gcc = true ; static constexpr auto is_msvc = ! is_gcc ; static constexpr auto is_clang = ! is_gcc ; // gcc-10 failes when __cdecl is used. declare it without convention using procedure_t = void ( * )( void * ); #else #error \"unexpected compiler. please contact the author\" #endif template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16u - 1u ) & ~ ( 16u - 1u )); // - Note // MSVC coroutine frame's prefix // Reference <experimental/resumable> for the detail // - Layout // +------------+------------------+--------------------+ // | Promise(?) | Frame Prefix(16) | Local variables(?) | // +------------+------------------+--------------------+ struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); // - Note // Clang coroutine frame's prefix // - Layout // +------------------+------------+---+--------------------+ // | Frame Prefix(16) | Promise(?) | ? | Local variables(?) | // +------------------+------------+---+--------------------+ struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 ); // - Note // GCC coroutine frame's prefix // - Layout // Unknown struct gcc_frame_prefix final { void * _unknown1 ; void * _unknown2 ; }; static_assert ( aligned_size_v < gcc_frame_prefix > == 16 ); #ifndef COROUTINE_PORTABLE_FRAME_H #define COROUTINE_PORTABLE_FRAME_H #pragma warning(push, 4) #pragma warning(disable : 4455 4494 4577 4619 4643 4702 4984 4988) #pragma warning(disable : 26490 26481 26476 26429 26409) #include <type_traits> // Alternative of `_coro_done` of msvc for this library. // It is renamed to avoid redefinition bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; // // intrinsic: MSVC // extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // // intrinsic: Clang/GCC // extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); // void* __builtin_coro_promise(void* ptr, int align, bool p); namespace std { namespace experimental { // template <typename R, class = void> // struct coroutine_traits_sfinae {}; // // template <typename R> // struct coroutine_traits_sfinae<R, void_t<typename R::promise_type>> { // using promise_type = typename R::promise_type; // }; // traits to enforce `promise_type`, without sfinae consideration. template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; template < typename PromiseType = void > class coroutine_handle ; template <> class coroutine_handle < void > { public : // This type is exposed // to provide more information for the frame and // to prepare for future adaptation. (especially for gcc family) union prefix_t { void * v {}; msvc_frame_prefix * m ; clang_frame_prefix * c ; gcc_frame_prefix * g ; }; static_assert ( sizeof ( prefix_t ) == sizeof ( void * )); prefix_t prefix ; public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept : prefix { nullptr } { } coroutine_handle & operator = ( nullptr_t ) noexcept { prefix . v = nullptr ; return * this ; } explicit operator bool () const noexcept { return prefix . v != nullptr ; } void resume () noexcept ( false ) { if constexpr ( is_msvc ) { _coro_resume ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_resume ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_resume ( prefix . g ); } } void destroy () noexcept { if constexpr ( is_msvc ) { _coro_destroy ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_destroy ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_destroy ( prefix . g ); } } bool done () const noexcept { if constexpr ( is_msvc ) { return _coro_finished ( prefix . m ); } else if constexpr ( is_clang ) { return __builtin_coro_done ( prefix . c ); } else if constexpr ( is_gcc ) { return __builtin_coro_done ( prefix . g ); } else { return false ; } } public : constexpr void * address () const noexcept { return prefix . v ; } static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } }; template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; private : static promise_type * from_frame ( prefix_t addr ) noexcept { if constexpr ( is_clang ) { // calculate the location of the frame's prefix auto * prefix = addr . c ; // for clang, promise is placed just after frame prefix // so this line works like `__builtin_coro_promise`, auto * promise = reinterpret_cast < promise_type *> ( prefix + 1 ); return promise ; } else if constexpr ( is_msvc ) { auto * ptr = reinterpret_cast < char *> ( addr . m ); // for msvc, promise is placed before frame prefix auto * promise = reinterpret_cast < promise_type *> ( ptr - aligned_size_v < promise_type > ); return promise ; } else if constexpr ( is_gcc ) { void * ptr = __builtin_coro_promise ( addr . g , __alignof ( promise_type ), false ); return reinterpret_cast < promise_type *> ( ptr ); } // !!! crash !!! return nullptr ; } public : using coroutine_handle < void >:: coroutine_handle ; coroutine_handle & operator = ( nullptr_t ) noexcept { this -> prefix . v = nullptr ; return * this ; } auto promise () const noexcept -> const promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } auto promise () noexcept -> promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } public : static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } static coroutine_handle from_promise ( promise_type & prom ) noexcept { promise_type * promise = & prom ; // calculate the location of the coroutine frame prefix if constexpr ( is_clang ) { void * prefix = reinterpret_cast < char *> ( promise ) - sizeof ( clang_frame_prefix ); return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_msvc ) { void * prefix = reinterpret_cast < char *> ( promise ) + aligned_size_v < promise_type > ; return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_gcc ) { void * prefix = __builtin_coro_promise ( reinterpret_cast < char *> ( & prom ), __alignof ( promise_type ), true ); return coroutine_handle :: from_address ( prefix ); } return coroutine_handle {}; } }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); inline bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () == rhs . address (); } inline bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs == rhs ); } inline bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () < rhs . address (); } inline bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } inline bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs > rhs ); } inline bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } struct noop_coroutine_promise {}; using noop_coroutine_handle = coroutine_handle < noop_coroutine_promise > ; template <> class coroutine_handle < noop_coroutine_promise > : public coroutine_handle < void > { public : coroutine_handle () noexcept : coroutine_handle < void > {} { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) this -> prefix . v = __builtin_coro_noop (); #else auto & p = this -> promise (); this -> prefix . v = & p ; #endif } public : constexpr explicit operator bool () const noexcept { return true ; } constexpr bool done () const noexcept { return false ; } constexpr void operator ()() const noexcept { return ; } constexpr void resume () const noexcept { return ; } constexpr void destroy () const noexcept { return ; } noop_coroutine_promise & promise () const noexcept { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) return * static_cast < noop_coroutine_promise *> ( __builtin_coro_promise ( this -> prefix . v , __alignof ( noop_coroutine_promise ), false )); #else static noop_coroutine_promise p {}; return p ; #endif } constexpr void * address () const noexcept { return this -> prefix . v ; } }; inline noop_coroutine_handle noop_coroutine () noexcept { return {}; } class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function won't be invoked } }; class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function will ignore the given handle } }; } // namespace experimental } // namespace std #if defined(__clang__) // // Note // VC++ header expects msvc intrinsics. Redirect them to Clang intrinsics. // If the project uses libc++ header files, this code won't be a problem // because they wont't be used // Reference // https://clang.llvm.org/docs/LanguageExtensions.html#c-coroutines-support-builtins // https://llvm.org/docs/Coroutines.html#example // inline bool _coro_finished ( msvc_frame_prefix * m ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed auto * c = reinterpret_cast < clang_frame_prefix *> ( m ); return __builtin_coro_done ( c ) ? 1 : 0 ; } inline size_t _coro_resume ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_resume ( c ); return 0 ; } inline void _coro_destroy ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_destroy ( c ); } #elif defined(_MSC_VER) inline bool _coro_finished ( const msvc_frame_prefix * prefix ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed return prefix -> index == 0 ; } namespace std :: experimental { // Helper traits for MSVC's coroutine compilation. // The original code is in <experimental/resumable> template < typename _Ret , typename ... _Ts > struct _Resumable_helper_traits { using promise_type = typename coroutine_traits < _Ret , _Ts ... >:: promise_type ; using handle_type = coroutine_handle < promise_type > ; static promise_type * _Promise_from_frame ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); return & prom ; } static handle_type _Handle_from_frame ( void * _Addr ) noexcept { auto * p = _Promise_from_frame ( _Addr ); return handle_type :: from_promise ( * p ); } static void _Set_exception ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); prom -> set_exception ( std :: current_exception ()); } static void _ConstructPromise ( void * addr , void * func , int _HeapElision ) noexcept ( false ) { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); prefix -> factivate = static_cast < procedure_t > ( func ); uint32_t * ptr = reinterpret_cast < uint32_t *> ( reinterpret_cast < uintptr_t > ( prefix ) + sizeof ( void * )); * ptr = 2 + ( _HeapElision ? 0 : 0x10000 ); auto * prom = _Promise_from_frame ( prefix ); :: new ( prom ) promise_type (); } static void _DestructPromise ( void * addr ) noexcept { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); _Promise_from_frame ( prefix ) ->~ promise_type (); } }; } // namespace std::experimental #elif defined(__GNUC__) inline bool is_suspended ( gcc_frame_prefix * g ) noexcept { return __builtin_coro_is_suspended ( g ); } #endif // __clang__ || _MSC_VER || __GNUC__ #pragma warning(pop) #endif // COROUTINE_PORTABLE_FRAME_H","title":"File frame.h"},{"location":"functions/","text":"Functions \u00b6 a \u00b6 av ( strided_span_tests.cpp ) c \u00b6 CHECK ( multi_span_tests.cpp , strided_span_tests.cpp ) CreateTempName ( string_span_tests.cpp ) CreateTempNameU16 ( string_span_tests.cpp ) CreateTempNameU32 ( string_span_tests.cpp ) CreateTempNameW ( string_span_tests.cpp ) create ( string_span_tests.cpp ) f \u00b6 f ( assertion_tests.cpp , utils_tests.cpp ) fixed_func ( multi_span_tests.cpp ) fn ( multi_span_tests.cpp ) for ( multi_span_tests.cpp , strided_span_tests.cpp ) g \u00b6 GSL_SUPPRESS ( algorithm_tests.cpp , at_tests.cpp , bounds_tests.cpp , multi_span_tests.cpp , notnull_tests.cpp , owner_tests.cpp , span_tests.cpp , strict_notnull_tests.cpp , strided_span_tests.cpp , string_span_tests.cpp , utils_tests.cpp ) g ( assertion_tests.cpp , utils_tests.cpp ) m \u00b6 main ( CMakeCXXCompilerId.cpp , no_exception_ensure_tests.cpp , no_exception_throw_tests.cpp ) move_wrapper ( string_span_tests.cpp ) n \u00b6 narrow_no_throw ( no_exception_throw_tests.cpp ) o \u00b6 overloaded_func ( multi_span_tests.cpp ) operator_subscript_no_throw ( no_exception_ensure_tests.cpp ) operator!= ( notnull_tests.cpp ) operator< ( notnull_tests.cpp ) operator<= ( notnull_tests.cpp ) operator== ( notnull_tests.cpp ) operator> ( notnull_tests.cpp ) operator>= ( notnull_tests.cpp ) r \u00b6 return_pointer ( notnull_tests.cpp , strict_notnull_tests.cpp ) return_pointer_const ( notnull_tests.cpp , strict_notnull_tests.cpp ) s \u00b6 setup_termination_handler ( no_exception_ensure_tests.cpp , no_exception_throw_tests.cpp ) setup_mutex_attr ( latch_pthread.cpp ) t \u00b6 TEST_CASE ( algorithm_tests.cpp , assertion_tests.cpp , multi_span_tests.cpp , notnull_tests.cpp , owner_tests.cpp , span_tests.cpp , strided_span_tests.cpp , string_span_tests.cpp , utils_tests.cpp ) test_terminate ( no_exception_ensure_tests.cpp , no_exception_throw_tests.cpp ) u \u00b6 use ( string_span_tests.cpp ) _ \u00b6 __builtin_coro_destroy ( frame.h ) __builtin_coro_done ( frame.h ) __builtin_coro_resume ( frame.h ) _coro_destroy ( frame.h ) _coro_done ( frame.h ) _coro_finished ( frame.h ) _coro_resume ( frame.h )","title":"Functions"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"functions/#a","text":"av ( strided_span_tests.cpp )","title":"a"},{"location":"functions/#c","text":"CHECK ( multi_span_tests.cpp , strided_span_tests.cpp ) CreateTempName ( string_span_tests.cpp ) CreateTempNameU16 ( string_span_tests.cpp ) CreateTempNameU32 ( string_span_tests.cpp ) CreateTempNameW ( string_span_tests.cpp ) create ( string_span_tests.cpp )","title":"c"},{"location":"functions/#f","text":"f ( assertion_tests.cpp , utils_tests.cpp ) fixed_func ( multi_span_tests.cpp ) fn ( multi_span_tests.cpp ) for ( multi_span_tests.cpp , strided_span_tests.cpp )","title":"f"},{"location":"functions/#g","text":"GSL_SUPPRESS ( algorithm_tests.cpp , at_tests.cpp , bounds_tests.cpp , multi_span_tests.cpp , notnull_tests.cpp , owner_tests.cpp , span_tests.cpp , strict_notnull_tests.cpp , strided_span_tests.cpp , string_span_tests.cpp , utils_tests.cpp ) g ( assertion_tests.cpp , utils_tests.cpp )","title":"g"},{"location":"functions/#m","text":"main ( CMakeCXXCompilerId.cpp , no_exception_ensure_tests.cpp , no_exception_throw_tests.cpp ) move_wrapper ( string_span_tests.cpp )","title":"m"},{"location":"functions/#n","text":"narrow_no_throw ( no_exception_throw_tests.cpp )","title":"n"},{"location":"functions/#o","text":"overloaded_func ( multi_span_tests.cpp ) operator_subscript_no_throw ( no_exception_ensure_tests.cpp ) operator!= ( notnull_tests.cpp ) operator< ( notnull_tests.cpp ) operator<= ( notnull_tests.cpp ) operator== ( notnull_tests.cpp ) operator> ( notnull_tests.cpp ) operator>= ( notnull_tests.cpp )","title":"o"},{"location":"functions/#r","text":"return_pointer ( notnull_tests.cpp , strict_notnull_tests.cpp ) return_pointer_const ( notnull_tests.cpp , strict_notnull_tests.cpp )","title":"r"},{"location":"functions/#s","text":"setup_termination_handler ( no_exception_ensure_tests.cpp , no_exception_throw_tests.cpp ) setup_mutex_attr ( latch_pthread.cpp )","title":"s"},{"location":"functions/#t","text":"TEST_CASE ( algorithm_tests.cpp , assertion_tests.cpp , multi_span_tests.cpp , notnull_tests.cpp , owner_tests.cpp , span_tests.cpp , strided_span_tests.cpp , string_span_tests.cpp , utils_tests.cpp ) test_terminate ( no_exception_ensure_tests.cpp , no_exception_throw_tests.cpp )","title":"t"},{"location":"functions/#u","text":"use ( string_span_tests.cpp )","title":"u"},{"location":"functions/#_","text":"__builtin_coro_destroy ( frame.h ) __builtin_coro_done ( frame.h ) __builtin_coro_resume ( frame.h ) _coro_destroy ( frame.h ) _coro_done ( frame.h ) _coro_finished ( frame.h ) _coro_resume ( frame.h )","title":"_"},{"location":"hierarchy/","text":"Class Hierarchy \u00b6 This inheritance list is sorted roughly, but not completely, alphabetically: class coro::internal::list class coro::enumerable class coro::enumerable::iterator class std::experimental::coroutine_handle< void > class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class std::experimental::coroutine_handle< noop_coroutine_promise > class coro::promise_aa class coro::frame_t::promise_type class coro::reader class coro::peeker class coro::promise_an class coro::promise_na class coro::promise_nn class coro::writer class std::experimental::coroutine_handle class std::experimental::suspend_always class std::experimental::suspend_never struct CustomPtr struct MyBase struct MyDerived struct NonCopyableNonMovable struct RefCounted struct Unrelated struct clang_frame_prefix struct coro::bypass_lock struct coro::darwin_event struct coro::event_poll_t struct coro::kernel_queue_t struct gcc_frame_prefix struct msvc_frame_prefix struct std::experimental::coroutine_traits struct std::experimental::noop_coroutine_promise class promise_manual_control class coro::enumerable::promise_type class io_control_block class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to","title":"Class Hierarchy"},{"location":"hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class coro::internal::list class coro::enumerable class coro::enumerable::iterator class std::experimental::coroutine_handle< void > class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class std::experimental::coroutine_handle< noop_coroutine_promise > class coro::promise_aa class coro::frame_t::promise_type class coro::reader class coro::peeker class coro::promise_an class coro::promise_na class coro::promise_nn class coro::writer class std::experimental::coroutine_handle class std::experimental::suspend_always class std::experimental::suspend_never struct CustomPtr struct MyBase struct MyDerived struct NonCopyableNonMovable struct RefCounted struct Unrelated struct clang_frame_prefix struct coro::bypass_lock struct coro::darwin_event struct coro::event_poll_t struct coro::kernel_queue_t struct gcc_frame_prefix struct msvc_frame_prefix struct std::experimental::coroutine_traits struct std::experimental::noop_coroutine_promise class promise_manual_control class coro::enumerable::promise_type class io_control_block class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to class coro::io_work_t class coro::io_recv class coro::io_recv_from class coro::io_send class coro::io_send_to","title":"Class Hierarchy"},{"location":"io__darwin_8cpp/","text":"File io_darwin.cpp \u00b6 File List > modules > net > io_darwin.cpp Go to the source code of this file. #include <coroutine/net.h> #include \"kernel_queue.h\" Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"File io\\_darwin.cpp"},{"location":"io__darwin_8cpp/#file-io95darwincpp","text":"File List > modules > net > io_darwin.cpp Go to the source code of this file. #include <coroutine/net.h> #include \"kernel_queue.h\"","title":"File io_darwin.cpp"},{"location":"io__darwin_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"Namespaces"},{"location":"io__darwin_8cpp_source/","text":"File io_darwin.cpp \u00b6 File List > modules > net > io_darwin.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/net.h> #include \"kernel_queue.h\" static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { kernel_queue_t kq {}; auto enumerate_net_tasks ( nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); for ( kevent64_s & ev : kq . wait ( ts )) { auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } void wait_net_tasks ( coro :: enumerable < io_task_t >& tasks , std :: chrono :: nanoseconds timeout ) noexcept ( false ) { tasks = enumerate_net_tasks ( timeout ); } bool io_work_t :: ready () const noexcept { const auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( io_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); kq . change ( req ); } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( io_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; // it is possible to pass `rh` for the user data, // but will pass this object to support // receiving some values from `wait_io_tasks` req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); kq . change ( req ); } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( io_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); kq . change ( req ); } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( io_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); kq . change ( req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io\\_darwin.cpp"},{"location":"io__darwin_8cpp_source/#file-io95darwincpp","text":"File List > modules > net > io_darwin.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/net.h> #include \"kernel_queue.h\" static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { kernel_queue_t kq {}; auto enumerate_net_tasks ( nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); for ( kevent64_s & ev : kq . wait ( ts )) { auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } void wait_net_tasks ( coro :: enumerable < io_task_t >& tasks , std :: chrono :: nanoseconds timeout ) noexcept ( false ) { tasks = enumerate_net_tasks ( timeout ); } bool io_work_t :: ready () const noexcept { const auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( io_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); kq . change ( req ); } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( io_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; // it is possible to pass `rh` for the user data, // but will pass this object to support // receiving some values from `wait_io_tasks` req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); kq . change ( req ); } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( io_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); kq . change ( req ); } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( io_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); kq . change ( req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io_darwin.cpp"},{"location":"io__linux_8cpp/","text":"File io_linux.cpp \u00b6 File List > modules > net > io_linux.cpp Go to the source code of this file. #include <coroutine/net.h> #include \"event_poll.h\" Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_linux.cpp","title":"File io\\_linux.cpp"},{"location":"io__linux_8cpp/#file-io95linuxcpp","text":"File List > modules > net > io_linux.cpp Go to the source code of this file. #include <coroutine/net.h> #include \"event_poll.h\"","title":"File io_linux.cpp"},{"location":"io__linux_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_linux.cpp","title":"Namespaces"},{"location":"io__linux_8cpp_source/","text":"File io_linux.cpp \u00b6 File List > modules > net > io_linux.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/net.h> #include \"event_poll.h\" static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { event_poll_t inbound {}, outbound {}; auto enumerate_net_tasks ( nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; io_task_t task {}; for ( auto event : inbound . wait ( half_time )) co_yield task = io_task_t :: from_address ( event . data . ptr ); for ( auto event : outbound . wait ( half_time )) co_yield task = io_task_t :: from_address ( event . data . ptr ); } void wait_net_tasks ( coro :: enumerable < io_task_t >& tasks , std :: chrono :: nanoseconds timeout ) noexcept ( false ) { tasks = enumerate_net_tasks ( timeout ); } bool io_work_t :: ready () const noexcept { auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( io_task_t rh ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); outbound . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( io_task_t rh ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( io_task_t rh ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); outbound . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( io_task_t rh ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io\\_linux.cpp"},{"location":"io__linux_8cpp_source/#file-io95linuxcpp","text":"File List > modules > net > io_linux.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/net.h> #include \"event_poll.h\" static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { event_poll_t inbound {}, outbound {}; auto enumerate_net_tasks ( nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; io_task_t task {}; for ( auto event : inbound . wait ( half_time )) co_yield task = io_task_t :: from_address ( event . data . ptr ); for ( auto event : outbound . wait ( half_time )) co_yield task = io_task_t :: from_address ( event . data . ptr ); } void wait_net_tasks ( coro :: enumerable < io_task_t >& tasks , std :: chrono :: nanoseconds timeout ) noexcept ( false ) { tasks = enumerate_net_tasks ( timeout ); } bool io_work_t :: ready () const noexcept { auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( io_task_t rh ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); outbound . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( io_task_t rh ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( io_task_t rh ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); outbound . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( io_task_t rh ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io_linux.cpp"},{"location":"io__windows_8cpp/","text":"File io_windows.cpp \u00b6 File List > modules > net > io_windows.cpp Go to the source code of this file. #include <coroutine/net.h> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"File io\\_windows.cpp"},{"location":"io__windows_8cpp/#file-io95windowscpp","text":"File List > modules > net > io_windows.cpp Go to the source code of this file. #include <coroutine/net.h>","title":"File io_windows.cpp"},{"location":"io__windows_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"Namespaces"},{"location":"io__windows_8cpp_source/","text":"File io_windows.cpp \u00b6 File List > modules > net > io_windows.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/net.h> using namespace std ; using namespace gsl ; namespace coro { void wait_net_tasks ( enumerable < io_task_t >& tasks , chrono :: nanoseconds ) noexcept ( false ) { // windows implementation rely on callback. // So there is noting to yield ... tasks = enumerable < io_task_t > {}; // Just comsume some items in this thread's APC queue SleepEx ( 0 , true ); } bool is_async_pending ( int ec ) noexcept { switch ( ec ) { case WSAEWOULDBLOCK : case EWOULDBLOCK : case EINPROGRESS : case ERROR_IO_PENDING : return true ; default : return false ; } } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .6 ) void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); // Mostly, `Internal` and `InternalHigh` holds exactly same value with the // parameters. So these assignments are redundant. // Here, we are just making sure of it. work -> Internal = errc ; // -> return of `work.error()` work -> InternalHigh = sz ; // -> return of `await_resume()` work -> task . resume (); } bool io_work_t :: ready () const noexcept { return false ; // always trigger `await_suspend` in Windows API } uint32_t get_io_error ( const OVERLAPPED * target ) noexcept { static_assert ( sizeof ( DWORD ) == sizeof ( uint32_t )); return gsl :: narrow_cast < uint32_t > ( target -> Internal ); } int64_t get_io_length ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < int64_t > ( target -> InternalHigh ); } // see also: `onWorkDone` uint32_t io_work_t :: error () const noexcept { return get_io_error ( this ); } // zero memory the `OVERLAPPED` part in the `io_work_t` auto zero_overlapped ( gsl :: not_null < io_control_block *> work ) noexcept -> gsl :: not_null < io_control_block *> { static_assert ( is_same_v < io_control_block , OVERLAPPED > ); * work = OVERLAPPED {}; return work ; } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .4 ) // for clang, this is not constexpr function. auto make_wsa_buf ( io_buffer_t v ) noexcept -> WSABUF { WSABUF buf {}; // expect NRVO buf . buf = reinterpret_cast < char *> ( v . data ()); buf . len = gsl :: narrow_cast < ULONG > ( v . size_bytes ()); return buf ; } // ensure we are x64 static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in6 *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send_to :: suspend ( io_task_t t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; LPOVERLAPPED pover = zero_overlapped ( gsl :: make_not_null ( this )); if ( :: WSASendTo ( sd , bufs , 1 , nullptr , flag , // addr , addrlen , // pover , onWorkDone ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASendTo\" }; } } int64_t io_send_to :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv_from :: suspend ( io_task_t t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecvFrom ( sd , bufs , 1 , nullptr , & flag , // addr , & addrlen , // zero_overlapped ( gsl :: make_not_null ( this )), onWorkDone ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecvFrom\" }; } } int64_t io_recv_from :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_send` return * reinterpret_cast < io_send *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send :: suspend ( io_task_t t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASend ( sd , bufs , 1 , nullptr , flag , // zero_overlapped ( gsl :: make_not_null ( this )), onWorkDone ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASend\" }; } } int64_t io_send :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_recv` return * reinterpret_cast < io_recv *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv :: suspend ( io_task_t t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecv ( sd , bufs , 1 , nullptr , & flag , // zero_overlapped ( gsl :: make_not_null ( this )), onWorkDone ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecv\" }; } } int64_t io_recv :: resume () noexcept { return get_io_length ( this ); } } // namespace coro","title":"File io\\_windows.cpp"},{"location":"io__windows_8cpp_source/#file-io95windowscpp","text":"File List > modules > net > io_windows.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/net.h> using namespace std ; using namespace gsl ; namespace coro { void wait_net_tasks ( enumerable < io_task_t >& tasks , chrono :: nanoseconds ) noexcept ( false ) { // windows implementation rely on callback. // So there is noting to yield ... tasks = enumerable < io_task_t > {}; // Just comsume some items in this thread's APC queue SleepEx ( 0 , true ); } bool is_async_pending ( int ec ) noexcept { switch ( ec ) { case WSAEWOULDBLOCK : case EWOULDBLOCK : case EINPROGRESS : case ERROR_IO_PENDING : return true ; default : return false ; } } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .6 ) void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); // Mostly, `Internal` and `InternalHigh` holds exactly same value with the // parameters. So these assignments are redundant. // Here, we are just making sure of it. work -> Internal = errc ; // -> return of `work.error()` work -> InternalHigh = sz ; // -> return of `await_resume()` work -> task . resume (); } bool io_work_t :: ready () const noexcept { return false ; // always trigger `await_suspend` in Windows API } uint32_t get_io_error ( const OVERLAPPED * target ) noexcept { static_assert ( sizeof ( DWORD ) == sizeof ( uint32_t )); return gsl :: narrow_cast < uint32_t > ( target -> Internal ); } int64_t get_io_length ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < int64_t > ( target -> InternalHigh ); } // see also: `onWorkDone` uint32_t io_work_t :: error () const noexcept { return get_io_error ( this ); } // zero memory the `OVERLAPPED` part in the `io_work_t` auto zero_overlapped ( gsl :: not_null < io_control_block *> work ) noexcept -> gsl :: not_null < io_control_block *> { static_assert ( is_same_v < io_control_block , OVERLAPPED > ); * work = OVERLAPPED {}; return work ; } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .4 ) // for clang, this is not constexpr function. auto make_wsa_buf ( io_buffer_t v ) noexcept -> WSABUF { WSABUF buf {}; // expect NRVO buf . buf = reinterpret_cast < char *> ( v . data ()); buf . len = gsl :: narrow_cast < ULONG > ( v . size_bytes ()); return buf ; } // ensure we are x64 static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in6 *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send_to :: suspend ( io_task_t t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; LPOVERLAPPED pover = zero_overlapped ( gsl :: make_not_null ( this )); if ( :: WSASendTo ( sd , bufs , 1 , nullptr , flag , // addr , addrlen , // pover , onWorkDone ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASendTo\" }; } } int64_t io_send_to :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv_from :: suspend ( io_task_t t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecvFrom ( sd , bufs , 1 , nullptr , & flag , // addr , & addrlen , // zero_overlapped ( gsl :: make_not_null ( this )), onWorkDone ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecvFrom\" }; } } int64_t io_recv_from :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_send` return * reinterpret_cast < io_send *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send :: suspend ( io_task_t t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASend ( sd , bufs , 1 , nullptr , flag , // zero_overlapped ( gsl :: make_not_null ( this )), onWorkDone ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASend\" }; } } int64_t io_send :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_recv` return * reinterpret_cast < io_recv *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv :: suspend ( io_task_t t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecv ( sd , bufs , 1 , nullptr , & flag , // zero_overlapped ( gsl :: make_not_null ( this )), onWorkDone ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecv\" }; } } int64_t io_recv :: resume () noexcept { return get_io_length ( this ); } } // namespace coro","title":"File io_windows.cpp"},{"location":"kernel__queue_8cpp/","text":"File kernel_queue.cpp \u00b6 File List > event > kernel_queue.cpp Go to the source code of this file. #include \"kernel_queue.h\" #include <system_error> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/event/kernel_queue.cpp","title":"File kernel\\_queue.cpp"},{"location":"kernel__queue_8cpp/#file-kernel95queuecpp","text":"File List > event > kernel_queue.cpp Go to the source code of this file. #include \"kernel_queue.h\" #include <system_error>","title":"File kernel_queue.cpp"},{"location":"kernel__queue_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/event/kernel_queue.cpp","title":"Namespaces"},{"location":"kernel__queue_8cpp_source/","text":"File kernel_queue.cpp \u00b6 File List > event > kernel_queue.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include \"kernel_queue.h\" #include <system_error> using namespace std ; namespace coro { kernel_queue_t :: kernel_queue_t () noexcept ( false ) : kqfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( kevent64_s )}, events { make_unique < kevent64_s [] > ( capacity )} { kqfd = kqueue (); if ( kqfd < 0 ) throw system_error { errno , system_category (), \"kqueue\" }; } kernel_queue_t ::~ kernel_queue_t () noexcept { close ( kqfd ); } void kernel_queue_t :: change ( kevent64_s & req ) noexcept ( false ) { // attach the event config auto ec = kevent64 ( kqfd , & req , 1 , nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } auto kernel_queue_t :: wait ( const timespec & ts ) noexcept ( false ) -> enumerable < kevent64_s > { // wait for events ... auto count = kevent64 ( kqfd , nullptr , 0 , // events . get (), capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } } // namespace coro /* void print_kevent(const kevent64_s& ev) { printf(\" ev.ident \\t: %llu\\n\", ev.ident); if (ev.filter == EVFILT_READ) printf(\" ev.filter\\t: EVFILT_READ\\n\"); if (ev.filter == EVFILT_WRITE) printf(\" ev.filter\\t: EVFILT_WRITE\\n\"); if (ev.filter == EVFILT_EXCEPT) printf(\" ev.filter\\t: EVFILT_EXCEPT\\n\"); if (ev.filter == EVFILT_AIO) printf(\" ev.filter\\t: EVFILT_AIO\\n\"); if (ev.filter == EVFILT_VNODE) printf(\" ev.filter\\t: EVFILT_VNODE\\n\"); if (ev.filter == EVFILT_PROC) printf(\" ev.filter\\t: EVFILT_PROC\\n\"); if (ev.filter == EVFILT_SIGNAL) printf(\" ev.filter\\t: EVFILT_SIGNAL\\n\"); if (ev.filter == EVFILT_MACHPORT) printf(\" ev.filter\\t: EVFILT_MACHPORT\\n\"); if (ev.filter == EVFILT_TIMER) printf(\" ev.filter\\t: EVFILT_TIMER\\n\"); if (ev.flags & EV_ADD) printf(\" ev.flags\\t: EV_ADD\\n\"); if (ev.flags & EV_DELETE) printf(\" ev.flags\\t: EV_DELETE\\n\"); if (ev.flags & EV_ENABLE) printf(\" ev.flags\\t: EV_ENABLE\\n\"); if (ev.flags & EV_DISABLE) printf(\" ev.flags\\t: EV_DISABLE\\n\"); if (ev.flags & EV_ONESHOT) printf(\" ev.flags\\t: EV_ONESHOT\\n\"); if (ev.flags & EV_CLEAR) printf(\" ev.flags\\t: EV_CLEAR\\n\"); if (ev.flags & EV_RECEIPT) printf(\" ev.flags\\t: EV_RECEIPT\\n\"); if (ev.flags & EV_DISPATCH) printf(\" ev.flags\\t: EV_DISPATCH\\n\"); if (ev.flags & EV_UDATA_SPECIFIC) printf(\" ev.flags\\t: EV_UDATA_SPECIFIC\\n\"); if (ev.flags & EV_VANISHED) printf(\" ev.flags\\t: EV_VANISHED\\n\"); if (ev.flags & EV_ERROR) printf(\" ev.flags\\t: EV_ERROR\\n\"); if (ev.flags & EV_OOBAND) printf(\" ev.flags\\t: EV_OOBAND\\n\"); if (ev.flags & EV_EOF) printf(\" ev.flags\\t: EV_EOF\\n\"); printf(\" ev.data\\t: %lld\\n\", ev.data); printf(\" ev.udata\\t: %llx, %llu\\n\", ev.udata, ev.udata); } */","title":"File kernel\\_queue.cpp"},{"location":"kernel__queue_8cpp_source/#file-kernel95queuecpp","text":"File List > event > kernel_queue.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include \"kernel_queue.h\" #include <system_error> using namespace std ; namespace coro { kernel_queue_t :: kernel_queue_t () noexcept ( false ) : kqfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( kevent64_s )}, events { make_unique < kevent64_s [] > ( capacity )} { kqfd = kqueue (); if ( kqfd < 0 ) throw system_error { errno , system_category (), \"kqueue\" }; } kernel_queue_t ::~ kernel_queue_t () noexcept { close ( kqfd ); } void kernel_queue_t :: change ( kevent64_s & req ) noexcept ( false ) { // attach the event config auto ec = kevent64 ( kqfd , & req , 1 , nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } auto kernel_queue_t :: wait ( const timespec & ts ) noexcept ( false ) -> enumerable < kevent64_s > { // wait for events ... auto count = kevent64 ( kqfd , nullptr , 0 , // events . get (), capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } } // namespace coro /* void print_kevent(const kevent64_s& ev) { printf(\" ev.ident \\t: %llu\\n\", ev.ident); if (ev.filter == EVFILT_READ) printf(\" ev.filter\\t: EVFILT_READ\\n\"); if (ev.filter == EVFILT_WRITE) printf(\" ev.filter\\t: EVFILT_WRITE\\n\"); if (ev.filter == EVFILT_EXCEPT) printf(\" ev.filter\\t: EVFILT_EXCEPT\\n\"); if (ev.filter == EVFILT_AIO) printf(\" ev.filter\\t: EVFILT_AIO\\n\"); if (ev.filter == EVFILT_VNODE) printf(\" ev.filter\\t: EVFILT_VNODE\\n\"); if (ev.filter == EVFILT_PROC) printf(\" ev.filter\\t: EVFILT_PROC\\n\"); if (ev.filter == EVFILT_SIGNAL) printf(\" ev.filter\\t: EVFILT_SIGNAL\\n\"); if (ev.filter == EVFILT_MACHPORT) printf(\" ev.filter\\t: EVFILT_MACHPORT\\n\"); if (ev.filter == EVFILT_TIMER) printf(\" ev.filter\\t: EVFILT_TIMER\\n\"); if (ev.flags & EV_ADD) printf(\" ev.flags\\t: EV_ADD\\n\"); if (ev.flags & EV_DELETE) printf(\" ev.flags\\t: EV_DELETE\\n\"); if (ev.flags & EV_ENABLE) printf(\" ev.flags\\t: EV_ENABLE\\n\"); if (ev.flags & EV_DISABLE) printf(\" ev.flags\\t: EV_DISABLE\\n\"); if (ev.flags & EV_ONESHOT) printf(\" ev.flags\\t: EV_ONESHOT\\n\"); if (ev.flags & EV_CLEAR) printf(\" ev.flags\\t: EV_CLEAR\\n\"); if (ev.flags & EV_RECEIPT) printf(\" ev.flags\\t: EV_RECEIPT\\n\"); if (ev.flags & EV_DISPATCH) printf(\" ev.flags\\t: EV_DISPATCH\\n\"); if (ev.flags & EV_UDATA_SPECIFIC) printf(\" ev.flags\\t: EV_UDATA_SPECIFIC\\n\"); if (ev.flags & EV_VANISHED) printf(\" ev.flags\\t: EV_VANISHED\\n\"); if (ev.flags & EV_ERROR) printf(\" ev.flags\\t: EV_ERROR\\n\"); if (ev.flags & EV_OOBAND) printf(\" ev.flags\\t: EV_OOBAND\\n\"); if (ev.flags & EV_EOF) printf(\" ev.flags\\t: EV_EOF\\n\"); printf(\" ev.data\\t: %lld\\n\", ev.data); printf(\" ev.udata\\t: %llx, %llu\\n\", ev.udata, ev.udata); } */","title":"File kernel_queue.cpp"},{"location":"kernel__queue_8h/","text":"File kernel_queue.h \u00b6 File List > event > kernel_queue.h Go to the source code of this file. #include <coroutine/event.h> #include <memory> #include <fcntl.h> #include <sys/event.h> #include <unistd.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name struct kernel_queue_t Macros \u00b6 Type Name define DARWIN_KERNEL_QUEUE_API_WRAPPER_H Macro Definition Documentation \u00b6 define DARWIN_KERNEL_QUEUE_API_WRAPPER_H \u00b6 #define DARWIN_KERNEL_QUEUE_API_WRAPPER_H The documentation for this class was generated from the following file modules/event/kernel_queue.h","title":"File kernel\\_queue.h"},{"location":"kernel__queue_8h/#file-kernel95queueh","text":"File List > event > kernel_queue.h Go to the source code of this file. #include <coroutine/event.h> #include <memory> #include <fcntl.h> #include <sys/event.h> #include <unistd.h>","title":"File kernel_queue.h"},{"location":"kernel__queue_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"kernel__queue_8h/#classes","text":"Type Name struct kernel_queue_t","title":"Classes"},{"location":"kernel__queue_8h/#macros","text":"Type Name define DARWIN_KERNEL_QUEUE_API_WRAPPER_H","title":"Macros"},{"location":"kernel__queue_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"kernel__queue_8h/#define-darwin95kernel95queue95api95wrapper95h","text":"#define DARWIN_KERNEL_QUEUE_API_WRAPPER_H The documentation for this class was generated from the following file modules/event/kernel_queue.h","title":"define DARWIN_KERNEL_QUEUE_API_WRAPPER_H"},{"location":"kernel__queue_8h_source/","text":"File kernel_queue.h \u00b6 File List > event > kernel_queue.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once #ifndef DARWIN_KERNEL_QUEUE_API_WRAPPER_H #define DARWIN_KERNEL_QUEUE_API_WRAPPER_H #include <coroutine/event.h> #include <memory> #include <fcntl.h> #include <sys/event.h> #include <unistd.h> namespace coro { struct _INTERFACE_ kernel_queue_t final { int kqfd ; const size_t capacity ; std :: unique_ptr < kevent64_s [] > events ; public : kernel_queue_t () noexcept ( false ); ~ kernel_queue_t () noexcept ; void change ( kevent64_s & req ) noexcept ( false ); auto wait ( const timespec & ts ) noexcept ( false ) -> enumerable < kevent64_s > ; }; } // namespace coro #endif // DARWIN_KERNEL_QUEUE_API_WRAPPER_H","title":"File kernel\\_queue.h"},{"location":"kernel__queue_8h_source/#file-kernel95queueh","text":"File List > event > kernel_queue.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once #ifndef DARWIN_KERNEL_QUEUE_API_WRAPPER_H #define DARWIN_KERNEL_QUEUE_API_WRAPPER_H #include <coroutine/event.h> #include <memory> #include <fcntl.h> #include <sys/event.h> #include <unistd.h> namespace coro { struct _INTERFACE_ kernel_queue_t final { int kqfd ; const size_t capacity ; std :: unique_ptr < kevent64_s [] > events ; public : kernel_queue_t () noexcept ( false ); ~ kernel_queue_t () noexcept ; void change ( kevent64_s & req ) noexcept ( false ); auto wait ( const timespec & ts ) noexcept ( false ) -> enumerable < kevent64_s > ; }; } // namespace coro #endif // DARWIN_KERNEL_QUEUE_API_WRAPPER_H","title":"File kernel_queue.h"},{"location":"latch__pthread_8cpp/","text":"File latch_pthread.cpp \u00b6 File List > concrt > latch_pthread.cpp Go to the source code of this file. #include <cstdio> #include <ctime> #include <system_error> #include <concurrency_helper.h> Namespaces \u00b6 Type Name namespace chrono Public Functions \u00b6 Type Name void setup_mutex_attr (pthread_mutexattr_t & attr) noexcept Public Functions Documentation \u00b6 function setup_mutex_attr \u00b6 void setup_mutex_attr ( pthread_mutexattr_t & attr ) noexcept The documentation for this class was generated from the following file modules/concrt/latch_pthread.cpp","title":"File latch\\_pthread.cpp"},{"location":"latch__pthread_8cpp/#file-latch95pthreadcpp","text":"File List > concrt > latch_pthread.cpp Go to the source code of this file. #include <cstdio> #include <ctime> #include <system_error> #include <concurrency_helper.h>","title":"File latch_pthread.cpp"},{"location":"latch__pthread_8cpp/#namespaces","text":"Type Name namespace chrono","title":"Namespaces"},{"location":"latch__pthread_8cpp/#public-functions","text":"Type Name void setup_mutex_attr (pthread_mutexattr_t & attr) noexcept","title":"Public Functions"},{"location":"latch__pthread_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"latch__pthread_8cpp/#function-setup95mutex95attr","text":"void setup_mutex_attr ( pthread_mutexattr_t & attr ) noexcept The documentation for this class was generated from the following file modules/concrt/latch_pthread.cpp","title":"function setup_mutex_attr"},{"location":"latch__pthread_8cpp_source/","text":"File latch_pthread.cpp \u00b6 File List > concrt > latch_pthread.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <cstdio> #include <ctime> #include <system_error> #include <concurrency_helper.h> using namespace std ; using namespace std :: chrono ; void setup_mutex_attr ( pthread_mutexattr_t & attr ) noexcept ( false ) { if ( auto ec = pthread_mutexattr_settype ( & attr , PTHREAD_MUTEX_ERRORCHECK )) throw system_error { ec , system_category (), \"pthread_mutexattr_settype\" }; // see pthread.h in /ndk/sysroot/usr/include // general POSIX or NDK high version #if !defined(__ANDROID_API__) || \\ (defined(__ANDROID_API__) && __ANDROID_API__ >= 28) if ( auto ec = pthread_mutexattr_setprotocol ( & attr , PTHREAD_PRIO_NONE )) throw system_error { ec , system_category (), \"pthread_mutexattr_setprotocol\" }; #endif } latch :: latch ( uint32_t count ) noexcept ( false ) : ref { count }, cv {}, mtx {} { // increase count on ctor phase // instread of std::mutex, use customized attributes pthread_mutexattr_t attr {}; if ( auto ec = pthread_mutexattr_init ( & attr )) throw system_error { ec , system_category (), \"pthread_mutexattr_init\" }; setup_mutex_attr ( attr ); if ( auto ec = pthread_mutex_init ( addressof ( this -> mtx ), & attr )) throw system_error { ec , system_category (), \"pthread_mutex_init\" }; if ( auto ec = pthread_mutexattr_destroy ( & attr )) throw system_error { ec , system_category (), \"pthread_mutexattr_destroy\" }; if ( auto ec = pthread_cond_init ( addressof ( this -> cv ), nullptr )) throw system_error { ec , system_category (), \"pthread_cond_init\" }; } latch ::~ latch () noexcept { try { if ( auto ec = pthread_cond_destroy ( addressof ( this -> cv ))) throw system_error { ec , system_category (), \"pthread_cond_destroy\" }; if ( auto ec = pthread_mutex_destroy ( addressof ( this -> mtx ))) throw system_error { ec , system_category (), \"pthread_mutex_destroy\" }; } catch ( const system_error & ex ) { fputs ( ex . what (), stderr ); } } void latch :: count_down_and_wait () noexcept ( false ) { this -> count_down (); this -> wait (); } void latch :: count_down ( uint32_t n ) noexcept ( false ) { // underflow if ( n > this -> ref . load ( memory_order_acquire )) throw underflow_error { \"latch::count_down\" }; this -> ref . fetch_sub ( n , memory_order_release ); if ( this -> ref . load ( memory_order_acquire ) != 0 ) return ; // notify error if ( auto ec = pthread_cond_signal ( & this -> cv )) throw system_error { ec , system_category (), \"pthread_cond_signal\" }; } bool latch :: is_ready () const noexcept { return this -> ref . load ( memory_order_acquire ) == 0 ; } int latch :: timed_wait ( nanoseconds timeout ) noexcept { // `pthread_cond_timedwait` uses absolute time(== time point). // so we have to calculate the timepoint first auto end_time = 0 ns ; auto until = timespec {}; const auto invoke_time = system_clock :: now (). time_since_epoch (); int reason = 0 ; end_time = invoke_time + timeout ; until . tv_sec = duration_cast < seconds > ( end_time ). count (); until . tv_nsec = duration_cast < nanoseconds > ( end_time ). count () % 1 ' 000 ' 000 ; CheckCurrentCount : if ( this -> is_ready ()) return 0 ; // This check is for possible spurious wakeup. auto current_time = system_clock :: now (). time_since_epoch (); if ( end_time < current_time ) // reached timeout. return error return reason ; { if ( auto ec = pthread_mutex_lock ( addressof ( this -> mtx ))) return ec ; reason = pthread_cond_timedwait ( addressof ( this -> cv ), addressof ( this -> mtx ), addressof ( until )); if ( auto ec = pthread_mutex_unlock ( addressof ( this -> mtx ))) return ec ; } if ( reason == ETIMEDOUT ) // this might be a spurious wakeup goto CheckCurrentCount ; // reason containes error code at this moment return reason ; } void latch :: wait () noexcept ( false ) { auto timeout = 1536 ms ; while ( true ) { // since latch doesn't provide interface for waiting with timeout, // this code will wait more if it reached timeout auto ec = this -> timed_wait ( timeout ); if ( ec == 0 ) return ; if ( ec != ETIMEDOUT ) throw system_error { static_cast < int > ( ec ), system_category ()}; // ... update timeout if it need to be changed ... } }","title":"File latch\\_pthread.cpp"},{"location":"latch__pthread_8cpp_source/#file-latch95pthreadcpp","text":"File List > concrt > latch_pthread.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <cstdio> #include <ctime> #include <system_error> #include <concurrency_helper.h> using namespace std ; using namespace std :: chrono ; void setup_mutex_attr ( pthread_mutexattr_t & attr ) noexcept ( false ) { if ( auto ec = pthread_mutexattr_settype ( & attr , PTHREAD_MUTEX_ERRORCHECK )) throw system_error { ec , system_category (), \"pthread_mutexattr_settype\" }; // see pthread.h in /ndk/sysroot/usr/include // general POSIX or NDK high version #if !defined(__ANDROID_API__) || \\ (defined(__ANDROID_API__) && __ANDROID_API__ >= 28) if ( auto ec = pthread_mutexattr_setprotocol ( & attr , PTHREAD_PRIO_NONE )) throw system_error { ec , system_category (), \"pthread_mutexattr_setprotocol\" }; #endif } latch :: latch ( uint32_t count ) noexcept ( false ) : ref { count }, cv {}, mtx {} { // increase count on ctor phase // instread of std::mutex, use customized attributes pthread_mutexattr_t attr {}; if ( auto ec = pthread_mutexattr_init ( & attr )) throw system_error { ec , system_category (), \"pthread_mutexattr_init\" }; setup_mutex_attr ( attr ); if ( auto ec = pthread_mutex_init ( addressof ( this -> mtx ), & attr )) throw system_error { ec , system_category (), \"pthread_mutex_init\" }; if ( auto ec = pthread_mutexattr_destroy ( & attr )) throw system_error { ec , system_category (), \"pthread_mutexattr_destroy\" }; if ( auto ec = pthread_cond_init ( addressof ( this -> cv ), nullptr )) throw system_error { ec , system_category (), \"pthread_cond_init\" }; } latch ::~ latch () noexcept { try { if ( auto ec = pthread_cond_destroy ( addressof ( this -> cv ))) throw system_error { ec , system_category (), \"pthread_cond_destroy\" }; if ( auto ec = pthread_mutex_destroy ( addressof ( this -> mtx ))) throw system_error { ec , system_category (), \"pthread_mutex_destroy\" }; } catch ( const system_error & ex ) { fputs ( ex . what (), stderr ); } } void latch :: count_down_and_wait () noexcept ( false ) { this -> count_down (); this -> wait (); } void latch :: count_down ( uint32_t n ) noexcept ( false ) { // underflow if ( n > this -> ref . load ( memory_order_acquire )) throw underflow_error { \"latch::count_down\" }; this -> ref . fetch_sub ( n , memory_order_release ); if ( this -> ref . load ( memory_order_acquire ) != 0 ) return ; // notify error if ( auto ec = pthread_cond_signal ( & this -> cv )) throw system_error { ec , system_category (), \"pthread_cond_signal\" }; } bool latch :: is_ready () const noexcept { return this -> ref . load ( memory_order_acquire ) == 0 ; } int latch :: timed_wait ( nanoseconds timeout ) noexcept { // `pthread_cond_timedwait` uses absolute time(== time point). // so we have to calculate the timepoint first auto end_time = 0 ns ; auto until = timespec {}; const auto invoke_time = system_clock :: now (). time_since_epoch (); int reason = 0 ; end_time = invoke_time + timeout ; until . tv_sec = duration_cast < seconds > ( end_time ). count (); until . tv_nsec = duration_cast < nanoseconds > ( end_time ). count () % 1 ' 000 ' 000 ; CheckCurrentCount : if ( this -> is_ready ()) return 0 ; // This check is for possible spurious wakeup. auto current_time = system_clock :: now (). time_since_epoch (); if ( end_time < current_time ) // reached timeout. return error return reason ; { if ( auto ec = pthread_mutex_lock ( addressof ( this -> mtx ))) return ec ; reason = pthread_cond_timedwait ( addressof ( this -> cv ), addressof ( this -> mtx ), addressof ( until )); if ( auto ec = pthread_mutex_unlock ( addressof ( this -> mtx ))) return ec ; } if ( reason == ETIMEDOUT ) // this might be a spurious wakeup goto CheckCurrentCount ; // reason containes error code at this moment return reason ; } void latch :: wait () noexcept ( false ) { auto timeout = 1536 ms ; while ( true ) { // since latch doesn't provide interface for waiting with timeout, // this code will wait more if it reached timeout auto ec = this -> timed_wait ( timeout ); if ( ec == 0 ) return ; if ( ec != ETIMEDOUT ) throw system_error { static_cast < int > ( ec ), system_category ()}; // ... update timeout if it need to be changed ... } }","title":"File latch_pthread.cpp"},{"location":"latch__win32_8cpp/","text":"File latch_win32.cpp \u00b6 File List > concrt > latch_win32.cpp Go to the source code of this file. #include <type_traits> #include <concurrency_helper.h> #include <system_error> #include <gsl/gsl> The documentation for this class was generated from the following file modules/concrt/latch_win32.cpp","title":"File latch\\_win32.cpp"},{"location":"latch__win32_8cpp/#file-latch95win32cpp","text":"File List > concrt > latch_win32.cpp Go to the source code of this file. #include <type_traits> #include <concurrency_helper.h> #include <system_error> #include <gsl/gsl> The documentation for this class was generated from the following file modules/concrt/latch_win32.cpp","title":"File latch_win32.cpp"},{"location":"latch__win32_8cpp_source/","text":"File latch_win32.cpp \u00b6 File List > concrt > latch_win32.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 #include <type_traits> #include <concurrency_helper.h> #include <system_error> #include <gsl/gsl> using namespace std ; static_assert ( is_move_assignable_v < latch > == false ); static_assert ( is_move_constructible_v < latch > == false ); static_assert ( is_copy_assignable_v < latch > == false ); static_assert ( is_copy_constructible_v < latch > == false ); latch :: latch ( uint32_t delta ) noexcept ( false ) : ev { CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , EVENT_ALL_ACCESS )}, ref { delta } { if ( ev == INVALID_HANDLE_VALUE ) throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"CreateEventEx\" }; ResetEvent ( ev ); } latch ::~ latch () noexcept { if ( ev != INVALID_HANDLE_VALUE ) { CloseHandle ( ev ); ev = INVALID_HANDLE_VALUE ; } } void latch :: count_down_and_wait () noexcept ( false ) { this -> count_down (); this -> wait (); } void latch :: count_down ( uint32_t n ) noexcept ( false ) { if ( ref . load ( memory_order_acquire ) < n ) throw underflow_error { \"latch's count can't be negative\" }; ref . fetch_sub ( n , memory_order_release ); if ( ref . load ( memory_order_acquire ) == 0 ) SetEvent ( ev ); } GSL_SUPPRESS ( f .23 ) GSL_SUPPRESS ( con .4 ) bool latch :: is_ready () const noexcept { if ( ref . load ( memory_order_acquire ) > 0 ) return false ; if ( ev == INVALID_HANDLE_VALUE ) return true ; // if it is not closed, test it auto ec = WaitForSingleObjectEx ( ev , 0 , TRUE ); if ( ec == WAIT_OBJECT_0 ) { // WAIT_OBJECT_0 : return by signal this ->~ latch (); return true ; } return false ; } GSL_SUPPRESS ( es .76 ) void latch :: wait () noexcept ( false ) { static_assert ( WAIT_OBJECT_0 == 0 ); StartWait : if ( this -> is_ready ()) return ; // standard interface doesn't define timed wait. // This makes APC available. expecially for Overlapped I/O if ( const auto ec = WaitForSingleObjectEx ( ev , 1536 , TRUE )) { // WAIT_IO_COMPLETION : return because of APC if ( ec == WAIT_IO_COMPLETION ) goto StartWait ; // WAIT_TIMEOUT : this is expected. try again if ( ec == WAIT_TIMEOUT ) goto StartWait ; // WAIT_FAILED : use GetLastError in the case // WAIT_ABANDONED throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"WaitForSingleObjectEx\" }; } // WAIT_OBJECT_0 : return by signal this ->~ latch (); return ; }","title":"File latch\\_win32.cpp"},{"location":"latch__win32_8cpp_source/#file-latch95win32cpp","text":"File List > concrt > latch_win32.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 #include <type_traits> #include <concurrency_helper.h> #include <system_error> #include <gsl/gsl> using namespace std ; static_assert ( is_move_assignable_v < latch > == false ); static_assert ( is_move_constructible_v < latch > == false ); static_assert ( is_copy_assignable_v < latch > == false ); static_assert ( is_copy_constructible_v < latch > == false ); latch :: latch ( uint32_t delta ) noexcept ( false ) : ev { CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , EVENT_ALL_ACCESS )}, ref { delta } { if ( ev == INVALID_HANDLE_VALUE ) throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"CreateEventEx\" }; ResetEvent ( ev ); } latch ::~ latch () noexcept { if ( ev != INVALID_HANDLE_VALUE ) { CloseHandle ( ev ); ev = INVALID_HANDLE_VALUE ; } } void latch :: count_down_and_wait () noexcept ( false ) { this -> count_down (); this -> wait (); } void latch :: count_down ( uint32_t n ) noexcept ( false ) { if ( ref . load ( memory_order_acquire ) < n ) throw underflow_error { \"latch's count can't be negative\" }; ref . fetch_sub ( n , memory_order_release ); if ( ref . load ( memory_order_acquire ) == 0 ) SetEvent ( ev ); } GSL_SUPPRESS ( f .23 ) GSL_SUPPRESS ( con .4 ) bool latch :: is_ready () const noexcept { if ( ref . load ( memory_order_acquire ) > 0 ) return false ; if ( ev == INVALID_HANDLE_VALUE ) return true ; // if it is not closed, test it auto ec = WaitForSingleObjectEx ( ev , 0 , TRUE ); if ( ec == WAIT_OBJECT_0 ) { // WAIT_OBJECT_0 : return by signal this ->~ latch (); return true ; } return false ; } GSL_SUPPRESS ( es .76 ) void latch :: wait () noexcept ( false ) { static_assert ( WAIT_OBJECT_0 == 0 ); StartWait : if ( this -> is_ready ()) return ; // standard interface doesn't define timed wait. // This makes APC available. expecially for Overlapped I/O if ( const auto ec = WaitForSingleObjectEx ( ev , 1536 , TRUE )) { // WAIT_IO_COMPLETION : return because of APC if ( ec == WAIT_IO_COMPLETION ) goto StartWait ; // WAIT_TIMEOUT : this is expected. try again if ( ec == WAIT_TIMEOUT ) goto StartWait ; // WAIT_FAILED : use GetLastError in the case // WAIT_ABANDONED throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"WaitForSingleObjectEx\" }; } // WAIT_OBJECT_0 : return by signal this ->~ latch (); return ; }","title":"File latch_win32.cpp"},{"location":"macros/","text":"Macros \u00b6 a \u00b6 ARCHITECTURE_ID ( CMakeCXXCompilerId.cpp ) c \u00b6 COMPILER_ID ( CMakeCXXCompilerId.cpp ) CXX_STD ( CMakeCXXCompilerId.cpp ) CATCH_CONFIG_MAIN ( test.cpp ) COROUTINE_AWAITABLE_EVENT_H ( event.h ) COROUTINE_PORTABLE_FRAME_H ( frame.h ) COROUTINE_NET_IO_H ( net.h ) COROUTINE_PROMISE_AND_RETURN_TYPES_H ( return.h ) COROUTINE_THREAD_UTILITY_H ( thread.h ) CONCURRENCY_HELPER_H ( concurrency_helper.h ) d \u00b6 DEC ( CMakeCXXCompilerId.cpp ) DARWIN_KERNEL_QUEUE_API_WRAPPER_H ( kernel_queue.h ) e \u00b6 EPILOGUE ( libmain.cpp , libmain.cpp ) h \u00b6 HEX ( CMakeCXXCompilerId.cpp ) l \u00b6 LUNCLIFF_COROUTINE_CHANNEL_HPP ( channel.hpp ) LIB_EPILOGUE ( section_pthread.cpp ) LIB_PROLOGUE ( section_pthread.cpp ) LINUX_EVENT_POLL_API_WRAPPER_H ( event_poll.h ) p \u00b6 PLATFORM_ID ( CMakeCXXCompilerId.cpp ) PROLOGUE ( libmain.cpp , libmain.cpp ) s \u00b6 STRINGIFY ( CMakeCXXCompilerId.cpp ) STRINGIFY_HELPER ( CMakeCXXCompilerId.cpp )","title":"Macros"},{"location":"macros/#macros","text":"","title":"Macros"},{"location":"macros/#a","text":"ARCHITECTURE_ID ( CMakeCXXCompilerId.cpp )","title":"a"},{"location":"macros/#c","text":"COMPILER_ID ( CMakeCXXCompilerId.cpp ) CXX_STD ( CMakeCXXCompilerId.cpp ) CATCH_CONFIG_MAIN ( test.cpp ) COROUTINE_AWAITABLE_EVENT_H ( event.h ) COROUTINE_PORTABLE_FRAME_H ( frame.h ) COROUTINE_NET_IO_H ( net.h ) COROUTINE_PROMISE_AND_RETURN_TYPES_H ( return.h ) COROUTINE_THREAD_UTILITY_H ( thread.h ) CONCURRENCY_HELPER_H ( concurrency_helper.h )","title":"c"},{"location":"macros/#d","text":"DEC ( CMakeCXXCompilerId.cpp ) DARWIN_KERNEL_QUEUE_API_WRAPPER_H ( kernel_queue.h )","title":"d"},{"location":"macros/#e","text":"EPILOGUE ( libmain.cpp , libmain.cpp )","title":"e"},{"location":"macros/#h","text":"HEX ( CMakeCXXCompilerId.cpp )","title":"h"},{"location":"macros/#l","text":"LUNCLIFF_COROUTINE_CHANNEL_HPP ( channel.hpp ) LIB_EPILOGUE ( section_pthread.cpp ) LIB_PROLOGUE ( section_pthread.cpp ) LINUX_EVENT_POLL_API_WRAPPER_H ( event_poll.h )","title":"l"},{"location":"macros/#p","text":"PLATFORM_ID ( CMakeCXXCompilerId.cpp ) PROLOGUE ( libmain.cpp , libmain.cpp )","title":"p"},{"location":"macros/#s","text":"STRINGIFY ( CMakeCXXCompilerId.cpp ) STRINGIFY_HELPER ( CMakeCXXCompilerId.cpp )","title":"s"},{"location":"modules/","text":"Modules \u00b6 Here is a list of all modules:","title":"Modules"},{"location":"modules/#modules","text":"Here is a list of all modules:","title":"Modules"},{"location":"multi__span__tests_8cpp/","text":"File multi_span_tests.cpp \u00b6 File List > external > guideline > tests > multi_span_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_byte> #include <gsl/gsl_util> #include <gsl/multi_span> #include <algorithm> #include <array> #include <iostream> #include <iterator> #include <numeric> #include <stddef.h> #include <string> #include <vector> Namespaces \u00b6 Type Name namespace gsl Public Attributes \u00b6 Type Name dynamic_range av = { auto length = av.size() / 2 auto check_sum = = 0 dynamic_range auto section = = av.section({0, 1}, {length, 1}) auto sum = = 0 Public Functions \u00b6 Type Name CHECK (section. size==length) CHECK (section. bounds==length) CHECK (section. bounds==1) CHECK (sum==check_sum) GSL_SUPPRESS (con. 4) GSL_SUPPRESS (f. 4) GSL_SUPPRESS (bounds. 4) TEST_CASE (\"operator_function_call\") void fixed_func (multi_span< int, 3, 3, 5 > exp, int expected_value) void fn (const Bounds &) for () for (auto num :section) for (auto iter=section.rbegin();iter !=section.rend();++iter) void overloaded_func (multi_span< const int, dynamic_range, 3, 5 > exp, int expected_value) void overloaded_func (multi_span< const char, dynamic_range, 3, 5 > exp, char expected_value) Public Attributes Documentation \u00b6 variable av \u00b6 dynamic_range av ; variable check_sum \u00b6 auto check_sum ; variable dynamic_range \u00b6 dynamic_range ; variable section \u00b6 section :: section ; variable sum \u00b6 auto sum ; Public Functions Documentation \u00b6 function CHECK \u00b6 CHECK ( section . size == length ) function CHECK \u00b6 CHECK ( section . bounds == length ) function CHECK \u00b6 CHECK ( section . bounds == 1 ) function CHECK \u00b6 CHECK ( sum == check_sum ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( con . 4 ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( f . 4 ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( bounds . 4 ) function TEST_CASE \u00b6 TEST_CASE ( \"operator_function_call\" ) function fixed_func \u00b6 void fixed_func ( multi_span < int , 3 , 3 , 5 > exp , int expected_value ) function fn \u00b6 template < class Bounds class Bounds > void fn ( const Bounds & ) function for \u00b6 for () function for \u00b6 for ( auto num : section ) function for \u00b6 for ( auto iter = section . rbegin (); iter != section . rend (); ++ iter ) function overloaded_func \u00b6 void overloaded_func ( multi_span < const int , dynamic_range , 3 , 5 > exp , int expected_value ) function overloaded_func \u00b6 void overloaded_func ( multi_span < const char , dynamic_range , 3 , 5 > exp , char expected_value ) The documentation for this class was generated from the following file external/guideline/tests/multi_span_tests.cpp","title":"File multi\\_span\\_tests.cpp"},{"location":"multi__span__tests_8cpp/#file-multi95span95testscpp","text":"File List > external > guideline > tests > multi_span_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_byte> #include <gsl/gsl_util> #include <gsl/multi_span> #include <algorithm> #include <array> #include <iostream> #include <iterator> #include <numeric> #include <stddef.h> #include <string> #include <vector>","title":"File multi_span_tests.cpp"},{"location":"multi__span__tests_8cpp/#namespaces","text":"Type Name namespace gsl","title":"Namespaces"},{"location":"multi__span__tests_8cpp/#public-attributes","text":"Type Name dynamic_range av = { auto length = av.size() / 2 auto check_sum = = 0 dynamic_range auto section = = av.section({0, 1}, {length, 1}) auto sum = = 0","title":"Public Attributes"},{"location":"multi__span__tests_8cpp/#public-functions","text":"Type Name CHECK (section. size==length) CHECK (section. bounds==length) CHECK (section. bounds==1) CHECK (sum==check_sum) GSL_SUPPRESS (con. 4) GSL_SUPPRESS (f. 4) GSL_SUPPRESS (bounds. 4) TEST_CASE (\"operator_function_call\") void fixed_func (multi_span< int, 3, 3, 5 > exp, int expected_value) void fn (const Bounds &) for () for (auto num :section) for (auto iter=section.rbegin();iter !=section.rend();++iter) void overloaded_func (multi_span< const int, dynamic_range, 3, 5 > exp, int expected_value) void overloaded_func (multi_span< const char, dynamic_range, 3, 5 > exp, char expected_value)","title":"Public Functions"},{"location":"multi__span__tests_8cpp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"multi__span__tests_8cpp/#variable-av","text":"dynamic_range av ;","title":"variable av"},{"location":"multi__span__tests_8cpp/#variable-check95sum","text":"auto check_sum ;","title":"variable check_sum"},{"location":"multi__span__tests_8cpp/#variable-dynamic95range","text":"dynamic_range ;","title":"variable dynamic_range"},{"location":"multi__span__tests_8cpp/#variable-section","text":"section :: section ;","title":"variable section"},{"location":"multi__span__tests_8cpp/#variable-sum","text":"auto sum ;","title":"variable sum"},{"location":"multi__span__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"multi__span__tests_8cpp/#function-check","text":"CHECK ( section . size == length )","title":"function CHECK"},{"location":"multi__span__tests_8cpp/#function-check_1","text":"CHECK ( section . bounds == length )","title":"function CHECK"},{"location":"multi__span__tests_8cpp/#function-check_2","text":"CHECK ( section . bounds == 1 )","title":"function CHECK"},{"location":"multi__span__tests_8cpp/#function-check_3","text":"CHECK ( sum == check_sum )","title":"function CHECK"},{"location":"multi__span__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( con . 4 )","title":"function GSL_SUPPRESS"},{"location":"multi__span__tests_8cpp/#function-gsl95suppress_1","text":"GSL_SUPPRESS ( f . 4 )","title":"function GSL_SUPPRESS"},{"location":"multi__span__tests_8cpp/#function-gsl95suppress_2","text":"GSL_SUPPRESS ( bounds . 4 )","title":"function GSL_SUPPRESS"},{"location":"multi__span__tests_8cpp/#function-test95case","text":"TEST_CASE ( \"operator_function_call\" )","title":"function TEST_CASE"},{"location":"multi__span__tests_8cpp/#function-fixed95func","text":"void fixed_func ( multi_span < int , 3 , 3 , 5 > exp , int expected_value )","title":"function fixed_func"},{"location":"multi__span__tests_8cpp/#function-fn","text":"template < class Bounds class Bounds > void fn ( const Bounds & )","title":"function fn"},{"location":"multi__span__tests_8cpp/#function-for","text":"for ()","title":"function for"},{"location":"multi__span__tests_8cpp/#function-for_1","text":"for ( auto num : section )","title":"function for"},{"location":"multi__span__tests_8cpp/#function-for_2","text":"for ( auto iter = section . rbegin (); iter != section . rend (); ++ iter )","title":"function for"},{"location":"multi__span__tests_8cpp/#function-overloaded95func","text":"void overloaded_func ( multi_span < const int , dynamic_range , 3 , 5 > exp , int expected_value )","title":"function overloaded_func"},{"location":"multi__span__tests_8cpp/#function-overloaded95func_1","text":"void overloaded_func ( multi_span < const char , dynamic_range , 3 , 5 > exp , char expected_value ) The documentation for this class was generated from the following file external/guideline/tests/multi_span_tests.cpp","title":"function overloaded_func"},{"location":"multi__span__tests_8cpp_source/","text":"File multi_span_tests.cpp \u00b6 File List > external > guideline > tests > multi_span_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #pragma warning(disable : 4996) // multi_span is in the process of being deprecated. // Suppressing warnings until it is completely removed #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\" #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, CHECK... #include <gsl/gsl_byte> // for byte #include <gsl/gsl_util> // for narrow_cast #include <gsl/multi_span> // for multi_span, contiguous_span_iterator, dim #include <algorithm> // for fill, for_each #include <array> // for array #include <iostream> // for ptrdiff_t, size_t #include <iterator> // for reverse_iterator, begin, end, operator!= #include <numeric> // for iota #include <stddef.h> // for ptrdiff_t #include <string> // for string #include <vector> // for vector namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; namespace { struct BaseClass { }; struct DerivedClass : BaseClass { }; } // namespace GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"default_constructor\" ) { { multi_span < int > s ; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs ; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { multi_span < int , 0 > s ; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int , 0 > cs ; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 1 > s ; CHECK (( s . length () == 1 && s . data () == nullptr )); // explains why it can't compile #endif } { multi_span < int > s {}; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs {}; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_nullptr_constructor\" ) { { multi_span < int > s = nullptr ; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs = nullptr ; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { multi_span < int , 0 > s = nullptr ; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int , 0 > cs = nullptr ; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 1 > s = nullptr ; CHECK (( s . length () == 1 && s . data () == nullptr )); // explains why it can't compile #endif } { multi_span < int > s { nullptr }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs { nullptr }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { multi_span < int *> s { nullptr }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int *> cs { nullptr }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_nullptr_length_constructor\" ) { { multi_span < int > s { nullptr , 0 }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs { nullptr , 0 }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { multi_span < int , 0 > s { nullptr , 0 }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int , 0 > cs { nullptr , 0 }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { auto workaround_macro = []() { const multi_span < int > s { nullptr , 1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); auto const_workaround_macro = []() { const multi_span < const int > cs { nullptr , 1 }; }; CHECK_THROWS_AS ( const_workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const multi_span < int , 0 > s { nullptr , 1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); auto const_workaround_macro = []() { const multi_span < const int , 0 > s { nullptr , 1 }; }; CHECK_THROWS_AS ( const_workaround_macro (), fail_fast ); } { multi_span < int *> s { nullptr , 0 }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int *> cs { nullptr , 0 }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 1 > s { nullptr , 0 }; CHECK (( s . length () == 1 && s . data () == nullptr )); // explains why it can't compile #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_element_constructor\" ) { int i = 5 ; { multi_span < int > s = i ; CHECK (( s . length () == 1 && s . data () == & i )); CHECK ( s [ 0 ] == 5 ); multi_span < const int > cs = i ; CHECK (( cs . length () == 1 && cs . data () == & i )); CHECK ( cs [ 0 ] == 5 ); } { #ifdef CONFIRM_COMPILATION_ERRORS const j = 1 ; multi_span < int , 0 > s = j ; #endif } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 0 > s = i ; CHECK (( s . length () == 0 && s . data () == & i )); #endif } { multi_span < int , 1 > s = i ; CHECK (( s . length () == 1 && s . data () == & i )); CHECK ( s [ 0 ] == 5 ); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 2 > s = i ; CHECK (( s . length () == 2 && s . data () == & i )); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_a_temp = []() -> int { return 4 ; }; auto use_a_span = []( multi_span < int > s ) { ( void ) s ; }; use_a_span ( get_a_temp ()); #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_pointer_length_constructor\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { multi_span < int > s { & arr [ 0 ], 2 }; CHECK (( s . length () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { multi_span < int , 2 > s { & arr [ 0 ], 2 }; CHECK (( s . length () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { int * p = nullptr ; multi_span < int > s { p , 0 }; CHECK (( s . length () == 0 && s . data () == nullptr )); } { int * p = nullptr ; auto workaround_macro = [ = ]() { const multi_span < int > s { p , 2 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_pointer_pointer_constructor\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { multi_span < int > s { & arr [ 0 ], & arr [ 2 ]}; CHECK (( s . length () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { multi_span < int , 2 > s { & arr [ 0 ], & arr [ 2 ]}; CHECK (( s . length () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { multi_span < int > s { & arr [ 0 ], & arr [ 0 ]}; CHECK (( s . length () == 0 && s . data () == & arr [ 0 ])); } { multi_span < int , 0 > s { & arr [ 0 ], & arr [ 0 ]}; CHECK (( s . length () == 0 && s . data () == & arr [ 0 ])); } { auto workaround_macro = [ & ]() { const multi_span < int > s { & arr [ 1 ], & arr [ 0 ]}; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; auto workaround_macro = [ & ]() { const multi_span < int > s { & arr [ 0 ], p }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; auto workaround_macro = [ & ]() { const multi_span < int > s { p , p }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; auto workaround_macro = [ & ]() { const multi_span < int > s { & arr [ 0 ], p }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"from_array_constructor\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { multi_span < int > s { arr }; CHECK (( s . length () == 5 && s . data () == & arr [ 0 ])); } { multi_span < int , 5 > s { arr }; CHECK (( s . length () == 5 && s . data () == & arr [ 0 ])); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 6 > s { arr }; #endif } { multi_span < int , 0 > s { arr }; CHECK (( s . length () == 0 && s . data () == & arr [ 0 ])); } int arr2d [ 2 ][ 3 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; { multi_span < int > s { arr2d }; CHECK (( s . length () == 6 && s . data () == & arr2d [ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } { multi_span < int , 0 > s { arr2d }; CHECK (( s . length () == 0 && s . data () == & arr2d [ 0 ][ 0 ])); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 5 > s { arr2d }; #endif } { multi_span < int , 6 > s { arr2d }; CHECK (( s . length () == 6 && s . data () == & arr2d [ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 7 > s { arr2d }; #endif } { multi_span < int [ 3 ] > s { arr2d [ 0 ]}; CHECK (( s . length () == 1 && s . data () == & arr2d [ 0 ])); } { multi_span < int , 2 , 3 > s { arr2d }; CHECK (( s . length () == 6 && s . data () == & arr2d [ 0 ][ 0 ])); auto workaround_macro = [ & ]() { return s [{ 1 , 2 }] == 6 ; }; CHECK ( workaround_macro ()); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 3 , 3 > s { arr2d }; #endif } int arr3d [ 2 ][ 3 ][ 2 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 }; { multi_span < int > s { arr3d }; CHECK (( s . length () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 11 ] == 12 )); } { multi_span < int , 0 > s { arr3d }; CHECK (( s . length () == 0 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 11 > s { arr3d }; #endif } { multi_span < int , 12 > s { arr3d }; CHECK (( s . length () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 13 > s { arr3d }; #endif } { multi_span < int [ 3 ][ 2 ] > s { arr3d [ 0 ]}; CHECK (( s . length () == 1 && s . data () == & arr3d [ 0 ])); } { multi_span < int , 3 , 2 , 2 > s { arr3d }; CHECK (( s . length () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); auto workaround_macro = [ & ]() { return s [{ 2 , 1 , 0 }] == 11 ; }; CHECK ( workaround_macro ()); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 3 , 3 , 3 > s { arr3d }; #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"from_dynamic_array_constructor\" ) { double ( * arr )[ 3 ][ 4 ] = new double [ 100 ][ 3 ][ 4 ]; { multi_span < double , dynamic_range , 3 , 4 > s ( arr , 10 ); CHECK (( s . length () == 120 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); CHECK_THROWS_AS ( s [ 10 ][ 3 ][ 4 ], fail_fast ); } { multi_span < double , dynamic_range , 4 , 3 > s ( arr , 10 ); CHECK (( s . length () == 120 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } { multi_span < double > s ( arr , 10 ); CHECK (( s . length () == 120 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } { multi_span < double , dynamic_range , 3 , 4 > s ( arr , 0 ); CHECK (( s . length () == 0 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: Attribute TEST_CASE ( \"from_std_array_constructor\" ) { std :: array < int , 4 > arr = { 1 , 2 , 3 , 4 }; { multi_span < int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); multi_span < const int > cs { arr }; CHECK (( cs . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && cs . data () == arr . data ())); } { multi_span < int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); multi_span < const int , 4 > cs { arr }; CHECK (( cs . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && cs . data () == arr . data ())); } { multi_span < int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); multi_span < const int , 2 > cs { arr }; CHECK (( cs . size () == 2 && cs . data () == arr . data ())); } { multi_span < int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); multi_span < const int , 0 > cs { arr }; CHECK (( cs . size () == 0 && cs . data () == arr . data ())); } // TODO This is currently an unsupported scenario. We will come back to it as we revise // the multidimensional interface and what transformations between dimensionality look like //{ // multi_span<int, 2, 2> s{arr}; // CHECK(s.size() == narrow_cast<ptrdiff_t>(arr.size()) && s.data() == arr.data()); //} { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 5 > s { arr }; #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_an_array = []() { return std :: array < int , 4 > { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( multi_span < int > s ) { ( void ) s ; }; // try to take a temporary std::array take_a_span ( get_an_array ()); #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_const_std_array_constructor\" ) { const std :: array < int , 4 > arr = { 1 , 2 , 3 , 4 }; { multi_span < const int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } { multi_span < const int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } { multi_span < const int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); } { multi_span < const int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); } // TODO This is currently an unsupported scenario. We will come back to it as we revise // the multidimensional interface and what transformations between dimensionality look like //{ // multi_span<int, 2, 2> s{arr}; // CHECK(s.size() == narrow_cast<ptrdiff_t>(arr.size()) && s.data() == arr.data()); //} { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < const int , 5 > s { arr }; #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_an_array = []() -> const std :: array < int , 4 > { return { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( multi_span < const int > s ) { ( void ) s ; }; // try to take a temporary std::array take_a_span ( get_an_array ()); #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_container_constructor\" ) { std :: vector < int > v = { 1 , 2 , 3 }; const std :: vector < int > cv = v ; { multi_span < int > s { v }; CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && s . data () == v . data ())); multi_span < const int > cs { v }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && cs . data () == v . data ())); } std :: string str = \"hello\" ; const std :: string cstr = \"hello\" ; { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < char > s { str }; CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( str . size ()) && s . data () == str . data ())); #endif multi_span < const char > cs { str }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( str . size ()) && cs . data () == str . data ())); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < char > s { cstr }; #endif multi_span < const char > cs { cstr }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( cstr . size ()) && cs . data () == cstr . data ())); } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_vector = []() -> std :: vector < int > { return {}; }; auto use_span = []( multi_span < int > s ) { ( void ) s ; }; use_span ( get_temp_vector ()); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_string = []() -> std :: string { return {}; }; auto use_span = []( multi_span < char > s ) { ( void ) s ; }; use_span ( get_temp_string ()); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_vector = []() -> const std :: vector < int > { return {}; }; auto use_span = []( multi_span < const char > s ) { ( void ) s ; }; use_span ( get_temp_vector ()); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_string = []() -> const std :: string { return {}; }; auto use_span = []( multi_span < const char > s ) { ( void ) s ; }; use_span ( get_temp_string ()); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS std :: map < int , int > m ; multi_span < int > s { m }; #endif } } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_convertible_span_constructor\" ) { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 7 , 4 , 2 > av1 ( nullptr , b1 ); auto f = [ & ]() { multi_span < int , 7 , 4 , 2 > av1 ( nullptr ); }; CHECK_THROWS_AS ( f (), fail_fast ); #endif #ifdef CONFIRM_COMPILATION_ERRORS static_bounds < std :: size_t , 7 , dynamic_range , 2 > b12 ( b11 ); b12 = b11 ; b11 = b12 ; multi_span < int , dynamic_range > av1 = nullptr ; multi_span < int , 7 , dynamic_range , 2 > av2 ( av1 ); multi_span < int , 7 , 4 , 2 > av2 ( av1 ); #endif multi_span < DerivedClass > avd ; #ifdef CONFIRM_COMPILATION_ERRORS multi_span < BaseClass > avb = avd ; #endif multi_span < const DerivedClass > avcd = avd ; ( void ) avcd ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"copy_move_and_assignment\" ) { multi_span < int > s1 ; CHECK ( s1 . empty ()); int arr [] = { 3 , 4 , 5 }; multi_span < const int > s2 = arr ; CHECK (( s2 . length () == 3 && s2 . data () == & arr [ 0 ])); s2 = s1 ; CHECK ( s2 . empty ()); auto get_temp_span = [ & ]() -> multi_span < int > { return { & arr [ 1 ], 2 }; }; auto use_span = [ & ]( multi_span < const int > s ) { CHECK (( s . length () == 2 && s . data () == & arr [ 1 ])); }; use_span ( get_temp_span ()); s1 = get_temp_span (); CHECK (( s1 . length () == 2 && s1 . data () == & arr [ 1 ])); } template < class Bounds > void fn ( const Bounds & ) { static_assert ( Bounds :: static_size == 60 , \"static bounds is wrong size\" ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_multi_span_reshape\" ) { int a [ 3 ][ 4 ][ 5 ]; auto av = as_multi_span ( a ); fn ( av . bounds ()); auto av2 = as_multi_span ( av , dim < 60 > ()); auto av3 = as_multi_span ( av2 , dim < 3 > (), dim < 4 > (), dim < 5 > ()); auto av4 = as_multi_span ( av3 , dim < 4 > (), dim ( 3 ), dim < 5 > ()); auto av5 = as_multi_span ( av4 , dim < 3 > (), dim < 4 > (), dim < 5 > ()); auto av6 = as_multi_span ( av5 , dim < 12 > (), dim ( 5 )); fill ( av6 . begin (), av6 . end (), 1 ); auto av7 = as_bytes ( av6 ); auto av8 = as_multi_span < int > ( av7 ); CHECK ( av8 . size () == av6 . size ()); for ( auto i = 0 ; i < av8 . size (); i ++ ) { CHECK ( av8 [ i ] == 1 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"first\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { multi_span < int , 5 > av = arr ; CHECK (( av . first < 2 > (). bounds () == static_bounds < 2 > ())); CHECK ( av . first < 2 > (). length () == 2 ); CHECK ( av . first ( 2 ). length () == 2 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . first < 0 > (). bounds () == static_bounds < 0 > ())); CHECK ( av . first < 0 > (). length () == 0 ); CHECK ( av . first ( 0 ). length () == 0 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . first < 5 > (). bounds () == static_bounds < 5 > ())); CHECK ( av . first < 5 > (). length () == 5 ); CHECK ( av . first ( 5 ). length () == 5 ); } { multi_span < int , 5 > av = arr ; #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( av . first < 6 > (). bounds () == static_bounds < 6 > ()); CHECK ( av . first < 6 > (). length () == 6 ); CHECK ( av . first <- 1 > (). length () == - 1 ); #endif CHECK_THROWS_AS ( av . first ( 6 ). length (), fail_fast ); } { multi_span < int , dynamic_range > av ; CHECK (( av . first < 0 > (). bounds () == static_bounds < 0 > ())); CHECK ( av . first < 0 > (). length () == 0 ); CHECK ( av . first ( 0 ). length () == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"last\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { multi_span < int , 5 > av = arr ; CHECK (( av . last < 2 > (). bounds () == static_bounds < 2 > ())); CHECK ( av . last < 2 > (). length () == 2 ); CHECK ( av . last ( 2 ). length () == 2 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . last < 0 > (). bounds () == static_bounds < 0 > ())); CHECK ( av . last < 0 > (). length () == 0 ); CHECK ( av . last ( 0 ). length () == 0 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . last < 5 > (). bounds () == static_bounds < 5 > ())); CHECK ( av . last < 5 > (). length () == 5 ); CHECK ( av . last ( 5 ). length () == 5 ); } { multi_span < int , 5 > av = arr ; #ifdef CONFIRM_COMPILATION_ERRORS CHECK (( av . last < 6 > (). bounds () == static_bounds < 6 > ())); CHECK ( av . last < 6 > (). length () == 6 ); #endif CHECK_THROWS_AS ( av . last ( 6 ). length (), fail_fast ); } { multi_span < int , dynamic_range > av ; CHECK (( av . last < 0 > (). bounds () == static_bounds < 0 > ())); CHECK ( av . last < 0 > (). length () == 0 ); CHECK ( av . last ( 0 ). length () == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"subspan\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { multi_span < int , 5 > av = arr ; CHECK (( av . subspan < 2 , 2 > (). bounds () == static_bounds < 2 > ())); CHECK (( av . subspan < 2 , 2 > (). length () == 2 )); CHECK ( av . subspan ( 2 , 2 ). length () == 2 ); CHECK ( av . subspan ( 2 , 3 ). length () == 3 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . subspan < 0 , 0 > (). bounds () == static_bounds < 0 > ())); CHECK (( av . subspan < 0 , 0 > (). length () == 0 )); CHECK ( av . subspan ( 0 , 0 ). length () == 0 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . subspan < 0 , 5 > (). bounds () == static_bounds < 5 > ())); CHECK (( av . subspan < 0 , 5 > (). length () == 5 )); CHECK ( av . subspan ( 0 , 5 ). length () == 5 ); CHECK_THROWS_AS ( av . subspan ( 0 , 6 ). length (), fail_fast ); CHECK_THROWS_AS ( av . subspan ( 1 , 5 ). length (), fail_fast ); } { multi_span < int , 5 > av = arr ; CHECK (( av . subspan < 5 , 0 > (). bounds () == static_bounds < 0 > ())); CHECK (( av . subspan < 5 , 0 > (). length () == 0 )); CHECK ( av . subspan ( 5 , 0 ). length () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 , 0 ). length (), fail_fast ); } { multi_span < int , dynamic_range > av ; CHECK (( av . subspan < 0 , 0 > (). bounds () == static_bounds < 0 > ())); CHECK (( av . subspan < 0 , 0 > (). length () == 0 )); CHECK ( av . subspan ( 0 , 0 ). length () == 0 ); CHECK_THROWS_AS (( av . subspan < 1 , 0 > (). length ()), fail_fast ); } { multi_span < int > av ; CHECK ( av . subspan ( 0 ). length () == 0 ); CHECK_THROWS_AS ( av . subspan ( 1 ). length (), fail_fast ); } { multi_span < int > av = arr ; CHECK ( av . subspan ( 0 ). length () == 5 ); CHECK ( av . subspan ( 1 ). length () == 4 ); CHECK ( av . subspan ( 4 ). length () == 1 ); CHECK ( av . subspan ( 5 ). length () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 ). length (), fail_fast ); auto av2 = av . subspan ( 1 ); for ( int i = 0 ; i < 4 ; ++ i ) CHECK ( av2 [ i ] == i + 2 ); } { multi_span < int , 5 > av = arr ; CHECK ( av . subspan ( 0 ). length () == 5 ); CHECK ( av . subspan ( 1 ). length () == 4 ); CHECK ( av . subspan ( 4 ). length () == 1 ); CHECK ( av . subspan ( 5 ). length () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 ). length (), fail_fast ); auto av2 = av . subspan ( 1 ); for ( int i = 0 ; i < 4 ; ++ i ) CHECK ( av2 [ i ] == i + 2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"rank\" ) { int arr [ 2 ] = { 1 , 2 }; { multi_span < int > s ; CHECK ( s . rank () == 1 ); } { multi_span < int , 2 > s = arr ; CHECK ( s . rank () == 1 ); } int arr2d [ 1 ][ 1 ] = {}; { multi_span < int , 1 , 1 > s = arr2d ; CHECK ( s . rank () == 2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"extent\" ) { { multi_span < int > s ; CHECK ( s . extent () == 0 ); CHECK ( s . extent ( 0 ) == 0 ); CHECK_THROWS_AS ( s . extent ( 1 ), fail_fast ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( s . extent < 1 > () == 0 ); #endif } { multi_span < int , 0 > s ; CHECK ( s . extent () == 0 ); CHECK ( s . extent ( 0 ) == 0 ); CHECK_THROWS_AS ( s . extent ( 1 ), fail_fast ); } { int arr2d [ 1 ][ 2 ] = {}; multi_span < int , 1 , 2 > s = arr2d ; CHECK ( s . extent () == 1 ); CHECK ( s . extent < 0 > () == 1 ); CHECK ( s . extent < 1 > () == 2 ); CHECK ( s . extent ( 0 ) == 1 ); CHECK ( s . extent ( 1 ) == 2 ); CHECK_THROWS_AS ( s . extent ( 3 ), fail_fast ); } { int arr2d [ 1 ][ 2 ] = {}; multi_span < int , 0 , 2 > s = arr2d ; CHECK ( s . extent () == 0 ); CHECK ( s . extent < 0 > () == 0 ); CHECK ( s . extent < 1 > () == 2 ); CHECK ( s . extent ( 0 ) == 0 ); CHECK ( s . extent ( 1 ) == 2 ); CHECK_THROWS_AS ( s . extent ( 3 ), fail_fast ); } } TEST_CASE ( \"operator_function_call\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { multi_span < int > s = arr ; CHECK ( s ( 0 ) == 1 ); CHECK_THROWS_AS ( s ( 5 ), fail_fast ); } int arr2d [ 2 ][ 3 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; { multi_span < int , 2 , 3 > s = arr2d ; CHECK ( s ( 0 , 0 ) == 1 ); CHECK ( s ( 0 , 1 ) == 2 ); CHECK ( s ( 1 , 2 ) == 6 ); } int arr3d [ 2 ][ 2 ][ 2 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; { multi_span < int , 2 , 2 , 2 > s = arr3d ; CHECK ( s ( 0 , 0 , 0 ) == 1 ); CHECK ( s ( 1 , 1 , 1 ) == 8 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"comparison_operators\" ) { { int arr [ 10 ][ 2 ]; auto s1 = as_multi_span ( arr ); multi_span < const int , dynamic_range , 2 > s2 = s1 ; CHECK ( s1 == s2 ); multi_span < int , 20 > s3 = as_multi_span ( s1 , dim ( 20 )); CHECK (( s3 == s2 && s3 == s1 )); } { multi_span < int > s1 = nullptr ; multi_span < int > s2 = nullptr ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 2 , 1 }; // bigger multi_span < int > s1 = nullptr ; multi_span < int > s2 = arr ; CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } { int arr1 [] = { 1 , 2 }; int arr2 [] = { 1 , 2 }; multi_span < int > s1 = arr1 ; multi_span < int > s2 = arr2 ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 1 , 2 , 3 }; multi_span < int > s1 = { & arr [ 0 ], 2 }; // shorter multi_span < int > s2 = arr ; // longer CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } { int arr1 [] = { 1 , 2 }; // smaller int arr2 [] = { 2 , 1 }; // bigger multi_span < int > s1 = arr1 ; multi_span < int > s2 = arr2 ; CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"basics\" ) { auto ptr = as_multi_span ( new int [ 10 ], 10 ); fill ( ptr . begin (), ptr . end (), 99 ); for ( int num : ptr ) { CHECK ( num == 99 ); } delete [] ptr . data (); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute TEST_CASE ( \"bounds_checks\" ) { int arr [ 10 ][ 2 ]; auto av = as_multi_span ( arr ); fill ( begin ( av ), end ( av ), 0 ); av [ 2 ][ 0 ] = 1 ; av [ 1 ][ 1 ] = 3 ; // out of bounds CHECK_THROWS_AS ( av [ 1 ][ 3 ] = 3 , fail_fast ); CHECK_THROWS_AS (( av [{ 1 , 3 }] = 3 ), fail_fast ); CHECK_THROWS_AS ( av [ 10 ][ 2 ], fail_fast ); CHECK_THROWS_AS (( av [{ 10 , 2 }]), fail_fast ); CHECK_THROWS_AS ( av [ - 1 ][ 0 ], fail_fast ); CHECK_THROWS_AS (( av [{ - 1 , 0 }]), fail_fast ); CHECK_THROWS_AS ( av [ 0 ][ - 1 ], fail_fast ); CHECK_THROWS_AS (( av [{ 0 , - 1 }]), fail_fast ); } void overloaded_func ( multi_span < const int , dynamic_range , 3 , 5 > exp , int expected_value ) { for ( auto val : exp ) { CHECK ( val == expected_value ); } } void overloaded_func ( multi_span < const char , dynamic_range , 3 , 5 > exp , char expected_value ) { for ( auto val : exp ) { CHECK ( val == expected_value ); } } void fixed_func ( multi_span < int , 3 , 3 , 5 > exp , int expected_value ) { for ( auto val : exp ) { CHECK ( val == expected_value ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute TEST_CASE ( \"span_parameter_test\" ) { auto data = new int [ 4 ][ 3 ][ 5 ]; auto av = as_multi_span ( data , 4 ); CHECK ( av . size () == 60 ); fill ( av . begin (), av . end (), 34 ); int count = 0 ; for_each ( av . rbegin (), av . rend (), [ & ]( int val ) { count += val ; }); CHECK ( count == 34 * 60 ); overloaded_func ( av , 34 ); overloaded_func ( as_multi_span ( av , dim ( 4 ), dim ( 3 ), dim ( 5 )), 34 ); // fixed_func(av, 34); delete [] data ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute // false positive, checker does not recognize multi_span yet GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute TEST_CASE ( \"md_access\" ) { auto width = 5 , height = 20 ; auto imgSize = width * height ; auto image_ptr = new int [ narrow_cast < std :: size_t > ( imgSize )][ 3 ]; // size check will be done auto image_view = as_multi_span ( as_multi_span ( image_ptr , imgSize ), dim ( height ), dim ( width ), dim < 3 > ()); iota ( image_view . begin (), image_view . end (), 1 ); int expected = 0 ; for ( auto i = 0 ; i < height ; i ++ ) { for ( auto j = 0 ; j < width ; j ++ ) { CHECK ( expected + 1 == image_view [ i ][ j ][ 0 ]); CHECK ( expected + 2 == image_view [ i ][ j ][ 1 ]); CHECK ( expected + 3 == image_view [ i ][ j ][ 2 ]); auto val = image_view [{ i , j , 0 }]; CHECK ( expected + 1 == val ); val = image_view [{ i , j , 1 }]; CHECK ( expected + 2 == val ); val = image_view [{ i , j , 2 }]; CHECK ( expected + 3 == val ); expected += 3 ; } } delete [] image_ptr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute TEST_CASE ( \"as_multi_span\" ) { { int * arr = new int [ 150 ]; auto av = as_multi_span ( arr , dim < 10 > (), dim ( 3 ), dim < 5 > ()); fill ( av . begin (), av . end (), 24 ); overloaded_func ( av , 24 ); delete [] arr ; array < int , 15 > stdarr { 0 }; auto av2 = as_multi_span ( stdarr ); overloaded_func ( as_multi_span ( av2 , dim ( 1 ), dim < 3 > (), dim < 5 > ()), 0 ); string str = \"ttttttttttttttt\" ; // size = 15 auto t = str . data (); GSL_SUPPRESS ( type .4 ) // NO-FORMAT: attribute // TODO: false positive ( void ) t ; auto av3 = as_multi_span ( str ); overloaded_func ( as_multi_span ( av3 , dim ( 1 ), dim < 3 > (), dim < 5 > ()), 't' ); } { string str ; multi_span < char > strspan = as_multi_span ( str ); ( void ) strspan ; const string cstr ; multi_span < const char > cstrspan = as_multi_span ( cstr ); ( void ) cstrspan ; } { int a [ 3 ][ 4 ][ 5 ]; auto av = as_multi_span ( a ); const int ( * b )[ 4 ][ 5 ]; b = a ; auto bv = as_multi_span ( b , 3 ); CHECK ( av == bv ); const std :: array < double , 3 > arr = { 0.0 , 0.0 , 0.0 }; auto cv = as_multi_span ( arr ); ( void ) cv ; vector < float > vec ( 3 ); auto dv = as_multi_span ( vec ); ( void ) dv ; #ifdef CONFIRM_COMPILATION_ERRORS auto dv2 = as_multi_span ( std :: move ( vec )); #endif } } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute TEST_CASE ( \"empty_spans\" ) { { multi_span < int , 0 > empty_av ( nullptr ); CHECK ( empty_av . bounds (). index_bounds () == multi_span_index < 1 > { 0 }); CHECK_THROWS_AS ( empty_av [ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_av . begin ()[ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_av . cbegin ()[ 0 ], fail_fast ); for ( auto & v : empty_av ) { ( void ) v ; CHECK ( false ); } } { multi_span < int > empty_av = {}; CHECK ( empty_av . bounds (). index_bounds () == multi_span_index < 1 > { 0 }); CHECK_THROWS_AS ( empty_av [ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_av . begin ()[ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_av . cbegin ()[ 0 ], fail_fast ); for ( auto & v : empty_av ) { ( void ) v ; CHECK ( false ); } } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"index_constructor\" ) { auto arr = new int [ 8 ]; for ( int i = 0 ; i < 4 ; ++ i ) { arr [ 2 * i ] = 4 + i ; arr [ 2 * i + 1 ] = i ; } multi_span < int , dynamic_range > av ( arr , 8 ); ptrdiff_t a [ 1 ] = { 0 }; multi_span_index < 1 > i = a ; CHECK ( av [ i ] == 4 ); auto av2 = as_multi_span ( av , dim < 4 > (), dim ( 2 )); ptrdiff_t a2 [ 2 ] = { 0 , 1 }; multi_span_index < 2 > i2 = a2 ; CHECK ( av2 [ i2 ] == 0 ); CHECK ( av2 [ 0 ][ i ] == 4 ); delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"index_constructors\" ) { { // components of the same type multi_span_index < 3 > i1 ( 0 , 1 , 2 ); CHECK ( i1 [ 0 ] == 0 ); // components of different types std :: size_t c0 = 0 ; std :: size_t c1 = 1 ; multi_span_index < 3 > i2 ( c0 , c1 , 2 ); CHECK ( i2 [ 0 ] == 0 ); // from array multi_span_index < 3 > i3 = { 0 , 1 , 2 }; CHECK ( i3 [ 0 ] == 0 ); // from other index of the same size type multi_span_index < 3 > i4 = i3 ; CHECK ( i4 [ 0 ] == 0 ); // default multi_span_index < 3 > i7 ; CHECK ( i7 [ 0 ] == 0 ); // default multi_span_index < 3 > i9 = {}; CHECK ( i9 [ 0 ] == 0 ); } { // components of the same type multi_span_index < 1 > i1 ( 0 ); CHECK ( i1 [ 0 ] == 0 ); // components of different types std :: size_t c0 = 0 ; multi_span_index < 1 > i2 ( c0 ); CHECK ( i2 [ 0 ] == 0 ); // from array multi_span_index < 1 > i3 = { 0 }; CHECK ( i3 [ 0 ] == 0 ); // from int multi_span_index < 1 > i4 = 0 ; CHECK ( i4 [ 0 ] == 0 ); // from other index of the same size type multi_span_index < 1 > i5 = i3 ; CHECK ( i5 [ 0 ] == 0 ); // default multi_span_index < 1 > i8 ; CHECK ( i8 [ 0 ] == 0 ); // default multi_span_index < 1 > i9 = {}; CHECK ( i9 [ 0 ] == 0 ); } #ifdef CONFIRM_COMPILATION_ERRORS { multi_span_index < 3 > i1 ( 0 , 1 ); multi_span_index < 3 > i2 ( 0 , 1 , 2 , 3 ); multi_span_index < 3 > i3 = { 0 }; multi_span_index < 3 > i4 = { 0 , 1 , 2 , 3 }; multi_span_index < 1 > i5 = { 0 , 1 }; } #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"index_operations\" ) { ptrdiff_t a [ 3 ] = { 0 , 1 , 2 }; ptrdiff_t b [ 3 ] = { 3 , 4 , 5 }; multi_span_index < 3 > i = a ; multi_span_index < 3 > j = b ; CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); { multi_span_index < 3 > k = i + j ; CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); CHECK ( k [ 0 ] == 3 ); CHECK ( k [ 1 ] == 5 ); CHECK ( k [ 2 ] == 7 ); } { multi_span_index < 3 > k = i * 3 ; CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); CHECK ( k [ 0 ] == 0 ); CHECK ( k [ 1 ] == 3 ); CHECK ( k [ 2 ] == 6 ); } { multi_span_index < 3 > k = 3 * i ; CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); CHECK ( k [ 0 ] == 0 ); CHECK ( k [ 1 ] == 3 ); CHECK ( k [ 2 ] == 6 ); } { multi_span_index < 2 > k = details :: shift_left ( i ); CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); CHECK ( k [ 0 ] == 1 ); CHECK ( k [ 1 ] == 2 ); } } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute void iterate_second_column ( multi_span < int , dynamic_range , dynamic_range > av ) { auto length = av . size () / 2 ; // view to the second column auto section = av . section ({ 0 , 1 }, { length , 1 }); CHECK ( section . size () == length ); for ( auto i = 0 ; i < section . size (); ++ i ) { CHECK ( section [ i ][ 0 ] == av [ i ][ 1 ]); } for ( auto i = 0 ; i < section . size (); ++ i ) { auto idx = multi_span_index < 2 > { i , 0 }; // avoid braces inside the CHECK macro CHECK ( section [ idx ] == av [ i ][ 1 ]); } CHECK ( section . bounds (). index_bounds ()[ 0 ] == length ); CHECK ( section . bounds (). index_bounds ()[ 1 ] == 1 ); for ( auto i = 0 ; i < section . bounds (). index_bounds ()[ 0 ]; ++ i ) { for ( auto j = 0 ; j < section . bounds (). index_bounds ()[ 1 ]; ++ j ) { auto idx = multi_span_index < 2 > { i , j }; // avoid braces inside the CHECK macro CHECK ( section [ idx ] == av [ i ][ 1 ]); } } auto check_sum = 0 ; for ( auto i = 0 ; i < length ; ++ i ) { check_sum += av [ i ][ 1 ]; } { auto idx = 0 ; auto sum = 0 ; for ( auto num : section ) { CHECK ( num == av [ idx ][ 1 ]); sum += num ; idx ++ ; } CHECK ( sum == check_sum ); } { auto idx = length - 1 ; auto sum = 0 ; for ( auto iter = section . rbegin (); iter != section . rend (); ++ iter ) { CHECK ( * iter == av [ idx ][ 1 ]); sum += * iter ; idx -- ; } CHECK ( sum == check_sum ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"span_section_iteration\" ) { int arr [ 4 ][ 2 ] = {{ 4 , 0 }, { 5 , 1 }, { 6 , 2 }, { 7 , 3 }}; // static bounds { multi_span < int , 4 , 2 > av = arr ; iterate_second_column ( av ); } // first bound is dynamic { multi_span < int , dynamic_range , 2 > av = arr ; iterate_second_column ( av ); } // second bound is dynamic { multi_span < int , 4 , dynamic_range > av = arr ; iterate_second_column ( av ); } // both bounds are dynamic { multi_span < int , dynamic_range , dynamic_range > av = arr ; iterate_second_column ( av ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"dynamic_span_section_iteration\" ) { auto height = 4 , width = 2 ; auto size = height * width ; auto arr = new int [ narrow_cast < std :: size_t > ( size )]; for ( auto i = 0 ; i < size ; ++ i ) { arr [ i ] = i ; } auto av = as_multi_span ( arr , size ); // first bound is dynamic { multi_span < int , dynamic_range , 2 > av2 = as_multi_span ( av , dim ( height ), dim ( width )); iterate_second_column ( av2 ); } // second bound is dynamic { multi_span < int , 4 , dynamic_range > av2 = as_multi_span ( av , dim ( height ), dim ( width )); iterate_second_column ( av2 ); } // both bounds are dynamic { multi_span < int , dynamic_range , dynamic_range > av2 = as_multi_span ( av , dim ( height ), dim ( width )); iterate_second_column ( av2 ); } delete [] arr ; } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute TEST_CASE ( \"span_structure_size\" ) { double ( * arr )[ 3 ][ 4 ] = new double [ 100 ][ 3 ][ 4 ]; multi_span < double , dynamic_range , 3 , 4 > av1 ( arr , 10 ); struct EffectiveStructure { double * v1 ; ptrdiff_t v2 ; }; CHECK ( sizeof ( av1 ) == sizeof ( EffectiveStructure )); CHECK_THROWS_AS ( av1 [ 10 ][ 3 ][ 4 ], fail_fast ); multi_span < const double , dynamic_range , 6 , 4 > av2 = as_multi_span ( av1 , dim ( 5 ), dim < 6 > (), dim < 4 > ()); ( void ) av2 ; delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"fixed_size_conversions\" ) { int arr [] = { 1 , 2 , 3 , 4 }; // converting to an multi_span from an equal size array is ok multi_span < int , 4 > av4 = arr ; CHECK ( av4 . length () == 4 ); // converting to dynamic_range a_v is always ok { multi_span < int , dynamic_range > av = av4 ; ( void ) av ; } { multi_span < int , dynamic_range > av = arr ; ( void ) av ; } // initialization or assignment to static multi_span that REDUCES size is NOT ok #ifdef CONFIRM_COMPILATION_ERRORS { multi_span < int , 2 > av2 = arr ; } { multi_span < int , 2 > av2 = av4 ; } #endif { multi_span < int , dynamic_range > av = arr ; multi_span < int , 2 > av2 = av ; ( void ) av2 ; } #ifdef CONFIRM_COMPILATION_ERRORS { multi_span < int , dynamic_range > av = arr ; multi_span < int , 2 , 1 > av2 = av . as_multi_span ( dim < 2 > (), dim < 2 > ()); } #endif { multi_span < int , dynamic_range > av = arr ; multi_span < int , 2 , 1 > av2 = as_multi_span ( av , dim ( 2 ), dim ( 2 )); auto workaround_macro = [ & ]() { return av2 [{ 1 , 0 }] == 2 ; }; CHECK ( workaround_macro ()); } // but doing so explicitly is ok // you can convert statically { multi_span < int , 2 > av2 = { arr , 2 }; ( void ) av2 ; } { multi_span < int , 1 > av2 = av4 . first < 1 > (); ( void ) av2 ; } // ...or dynamically { // NB: implicit conversion to multi_span<int,2> from multi_span<int,dynamic_range> multi_span < int , 1 > av2 = av4 . first ( 1 ); ( void ) av2 ; } // initialization or assignment to static multi_span that requires size INCREASE is not ok. int arr2 [ 2 ] = { 1 , 2 }; #ifdef CONFIRM_COMPILATION_ERRORS { multi_span < int , 4 > av4 = arr2 ; } { multi_span < int , 2 > av2 = arr2 ; multi_span < int , 4 > av4 = av2 ; } #endif { auto f = [ & ]() { const multi_span < int , 4 > av9 = { arr2 , 2 }; ( void ) av9 ; }; CHECK_THROWS_AS ( f (), fail_fast ); } // this should fail - we are trying to assign a small dynamic a_v to a fixed_size larger one multi_span < int , dynamic_range > av = arr2 ; auto f = [ & ]() { const multi_span < int , 4 > av2 = av ; ( void ) av2 ; }; CHECK_THROWS_AS ( f (), fail_fast ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_writeable_bytes\" ) { int a [] = { 1 , 2 , 3 , 4 }; { #ifdef CONFIRM_COMPILATION_ERRORS // you should not be able to get writeable bytes for const objects multi_span < const int , dynamic_range > av = a ; auto wav = av . as_writeable_bytes (); #endif } { multi_span < int , dynamic_range > av ; auto wav = as_writeable_bytes ( av ); CHECK ( wav . length () == av . length ()); CHECK ( wav . length () == 0 ); CHECK ( wav . size_bytes () == 0 ); } { multi_span < int , dynamic_range > av = a ; auto wav = as_writeable_bytes ( av ); CHECK ( wav . data () == reinterpret_cast < byte *> ( & a [ 0 ])); CHECK ( static_cast < std :: size_t > ( wav . length ()) == sizeof ( a )); } } GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"iterator\" ) { int a [] = { 1 , 2 , 3 , 4 }; { multi_span < int , dynamic_range > av = a ; auto wav = as_writeable_bytes ( av ); for ( auto & b : wav ) { #if defined(__cplusplus) && (__cplusplus >= 201703L) b = byte { 0 }; #else GSL_SUPPRESS ( es .49 ) b = byte ( 0 ); #endif } for ( std :: size_t i = 0 ; i < 4 ; ++ i ) { CHECK ( a [ i ] == 0 ); } } { multi_span < int , dynamic_range > av = a ; for ( auto & n : av ) { n = 1 ; } for ( std :: size_t i = 0 ; i < 4 ; ++ i ) { CHECK ( a [ i ] == 1 ); } } } #ifdef CONFIRM_COMPILATION_ERRORS copy ( src_span_static , dst_span_static ); #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic pop #endif","title":"File multi\\_span\\_tests.cpp"},{"location":"multi__span__tests_8cpp_source/#file-multi95span95testscpp","text":"File List > external > guideline > tests > multi_span_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #pragma warning(disable : 4996) // multi_span is in the process of being deprecated. // Suppressing warnings until it is completely removed #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\" #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, CHECK... #include <gsl/gsl_byte> // for byte #include <gsl/gsl_util> // for narrow_cast #include <gsl/multi_span> // for multi_span, contiguous_span_iterator, dim #include <algorithm> // for fill, for_each #include <array> // for array #include <iostream> // for ptrdiff_t, size_t #include <iterator> // for reverse_iterator, begin, end, operator!= #include <numeric> // for iota #include <stddef.h> // for ptrdiff_t #include <string> // for string #include <vector> // for vector namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; namespace { struct BaseClass { }; struct DerivedClass : BaseClass { }; } // namespace GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"default_constructor\" ) { { multi_span < int > s ; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs ; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { multi_span < int , 0 > s ; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int , 0 > cs ; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 1 > s ; CHECK (( s . length () == 1 && s . data () == nullptr )); // explains why it can't compile #endif } { multi_span < int > s {}; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs {}; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_nullptr_constructor\" ) { { multi_span < int > s = nullptr ; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs = nullptr ; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { multi_span < int , 0 > s = nullptr ; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int , 0 > cs = nullptr ; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 1 > s = nullptr ; CHECK (( s . length () == 1 && s . data () == nullptr )); // explains why it can't compile #endif } { multi_span < int > s { nullptr }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs { nullptr }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { multi_span < int *> s { nullptr }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int *> cs { nullptr }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_nullptr_length_constructor\" ) { { multi_span < int > s { nullptr , 0 }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int > cs { nullptr , 0 }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { multi_span < int , 0 > s { nullptr , 0 }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int , 0 > cs { nullptr , 0 }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { auto workaround_macro = []() { const multi_span < int > s { nullptr , 1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); auto const_workaround_macro = []() { const multi_span < const int > cs { nullptr , 1 }; }; CHECK_THROWS_AS ( const_workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const multi_span < int , 0 > s { nullptr , 1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); auto const_workaround_macro = []() { const multi_span < const int , 0 > s { nullptr , 1 }; }; CHECK_THROWS_AS ( const_workaround_macro (), fail_fast ); } { multi_span < int *> s { nullptr , 0 }; CHECK (( s . length () == 0 && s . data () == nullptr )); multi_span < const int *> cs { nullptr , 0 }; CHECK (( cs . length () == 0 && cs . data () == nullptr )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 1 > s { nullptr , 0 }; CHECK (( s . length () == 1 && s . data () == nullptr )); // explains why it can't compile #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_element_constructor\" ) { int i = 5 ; { multi_span < int > s = i ; CHECK (( s . length () == 1 && s . data () == & i )); CHECK ( s [ 0 ] == 5 ); multi_span < const int > cs = i ; CHECK (( cs . length () == 1 && cs . data () == & i )); CHECK ( cs [ 0 ] == 5 ); } { #ifdef CONFIRM_COMPILATION_ERRORS const j = 1 ; multi_span < int , 0 > s = j ; #endif } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 0 > s = i ; CHECK (( s . length () == 0 && s . data () == & i )); #endif } { multi_span < int , 1 > s = i ; CHECK (( s . length () == 1 && s . data () == & i )); CHECK ( s [ 0 ] == 5 ); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 2 > s = i ; CHECK (( s . length () == 2 && s . data () == & i )); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_a_temp = []() -> int { return 4 ; }; auto use_a_span = []( multi_span < int > s ) { ( void ) s ; }; use_a_span ( get_a_temp ()); #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_pointer_length_constructor\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { multi_span < int > s { & arr [ 0 ], 2 }; CHECK (( s . length () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { multi_span < int , 2 > s { & arr [ 0 ], 2 }; CHECK (( s . length () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { int * p = nullptr ; multi_span < int > s { p , 0 }; CHECK (( s . length () == 0 && s . data () == nullptr )); } { int * p = nullptr ; auto workaround_macro = [ = ]() { const multi_span < int > s { p , 2 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_pointer_pointer_constructor\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { multi_span < int > s { & arr [ 0 ], & arr [ 2 ]}; CHECK (( s . length () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { multi_span < int , 2 > s { & arr [ 0 ], & arr [ 2 ]}; CHECK (( s . length () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { multi_span < int > s { & arr [ 0 ], & arr [ 0 ]}; CHECK (( s . length () == 0 && s . data () == & arr [ 0 ])); } { multi_span < int , 0 > s { & arr [ 0 ], & arr [ 0 ]}; CHECK (( s . length () == 0 && s . data () == & arr [ 0 ])); } { auto workaround_macro = [ & ]() { const multi_span < int > s { & arr [ 1 ], & arr [ 0 ]}; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; auto workaround_macro = [ & ]() { const multi_span < int > s { & arr [ 0 ], p }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; auto workaround_macro = [ & ]() { const multi_span < int > s { p , p }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; auto workaround_macro = [ & ]() { const multi_span < int > s { & arr [ 0 ], p }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"from_array_constructor\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { multi_span < int > s { arr }; CHECK (( s . length () == 5 && s . data () == & arr [ 0 ])); } { multi_span < int , 5 > s { arr }; CHECK (( s . length () == 5 && s . data () == & arr [ 0 ])); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 6 > s { arr }; #endif } { multi_span < int , 0 > s { arr }; CHECK (( s . length () == 0 && s . data () == & arr [ 0 ])); } int arr2d [ 2 ][ 3 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; { multi_span < int > s { arr2d }; CHECK (( s . length () == 6 && s . data () == & arr2d [ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } { multi_span < int , 0 > s { arr2d }; CHECK (( s . length () == 0 && s . data () == & arr2d [ 0 ][ 0 ])); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 5 > s { arr2d }; #endif } { multi_span < int , 6 > s { arr2d }; CHECK (( s . length () == 6 && s . data () == & arr2d [ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 7 > s { arr2d }; #endif } { multi_span < int [ 3 ] > s { arr2d [ 0 ]}; CHECK (( s . length () == 1 && s . data () == & arr2d [ 0 ])); } { multi_span < int , 2 , 3 > s { arr2d }; CHECK (( s . length () == 6 && s . data () == & arr2d [ 0 ][ 0 ])); auto workaround_macro = [ & ]() { return s [{ 1 , 2 }] == 6 ; }; CHECK ( workaround_macro ()); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 3 , 3 > s { arr2d }; #endif } int arr3d [ 2 ][ 3 ][ 2 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 }; { multi_span < int > s { arr3d }; CHECK (( s . length () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 11 ] == 12 )); } { multi_span < int , 0 > s { arr3d }; CHECK (( s . length () == 0 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 11 > s { arr3d }; #endif } { multi_span < int , 12 > s { arr3d }; CHECK (( s . length () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 13 > s { arr3d }; #endif } { multi_span < int [ 3 ][ 2 ] > s { arr3d [ 0 ]}; CHECK (( s . length () == 1 && s . data () == & arr3d [ 0 ])); } { multi_span < int , 3 , 2 , 2 > s { arr3d }; CHECK (( s . length () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); auto workaround_macro = [ & ]() { return s [{ 2 , 1 , 0 }] == 11 ; }; CHECK ( workaround_macro ()); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 3 , 3 , 3 > s { arr3d }; #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"from_dynamic_array_constructor\" ) { double ( * arr )[ 3 ][ 4 ] = new double [ 100 ][ 3 ][ 4 ]; { multi_span < double , dynamic_range , 3 , 4 > s ( arr , 10 ); CHECK (( s . length () == 120 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); CHECK_THROWS_AS ( s [ 10 ][ 3 ][ 4 ], fail_fast ); } { multi_span < double , dynamic_range , 4 , 3 > s ( arr , 10 ); CHECK (( s . length () == 120 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } { multi_span < double > s ( arr , 10 ); CHECK (( s . length () == 120 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } { multi_span < double , dynamic_range , 3 , 4 > s ( arr , 0 ); CHECK (( s . length () == 0 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: Attribute TEST_CASE ( \"from_std_array_constructor\" ) { std :: array < int , 4 > arr = { 1 , 2 , 3 , 4 }; { multi_span < int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); multi_span < const int > cs { arr }; CHECK (( cs . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && cs . data () == arr . data ())); } { multi_span < int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); multi_span < const int , 4 > cs { arr }; CHECK (( cs . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && cs . data () == arr . data ())); } { multi_span < int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); multi_span < const int , 2 > cs { arr }; CHECK (( cs . size () == 2 && cs . data () == arr . data ())); } { multi_span < int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); multi_span < const int , 0 > cs { arr }; CHECK (( cs . size () == 0 && cs . data () == arr . data ())); } // TODO This is currently an unsupported scenario. We will come back to it as we revise // the multidimensional interface and what transformations between dimensionality look like //{ // multi_span<int, 2, 2> s{arr}; // CHECK(s.size() == narrow_cast<ptrdiff_t>(arr.size()) && s.data() == arr.data()); //} { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 5 > s { arr }; #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_an_array = []() { return std :: array < int , 4 > { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( multi_span < int > s ) { ( void ) s ; }; // try to take a temporary std::array take_a_span ( get_an_array ()); #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_const_std_array_constructor\" ) { const std :: array < int , 4 > arr = { 1 , 2 , 3 , 4 }; { multi_span < const int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } { multi_span < const int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } { multi_span < const int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); } { multi_span < const int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); } // TODO This is currently an unsupported scenario. We will come back to it as we revise // the multidimensional interface and what transformations between dimensionality look like //{ // multi_span<int, 2, 2> s{arr}; // CHECK(s.size() == narrow_cast<ptrdiff_t>(arr.size()) && s.data() == arr.data()); //} { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < const int , 5 > s { arr }; #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_an_array = []() -> const std :: array < int , 4 > { return { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( multi_span < const int > s ) { ( void ) s ; }; // try to take a temporary std::array take_a_span ( get_an_array ()); #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_container_constructor\" ) { std :: vector < int > v = { 1 , 2 , 3 }; const std :: vector < int > cv = v ; { multi_span < int > s { v }; CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && s . data () == v . data ())); multi_span < const int > cs { v }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && cs . data () == v . data ())); } std :: string str = \"hello\" ; const std :: string cstr = \"hello\" ; { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < char > s { str }; CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( str . size ()) && s . data () == str . data ())); #endif multi_span < const char > cs { str }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( str . size ()) && cs . data () == str . data ())); } { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < char > s { cstr }; #endif multi_span < const char > cs { cstr }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( cstr . size ()) && cs . data () == cstr . data ())); } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_vector = []() -> std :: vector < int > { return {}; }; auto use_span = []( multi_span < int > s ) { ( void ) s ; }; use_span ( get_temp_vector ()); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_string = []() -> std :: string { return {}; }; auto use_span = []( multi_span < char > s ) { ( void ) s ; }; use_span ( get_temp_string ()); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_vector = []() -> const std :: vector < int > { return {}; }; auto use_span = []( multi_span < const char > s ) { ( void ) s ; }; use_span ( get_temp_vector ()); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_string = []() -> const std :: string { return {}; }; auto use_span = []( multi_span < const char > s ) { ( void ) s ; }; use_span ( get_temp_string ()); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS std :: map < int , int > m ; multi_span < int > s { m }; #endif } } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_convertible_span_constructor\" ) { #ifdef CONFIRM_COMPILATION_ERRORS multi_span < int , 7 , 4 , 2 > av1 ( nullptr , b1 ); auto f = [ & ]() { multi_span < int , 7 , 4 , 2 > av1 ( nullptr ); }; CHECK_THROWS_AS ( f (), fail_fast ); #endif #ifdef CONFIRM_COMPILATION_ERRORS static_bounds < std :: size_t , 7 , dynamic_range , 2 > b12 ( b11 ); b12 = b11 ; b11 = b12 ; multi_span < int , dynamic_range > av1 = nullptr ; multi_span < int , 7 , dynamic_range , 2 > av2 ( av1 ); multi_span < int , 7 , 4 , 2 > av2 ( av1 ); #endif multi_span < DerivedClass > avd ; #ifdef CONFIRM_COMPILATION_ERRORS multi_span < BaseClass > avb = avd ; #endif multi_span < const DerivedClass > avcd = avd ; ( void ) avcd ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"copy_move_and_assignment\" ) { multi_span < int > s1 ; CHECK ( s1 . empty ()); int arr [] = { 3 , 4 , 5 }; multi_span < const int > s2 = arr ; CHECK (( s2 . length () == 3 && s2 . data () == & arr [ 0 ])); s2 = s1 ; CHECK ( s2 . empty ()); auto get_temp_span = [ & ]() -> multi_span < int > { return { & arr [ 1 ], 2 }; }; auto use_span = [ & ]( multi_span < const int > s ) { CHECK (( s . length () == 2 && s . data () == & arr [ 1 ])); }; use_span ( get_temp_span ()); s1 = get_temp_span (); CHECK (( s1 . length () == 2 && s1 . data () == & arr [ 1 ])); } template < class Bounds > void fn ( const Bounds & ) { static_assert ( Bounds :: static_size == 60 , \"static bounds is wrong size\" ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_multi_span_reshape\" ) { int a [ 3 ][ 4 ][ 5 ]; auto av = as_multi_span ( a ); fn ( av . bounds ()); auto av2 = as_multi_span ( av , dim < 60 > ()); auto av3 = as_multi_span ( av2 , dim < 3 > (), dim < 4 > (), dim < 5 > ()); auto av4 = as_multi_span ( av3 , dim < 4 > (), dim ( 3 ), dim < 5 > ()); auto av5 = as_multi_span ( av4 , dim < 3 > (), dim < 4 > (), dim < 5 > ()); auto av6 = as_multi_span ( av5 , dim < 12 > (), dim ( 5 )); fill ( av6 . begin (), av6 . end (), 1 ); auto av7 = as_bytes ( av6 ); auto av8 = as_multi_span < int > ( av7 ); CHECK ( av8 . size () == av6 . size ()); for ( auto i = 0 ; i < av8 . size (); i ++ ) { CHECK ( av8 [ i ] == 1 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"first\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { multi_span < int , 5 > av = arr ; CHECK (( av . first < 2 > (). bounds () == static_bounds < 2 > ())); CHECK ( av . first < 2 > (). length () == 2 ); CHECK ( av . first ( 2 ). length () == 2 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . first < 0 > (). bounds () == static_bounds < 0 > ())); CHECK ( av . first < 0 > (). length () == 0 ); CHECK ( av . first ( 0 ). length () == 0 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . first < 5 > (). bounds () == static_bounds < 5 > ())); CHECK ( av . first < 5 > (). length () == 5 ); CHECK ( av . first ( 5 ). length () == 5 ); } { multi_span < int , 5 > av = arr ; #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( av . first < 6 > (). bounds () == static_bounds < 6 > ()); CHECK ( av . first < 6 > (). length () == 6 ); CHECK ( av . first <- 1 > (). length () == - 1 ); #endif CHECK_THROWS_AS ( av . first ( 6 ). length (), fail_fast ); } { multi_span < int , dynamic_range > av ; CHECK (( av . first < 0 > (). bounds () == static_bounds < 0 > ())); CHECK ( av . first < 0 > (). length () == 0 ); CHECK ( av . first ( 0 ). length () == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"last\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { multi_span < int , 5 > av = arr ; CHECK (( av . last < 2 > (). bounds () == static_bounds < 2 > ())); CHECK ( av . last < 2 > (). length () == 2 ); CHECK ( av . last ( 2 ). length () == 2 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . last < 0 > (). bounds () == static_bounds < 0 > ())); CHECK ( av . last < 0 > (). length () == 0 ); CHECK ( av . last ( 0 ). length () == 0 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . last < 5 > (). bounds () == static_bounds < 5 > ())); CHECK ( av . last < 5 > (). length () == 5 ); CHECK ( av . last ( 5 ). length () == 5 ); } { multi_span < int , 5 > av = arr ; #ifdef CONFIRM_COMPILATION_ERRORS CHECK (( av . last < 6 > (). bounds () == static_bounds < 6 > ())); CHECK ( av . last < 6 > (). length () == 6 ); #endif CHECK_THROWS_AS ( av . last ( 6 ). length (), fail_fast ); } { multi_span < int , dynamic_range > av ; CHECK (( av . last < 0 > (). bounds () == static_bounds < 0 > ())); CHECK ( av . last < 0 > (). length () == 0 ); CHECK ( av . last ( 0 ). length () == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"subspan\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { multi_span < int , 5 > av = arr ; CHECK (( av . subspan < 2 , 2 > (). bounds () == static_bounds < 2 > ())); CHECK (( av . subspan < 2 , 2 > (). length () == 2 )); CHECK ( av . subspan ( 2 , 2 ). length () == 2 ); CHECK ( av . subspan ( 2 , 3 ). length () == 3 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . subspan < 0 , 0 > (). bounds () == static_bounds < 0 > ())); CHECK (( av . subspan < 0 , 0 > (). length () == 0 )); CHECK ( av . subspan ( 0 , 0 ). length () == 0 ); } { multi_span < int , 5 > av = arr ; CHECK (( av . subspan < 0 , 5 > (). bounds () == static_bounds < 5 > ())); CHECK (( av . subspan < 0 , 5 > (). length () == 5 )); CHECK ( av . subspan ( 0 , 5 ). length () == 5 ); CHECK_THROWS_AS ( av . subspan ( 0 , 6 ). length (), fail_fast ); CHECK_THROWS_AS ( av . subspan ( 1 , 5 ). length (), fail_fast ); } { multi_span < int , 5 > av = arr ; CHECK (( av . subspan < 5 , 0 > (). bounds () == static_bounds < 0 > ())); CHECK (( av . subspan < 5 , 0 > (). length () == 0 )); CHECK ( av . subspan ( 5 , 0 ). length () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 , 0 ). length (), fail_fast ); } { multi_span < int , dynamic_range > av ; CHECK (( av . subspan < 0 , 0 > (). bounds () == static_bounds < 0 > ())); CHECK (( av . subspan < 0 , 0 > (). length () == 0 )); CHECK ( av . subspan ( 0 , 0 ). length () == 0 ); CHECK_THROWS_AS (( av . subspan < 1 , 0 > (). length ()), fail_fast ); } { multi_span < int > av ; CHECK ( av . subspan ( 0 ). length () == 0 ); CHECK_THROWS_AS ( av . subspan ( 1 ). length (), fail_fast ); } { multi_span < int > av = arr ; CHECK ( av . subspan ( 0 ). length () == 5 ); CHECK ( av . subspan ( 1 ). length () == 4 ); CHECK ( av . subspan ( 4 ). length () == 1 ); CHECK ( av . subspan ( 5 ). length () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 ). length (), fail_fast ); auto av2 = av . subspan ( 1 ); for ( int i = 0 ; i < 4 ; ++ i ) CHECK ( av2 [ i ] == i + 2 ); } { multi_span < int , 5 > av = arr ; CHECK ( av . subspan ( 0 ). length () == 5 ); CHECK ( av . subspan ( 1 ). length () == 4 ); CHECK ( av . subspan ( 4 ). length () == 1 ); CHECK ( av . subspan ( 5 ). length () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 ). length (), fail_fast ); auto av2 = av . subspan ( 1 ); for ( int i = 0 ; i < 4 ; ++ i ) CHECK ( av2 [ i ] == i + 2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"rank\" ) { int arr [ 2 ] = { 1 , 2 }; { multi_span < int > s ; CHECK ( s . rank () == 1 ); } { multi_span < int , 2 > s = arr ; CHECK ( s . rank () == 1 ); } int arr2d [ 1 ][ 1 ] = {}; { multi_span < int , 1 , 1 > s = arr2d ; CHECK ( s . rank () == 2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"extent\" ) { { multi_span < int > s ; CHECK ( s . extent () == 0 ); CHECK ( s . extent ( 0 ) == 0 ); CHECK_THROWS_AS ( s . extent ( 1 ), fail_fast ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( s . extent < 1 > () == 0 ); #endif } { multi_span < int , 0 > s ; CHECK ( s . extent () == 0 ); CHECK ( s . extent ( 0 ) == 0 ); CHECK_THROWS_AS ( s . extent ( 1 ), fail_fast ); } { int arr2d [ 1 ][ 2 ] = {}; multi_span < int , 1 , 2 > s = arr2d ; CHECK ( s . extent () == 1 ); CHECK ( s . extent < 0 > () == 1 ); CHECK ( s . extent < 1 > () == 2 ); CHECK ( s . extent ( 0 ) == 1 ); CHECK ( s . extent ( 1 ) == 2 ); CHECK_THROWS_AS ( s . extent ( 3 ), fail_fast ); } { int arr2d [ 1 ][ 2 ] = {}; multi_span < int , 0 , 2 > s = arr2d ; CHECK ( s . extent () == 0 ); CHECK ( s . extent < 0 > () == 0 ); CHECK ( s . extent < 1 > () == 2 ); CHECK ( s . extent ( 0 ) == 0 ); CHECK ( s . extent ( 1 ) == 2 ); CHECK_THROWS_AS ( s . extent ( 3 ), fail_fast ); } } TEST_CASE ( \"operator_function_call\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { multi_span < int > s = arr ; CHECK ( s ( 0 ) == 1 ); CHECK_THROWS_AS ( s ( 5 ), fail_fast ); } int arr2d [ 2 ][ 3 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; { multi_span < int , 2 , 3 > s = arr2d ; CHECK ( s ( 0 , 0 ) == 1 ); CHECK ( s ( 0 , 1 ) == 2 ); CHECK ( s ( 1 , 2 ) == 6 ); } int arr3d [ 2 ][ 2 ][ 2 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; { multi_span < int , 2 , 2 , 2 > s = arr3d ; CHECK ( s ( 0 , 0 , 0 ) == 1 ); CHECK ( s ( 1 , 1 , 1 ) == 8 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"comparison_operators\" ) { { int arr [ 10 ][ 2 ]; auto s1 = as_multi_span ( arr ); multi_span < const int , dynamic_range , 2 > s2 = s1 ; CHECK ( s1 == s2 ); multi_span < int , 20 > s3 = as_multi_span ( s1 , dim ( 20 )); CHECK (( s3 == s2 && s3 == s1 )); } { multi_span < int > s1 = nullptr ; multi_span < int > s2 = nullptr ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 2 , 1 }; // bigger multi_span < int > s1 = nullptr ; multi_span < int > s2 = arr ; CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } { int arr1 [] = { 1 , 2 }; int arr2 [] = { 1 , 2 }; multi_span < int > s1 = arr1 ; multi_span < int > s2 = arr2 ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 1 , 2 , 3 }; multi_span < int > s1 = { & arr [ 0 ], 2 }; // shorter multi_span < int > s2 = arr ; // longer CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } { int arr1 [] = { 1 , 2 }; // smaller int arr2 [] = { 2 , 1 }; // bigger multi_span < int > s1 = arr1 ; multi_span < int > s2 = arr2 ; CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"basics\" ) { auto ptr = as_multi_span ( new int [ 10 ], 10 ); fill ( ptr . begin (), ptr . end (), 99 ); for ( int num : ptr ) { CHECK ( num == 99 ); } delete [] ptr . data (); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute TEST_CASE ( \"bounds_checks\" ) { int arr [ 10 ][ 2 ]; auto av = as_multi_span ( arr ); fill ( begin ( av ), end ( av ), 0 ); av [ 2 ][ 0 ] = 1 ; av [ 1 ][ 1 ] = 3 ; // out of bounds CHECK_THROWS_AS ( av [ 1 ][ 3 ] = 3 , fail_fast ); CHECK_THROWS_AS (( av [{ 1 , 3 }] = 3 ), fail_fast ); CHECK_THROWS_AS ( av [ 10 ][ 2 ], fail_fast ); CHECK_THROWS_AS (( av [{ 10 , 2 }]), fail_fast ); CHECK_THROWS_AS ( av [ - 1 ][ 0 ], fail_fast ); CHECK_THROWS_AS (( av [{ - 1 , 0 }]), fail_fast ); CHECK_THROWS_AS ( av [ 0 ][ - 1 ], fail_fast ); CHECK_THROWS_AS (( av [{ 0 , - 1 }]), fail_fast ); } void overloaded_func ( multi_span < const int , dynamic_range , 3 , 5 > exp , int expected_value ) { for ( auto val : exp ) { CHECK ( val == expected_value ); } } void overloaded_func ( multi_span < const char , dynamic_range , 3 , 5 > exp , char expected_value ) { for ( auto val : exp ) { CHECK ( val == expected_value ); } } void fixed_func ( multi_span < int , 3 , 3 , 5 > exp , int expected_value ) { for ( auto val : exp ) { CHECK ( val == expected_value ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute TEST_CASE ( \"span_parameter_test\" ) { auto data = new int [ 4 ][ 3 ][ 5 ]; auto av = as_multi_span ( data , 4 ); CHECK ( av . size () == 60 ); fill ( av . begin (), av . end (), 34 ); int count = 0 ; for_each ( av . rbegin (), av . rend (), [ & ]( int val ) { count += val ; }); CHECK ( count == 34 * 60 ); overloaded_func ( av , 34 ); overloaded_func ( as_multi_span ( av , dim ( 4 ), dim ( 3 ), dim ( 5 )), 34 ); // fixed_func(av, 34); delete [] data ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute // false positive, checker does not recognize multi_span yet GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute TEST_CASE ( \"md_access\" ) { auto width = 5 , height = 20 ; auto imgSize = width * height ; auto image_ptr = new int [ narrow_cast < std :: size_t > ( imgSize )][ 3 ]; // size check will be done auto image_view = as_multi_span ( as_multi_span ( image_ptr , imgSize ), dim ( height ), dim ( width ), dim < 3 > ()); iota ( image_view . begin (), image_view . end (), 1 ); int expected = 0 ; for ( auto i = 0 ; i < height ; i ++ ) { for ( auto j = 0 ; j < width ; j ++ ) { CHECK ( expected + 1 == image_view [ i ][ j ][ 0 ]); CHECK ( expected + 2 == image_view [ i ][ j ][ 1 ]); CHECK ( expected + 3 == image_view [ i ][ j ][ 2 ]); auto val = image_view [{ i , j , 0 }]; CHECK ( expected + 1 == val ); val = image_view [{ i , j , 1 }]; CHECK ( expected + 2 == val ); val = image_view [{ i , j , 2 }]; CHECK ( expected + 3 == val ); expected += 3 ; } } delete [] image_ptr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute TEST_CASE ( \"as_multi_span\" ) { { int * arr = new int [ 150 ]; auto av = as_multi_span ( arr , dim < 10 > (), dim ( 3 ), dim < 5 > ()); fill ( av . begin (), av . end (), 24 ); overloaded_func ( av , 24 ); delete [] arr ; array < int , 15 > stdarr { 0 }; auto av2 = as_multi_span ( stdarr ); overloaded_func ( as_multi_span ( av2 , dim ( 1 ), dim < 3 > (), dim < 5 > ()), 0 ); string str = \"ttttttttttttttt\" ; // size = 15 auto t = str . data (); GSL_SUPPRESS ( type .4 ) // NO-FORMAT: attribute // TODO: false positive ( void ) t ; auto av3 = as_multi_span ( str ); overloaded_func ( as_multi_span ( av3 , dim ( 1 ), dim < 3 > (), dim < 5 > ()), 't' ); } { string str ; multi_span < char > strspan = as_multi_span ( str ); ( void ) strspan ; const string cstr ; multi_span < const char > cstrspan = as_multi_span ( cstr ); ( void ) cstrspan ; } { int a [ 3 ][ 4 ][ 5 ]; auto av = as_multi_span ( a ); const int ( * b )[ 4 ][ 5 ]; b = a ; auto bv = as_multi_span ( b , 3 ); CHECK ( av == bv ); const std :: array < double , 3 > arr = { 0.0 , 0.0 , 0.0 }; auto cv = as_multi_span ( arr ); ( void ) cv ; vector < float > vec ( 3 ); auto dv = as_multi_span ( vec ); ( void ) dv ; #ifdef CONFIRM_COMPILATION_ERRORS auto dv2 = as_multi_span ( std :: move ( vec )); #endif } } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute TEST_CASE ( \"empty_spans\" ) { { multi_span < int , 0 > empty_av ( nullptr ); CHECK ( empty_av . bounds (). index_bounds () == multi_span_index < 1 > { 0 }); CHECK_THROWS_AS ( empty_av [ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_av . begin ()[ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_av . cbegin ()[ 0 ], fail_fast ); for ( auto & v : empty_av ) { ( void ) v ; CHECK ( false ); } } { multi_span < int > empty_av = {}; CHECK ( empty_av . bounds (). index_bounds () == multi_span_index < 1 > { 0 }); CHECK_THROWS_AS ( empty_av [ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_av . begin ()[ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_av . cbegin ()[ 0 ], fail_fast ); for ( auto & v : empty_av ) { ( void ) v ; CHECK ( false ); } } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"index_constructor\" ) { auto arr = new int [ 8 ]; for ( int i = 0 ; i < 4 ; ++ i ) { arr [ 2 * i ] = 4 + i ; arr [ 2 * i + 1 ] = i ; } multi_span < int , dynamic_range > av ( arr , 8 ); ptrdiff_t a [ 1 ] = { 0 }; multi_span_index < 1 > i = a ; CHECK ( av [ i ] == 4 ); auto av2 = as_multi_span ( av , dim < 4 > (), dim ( 2 )); ptrdiff_t a2 [ 2 ] = { 0 , 1 }; multi_span_index < 2 > i2 = a2 ; CHECK ( av2 [ i2 ] == 0 ); CHECK ( av2 [ 0 ][ i ] == 4 ); delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"index_constructors\" ) { { // components of the same type multi_span_index < 3 > i1 ( 0 , 1 , 2 ); CHECK ( i1 [ 0 ] == 0 ); // components of different types std :: size_t c0 = 0 ; std :: size_t c1 = 1 ; multi_span_index < 3 > i2 ( c0 , c1 , 2 ); CHECK ( i2 [ 0 ] == 0 ); // from array multi_span_index < 3 > i3 = { 0 , 1 , 2 }; CHECK ( i3 [ 0 ] == 0 ); // from other index of the same size type multi_span_index < 3 > i4 = i3 ; CHECK ( i4 [ 0 ] == 0 ); // default multi_span_index < 3 > i7 ; CHECK ( i7 [ 0 ] == 0 ); // default multi_span_index < 3 > i9 = {}; CHECK ( i9 [ 0 ] == 0 ); } { // components of the same type multi_span_index < 1 > i1 ( 0 ); CHECK ( i1 [ 0 ] == 0 ); // components of different types std :: size_t c0 = 0 ; multi_span_index < 1 > i2 ( c0 ); CHECK ( i2 [ 0 ] == 0 ); // from array multi_span_index < 1 > i3 = { 0 }; CHECK ( i3 [ 0 ] == 0 ); // from int multi_span_index < 1 > i4 = 0 ; CHECK ( i4 [ 0 ] == 0 ); // from other index of the same size type multi_span_index < 1 > i5 = i3 ; CHECK ( i5 [ 0 ] == 0 ); // default multi_span_index < 1 > i8 ; CHECK ( i8 [ 0 ] == 0 ); // default multi_span_index < 1 > i9 = {}; CHECK ( i9 [ 0 ] == 0 ); } #ifdef CONFIRM_COMPILATION_ERRORS { multi_span_index < 3 > i1 ( 0 , 1 ); multi_span_index < 3 > i2 ( 0 , 1 , 2 , 3 ); multi_span_index < 3 > i3 = { 0 }; multi_span_index < 3 > i4 = { 0 , 1 , 2 , 3 }; multi_span_index < 1 > i5 = { 0 , 1 }; } #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"index_operations\" ) { ptrdiff_t a [ 3 ] = { 0 , 1 , 2 }; ptrdiff_t b [ 3 ] = { 3 , 4 , 5 }; multi_span_index < 3 > i = a ; multi_span_index < 3 > j = b ; CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); { multi_span_index < 3 > k = i + j ; CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); CHECK ( k [ 0 ] == 3 ); CHECK ( k [ 1 ] == 5 ); CHECK ( k [ 2 ] == 7 ); } { multi_span_index < 3 > k = i * 3 ; CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); CHECK ( k [ 0 ] == 0 ); CHECK ( k [ 1 ] == 3 ); CHECK ( k [ 2 ] == 6 ); } { multi_span_index < 3 > k = 3 * i ; CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); CHECK ( k [ 0 ] == 0 ); CHECK ( k [ 1 ] == 3 ); CHECK ( k [ 2 ] == 6 ); } { multi_span_index < 2 > k = details :: shift_left ( i ); CHECK ( i [ 0 ] == 0 ); CHECK ( i [ 1 ] == 1 ); CHECK ( i [ 2 ] == 2 ); CHECK ( k [ 0 ] == 1 ); CHECK ( k [ 1 ] == 2 ); } } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute void iterate_second_column ( multi_span < int , dynamic_range , dynamic_range > av ) { auto length = av . size () / 2 ; // view to the second column auto section = av . section ({ 0 , 1 }, { length , 1 }); CHECK ( section . size () == length ); for ( auto i = 0 ; i < section . size (); ++ i ) { CHECK ( section [ i ][ 0 ] == av [ i ][ 1 ]); } for ( auto i = 0 ; i < section . size (); ++ i ) { auto idx = multi_span_index < 2 > { i , 0 }; // avoid braces inside the CHECK macro CHECK ( section [ idx ] == av [ i ][ 1 ]); } CHECK ( section . bounds (). index_bounds ()[ 0 ] == length ); CHECK ( section . bounds (). index_bounds ()[ 1 ] == 1 ); for ( auto i = 0 ; i < section . bounds (). index_bounds ()[ 0 ]; ++ i ) { for ( auto j = 0 ; j < section . bounds (). index_bounds ()[ 1 ]; ++ j ) { auto idx = multi_span_index < 2 > { i , j }; // avoid braces inside the CHECK macro CHECK ( section [ idx ] == av [ i ][ 1 ]); } } auto check_sum = 0 ; for ( auto i = 0 ; i < length ; ++ i ) { check_sum += av [ i ][ 1 ]; } { auto idx = 0 ; auto sum = 0 ; for ( auto num : section ) { CHECK ( num == av [ idx ][ 1 ]); sum += num ; idx ++ ; } CHECK ( sum == check_sum ); } { auto idx = length - 1 ; auto sum = 0 ; for ( auto iter = section . rbegin (); iter != section . rend (); ++ iter ) { CHECK ( * iter == av [ idx ][ 1 ]); sum += * iter ; idx -- ; } CHECK ( sum == check_sum ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"span_section_iteration\" ) { int arr [ 4 ][ 2 ] = {{ 4 , 0 }, { 5 , 1 }, { 6 , 2 }, { 7 , 3 }}; // static bounds { multi_span < int , 4 , 2 > av = arr ; iterate_second_column ( av ); } // first bound is dynamic { multi_span < int , dynamic_range , 2 > av = arr ; iterate_second_column ( av ); } // second bound is dynamic { multi_span < int , 4 , dynamic_range > av = arr ; iterate_second_column ( av ); } // both bounds are dynamic { multi_span < int , dynamic_range , dynamic_range > av = arr ; iterate_second_column ( av ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"dynamic_span_section_iteration\" ) { auto height = 4 , width = 2 ; auto size = height * width ; auto arr = new int [ narrow_cast < std :: size_t > ( size )]; for ( auto i = 0 ; i < size ; ++ i ) { arr [ i ] = i ; } auto av = as_multi_span ( arr , size ); // first bound is dynamic { multi_span < int , dynamic_range , 2 > av2 = as_multi_span ( av , dim ( height ), dim ( width )); iterate_second_column ( av2 ); } // second bound is dynamic { multi_span < int , 4 , dynamic_range > av2 = as_multi_span ( av , dim ( height ), dim ( width )); iterate_second_column ( av2 ); } // both bounds are dynamic { multi_span < int , dynamic_range , dynamic_range > av2 = as_multi_span ( av , dim ( height ), dim ( width )); iterate_second_column ( av2 ); } delete [] arr ; } GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute TEST_CASE ( \"span_structure_size\" ) { double ( * arr )[ 3 ][ 4 ] = new double [ 100 ][ 3 ][ 4 ]; multi_span < double , dynamic_range , 3 , 4 > av1 ( arr , 10 ); struct EffectiveStructure { double * v1 ; ptrdiff_t v2 ; }; CHECK ( sizeof ( av1 ) == sizeof ( EffectiveStructure )); CHECK_THROWS_AS ( av1 [ 10 ][ 3 ][ 4 ], fail_fast ); multi_span < const double , dynamic_range , 6 , 4 > av2 = as_multi_span ( av1 , dim ( 5 ), dim < 6 > (), dim < 4 > ()); ( void ) av2 ; delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"fixed_size_conversions\" ) { int arr [] = { 1 , 2 , 3 , 4 }; // converting to an multi_span from an equal size array is ok multi_span < int , 4 > av4 = arr ; CHECK ( av4 . length () == 4 ); // converting to dynamic_range a_v is always ok { multi_span < int , dynamic_range > av = av4 ; ( void ) av ; } { multi_span < int , dynamic_range > av = arr ; ( void ) av ; } // initialization or assignment to static multi_span that REDUCES size is NOT ok #ifdef CONFIRM_COMPILATION_ERRORS { multi_span < int , 2 > av2 = arr ; } { multi_span < int , 2 > av2 = av4 ; } #endif { multi_span < int , dynamic_range > av = arr ; multi_span < int , 2 > av2 = av ; ( void ) av2 ; } #ifdef CONFIRM_COMPILATION_ERRORS { multi_span < int , dynamic_range > av = arr ; multi_span < int , 2 , 1 > av2 = av . as_multi_span ( dim < 2 > (), dim < 2 > ()); } #endif { multi_span < int , dynamic_range > av = arr ; multi_span < int , 2 , 1 > av2 = as_multi_span ( av , dim ( 2 ), dim ( 2 )); auto workaround_macro = [ & ]() { return av2 [{ 1 , 0 }] == 2 ; }; CHECK ( workaround_macro ()); } // but doing so explicitly is ok // you can convert statically { multi_span < int , 2 > av2 = { arr , 2 }; ( void ) av2 ; } { multi_span < int , 1 > av2 = av4 . first < 1 > (); ( void ) av2 ; } // ...or dynamically { // NB: implicit conversion to multi_span<int,2> from multi_span<int,dynamic_range> multi_span < int , 1 > av2 = av4 . first ( 1 ); ( void ) av2 ; } // initialization or assignment to static multi_span that requires size INCREASE is not ok. int arr2 [ 2 ] = { 1 , 2 }; #ifdef CONFIRM_COMPILATION_ERRORS { multi_span < int , 4 > av4 = arr2 ; } { multi_span < int , 2 > av2 = arr2 ; multi_span < int , 4 > av4 = av2 ; } #endif { auto f = [ & ]() { const multi_span < int , 4 > av9 = { arr2 , 2 }; ( void ) av9 ; }; CHECK_THROWS_AS ( f (), fail_fast ); } // this should fail - we are trying to assign a small dynamic a_v to a fixed_size larger one multi_span < int , dynamic_range > av = arr2 ; auto f = [ & ]() { const multi_span < int , 4 > av2 = av ; ( void ) av2 ; }; CHECK_THROWS_AS ( f (), fail_fast ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_writeable_bytes\" ) { int a [] = { 1 , 2 , 3 , 4 }; { #ifdef CONFIRM_COMPILATION_ERRORS // you should not be able to get writeable bytes for const objects multi_span < const int , dynamic_range > av = a ; auto wav = av . as_writeable_bytes (); #endif } { multi_span < int , dynamic_range > av ; auto wav = as_writeable_bytes ( av ); CHECK ( wav . length () == av . length ()); CHECK ( wav . length () == 0 ); CHECK ( wav . size_bytes () == 0 ); } { multi_span < int , dynamic_range > av = a ; auto wav = as_writeable_bytes ( av ); CHECK ( wav . data () == reinterpret_cast < byte *> ( & a [ 0 ])); CHECK ( static_cast < std :: size_t > ( wav . length ()) == sizeof ( a )); } } GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"iterator\" ) { int a [] = { 1 , 2 , 3 , 4 }; { multi_span < int , dynamic_range > av = a ; auto wav = as_writeable_bytes ( av ); for ( auto & b : wav ) { #if defined(__cplusplus) && (__cplusplus >= 201703L) b = byte { 0 }; #else GSL_SUPPRESS ( es .49 ) b = byte ( 0 ); #endif } for ( std :: size_t i = 0 ; i < 4 ; ++ i ) { CHECK ( a [ i ] == 0 ); } } { multi_span < int , dynamic_range > av = a ; for ( auto & n : av ) { n = 1 ; } for ( std :: size_t i = 0 ; i < 4 ; ++ i ) { CHECK ( a [ i ] == 1 ); } } } #ifdef CONFIRM_COMPILATION_ERRORS copy ( src_span_static , dst_span_static ); #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic pop #endif","title":"File multi_span_tests.cpp"},{"location":"namespace_0d11/","text":"Namespace @11 \u00b6 Class List > @11 The documentation for this class was generated from the following file external/guideline/tests/span_tests.cpp","title":"Namespace @11"},{"location":"namespace_0d11/#namespace-11","text":"Class List > @11 The documentation for this class was generated from the following file external/guideline/tests/span_tests.cpp","title":"Namespace @11"},{"location":"namespace_0d13/","text":"Namespace @13 \u00b6 Class List > @13 The documentation for this class was generated from the following file external/guideline/tests/strided_span_tests.cpp","title":"Namespace @13"},{"location":"namespace_0d13/#namespace-13","text":"Class List > @13 The documentation for this class was generated from the following file external/guideline/tests/strided_span_tests.cpp","title":"Namespace @13"},{"location":"namespace_0d4/","text":"Namespace @4 \u00b6 Class List > @4 The documentation for this class was generated from the following file external/guideline/tests/bounds_tests.cpp","title":"Namespace @4"},{"location":"namespace_0d4/#namespace-4","text":"Class List > @4 The documentation for this class was generated from the following file external/guideline/tests/bounds_tests.cpp","title":"Namespace @4"},{"location":"namespace_0d5/","text":"Namespace @5 \u00b6 Class List > @5 The documentation for this class was generated from the following file external/guideline/tests/byte_tests.cpp","title":"Namespace @5"},{"location":"namespace_0d5/#namespace-5","text":"Class List > @5 The documentation for this class was generated from the following file external/guideline/tests/byte_tests.cpp","title":"Namespace @5"},{"location":"namespace_0d6/","text":"Namespace @6 \u00b6 Class List > @6 The documentation for this class was generated from the following file external/guideline/tests/multi_span_tests.cpp","title":"Namespace @6"},{"location":"namespace_0d6/#namespace-6","text":"Class List > @6 The documentation for this class was generated from the following file external/guideline/tests/multi_span_tests.cpp","title":"Namespace @6"},{"location":"namespace_member_enums/","text":"Namespace Member Enums \u00b6","title":"Namespace Member Enums"},{"location":"namespace_member_enums/#namespace-member-enums","text":"","title":"Namespace Member Enums"},{"location":"namespace_member_functions/","text":"Namespace Member Functions \u00b6 c \u00b6 consume_event ( coro ) coroutine_pthread_resume ( coro ) e \u00b6 enumerate_addrinfo ( coro ) enumerate_net_tasks ( coro ) g \u00b6 GSL_SUPPRESS ( coro , generic ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro ) get_threads_of ( coro ) i \u00b6 is_async_pending ( coro ) is_signaled ( coro ) n \u00b6 notify_event ( coro ) noop_coroutine ( std::experimental ) o \u00b6 onWorkDone ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental ) p \u00b6 poison ( coro::internal ) r \u00b6 recv_from ( coro ) recv_stream ( coro ) render_temp_name ( coro ) resolve ( coro ) resolve_error ( coro ) s \u00b6 select ( coro ) send_stream ( coro ) send_to ( coro ) signaled_event_tasks ( coro ) w \u00b6 wait_net_tasks ( coro ) wait_on_thread_pool ( coro ) z \u00b6 zero_overlapped ( coro )","title":"Namespace Member Functions"},{"location":"namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"namespace_member_functions/#c","text":"consume_event ( coro ) coroutine_pthread_resume ( coro )","title":"c"},{"location":"namespace_member_functions/#e","text":"enumerate_addrinfo ( coro ) enumerate_net_tasks ( coro )","title":"e"},{"location":"namespace_member_functions/#g","text":"GSL_SUPPRESS ( coro , generic ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro ) get_threads_of ( coro )","title":"g"},{"location":"namespace_member_functions/#i","text":"is_async_pending ( coro ) is_signaled ( coro )","title":"i"},{"location":"namespace_member_functions/#n","text":"notify_event ( coro ) noop_coroutine ( std::experimental )","title":"n"},{"location":"namespace_member_functions/#o","text":"onWorkDone ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental )","title":"o"},{"location":"namespace_member_functions/#p","text":"poison ( coro::internal )","title":"p"},{"location":"namespace_member_functions/#r","text":"recv_from ( coro ) recv_stream ( coro ) render_temp_name ( coro ) resolve ( coro ) resolve_error ( coro )","title":"r"},{"location":"namespace_member_functions/#s","text":"select ( coro ) send_stream ( coro ) send_to ( coro ) signaled_event_tasks ( coro )","title":"s"},{"location":"namespace_member_functions/#w","text":"wait_net_tasks ( coro ) wait_on_thread_pool ( coro )","title":"w"},{"location":"namespace_member_functions/#z","text":"zero_overlapped ( coro )","title":"z"},{"location":"namespace_member_typedefs/","text":"Namespace Member Typedefs \u00b6 c \u00b6 czstring_host ( coro ) czstring_serv ( coro ) i \u00b6 io_buffer_t ( coro ) io_task_t ( coro ) n \u00b6 noop_coroutine_handle ( std::experimental ) z \u00b6 zstring_host ( coro ) zstring_serv ( coro )","title":"Namespace Member Typedefs"},{"location":"namespace_member_typedefs/#namespace-member-typedefs","text":"","title":"Namespace Member Typedefs"},{"location":"namespace_member_typedefs/#c","text":"czstring_host ( coro ) czstring_serv ( coro )","title":"c"},{"location":"namespace_member_typedefs/#i","text":"io_buffer_t ( coro ) io_task_t ( coro )","title":"i"},{"location":"namespace_member_typedefs/#n","text":"noop_coroutine_handle ( std::experimental )","title":"n"},{"location":"namespace_member_typedefs/#z","text":"zstring_host ( coro ) zstring_serv ( coro )","title":"z"},{"location":"namespace_member_variables/","text":"Namespace Member Variables \u00b6 e \u00b6 emask ( coro ) i \u00b6 inbound ( coro ) k \u00b6 kq ( coro ) n \u00b6 n ( generic ) o \u00b6 outbound ( coro ) s \u00b6 selist ( coro )","title":"Namespace Member Variables"},{"location":"namespace_member_variables/#namespace-member-variables","text":"","title":"Namespace Member Variables"},{"location":"namespace_member_variables/#e","text":"emask ( coro )","title":"e"},{"location":"namespace_member_variables/#i","text":"inbound ( coro )","title":"i"},{"location":"namespace_member_variables/#k","text":"kq ( coro )","title":"k"},{"location":"namespace_member_variables/#n","text":"n ( generic )","title":"n"},{"location":"namespace_member_variables/#o","text":"outbound ( coro )","title":"o"},{"location":"namespace_member_variables/#s","text":"selist ( coro )","title":"s"},{"location":"namespace_members/","text":"Namespace Members \u00b6 c \u00b6 consume_event ( coro ) coroutine_pthread_resume ( coro ) czstring_host ( coro ) czstring_serv ( coro ) e \u00b6 emask ( coro ) enumerate_addrinfo ( coro ) enumerate_net_tasks ( coro ) g \u00b6 GSL_SUPPRESS ( coro , generic ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro ) get_threads_of ( coro ) i \u00b6 inbound ( coro ) io_buffer_t ( coro ) io_task_t ( coro ) is_async_pending ( coro ) is_signaled ( coro ) k \u00b6 kq ( coro ) n \u00b6 notify_event ( coro ) n ( generic ) noop_coroutine ( std::experimental ) noop_coroutine_handle ( std::experimental ) o \u00b6 onWorkDone ( coro ) outbound ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental ) p \u00b6 poison ( coro::internal ) r \u00b6 recv_from ( coro ) recv_stream ( coro ) render_temp_name ( coro ) resolve ( coro ) resolve_error ( coro ) s \u00b6 select ( coro ) selist ( coro ) send_stream ( coro ) send_to ( coro ) signaled_event_tasks ( coro ) w \u00b6 wait_net_tasks ( coro ) wait_on_thread_pool ( coro ) z \u00b6 zero_overlapped ( coro ) zstring_host ( coro ) zstring_serv ( coro )","title":"Namespace Members"},{"location":"namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"namespace_members/#c","text":"consume_event ( coro ) coroutine_pthread_resume ( coro ) czstring_host ( coro ) czstring_serv ( coro )","title":"c"},{"location":"namespace_members/#e","text":"emask ( coro ) enumerate_addrinfo ( coro ) enumerate_net_tasks ( coro )","title":"e"},{"location":"namespace_members/#g","text":"GSL_SUPPRESS ( coro , generic ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro ) get_threads_of ( coro )","title":"g"},{"location":"namespace_members/#i","text":"inbound ( coro ) io_buffer_t ( coro ) io_task_t ( coro ) is_async_pending ( coro ) is_signaled ( coro )","title":"i"},{"location":"namespace_members/#k","text":"kq ( coro )","title":"k"},{"location":"namespace_members/#n","text":"notify_event ( coro ) n ( generic ) noop_coroutine ( std::experimental ) noop_coroutine_handle ( std::experimental )","title":"n"},{"location":"namespace_members/#o","text":"onWorkDone ( coro ) outbound ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental )","title":"o"},{"location":"namespace_members/#p","text":"poison ( coro::internal )","title":"p"},{"location":"namespace_members/#r","text":"recv_from ( coro ) recv_stream ( coro ) render_temp_name ( coro ) resolve ( coro ) resolve_error ( coro )","title":"r"},{"location":"namespace_members/#s","text":"select ( coro ) selist ( coro ) send_stream ( coro ) send_to ( coro ) signaled_event_tasks ( coro )","title":"s"},{"location":"namespace_members/#w","text":"wait_net_tasks ( coro ) wait_on_thread_pool ( coro )","title":"w"},{"location":"namespace_members/#z","text":"zero_overlapped ( coro ) zstring_host ( coro ) zstring_serv ( coro )","title":"z"},{"location":"namespacecoro/","text":"Namespace coro \u00b6 Class List > coro Namespaces \u00b6 Type Name namespace internal Classes \u00b6 Type Name struct bypass_lock class channel <typename T, typename M> struct darwin_event class enumerable <T> struct event_poll_t class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class io_recv class io_recv_from class io_send class io_send_to class io_work_t struct kernel_queue_t class peeker <typename T, typename M> class promise_aa class promise_an class promise_na class promise_nn class reader <typename T, typename M> class writer <typename T, typename M> Public Types \u00b6 Type Name typedef gsl::czstring< NI_MAXHOST > czstring_host typedef gsl::czstring< NI_MAXSERV > czstring_serv typedef gsl::span< std::byte > io_buffer_t typedef coroutine_handle < void > io_task_t typedef gsl::zstring< NI_MAXHOST > zstring_host typedef gsl::zstring< NI_MAXSERV > zstring_serv Public Attributes \u00b6 Type Name constexpr uint64_t emask = = 1ULL << 63 event_poll_t inbound = {} kernel_queue_t kq = {} event_poll_t outbound = {} kernel_queue_t selist = {} Public Functions \u00b6 Type Name GSL_SUPPRESS (f . 4) noexcept void consume_event (int64_t efd) noexcept void * coroutine_pthread_resume (void * ptr) noexcept auto enumerate_addrinfo (gsl::not_null< addrinfo * > list) noexcept auto enumerate_net_tasks (nanoseconds timeout) noexcept int64_t get_eventfd (uint64_t state) noexcept uint32_t get_io_error (const OVERLAPPED * target) noexcept int64_t get_io_length (const OVERLAPPED * target) noexcept _INTERFACE_ int32_t get_name (const sockaddr_in & addr, zstring_host name, zstring_serv serv, int32_t flags=NI_NUMERICHOST _INTERFACE_ int32_t get_name (const sockaddr_in6 & addr, zstring_host name, zstring_serv serv, int32_t flags=NI_NUMERICHOST auto get_threads_of (DWORD pid) noexcept bool is_async_pending (int ec) noexcept bool is_signaled (uint64_t state) noexcept void notify_event (int64_t efd) noexcept void CALLBACK onWorkDone (DWORD errc, DWORD sz, LPWSAOVERLAPPED pover, DWORD flags) noexcept _INTERFACE_ auto recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept _INTERFACE_ auto recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept _INTERFACE_ auto recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept int32_t render_temp_name (char * buffer) noexcept _INTERFACE_ int32_t resolve ( enumerable < sockaddr > & g, const addrinfo & hint, czstring_host name, czstring_serv serv) noexcept auto resolve (const addrinfo & hint, czstring_host name, czstring_serv serv) noexcept _INTERFACE_ auto resolve_error (int32_t ec) noexcept void select ( channel < T, M > & ch, Fn && fn) noexcept void select (ChanType & ch, FuncType && fn, Args &&... args) noexcept _INTERFACE_ auto send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept _INTERFACE_ auto send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept _INTERFACE_ auto send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept auto signaled_event_tasks () noexcept _INTERFACE_ void wait_net_tasks ( enumerable < io_task_t > & tasks, chrono::nanoseconds timeout) noexcept auto wait_net_tasks (chrono::nanoseconds timeout) noexcept void wait_net_tasks ( coro::enumerable < io_task_t > & tasks, std::chrono::nanoseconds timeout) noexcept void __stdcall wait_on_thread_pool (PVOID ctx, BOOLEAN timedout) auto zero_overlapped (gsl::not_null< io_control_block * > work) noexcept Public Types Documentation \u00b6 typedef czstring_host \u00b6 using coro :: czstring_host = typedef gsl :: czstring < NI_MAXHOST > ; typedef czstring_serv \u00b6 using coro :: czstring_serv = typedef gsl :: czstring < NI_MAXSERV > ; typedef io_buffer_t \u00b6 using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ; typedef io_task_t \u00b6 using coro :: io_task_t = typedef coroutine_handle < void > ; typedef zstring_host \u00b6 using coro :: zstring_host = typedef gsl :: zstring < NI_MAXHOST > ; typedef zstring_serv \u00b6 using coro :: zstring_serv = typedef gsl :: zstring < NI_MAXSERV > ; Public Attributes Documentation \u00b6 variable emask \u00b6 constexpr uint64_t coro :: emask ; variable inbound \u00b6 event_poll_t coro :: inbound ; variable kq \u00b6 kernel_queue_t coro :: kq ; variable outbound \u00b6 event_poll_t coro :: outbound ; variable selist \u00b6 event_poll_t coro :: selist ; Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 coro :: GSL_SUPPRESS ( f . 4 ) noexcept function consume_event \u00b6 void coro :: consume_event ( int64_t efd ) noexcept function coroutine_pthread_resume \u00b6 void * coro :: coroutine_pthread_resume ( void * ptr ) noexcept function enumerate_addrinfo \u00b6 auto coro :: enumerate_addrinfo ( gsl :: not_null < addrinfo * > list ) noexcept function enumerate_net_tasks \u00b6 auto coro :: enumerate_net_tasks ( nanoseconds timeout ) noexcept function get_eventfd \u00b6 int64_t coro :: get_eventfd ( uint64_t state ) noexcept function get_io_error \u00b6 uint32_t coro :: get_io_error ( const OVERLAPPED * target ) noexcept function get_io_length \u00b6 int64_t coro :: get_io_length ( const OVERLAPPED * target ) noexcept function get_name \u00b6 _INTERFACE_ int32_t coro :: get_name ( const sockaddr_in & addr , zstring_host name , zstring_serv serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept function get_name \u00b6 _INTERFACE_ int32_t coro :: get_name ( const sockaddr_in6 & addr , zstring_host name , zstring_serv serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept function get_threads_of \u00b6 auto coro :: get_threads_of ( DWORD pid ) noexcept function is_async_pending \u00b6 bool coro :: is_async_pending ( int ec ) noexcept function is_signaled \u00b6 bool coro :: is_signaled ( uint64_t state ) noexcept function notify_event \u00b6 void coro :: notify_event ( int64_t efd ) noexcept function onWorkDone \u00b6 void CALLBACK coro :: onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept function recv_from \u00b6 _INTERFACE_ auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept function recv_from \u00b6 _INTERFACE_ auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept function recv_stream \u00b6 _INTERFACE_ auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept function render_temp_name \u00b6 int32_t coro :: render_temp_name ( char * buffer ) noexcept function resolve \u00b6 _INTERFACE_ int32_t coro :: resolve ( enumerable < sockaddr > & g , const addrinfo & hint , czstring_host name , czstring_serv serv ) noexcept function resolve \u00b6 inline auto coro :: resolve ( const addrinfo & hint , czstring_host name , czstring_serv serv ) noexcept function resolve_error \u00b6 _INTERFACE_ auto coro :: resolve_error ( int32_t ec ) noexcept function select \u00b6 template < typename T typename T , typename M typename M , typename Fn typename Fn > void coro :: select ( channel < T , M > & ch , Fn && fn ) noexcept function select \u00b6 template < typename ... Args , typename ChanType typename ChanType , typename FuncType typename FuncType > void coro :: select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept function send_stream \u00b6 _INTERFACE_ auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept function send_to \u00b6 _INTERFACE_ auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept function send_to \u00b6 _INTERFACE_ auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept function signaled_event_tasks \u00b6 auto coro :: signaled_event_tasks () noexcept function wait_net_tasks \u00b6 _INTERFACE_ void coro :: wait_net_tasks ( enumerable < io_task_t > & tasks , chrono :: nanoseconds timeout ) noexcept function wait_net_tasks \u00b6 inline auto coro :: wait_net_tasks ( chrono :: nanoseconds timeout ) noexcept function wait_net_tasks \u00b6 void coro :: wait_net_tasks ( coro :: enumerable < io_task_t > & tasks , std :: chrono :: nanoseconds timeout ) noexcept function wait_on_thread_pool \u00b6 void __stdcall coro :: wait_on_thread_pool ( PVOID ctx , BOOLEAN timedout ) function zero_overlapped \u00b6 auto coro :: zero_overlapped ( gsl :: not_null < io_control_block * > work ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Namespace coro"},{"location":"namespacecoro/#namespace-coro","text":"Class List > coro","title":"Namespace coro"},{"location":"namespacecoro/#namespaces","text":"Type Name namespace internal","title":"Namespaces"},{"location":"namespacecoro/#classes","text":"Type Name struct bypass_lock class channel <typename T, typename M> struct darwin_event class enumerable <T> struct event_poll_t class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class io_recv class io_recv_from class io_send class io_send_to class io_work_t struct kernel_queue_t class peeker <typename T, typename M> class promise_aa class promise_an class promise_na class promise_nn class reader <typename T, typename M> class writer <typename T, typename M>","title":"Classes"},{"location":"namespacecoro/#public-types","text":"Type Name typedef gsl::czstring< NI_MAXHOST > czstring_host typedef gsl::czstring< NI_MAXSERV > czstring_serv typedef gsl::span< std::byte > io_buffer_t typedef coroutine_handle < void > io_task_t typedef gsl::zstring< NI_MAXHOST > zstring_host typedef gsl::zstring< NI_MAXSERV > zstring_serv","title":"Public Types"},{"location":"namespacecoro/#public-attributes","text":"Type Name constexpr uint64_t emask = = 1ULL << 63 event_poll_t inbound = {} kernel_queue_t kq = {} event_poll_t outbound = {} kernel_queue_t selist = {}","title":"Public Attributes"},{"location":"namespacecoro/#public-functions","text":"Type Name GSL_SUPPRESS (f . 4) noexcept void consume_event (int64_t efd) noexcept void * coroutine_pthread_resume (void * ptr) noexcept auto enumerate_addrinfo (gsl::not_null< addrinfo * > list) noexcept auto enumerate_net_tasks (nanoseconds timeout) noexcept int64_t get_eventfd (uint64_t state) noexcept uint32_t get_io_error (const OVERLAPPED * target) noexcept int64_t get_io_length (const OVERLAPPED * target) noexcept _INTERFACE_ int32_t get_name (const sockaddr_in & addr, zstring_host name, zstring_serv serv, int32_t flags=NI_NUMERICHOST _INTERFACE_ int32_t get_name (const sockaddr_in6 & addr, zstring_host name, zstring_serv serv, int32_t flags=NI_NUMERICHOST auto get_threads_of (DWORD pid) noexcept bool is_async_pending (int ec) noexcept bool is_signaled (uint64_t state) noexcept void notify_event (int64_t efd) noexcept void CALLBACK onWorkDone (DWORD errc, DWORD sz, LPWSAOVERLAPPED pover, DWORD flags) noexcept _INTERFACE_ auto recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept _INTERFACE_ auto recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept _INTERFACE_ auto recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept int32_t render_temp_name (char * buffer) noexcept _INTERFACE_ int32_t resolve ( enumerable < sockaddr > & g, const addrinfo & hint, czstring_host name, czstring_serv serv) noexcept auto resolve (const addrinfo & hint, czstring_host name, czstring_serv serv) noexcept _INTERFACE_ auto resolve_error (int32_t ec) noexcept void select ( channel < T, M > & ch, Fn && fn) noexcept void select (ChanType & ch, FuncType && fn, Args &&... args) noexcept _INTERFACE_ auto send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept _INTERFACE_ auto send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept _INTERFACE_ auto send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept auto signaled_event_tasks () noexcept _INTERFACE_ void wait_net_tasks ( enumerable < io_task_t > & tasks, chrono::nanoseconds timeout) noexcept auto wait_net_tasks (chrono::nanoseconds timeout) noexcept void wait_net_tasks ( coro::enumerable < io_task_t > & tasks, std::chrono::nanoseconds timeout) noexcept void __stdcall wait_on_thread_pool (PVOID ctx, BOOLEAN timedout) auto zero_overlapped (gsl::not_null< io_control_block * > work) noexcept","title":"Public Functions"},{"location":"namespacecoro/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"namespacecoro/#typedef-czstring95host","text":"using coro :: czstring_host = typedef gsl :: czstring < NI_MAXHOST > ;","title":"typedef czstring_host"},{"location":"namespacecoro/#typedef-czstring95serv","text":"using coro :: czstring_serv = typedef gsl :: czstring < NI_MAXSERV > ;","title":"typedef czstring_serv"},{"location":"namespacecoro/#typedef-io95buffer95t","text":"using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ;","title":"typedef io_buffer_t"},{"location":"namespacecoro/#typedef-io95task95t","text":"using coro :: io_task_t = typedef coroutine_handle < void > ;","title":"typedef io_task_t"},{"location":"namespacecoro/#typedef-zstring95host","text":"using coro :: zstring_host = typedef gsl :: zstring < NI_MAXHOST > ;","title":"typedef zstring_host"},{"location":"namespacecoro/#typedef-zstring95serv","text":"using coro :: zstring_serv = typedef gsl :: zstring < NI_MAXSERV > ;","title":"typedef zstring_serv"},{"location":"namespacecoro/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"namespacecoro/#variable-emask","text":"constexpr uint64_t coro :: emask ;","title":"variable emask"},{"location":"namespacecoro/#variable-inbound","text":"event_poll_t coro :: inbound ;","title":"variable inbound"},{"location":"namespacecoro/#variable-kq","text":"kernel_queue_t coro :: kq ;","title":"variable kq"},{"location":"namespacecoro/#variable-outbound","text":"event_poll_t coro :: outbound ;","title":"variable outbound"},{"location":"namespacecoro/#variable-selist","text":"event_poll_t coro :: selist ;","title":"variable selist"},{"location":"namespacecoro/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"namespacecoro/#function-gsl95suppress","text":"coro :: GSL_SUPPRESS ( f . 4 ) noexcept","title":"function GSL_SUPPRESS"},{"location":"namespacecoro/#function-consume95event","text":"void coro :: consume_event ( int64_t efd ) noexcept","title":"function consume_event"},{"location":"namespacecoro/#function-coroutine95pthread95resume","text":"void * coro :: coroutine_pthread_resume ( void * ptr ) noexcept","title":"function coroutine_pthread_resume"},{"location":"namespacecoro/#function-enumerate95addrinfo","text":"auto coro :: enumerate_addrinfo ( gsl :: not_null < addrinfo * > list ) noexcept","title":"function enumerate_addrinfo"},{"location":"namespacecoro/#function-enumerate95net95tasks","text":"auto coro :: enumerate_net_tasks ( nanoseconds timeout ) noexcept","title":"function enumerate_net_tasks"},{"location":"namespacecoro/#function-get95eventfd","text":"int64_t coro :: get_eventfd ( uint64_t state ) noexcept","title":"function get_eventfd"},{"location":"namespacecoro/#function-get95io95error","text":"uint32_t coro :: get_io_error ( const OVERLAPPED * target ) noexcept","title":"function get_io_error"},{"location":"namespacecoro/#function-get95io95length","text":"int64_t coro :: get_io_length ( const OVERLAPPED * target ) noexcept","title":"function get_io_length"},{"location":"namespacecoro/#function-get95name","text":"_INTERFACE_ int32_t coro :: get_name ( const sockaddr_in & addr , zstring_host name , zstring_serv serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept","title":"function get_name"},{"location":"namespacecoro/#function-get95name_1","text":"_INTERFACE_ int32_t coro :: get_name ( const sockaddr_in6 & addr , zstring_host name , zstring_serv serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept","title":"function get_name"},{"location":"namespacecoro/#function-get95threads95of","text":"auto coro :: get_threads_of ( DWORD pid ) noexcept","title":"function get_threads_of"},{"location":"namespacecoro/#function-is95async95pending","text":"bool coro :: is_async_pending ( int ec ) noexcept","title":"function is_async_pending"},{"location":"namespacecoro/#function-is95signaled","text":"bool coro :: is_signaled ( uint64_t state ) noexcept","title":"function is_signaled"},{"location":"namespacecoro/#function-notify95event","text":"void coro :: notify_event ( int64_t efd ) noexcept","title":"function notify_event"},{"location":"namespacecoro/#function-onworkdone","text":"void CALLBACK coro :: onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept","title":"function onWorkDone"},{"location":"namespacecoro/#function-recv95from","text":"_INTERFACE_ auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept","title":"function recv_from"},{"location":"namespacecoro/#function-recv95from_1","text":"_INTERFACE_ auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept","title":"function recv_from"},{"location":"namespacecoro/#function-recv95stream","text":"_INTERFACE_ auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept","title":"function recv_stream"},{"location":"namespacecoro/#function-render95temp95name","text":"int32_t coro :: render_temp_name ( char * buffer ) noexcept","title":"function render_temp_name"},{"location":"namespacecoro/#function-resolve","text":"_INTERFACE_ int32_t coro :: resolve ( enumerable < sockaddr > & g , const addrinfo & hint , czstring_host name , czstring_serv serv ) noexcept","title":"function resolve"},{"location":"namespacecoro/#function-resolve_1","text":"inline auto coro :: resolve ( const addrinfo & hint , czstring_host name , czstring_serv serv ) noexcept","title":"function resolve"},{"location":"namespacecoro/#function-resolve95error","text":"_INTERFACE_ auto coro :: resolve_error ( int32_t ec ) noexcept","title":"function resolve_error"},{"location":"namespacecoro/#function-select","text":"template < typename T typename T , typename M typename M , typename Fn typename Fn > void coro :: select ( channel < T , M > & ch , Fn && fn ) noexcept","title":"function select"},{"location":"namespacecoro/#function-select_1","text":"template < typename ... Args , typename ChanType typename ChanType , typename FuncType typename FuncType > void coro :: select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept","title":"function select"},{"location":"namespacecoro/#function-send95stream","text":"_INTERFACE_ auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept","title":"function send_stream"},{"location":"namespacecoro/#function-send95to","text":"_INTERFACE_ auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept","title":"function send_to"},{"location":"namespacecoro/#function-send95to_1","text":"_INTERFACE_ auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept","title":"function send_to"},{"location":"namespacecoro/#function-signaled95event95tasks","text":"auto coro :: signaled_event_tasks () noexcept","title":"function signaled_event_tasks"},{"location":"namespacecoro/#function-wait95net95tasks","text":"_INTERFACE_ void coro :: wait_net_tasks ( enumerable < io_task_t > & tasks , chrono :: nanoseconds timeout ) noexcept","title":"function wait_net_tasks"},{"location":"namespacecoro/#function-wait95net95tasks_1","text":"inline auto coro :: wait_net_tasks ( chrono :: nanoseconds timeout ) noexcept","title":"function wait_net_tasks"},{"location":"namespacecoro/#function-wait95net95tasks_2","text":"void coro :: wait_net_tasks ( coro :: enumerable < io_task_t > & tasks , std :: chrono :: nanoseconds timeout ) noexcept","title":"function wait_net_tasks"},{"location":"namespacecoro/#function-wait95on95thread95pool","text":"void __stdcall coro :: wait_on_thread_pool ( PVOID ctx , BOOLEAN timedout )","title":"function wait_on_thread_pool"},{"location":"namespacecoro/#function-zero95overlapped","text":"auto coro :: zero_overlapped ( gsl :: not_null < io_control_block * > work ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function zero_overlapped"},{"location":"namespacecoro_1_1internal/","text":"Namespace coro::internal \u00b6 Class List > coro > internal Classes \u00b6 Type Name class list <T> Public Static Functions \u00b6 Type Name void * poison () noexcept Public Static Functions Documentation \u00b6 function poison \u00b6 static inline void * coro :: internal :: poison () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Namespace coro::internal"},{"location":"namespacecoro_1_1internal/#namespace-corointernal","text":"Class List > coro > internal","title":"Namespace coro::internal"},{"location":"namespacecoro_1_1internal/#classes","text":"Type Name class list <T>","title":"Classes"},{"location":"namespacecoro_1_1internal/#public-static-functions","text":"Type Name void * poison () noexcept","title":"Public Static Functions"},{"location":"namespacecoro_1_1internal/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"namespacecoro_1_1internal/#function-poison","text":"static inline void * coro :: internal :: poison () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function poison"},{"location":"namespacegeneric/","text":"Namespace generic \u00b6 Class List > generic Public Attributes \u00b6 Type Name std::size_t n = { return std::find(s, s + n, CharT{0}) - s Public Functions \u00b6 Type Name GSL_SUPPRESS (bounds. 1) const Public Attributes Documentation \u00b6 variable n \u00b6 std :: size_t generic :: n ; Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 template < typename CharT typename CharT > generic :: GSL_SUPPRESS ( bounds . 1 ) const The documentation for this class was generated from the following file external/guideline/tests/string_span_tests.cpp","title":"Namespace generic"},{"location":"namespacegeneric/#namespace-generic","text":"Class List > generic","title":"Namespace generic"},{"location":"namespacegeneric/#public-attributes","text":"Type Name std::size_t n = { return std::find(s, s + n, CharT{0}) - s","title":"Public Attributes"},{"location":"namespacegeneric/#public-functions","text":"Type Name GSL_SUPPRESS (bounds. 1) const","title":"Public Functions"},{"location":"namespacegeneric/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"namespacegeneric/#variable-n","text":"std :: size_t generic :: n ;","title":"variable n"},{"location":"namespacegeneric/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"namespacegeneric/#function-gsl95suppress","text":"template < typename CharT typename CharT > generic :: GSL_SUPPRESS ( bounds . 1 ) const The documentation for this class was generated from the following file external/guideline/tests/string_span_tests.cpp","title":"function GSL_SUPPRESS"},{"location":"namespacegsl/","text":"Namespace gsl \u00b6 Class List > gsl The documentation for this class was generated from the following file external/guideline/tests/algorithm_tests.cpp","title":"Namespace gsl"},{"location":"namespacegsl/#namespace-gsl","text":"Class List > gsl The documentation for this class was generated from the following file external/guideline/tests/algorithm_tests.cpp","title":"Namespace gsl"},{"location":"namespaces/","text":"Namespace List \u00b6 Here is a list of all namespaces with brief descriptions: namespace @11 namespace @13 namespace @4 namespace @5 namespace @6 namespace coro namespace internal namespace generic namespace gsl namespace std namespace experimental namespace chrono","title":"Namespaces"},{"location":"namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace @11 namespace @13 namespace @4 namespace @5 namespace @6 namespace coro namespace internal namespace generic namespace gsl namespace std namespace experimental namespace chrono","title":"Namespace List"},{"location":"namespacestd/","text":"Namespace std \u00b6 Class List > std Namespaces \u00b6 Type Name namespace experimental The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Namespace std"},{"location":"namespacestd/#namespace-std","text":"Class List > std","title":"Namespace std"},{"location":"namespacestd/#namespaces","text":"Type Name namespace experimental The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Namespaces"},{"location":"namespacestd_1_1chrono/","text":"Namespace std::chrono \u00b6 Class List > chrono The documentation for this class was generated from the following file modules/concrt/latch_pthread.cpp","title":"Namespace std::chrono"},{"location":"namespacestd_1_1chrono/#namespace-stdchrono","text":"Class List > chrono The documentation for this class was generated from the following file modules/concrt/latch_pthread.cpp","title":"Namespace std::chrono"},{"location":"namespacestd_1_1experimental/","text":"Namespace std::experimental \u00b6 Class List > std > experimental Classes \u00b6 Type Name class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never Public Types \u00b6 Type Name typedef coroutine_handle < noop_coroutine_promise > noop_coroutine_handle Public Functions \u00b6 Type Name noop_coroutine_handle noop_coroutine () noexcept bool operator!= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator< (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator<= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator== (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator> (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator>= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept Public Types Documentation \u00b6 typedef noop_coroutine_handle \u00b6 using std :: experimental :: noop_coroutine_handle = typedef coroutine_handle < noop_coroutine_promise > ; Public Functions Documentation \u00b6 function noop_coroutine \u00b6 inline noop_coroutine_handle std :: experimental :: noop_coroutine () noexcept function operator!= \u00b6 inline bool std :: experimental :: operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator< \u00b6 inline bool std :: experimental :: operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator<= \u00b6 inline bool std :: experimental :: operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator== \u00b6 inline bool std :: experimental :: operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator> \u00b6 inline bool std :: experimental :: operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator>= \u00b6 inline bool std :: experimental :: operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Namespace std::experimental"},{"location":"namespacestd_1_1experimental/#namespace-stdexperimental","text":"Class List > std > experimental","title":"Namespace std::experimental"},{"location":"namespacestd_1_1experimental/#classes","text":"Type Name class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never","title":"Classes"},{"location":"namespacestd_1_1experimental/#public-types","text":"Type Name typedef coroutine_handle < noop_coroutine_promise > noop_coroutine_handle","title":"Public Types"},{"location":"namespacestd_1_1experimental/#public-functions","text":"Type Name noop_coroutine_handle noop_coroutine () noexcept bool operator!= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator< (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator<= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator== (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator> (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator>= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept","title":"Public Functions"},{"location":"namespacestd_1_1experimental/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"namespacestd_1_1experimental/#typedef-noop95coroutine95handle","text":"using std :: experimental :: noop_coroutine_handle = typedef coroutine_handle < noop_coroutine_promise > ;","title":"typedef noop_coroutine_handle"},{"location":"namespacestd_1_1experimental/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"namespacestd_1_1experimental/#function-noop95coroutine","text":"inline noop_coroutine_handle std :: experimental :: noop_coroutine () noexcept","title":"function noop_coroutine"},{"location":"namespacestd_1_1experimental/#function-operator","text":"inline bool std :: experimental :: operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator!="},{"location":"namespacestd_1_1experimental/#function-operator_1","text":"inline bool std :: experimental :: operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator&lt;"},{"location":"namespacestd_1_1experimental/#function-operator_2","text":"inline bool std :: experimental :: operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator&lt;="},{"location":"namespacestd_1_1experimental/#function-operator_3","text":"inline bool std :: experimental :: operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator=="},{"location":"namespacestd_1_1experimental/#function-operator_4","text":"inline bool std :: experimental :: operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator&gt;"},{"location":"namespacestd_1_1experimental/#function-operator_5","text":"inline bool std :: experimental :: operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function operator&gt;="},{"location":"net_8h/","text":"File net.h \u00b6 File List > coroutine > net.h Go to the source code of this file. #include <chrono> #include <gsl/gsl> #include <coroutine/yield.hpp> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class io_recv class io_recv_from class io_send class io_send_to class io_work_t Macros \u00b6 Type Name define COROUTINE_NET_IO_H Macro Definition Documentation \u00b6 define COROUTINE_NET_IO_H \u00b6 #define COROUTINE_NET_IO_H The documentation for this class was generated from the following file interface/coroutine/net.h","title":"File net.h"},{"location":"net_8h/#file-neth","text":"File List > coroutine > net.h Go to the source code of this file. #include <chrono> #include <gsl/gsl> #include <coroutine/yield.hpp>","title":"File net.h"},{"location":"net_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"net_8h/#classes","text":"Type Name class io_recv class io_recv_from class io_send class io_send_to class io_work_t","title":"Classes"},{"location":"net_8h/#macros","text":"Type Name define COROUTINE_NET_IO_H","title":"Macros"},{"location":"net_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"net_8h/#define-coroutine95net95io95h","text":"#define COROUTINE_NET_IO_H The documentation for this class was generated from the following file interface/coroutine/net.h","title":"define COROUTINE_NET_IO_H"},{"location":"net_8h_source/","text":"File net.h \u00b6 File List > coroutine > net.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // Async I/O operation support for socket // #pragma once // clang-format off #if defined(FORCE_STATIC_LINK) # define _INTERFACE_ # define _HIDDEN_ #elif defined(_MSC_VER) // MSVC or clang-cl # define _HIDDEN_ # ifdef _WINDLL # define _INTERFACE_ __declspec(dllexport) # else # define _INTERFACE_ __declspec(dllimport) # endif #elif defined(__GNUC__) || defined(__clang__) # define _INTERFACE_ __attribute__((visibility(\"default\"))) # define _HIDDEN_ __attribute__((visibility(\"hidden\"))) #else # error \"unexpected linking configuration\" #endif // clang-format on #ifndef COROUTINE_NET_IO_H #define COROUTINE_NET_IO_H #include <chrono> #include <gsl/gsl> #include <coroutine/yield.hpp> #if __has_include(<WinSock2.h>) // use winsock #include <WS2tcpip.h> #include <WinSock2.h> #include <ws2def.h> using io_control_block = OVERLAPPED ; static constexpr bool is_winsock = true ; static constexpr bool is_netinet = false ; #elif __has_include(<netinet/in.h>) // use netinet #include <fcntl.h> #include <netdb.h> #include <netinet/in.h> #include <netinet/tcp.h> #include <sys/socket.h> #include <unistd.h> // Follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc, int32_t flag uint64_t internal_high ; // int64_t len, socklen_t addrlen union { struct { int32_t offset ; int32_t offset_high ; }; void * ptr ; // sockaddr* addr; }; int64_t handle ; // int64_t sd; }; static constexpr bool is_winsock = false ; static constexpr bool is_netinet = true ; #endif // winsock || netinet namespace coro { using namespace std ; using namespace std :: experimental ; // 1 I/O task == 1 coroutine function using io_task_t = coroutine_handle < void > ; // This is simply a view to storage. Be aware that it doesn't have ownership using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); // A struct to describe \"1 I/O request\" to system API class io_work_t : public io_control_block { public : io_task_t task {}; io_buffer_t buffer {}; protected : _INTERFACE_ bool ready () const noexcept ; public : // Multiple retrieving won't be a matter _INTERFACE_ uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 56 ); // Type to perform `sendto` I/O request class io_send_to final : public io_work_t { private : // This function must be used through `co_await` _INTERFACE_ void suspend ( io_task_t t ) noexcept ( false ); // This function must be used through `co_await` // Unlike inherited `error` function, multiple invoke of this will // lead to malfunction. _INTERFACE_ int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( io_task_t t ) noexcept ( false ) { return this -> suspend ( t ); } auto await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); // Type to perform `recvfrom` I/O request class io_recv_from final : public io_work_t { private : // This function must be used through `co_await` _INTERFACE_ void suspend ( io_task_t t ) noexcept ( false ); // This function must be used through `co_await` // Unlike inherited `error` function, multiple invoke of this will // lead to malfunction. _INTERFACE_ int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( io_task_t t ) noexcept ( false ) { return this -> suspend ( t ); } auto await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); // Type to perform `send` I/O request class io_send final : public io_work_t { private : // This function must be used through `co_await` _INTERFACE_ void suspend ( io_task_t t ) noexcept ( false ); // This function must be used through `co_await` // Unlike inherited `error` function, multiple invoke of this will // lead to malfunction. _INTERFACE_ int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( io_task_t t ) noexcept ( false ) { return this -> suspend ( t ); } auto await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); // Type to perform `recv` I/O request class io_recv final : public io_work_t { private : // This function must be used through `co_await` _INTERFACE_ void suspend ( io_task_t t ) noexcept ( false ); // This function must be used through `co_await` // Unlike inherited `error` function, multiple invoke of this will // lead to malfunction. _INTERFACE_ int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( io_task_t t ) noexcept ( false ) { return this -> suspend ( t ); } auto await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); // Constructs awaitable `io_send_to` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; // Constructs awaitable `io_send_to` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_send_to & ; // Constructs awaitable `io_recv_from` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; // Constructs awaitable `io_recv_from` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; // Constructs awaitable `io_send` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ; // Constructs awaitable `io_recv` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ; // This function is for non-Windows platform. // Over Windows api, it always yields **nothing**. // // Its caller must continue the loop without break // so there is no leak of the I/O events // // Also, the library doesn't guarantee all coroutines(i/o tasks) will be // fetched at once. Therefore it is strongly recommended for user to have // another method to detect that watching I/O coroutines are returned. _INTERFACE_ void wait_net_tasks ( enumerable < io_task_t >& tasks , chrono :: nanoseconds timeout ) noexcept ( false ); inline auto wait_net_tasks ( chrono :: nanoseconds timeout ) noexcept ( false ) { enumerable < io_task_t > tasks {}; wait_net_tasks ( tasks , timeout ); return tasks ; } // // Name resolution utilities // using zstring_host = gsl :: zstring < NI_MAXHOST > ; using zstring_serv = gsl :: zstring < NI_MAXSERV > ; using czstring_host = gsl :: czstring < NI_MAXHOST > ; using czstring_serv = gsl :: czstring < NI_MAXSERV > ; // Combination of `getaddrinfo` functions // If there is an error, the enumerable is untouched _INTERFACE_ int32_t resolve ( enumerable < sockaddr >& g , const addrinfo & hint , // czstring_host name , czstring_serv serv ) noexcept ; // construct system_error using `gai_strerror` function _INTERFACE_ auto resolve_error ( int32_t ec ) noexcept -> std :: system_error ; inline auto resolve ( const addrinfo & hint , // czstring_host name , czstring_serv serv ) noexcept ( false ) -> enumerable < sockaddr > { enumerable < sockaddr > g {}; if ( const auto ec = resolve ( g , hint , name , serv )) { throw resolve_error ( ec ); } return g ; } // Thin wrapper of `getnameinfo`. Parameter 'serv' can be nullptr. _INTERFACE_ int32_t get_name ( const sockaddr_in & addr , zstring_host name , zstring_serv serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; _INTERFACE_ int32_t get_name ( const sockaddr_in6 & addr , zstring_host name , zstring_serv serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; } // namespace coro #endif // COROUTINE_NET_IO_H","title":"File net.h"},{"location":"net_8h_source/#file-neth","text":"File List > coroutine > net.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // Async I/O operation support for socket // #pragma once // clang-format off #if defined(FORCE_STATIC_LINK) # define _INTERFACE_ # define _HIDDEN_ #elif defined(_MSC_VER) // MSVC or clang-cl # define _HIDDEN_ # ifdef _WINDLL # define _INTERFACE_ __declspec(dllexport) # else # define _INTERFACE_ __declspec(dllimport) # endif #elif defined(__GNUC__) || defined(__clang__) # define _INTERFACE_ __attribute__((visibility(\"default\"))) # define _HIDDEN_ __attribute__((visibility(\"hidden\"))) #else # error \"unexpected linking configuration\" #endif // clang-format on #ifndef COROUTINE_NET_IO_H #define COROUTINE_NET_IO_H #include <chrono> #include <gsl/gsl> #include <coroutine/yield.hpp> #if __has_include(<WinSock2.h>) // use winsock #include <WS2tcpip.h> #include <WinSock2.h> #include <ws2def.h> using io_control_block = OVERLAPPED ; static constexpr bool is_winsock = true ; static constexpr bool is_netinet = false ; #elif __has_include(<netinet/in.h>) // use netinet #include <fcntl.h> #include <netdb.h> #include <netinet/in.h> #include <netinet/tcp.h> #include <sys/socket.h> #include <unistd.h> // Follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc, int32_t flag uint64_t internal_high ; // int64_t len, socklen_t addrlen union { struct { int32_t offset ; int32_t offset_high ; }; void * ptr ; // sockaddr* addr; }; int64_t handle ; // int64_t sd; }; static constexpr bool is_winsock = false ; static constexpr bool is_netinet = true ; #endif // winsock || netinet namespace coro { using namespace std ; using namespace std :: experimental ; // 1 I/O task == 1 coroutine function using io_task_t = coroutine_handle < void > ; // This is simply a view to storage. Be aware that it doesn't have ownership using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); // A struct to describe \"1 I/O request\" to system API class io_work_t : public io_control_block { public : io_task_t task {}; io_buffer_t buffer {}; protected : _INTERFACE_ bool ready () const noexcept ; public : // Multiple retrieving won't be a matter _INTERFACE_ uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 56 ); // Type to perform `sendto` I/O request class io_send_to final : public io_work_t { private : // This function must be used through `co_await` _INTERFACE_ void suspend ( io_task_t t ) noexcept ( false ); // This function must be used through `co_await` // Unlike inherited `error` function, multiple invoke of this will // lead to malfunction. _INTERFACE_ int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( io_task_t t ) noexcept ( false ) { return this -> suspend ( t ); } auto await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); // Type to perform `recvfrom` I/O request class io_recv_from final : public io_work_t { private : // This function must be used through `co_await` _INTERFACE_ void suspend ( io_task_t t ) noexcept ( false ); // This function must be used through `co_await` // Unlike inherited `error` function, multiple invoke of this will // lead to malfunction. _INTERFACE_ int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( io_task_t t ) noexcept ( false ) { return this -> suspend ( t ); } auto await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); // Type to perform `send` I/O request class io_send final : public io_work_t { private : // This function must be used through `co_await` _INTERFACE_ void suspend ( io_task_t t ) noexcept ( false ); // This function must be used through `co_await` // Unlike inherited `error` function, multiple invoke of this will // lead to malfunction. _INTERFACE_ int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( io_task_t t ) noexcept ( false ) { return this -> suspend ( t ); } auto await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); // Type to perform `recv` I/O request class io_recv final : public io_work_t { private : // This function must be used through `co_await` _INTERFACE_ void suspend ( io_task_t t ) noexcept ( false ); // This function must be used through `co_await` // Unlike inherited `error` function, multiple invoke of this will // lead to malfunction. _INTERFACE_ int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( io_task_t t ) noexcept ( false ) { return this -> suspend ( t ); } auto await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); // Constructs awaitable `io_send_to` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; // Constructs awaitable `io_send_to` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_send_to & ; // Constructs awaitable `io_recv_from` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; // Constructs awaitable `io_recv_from` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; // Constructs awaitable `io_send` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ; // Constructs awaitable `io_recv` object with the given parameters [[ nodiscard ]] _INTERFACE_ // auto // recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ; // This function is for non-Windows platform. // Over Windows api, it always yields **nothing**. // // Its caller must continue the loop without break // so there is no leak of the I/O events // // Also, the library doesn't guarantee all coroutines(i/o tasks) will be // fetched at once. Therefore it is strongly recommended for user to have // another method to detect that watching I/O coroutines are returned. _INTERFACE_ void wait_net_tasks ( enumerable < io_task_t >& tasks , chrono :: nanoseconds timeout ) noexcept ( false ); inline auto wait_net_tasks ( chrono :: nanoseconds timeout ) noexcept ( false ) { enumerable < io_task_t > tasks {}; wait_net_tasks ( tasks , timeout ); return tasks ; } // // Name resolution utilities // using zstring_host = gsl :: zstring < NI_MAXHOST > ; using zstring_serv = gsl :: zstring < NI_MAXSERV > ; using czstring_host = gsl :: czstring < NI_MAXHOST > ; using czstring_serv = gsl :: czstring < NI_MAXSERV > ; // Combination of `getaddrinfo` functions // If there is an error, the enumerable is untouched _INTERFACE_ int32_t resolve ( enumerable < sockaddr >& g , const addrinfo & hint , // czstring_host name , czstring_serv serv ) noexcept ; // construct system_error using `gai_strerror` function _INTERFACE_ auto resolve_error ( int32_t ec ) noexcept -> std :: system_error ; inline auto resolve ( const addrinfo & hint , // czstring_host name , czstring_serv serv ) noexcept ( false ) -> enumerable < sockaddr > { enumerable < sockaddr > g {}; if ( const auto ec = resolve ( g , hint , name , serv )) { throw resolve_error ( ec ); } return g ; } // Thin wrapper of `getnameinfo`. Parameter 'serv' can be nullptr. _INTERFACE_ int32_t get_name ( const sockaddr_in & addr , zstring_host name , zstring_serv serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; _INTERFACE_ int32_t get_name ( const sockaddr_in6 & addr , zstring_host name , zstring_serv serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; } // namespace coro #endif // COROUTINE_NET_IO_H","title":"File net.h"},{"location":"no__exception__ensure__tests_8cpp/","text":"File no_exception_ensure_tests.cpp \u00b6 File List > external > guideline > tests > no_exception_ensure_tests.cpp Go to the source code of this file. #include <cstdlib> #include <gsl/span> Public Functions \u00b6 Type Name int main () noexcept int operator_subscript_no_throw () noexcept void setup_termination_handler () noexcept void test_terminate () Public Functions Documentation \u00b6 function main \u00b6 int main () noexcept function operator_subscript_no_throw \u00b6 int operator_subscript_no_throw () noexcept function setup_termination_handler \u00b6 void setup_termination_handler () noexcept function test_terminate \u00b6 void test_terminate () The documentation for this class was generated from the following file external/guideline/tests/no_exception_ensure_tests.cpp","title":"File no\\_exception\\_ensure\\_tests.cpp"},{"location":"no__exception__ensure__tests_8cpp/#file-no95exception95ensure95testscpp","text":"File List > external > guideline > tests > no_exception_ensure_tests.cpp Go to the source code of this file. #include <cstdlib> #include <gsl/span>","title":"File no_exception_ensure_tests.cpp"},{"location":"no__exception__ensure__tests_8cpp/#public-functions","text":"Type Name int main () noexcept int operator_subscript_no_throw () noexcept void setup_termination_handler () noexcept void test_terminate ()","title":"Public Functions"},{"location":"no__exception__ensure__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"no__exception__ensure__tests_8cpp/#function-main","text":"int main () noexcept","title":"function main"},{"location":"no__exception__ensure__tests_8cpp/#function-operator95subscript95no95throw","text":"int operator_subscript_no_throw () noexcept","title":"function operator_subscript_no_throw"},{"location":"no__exception__ensure__tests_8cpp/#function-setup95termination95handler","text":"void setup_termination_handler () noexcept","title":"function setup_termination_handler"},{"location":"no__exception__ensure__tests_8cpp/#function-test95terminate","text":"void test_terminate () The documentation for this class was generated from the following file external/guideline/tests/no_exception_ensure_tests.cpp","title":"function test_terminate"},{"location":"no__exception__ensure__tests_8cpp_source/","text":"File no_exception_ensure_tests.cpp \u00b6 File List > external > guideline > tests > no_exception_ensure_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #include <cstdlib> // for std::exit #include <gsl/span> // for span int operator_subscript_no_throw () noexcept { int arr [ 10 ]; const gsl :: span < int > sp { arr }; return sp [ 11 ]; } [[ noreturn ]] void test_terminate () { std :: exit ( 0 ); } void setup_termination_handler () noexcept { #if defined(GSL_MSVC_USE_STL_NOEXCEPTION_WORKAROUND) auto & handler = gsl :: details :: get_terminate_handler (); handler = & test_terminate ; #else std :: set_terminate ( test_terminate ); #endif } int main () noexcept { setup_termination_handler (); operator_subscript_no_throw (); return - 1 ; }","title":"File no\\_exception\\_ensure\\_tests.cpp"},{"location":"no__exception__ensure__tests_8cpp_source/#file-no95exception95ensure95testscpp","text":"File List > external > guideline > tests > no_exception_ensure_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #include <cstdlib> // for std::exit #include <gsl/span> // for span int operator_subscript_no_throw () noexcept { int arr [ 10 ]; const gsl :: span < int > sp { arr }; return sp [ 11 ]; } [[ noreturn ]] void test_terminate () { std :: exit ( 0 ); } void setup_termination_handler () noexcept { #if defined(GSL_MSVC_USE_STL_NOEXCEPTION_WORKAROUND) auto & handler = gsl :: details :: get_terminate_handler (); handler = & test_terminate ; #else std :: set_terminate ( test_terminate ); #endif } int main () noexcept { setup_termination_handler (); operator_subscript_no_throw (); return - 1 ; }","title":"File no_exception_ensure_tests.cpp"},{"location":"no__exception__throw__tests_8cpp/","text":"File no_exception_throw_tests.cpp \u00b6 File List > external > guideline > tests > no_exception_throw_tests.cpp Go to the source code of this file. #include <cstdlib> #include <gsl/gsl_assert> #include <gsl/gsl_util> Public Functions \u00b6 Type Name int main () int narrow_no_throw () void setup_termination_handler () noexcept void test_terminate () Public Functions Documentation \u00b6 function main \u00b6 int main () function narrow_no_throw \u00b6 int narrow_no_throw () function setup_termination_handler \u00b6 void setup_termination_handler () noexcept function test_terminate \u00b6 void test_terminate () The documentation for this class was generated from the following file external/guideline/tests/no_exception_throw_tests.cpp","title":"File no\\_exception\\_throw\\_tests.cpp"},{"location":"no__exception__throw__tests_8cpp/#file-no95exception95throw95testscpp","text":"File List > external > guideline > tests > no_exception_throw_tests.cpp Go to the source code of this file. #include <cstdlib> #include <gsl/gsl_assert> #include <gsl/gsl_util>","title":"File no_exception_throw_tests.cpp"},{"location":"no__exception__throw__tests_8cpp/#public-functions","text":"Type Name int main () int narrow_no_throw () void setup_termination_handler () noexcept void test_terminate ()","title":"Public Functions"},{"location":"no__exception__throw__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"no__exception__throw__tests_8cpp/#function-main","text":"int main ()","title":"function main"},{"location":"no__exception__throw__tests_8cpp/#function-narrow95no95throw","text":"int narrow_no_throw ()","title":"function narrow_no_throw"},{"location":"no__exception__throw__tests_8cpp/#function-setup95termination95handler","text":"void setup_termination_handler () noexcept","title":"function setup_termination_handler"},{"location":"no__exception__throw__tests_8cpp/#function-test95terminate","text":"void test_terminate () The documentation for this class was generated from the following file external/guideline/tests/no_exception_throw_tests.cpp","title":"function test_terminate"},{"location":"no__exception__throw__tests_8cpp_source/","text":"File no_exception_throw_tests.cpp \u00b6 File List > external > guideline > tests > no_exception_throw_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #include <cstdlib> // for std::exit #include <gsl/gsl_assert> // for get_terminate #include <gsl/gsl_util> // for narrow int narrow_no_throw () { const long long bigNumber = 0x0fffffffffffffff ; return gsl :: narrow < int > ( bigNumber ); } [[ noreturn ]] void test_terminate () { std :: exit ( 0 ); } void setup_termination_handler () noexcept { #if defined(GSL_MSVC_USE_STL_NOEXCEPTION_WORKAROUND) auto & handler = gsl :: details :: get_terminate_handler (); handler = & test_terminate ; #else std :: set_terminate ( test_terminate ); #endif } int main () { setup_termination_handler (); narrow_no_throw (); return - 1 ; }","title":"File no\\_exception\\_throw\\_tests.cpp"},{"location":"no__exception__throw__tests_8cpp_source/#file-no95exception95throw95testscpp","text":"File List > external > guideline > tests > no_exception_throw_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #include <cstdlib> // for std::exit #include <gsl/gsl_assert> // for get_terminate #include <gsl/gsl_util> // for narrow int narrow_no_throw () { const long long bigNumber = 0x0fffffffffffffff ; return gsl :: narrow < int > ( bigNumber ); } [[ noreturn ]] void test_terminate () { std :: exit ( 0 ); } void setup_termination_handler () noexcept { #if defined(GSL_MSVC_USE_STL_NOEXCEPTION_WORKAROUND) auto & handler = gsl :: details :: get_terminate_handler (); handler = & test_terminate ; #else std :: set_terminate ( test_terminate ); #endif } int main () { setup_termination_handler (); narrow_no_throw (); return - 1 ; }","title":"File no_exception_throw_tests.cpp"},{"location":"notnull__tests_8cpp/","text":"File notnull_tests.cpp \u00b6 File List > external > guideline > tests > notnull_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/pointers> #include <algorithm> #include <memory> #include <sstream> #include <stdint.h> #include <string> #include <typeinfo> Namespaces \u00b6 Type Name namespace gsl Classes \u00b6 Type Name struct CustomPtr <typename T> struct MyBase struct MyDerived struct NonCopyableNonMovable struct RefCounted <typename T> struct Unrelated Public Functions \u00b6 Type Name GSL_SUPPRESS (f. 4) GSL_SUPPRESS (con. 4) GSL_SUPPRESS (type. 1) TEST_CASE (\"TestNotNullostream\") TEST_CASE (\"TestNotNullAssignment\") TEST_CASE (\"TestNotNullRawPointerComparison\") TEST_CASE (\"TestNotNullSharedPtrComparison\") TEST_CASE (\"TestMakeNotNull\") std::string operator!= ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator< ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator<= ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator== ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator> ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator>= ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) int * return_pointer () const int * return_pointer_const () Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( f . 4 ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( con . 4 ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( type . 1 ) function TEST_CASE \u00b6 TEST_CASE ( \"TestNotNullostream\" ) function TEST_CASE \u00b6 TEST_CASE ( \"TestNotNullAssignment\" ) function TEST_CASE \u00b6 TEST_CASE ( \"TestNotNullRawPointerComparison\" ) function TEST_CASE \u00b6 TEST_CASE ( \"TestNotNullSharedPtrComparison\" ) function TEST_CASE \u00b6 TEST_CASE ( \"TestMakeNotNull\" ) function operator!= \u00b6 template < typename T typename T , typename U typename U > std :: string operator != ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) function operator< \u00b6 template < typename T typename T , typename U typename U > std :: string operator < ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) function operator<= \u00b6 template < typename T typename T , typename U typename U > std :: string operator <= ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) function operator== \u00b6 template < typename T typename T , typename U typename U > std :: string operator == ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) function operator> \u00b6 template < typename T typename T , typename U typename U > std :: string operator > ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) function operator>= \u00b6 template < typename T typename T , typename U typename U > std :: string operator >= ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) function return_pointer \u00b6 int * return_pointer () function return_pointer_const \u00b6 const int * return_pointer_const () The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"File notnull\\_tests.cpp"},{"location":"notnull__tests_8cpp/#file-notnull95testscpp","text":"File List > external > guideline > tests > notnull_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/pointers> #include <algorithm> #include <memory> #include <sstream> #include <stdint.h> #include <string> #include <typeinfo>","title":"File notnull_tests.cpp"},{"location":"notnull__tests_8cpp/#namespaces","text":"Type Name namespace gsl","title":"Namespaces"},{"location":"notnull__tests_8cpp/#classes","text":"Type Name struct CustomPtr <typename T> struct MyBase struct MyDerived struct NonCopyableNonMovable struct RefCounted <typename T> struct Unrelated","title":"Classes"},{"location":"notnull__tests_8cpp/#public-functions","text":"Type Name GSL_SUPPRESS (f. 4) GSL_SUPPRESS (con. 4) GSL_SUPPRESS (type. 1) TEST_CASE (\"TestNotNullostream\") TEST_CASE (\"TestNotNullAssignment\") TEST_CASE (\"TestNotNullRawPointerComparison\") TEST_CASE (\"TestNotNullSharedPtrComparison\") TEST_CASE (\"TestMakeNotNull\") std::string operator!= ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator< ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator<= ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator== ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator> ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) std::string operator>= ( CustomPtr < T > const & lhs, CustomPtr < U > const & rhs) int * return_pointer () const int * return_pointer_const ()","title":"Public Functions"},{"location":"notnull__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"notnull__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( f . 4 )","title":"function GSL_SUPPRESS"},{"location":"notnull__tests_8cpp/#function-gsl95suppress_1","text":"GSL_SUPPRESS ( con . 4 )","title":"function GSL_SUPPRESS"},{"location":"notnull__tests_8cpp/#function-gsl95suppress_2","text":"GSL_SUPPRESS ( type . 1 )","title":"function GSL_SUPPRESS"},{"location":"notnull__tests_8cpp/#function-test95case","text":"TEST_CASE ( \"TestNotNullostream\" )","title":"function TEST_CASE"},{"location":"notnull__tests_8cpp/#function-test95case_1","text":"TEST_CASE ( \"TestNotNullAssignment\" )","title":"function TEST_CASE"},{"location":"notnull__tests_8cpp/#function-test95case_2","text":"TEST_CASE ( \"TestNotNullRawPointerComparison\" )","title":"function TEST_CASE"},{"location":"notnull__tests_8cpp/#function-test95case_3","text":"TEST_CASE ( \"TestNotNullSharedPtrComparison\" )","title":"function TEST_CASE"},{"location":"notnull__tests_8cpp/#function-test95case_4","text":"TEST_CASE ( \"TestMakeNotNull\" )","title":"function TEST_CASE"},{"location":"notnull__tests_8cpp/#function-operator","text":"template < typename T typename T , typename U typename U > std :: string operator != ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs )","title":"function operator!="},{"location":"notnull__tests_8cpp/#function-operator_1","text":"template < typename T typename T , typename U typename U > std :: string operator < ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs )","title":"function operator&lt;"},{"location":"notnull__tests_8cpp/#function-operator_2","text":"template < typename T typename T , typename U typename U > std :: string operator <= ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs )","title":"function operator&lt;="},{"location":"notnull__tests_8cpp/#function-operator_3","text":"template < typename T typename T , typename U typename U > std :: string operator == ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs )","title":"function operator=="},{"location":"notnull__tests_8cpp/#function-operator_4","text":"template < typename T typename T , typename U typename U > std :: string operator > ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs )","title":"function operator&gt;"},{"location":"notnull__tests_8cpp/#function-operator_5","text":"template < typename T typename T , typename U typename U > std :: string operator >= ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs )","title":"function operator&gt;="},{"location":"notnull__tests_8cpp/#function-return95pointer","text":"int * return_pointer ()","title":"function return_pointer"},{"location":"notnull__tests_8cpp/#function-return95pointer95const","text":"const int * return_pointer_const () The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"function return_pointer_const"},{"location":"notnull__tests_8cpp_source/","text":"File notnull_tests.cpp \u00b6 File List > external > guideline > tests > notnull_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch // Fix VS2015 build breaks in Release #pragma warning(disable : 4702) // unreachable code #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/pointers> // for not_null, operator<, operator<=, operator> #include <algorithm> // for addressof #include <memory> // for shared_ptr, make_shared, operator<, opera... #include <sstream> // for operator<<, ostringstream, basic_ostream:... #include <stdint.h> // for uint16_t #include <string> // for basic_string, operator==, string, operator<< #include <typeinfo> // for type_info namespace gsl { struct fail_fast ; } // namespace gsl using namespace gsl ; struct MyBase { }; struct MyDerived : public MyBase { }; struct Unrelated { }; // stand-in for a user-defined ref-counted class template < typename T > struct RefCounted { RefCounted ( T * p ) : p_ ( p ) {} operator T * () { return p_ ; } T * p_ ; }; // user defined smart pointer with comparison operators returning non bool value template < typename T > struct CustomPtr { CustomPtr ( T * p ) : p_ ( p ) {} operator T * () { return p_ ; } bool operator != ( std :: nullptr_t ) const { return p_ != nullptr ; } T * p_ = nullptr ; }; template < typename T , typename U > std :: string operator == ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) == reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator != ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) != reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator < ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) < reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator > ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) > reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator <= ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) <= reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator >= ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) >= reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } struct NonCopyableNonMovable { NonCopyableNonMovable () = default ; NonCopyableNonMovable ( const NonCopyableNonMovable & ) = delete ; NonCopyableNonMovable & operator = ( const NonCopyableNonMovable & ) = delete ; NonCopyableNonMovable ( NonCopyableNonMovable && ) = delete ; NonCopyableNonMovable & operator = ( NonCopyableNonMovable && ) = delete ; }; GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool helper ( not_null < int *> p ) { return * p == 12 ; } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool helper_const ( not_null < const int *> p ) { return * p == 12 ; } int * return_pointer () { return nullptr ; } const int * return_pointer_const () { return nullptr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullConstructors\" ) { { #ifdef CONFIRM_COMPILATION_ERRORS not_null < int *> p = nullptr ; // yay...does not compile! not_null < std :: vector < char >*> p1 = 0 ; // yay...does not compile! not_null < int *> p2 ; // yay...does not compile! std :: unique_ptr < int > up = std :: make_unique < int > ( 120 ); not_null < int *> p3 = up ; // Forbid non-nullptr assignable types not_null < std :: vector < int >> f ( std :: vector < int > { 1 }); not_null < int > z ( 10 ); not_null < std :: vector < int >> y ({ 1 , 2 }); #endif } { // from shared pointer int i = 12 ; auto rp = RefCounted < int > ( & i ); not_null < int *> p ( rp ); CHECK ( p . get () == & i ); not_null < std :: shared_ptr < int >> x ( std :: make_shared < int > ( 10 )); // shared_ptr<int> is nullptr assignable int * pi = nullptr ; CHECK_THROWS_AS ( not_null < decltype ( pi ) > ( pi ), fail_fast ); } { // from pointer to local int t = 42 ; not_null < int *> x = & t ; helper ( & t ); helper_const ( & t ); CHECK ( * x == 42 ); } { // from raw pointer // from not_null pointer int t = 42 ; int * p = & t ; not_null < int *> x = p ; helper ( p ); helper_const ( p ); helper ( x ); helper_const ( x ); CHECK ( * x == 42 ); } { // from raw const pointer // from not_null const pointer int t = 42 ; const int * cp = & t ; not_null < const int *> x = cp ; helper_const ( cp ); helper_const ( x ); CHECK ( * x == 42 ); } { // from not_null const pointer, using auto int t = 42 ; const int * cp = & t ; auto x = not_null < const int *> { cp }; CHECK ( * x == 42 ); } { // from returned pointer CHECK_THROWS_AS ( helper ( return_pointer ()), fail_fast ); CHECK_THROWS_AS ( helper_const ( return_pointer ()), fail_fast ); } } template < typename T > GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute void ostream_helper ( T v ) { not_null < T *> p ( & v ); { std :: ostringstream os ; std :: ostringstream ref ; os << static_cast < void *> ( p ); ref << static_cast < void *> ( & v ); CHECK ( os . str () == ref . str ()); } { std :: ostringstream os ; std :: ostringstream ref ; os << * p ; ref << v ; CHECK ( os . str () == ref . str ()); } } TEST_CASE ( \"TestNotNullostream\" ) { ostream_helper < int > ( 17 ); ostream_helper < float > ( 21.5f ); ostream_helper < double > ( 3.4566e-7 ); ostream_helper < char > ( 'c' ); ostream_helper < uint16_t > ( 0x0123u ); ostream_helper < const char *> ( \"cstring\" ); ostream_helper < std :: string > ( \"string\" ); } GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullCasting\" ) { MyBase base ; MyDerived derived ; Unrelated unrelated ; not_null < Unrelated *> u { & unrelated }; ( void ) u ; not_null < MyDerived *> p { & derived }; not_null < MyBase *> q ( & base ); q = p ; // allowed with heterogeneous copy ctor CHECK ( q == p ); #ifdef CONFIRM_COMPILATION_ERRORS q = u ; // no viable conversion possible between MyBase* and Unrelated* p = q ; // not possible to implicitly convert MyBase* to MyDerived* not_null < Unrelated *> r = p ; not_null < Unrelated *> s = reinterpret_cast < Unrelated *> ( p ); #endif not_null < Unrelated *> t ( reinterpret_cast < Unrelated *> ( p . get ())); CHECK ( reinterpret_cast < void *> ( p . get ()) == reinterpret_cast < void *> ( t . get ())); } TEST_CASE ( \"TestNotNullAssignment\" ) { int i = 12 ; not_null < int *> p ( & i ); CHECK ( helper ( p )); int * q = nullptr ; CHECK_THROWS_AS ( p = not_null < int *> ( q ), fail_fast ); } TEST_CASE ( \"TestNotNullRawPointerComparison\" ) { int ints [ 2 ] = { 42 , 43 }; int * p1 = & ints [ 0 ]; const int * p2 = & ints [ 1 ]; using NotNull1 = not_null < decltype ( p1 ) > ; using NotNull2 = not_null < decltype ( p2 ) > ; CHECK (( NotNull1 ( p1 ) == NotNull1 ( p1 )) == true ); CHECK (( NotNull1 ( p1 ) == NotNull2 ( p2 )) == false ); CHECK (( NotNull1 ( p1 ) != NotNull1 ( p1 )) == false ); CHECK (( NotNull1 ( p1 ) != NotNull2 ( p2 )) == true ); CHECK (( NotNull1 ( p1 ) < NotNull1 ( p1 )) == false ); CHECK (( NotNull1 ( p1 ) < NotNull2 ( p2 )) == ( p1 < p2 )); CHECK (( NotNull2 ( p2 ) < NotNull1 ( p1 )) == ( p2 < p1 )); CHECK (( NotNull1 ( p1 ) > NotNull1 ( p1 )) == false ); CHECK (( NotNull1 ( p1 ) > NotNull2 ( p2 )) == ( p1 > p2 )); CHECK (( NotNull2 ( p2 ) > NotNull1 ( p1 )) == ( p2 > p1 )); CHECK (( NotNull1 ( p1 ) <= NotNull1 ( p1 )) == true ); CHECK (( NotNull1 ( p1 ) <= NotNull2 ( p2 )) == ( p1 <= p2 )); CHECK (( NotNull2 ( p2 ) <= NotNull1 ( p1 )) == ( p2 <= p1 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullDereferenceOperator\" ) { { auto sp1 = std :: make_shared < NonCopyableNonMovable > (); using NotNullSp1 = not_null < decltype ( sp1 ) > ; CHECK ( typeid ( * sp1 ) == typeid ( * NotNullSp1 ( sp1 ))); CHECK ( std :: addressof ( * NotNullSp1 ( sp1 )) == std :: addressof ( * sp1 )); } { int ints [ 1 ] = { 42 }; CustomPtr < int > p1 ( & ints [ 0 ]); using NotNull1 = not_null < decltype ( p1 ) > ; CHECK ( typeid ( * NotNull1 ( p1 )) == typeid ( * p1 )); CHECK ( * NotNull1 ( p1 ) == 42 ); * NotNull1 ( p1 ) = 43 ; CHECK ( ints [ 0 ] == 43 ); } { int v = 42 ; gsl :: not_null < int *> p ( & v ); CHECK ( typeid ( * p ) == typeid ( * ( & v ))); * p = 43 ; CHECK ( v == 43 ); } } TEST_CASE ( \"TestNotNullSharedPtrComparison\" ) { auto sp1 = std :: make_shared < int > ( 42 ); auto sp2 = std :: make_shared < const int > ( 43 ); using NotNullSp1 = not_null < decltype ( sp1 ) > ; using NotNullSp2 = not_null < decltype ( sp2 ) > ; CHECK (( NotNullSp1 ( sp1 ) == NotNullSp1 ( sp1 )) == true ); CHECK (( NotNullSp1 ( sp1 ) == NotNullSp2 ( sp2 )) == false ); CHECK (( NotNullSp1 ( sp1 ) != NotNullSp1 ( sp1 )) == false ); CHECK (( NotNullSp1 ( sp1 ) != NotNullSp2 ( sp2 )) == true ); CHECK (( NotNullSp1 ( sp1 ) < NotNullSp1 ( sp1 )) == false ); CHECK (( NotNullSp1 ( sp1 ) < NotNullSp2 ( sp2 )) == ( sp1 < sp2 )); CHECK (( NotNullSp2 ( sp2 ) < NotNullSp1 ( sp1 )) == ( sp2 < sp1 )); CHECK (( NotNullSp1 ( sp1 ) > NotNullSp1 ( sp1 )) == false ); CHECK (( NotNullSp1 ( sp1 ) > NotNullSp2 ( sp2 )) == ( sp1 > sp2 )); CHECK (( NotNullSp2 ( sp2 ) > NotNullSp1 ( sp1 )) == ( sp2 > sp1 )); CHECK (( NotNullSp1 ( sp1 ) <= NotNullSp1 ( sp1 )) == true ); CHECK (( NotNullSp1 ( sp1 ) <= NotNullSp2 ( sp2 )) == ( sp1 <= sp2 )); CHECK (( NotNullSp2 ( sp2 ) <= NotNullSp1 ( sp1 )) == ( sp2 <= sp1 )); CHECK (( NotNullSp1 ( sp1 ) >= NotNullSp1 ( sp1 )) == true ); CHECK (( NotNullSp1 ( sp1 ) >= NotNullSp2 ( sp2 )) == ( sp1 >= sp2 )); CHECK (( NotNullSp2 ( sp2 ) >= NotNullSp1 ( sp1 )) == ( sp2 >= sp1 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullCustomPtrComparison\" ) { int ints [ 2 ] = { 42 , 43 }; CustomPtr < int > p1 ( & ints [ 0 ]); CustomPtr < const int > p2 ( & ints [ 1 ]); using NotNull1 = not_null < decltype ( p1 ) > ; using NotNull2 = not_null < decltype ( p2 ) > ; CHECK (( NotNull1 ( p1 ) == NotNull1 ( p1 )) == \"true\" ); CHECK (( NotNull1 ( p1 ) == NotNull2 ( p2 )) == \"false\" ); CHECK (( NotNull1 ( p1 ) != NotNull1 ( p1 )) == \"false\" ); CHECK (( NotNull1 ( p1 ) != NotNull2 ( p2 )) == \"true\" ); CHECK (( NotNull1 ( p1 ) < NotNull1 ( p1 )) == \"false\" ); CHECK (( NotNull1 ( p1 ) < NotNull2 ( p2 )) == ( p1 < p2 )); CHECK (( NotNull2 ( p2 ) < NotNull1 ( p1 )) == ( p2 < p1 )); CHECK (( NotNull1 ( p1 ) > NotNull1 ( p1 )) == \"false\" ); CHECK (( NotNull1 ( p1 ) > NotNull2 ( p2 )) == ( p1 > p2 )); CHECK (( NotNull2 ( p2 ) > NotNull1 ( p1 )) == ( p2 > p1 )); CHECK (( NotNull1 ( p1 ) <= NotNull1 ( p1 )) == \"true\" ); CHECK (( NotNull1 ( p1 ) <= NotNull2 ( p2 )) == ( p1 <= p2 )); CHECK (( NotNull2 ( p2 ) <= NotNull1 ( p1 )) == ( p2 <= p1 )); CHECK (( NotNull1 ( p1 ) >= NotNull1 ( p1 )) == \"true\" ); CHECK (( NotNull1 ( p1 ) >= NotNull2 ( p2 )) == ( p1 >= p2 )); CHECK (( NotNull2 ( p2 ) >= NotNull1 ( p1 )) == ( p2 >= p1 )); } #if defined(__cplusplus) && (__cplusplus >= 201703L) GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullConstructorTypeDeduction\" ) { { int i = 42 ; not_null x { & i }; helper ( not_null { & i }); helper_const ( not_null { & i }); CHECK ( * x == 42 ); } { int i = 42 ; int * p = & i ; not_null x { p }; helper ( not_null { p }); helper_const ( not_null { p }); CHECK ( * x == 42 ); } { auto workaround_macro = []() { int * p1 = nullptr ; const not_null x { p1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const int * p1 = nullptr ; const not_null x { p1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; CHECK_THROWS_AS ( helper ( not_null { p }), fail_fast ); CHECK_THROWS_AS ( helper_const ( not_null { p }), fail_fast ); } #ifdef CONFIRM_COMPILATION_ERRORS { not_null x { nullptr }; helper ( not_null { nullptr }); helper_const ( not_null { nullptr }); } #endif } #endif // #if defined(__cplusplus) && (__cplusplus >= 201703L) TEST_CASE ( \"TestMakeNotNull\" ) { { int i = 42 ; const auto x = make_not_null ( & i ); helper ( make_not_null ( & i )); helper_const ( make_not_null ( & i )); CHECK ( * x == 42 ); } { int i = 42 ; int * p = & i ; const auto x = make_not_null ( p ); helper ( make_not_null ( p )); helper_const ( make_not_null ( p )); CHECK ( * x == 42 ); } { const auto workaround_macro = []() { int * p1 = nullptr ; const auto x = make_not_null ( p1 ); CHECK ( * x == 42 ); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { const auto workaround_macro = []() { const int * p1 = nullptr ; const auto x = make_not_null ( p1 ); CHECK ( * x == 42 ); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; CHECK_THROWS_AS ( helper ( make_not_null ( p )), fail_fast ); CHECK_THROWS_AS ( helper_const ( make_not_null ( p )), fail_fast ); } #ifdef CONFIRM_COMPILATION_ERRORS { CHECK_THROWS_AS ( make_not_null ( nullptr ), fail_fast ); CHECK_THROWS_AS ( helper ( make_not_null ( nullptr )), fail_fast ); CHECK_THROWS_AS ( helper_const ( make_not_null ( nullptr )), fail_fast ); } #endif } static_assert ( std :: is_nothrow_move_constructible < not_null < void *>>:: value , \"not_null must be no-throw move constructible\" );","title":"File notnull\\_tests.cpp"},{"location":"notnull__tests_8cpp_source/#file-notnull95testscpp","text":"File List > external > guideline > tests > notnull_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch // Fix VS2015 build breaks in Release #pragma warning(disable : 4702) // unreachable code #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/pointers> // for not_null, operator<, operator<=, operator> #include <algorithm> // for addressof #include <memory> // for shared_ptr, make_shared, operator<, opera... #include <sstream> // for operator<<, ostringstream, basic_ostream:... #include <stdint.h> // for uint16_t #include <string> // for basic_string, operator==, string, operator<< #include <typeinfo> // for type_info namespace gsl { struct fail_fast ; } // namespace gsl using namespace gsl ; struct MyBase { }; struct MyDerived : public MyBase { }; struct Unrelated { }; // stand-in for a user-defined ref-counted class template < typename T > struct RefCounted { RefCounted ( T * p ) : p_ ( p ) {} operator T * () { return p_ ; } T * p_ ; }; // user defined smart pointer with comparison operators returning non bool value template < typename T > struct CustomPtr { CustomPtr ( T * p ) : p_ ( p ) {} operator T * () { return p_ ; } bool operator != ( std :: nullptr_t ) const { return p_ != nullptr ; } T * p_ = nullptr ; }; template < typename T , typename U > std :: string operator == ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) == reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator != ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) != reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator < ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) < reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator > ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) > reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator <= ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) <= reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } template < typename T , typename U > std :: string operator >= ( CustomPtr < T > const & lhs , CustomPtr < U > const & rhs ) { GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute return reinterpret_cast < const void *> ( lhs . p_ ) >= reinterpret_cast < const void *> ( rhs . p_ ) ? \"true\" : \"false\" ; } struct NonCopyableNonMovable { NonCopyableNonMovable () = default ; NonCopyableNonMovable ( const NonCopyableNonMovable & ) = delete ; NonCopyableNonMovable & operator = ( const NonCopyableNonMovable & ) = delete ; NonCopyableNonMovable ( NonCopyableNonMovable && ) = delete ; NonCopyableNonMovable & operator = ( NonCopyableNonMovable && ) = delete ; }; GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool helper ( not_null < int *> p ) { return * p == 12 ; } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool helper_const ( not_null < const int *> p ) { return * p == 12 ; } int * return_pointer () { return nullptr ; } const int * return_pointer_const () { return nullptr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullConstructors\" ) { { #ifdef CONFIRM_COMPILATION_ERRORS not_null < int *> p = nullptr ; // yay...does not compile! not_null < std :: vector < char >*> p1 = 0 ; // yay...does not compile! not_null < int *> p2 ; // yay...does not compile! std :: unique_ptr < int > up = std :: make_unique < int > ( 120 ); not_null < int *> p3 = up ; // Forbid non-nullptr assignable types not_null < std :: vector < int >> f ( std :: vector < int > { 1 }); not_null < int > z ( 10 ); not_null < std :: vector < int >> y ({ 1 , 2 }); #endif } { // from shared pointer int i = 12 ; auto rp = RefCounted < int > ( & i ); not_null < int *> p ( rp ); CHECK ( p . get () == & i ); not_null < std :: shared_ptr < int >> x ( std :: make_shared < int > ( 10 )); // shared_ptr<int> is nullptr assignable int * pi = nullptr ; CHECK_THROWS_AS ( not_null < decltype ( pi ) > ( pi ), fail_fast ); } { // from pointer to local int t = 42 ; not_null < int *> x = & t ; helper ( & t ); helper_const ( & t ); CHECK ( * x == 42 ); } { // from raw pointer // from not_null pointer int t = 42 ; int * p = & t ; not_null < int *> x = p ; helper ( p ); helper_const ( p ); helper ( x ); helper_const ( x ); CHECK ( * x == 42 ); } { // from raw const pointer // from not_null const pointer int t = 42 ; const int * cp = & t ; not_null < const int *> x = cp ; helper_const ( cp ); helper_const ( x ); CHECK ( * x == 42 ); } { // from not_null const pointer, using auto int t = 42 ; const int * cp = & t ; auto x = not_null < const int *> { cp }; CHECK ( * x == 42 ); } { // from returned pointer CHECK_THROWS_AS ( helper ( return_pointer ()), fail_fast ); CHECK_THROWS_AS ( helper_const ( return_pointer ()), fail_fast ); } } template < typename T > GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute void ostream_helper ( T v ) { not_null < T *> p ( & v ); { std :: ostringstream os ; std :: ostringstream ref ; os << static_cast < void *> ( p ); ref << static_cast < void *> ( & v ); CHECK ( os . str () == ref . str ()); } { std :: ostringstream os ; std :: ostringstream ref ; os << * p ; ref << v ; CHECK ( os . str () == ref . str ()); } } TEST_CASE ( \"TestNotNullostream\" ) { ostream_helper < int > ( 17 ); ostream_helper < float > ( 21.5f ); ostream_helper < double > ( 3.4566e-7 ); ostream_helper < char > ( 'c' ); ostream_helper < uint16_t > ( 0x0123u ); ostream_helper < const char *> ( \"cstring\" ); ostream_helper < std :: string > ( \"string\" ); } GSL_SUPPRESS ( type .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullCasting\" ) { MyBase base ; MyDerived derived ; Unrelated unrelated ; not_null < Unrelated *> u { & unrelated }; ( void ) u ; not_null < MyDerived *> p { & derived }; not_null < MyBase *> q ( & base ); q = p ; // allowed with heterogeneous copy ctor CHECK ( q == p ); #ifdef CONFIRM_COMPILATION_ERRORS q = u ; // no viable conversion possible between MyBase* and Unrelated* p = q ; // not possible to implicitly convert MyBase* to MyDerived* not_null < Unrelated *> r = p ; not_null < Unrelated *> s = reinterpret_cast < Unrelated *> ( p ); #endif not_null < Unrelated *> t ( reinterpret_cast < Unrelated *> ( p . get ())); CHECK ( reinterpret_cast < void *> ( p . get ()) == reinterpret_cast < void *> ( t . get ())); } TEST_CASE ( \"TestNotNullAssignment\" ) { int i = 12 ; not_null < int *> p ( & i ); CHECK ( helper ( p )); int * q = nullptr ; CHECK_THROWS_AS ( p = not_null < int *> ( q ), fail_fast ); } TEST_CASE ( \"TestNotNullRawPointerComparison\" ) { int ints [ 2 ] = { 42 , 43 }; int * p1 = & ints [ 0 ]; const int * p2 = & ints [ 1 ]; using NotNull1 = not_null < decltype ( p1 ) > ; using NotNull2 = not_null < decltype ( p2 ) > ; CHECK (( NotNull1 ( p1 ) == NotNull1 ( p1 )) == true ); CHECK (( NotNull1 ( p1 ) == NotNull2 ( p2 )) == false ); CHECK (( NotNull1 ( p1 ) != NotNull1 ( p1 )) == false ); CHECK (( NotNull1 ( p1 ) != NotNull2 ( p2 )) == true ); CHECK (( NotNull1 ( p1 ) < NotNull1 ( p1 )) == false ); CHECK (( NotNull1 ( p1 ) < NotNull2 ( p2 )) == ( p1 < p2 )); CHECK (( NotNull2 ( p2 ) < NotNull1 ( p1 )) == ( p2 < p1 )); CHECK (( NotNull1 ( p1 ) > NotNull1 ( p1 )) == false ); CHECK (( NotNull1 ( p1 ) > NotNull2 ( p2 )) == ( p1 > p2 )); CHECK (( NotNull2 ( p2 ) > NotNull1 ( p1 )) == ( p2 > p1 )); CHECK (( NotNull1 ( p1 ) <= NotNull1 ( p1 )) == true ); CHECK (( NotNull1 ( p1 ) <= NotNull2 ( p2 )) == ( p1 <= p2 )); CHECK (( NotNull2 ( p2 ) <= NotNull1 ( p1 )) == ( p2 <= p1 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullDereferenceOperator\" ) { { auto sp1 = std :: make_shared < NonCopyableNonMovable > (); using NotNullSp1 = not_null < decltype ( sp1 ) > ; CHECK ( typeid ( * sp1 ) == typeid ( * NotNullSp1 ( sp1 ))); CHECK ( std :: addressof ( * NotNullSp1 ( sp1 )) == std :: addressof ( * sp1 )); } { int ints [ 1 ] = { 42 }; CustomPtr < int > p1 ( & ints [ 0 ]); using NotNull1 = not_null < decltype ( p1 ) > ; CHECK ( typeid ( * NotNull1 ( p1 )) == typeid ( * p1 )); CHECK ( * NotNull1 ( p1 ) == 42 ); * NotNull1 ( p1 ) = 43 ; CHECK ( ints [ 0 ] == 43 ); } { int v = 42 ; gsl :: not_null < int *> p ( & v ); CHECK ( typeid ( * p ) == typeid ( * ( & v ))); * p = 43 ; CHECK ( v == 43 ); } } TEST_CASE ( \"TestNotNullSharedPtrComparison\" ) { auto sp1 = std :: make_shared < int > ( 42 ); auto sp2 = std :: make_shared < const int > ( 43 ); using NotNullSp1 = not_null < decltype ( sp1 ) > ; using NotNullSp2 = not_null < decltype ( sp2 ) > ; CHECK (( NotNullSp1 ( sp1 ) == NotNullSp1 ( sp1 )) == true ); CHECK (( NotNullSp1 ( sp1 ) == NotNullSp2 ( sp2 )) == false ); CHECK (( NotNullSp1 ( sp1 ) != NotNullSp1 ( sp1 )) == false ); CHECK (( NotNullSp1 ( sp1 ) != NotNullSp2 ( sp2 )) == true ); CHECK (( NotNullSp1 ( sp1 ) < NotNullSp1 ( sp1 )) == false ); CHECK (( NotNullSp1 ( sp1 ) < NotNullSp2 ( sp2 )) == ( sp1 < sp2 )); CHECK (( NotNullSp2 ( sp2 ) < NotNullSp1 ( sp1 )) == ( sp2 < sp1 )); CHECK (( NotNullSp1 ( sp1 ) > NotNullSp1 ( sp1 )) == false ); CHECK (( NotNullSp1 ( sp1 ) > NotNullSp2 ( sp2 )) == ( sp1 > sp2 )); CHECK (( NotNullSp2 ( sp2 ) > NotNullSp1 ( sp1 )) == ( sp2 > sp1 )); CHECK (( NotNullSp1 ( sp1 ) <= NotNullSp1 ( sp1 )) == true ); CHECK (( NotNullSp1 ( sp1 ) <= NotNullSp2 ( sp2 )) == ( sp1 <= sp2 )); CHECK (( NotNullSp2 ( sp2 ) <= NotNullSp1 ( sp1 )) == ( sp2 <= sp1 )); CHECK (( NotNullSp1 ( sp1 ) >= NotNullSp1 ( sp1 )) == true ); CHECK (( NotNullSp1 ( sp1 ) >= NotNullSp2 ( sp2 )) == ( sp1 >= sp2 )); CHECK (( NotNullSp2 ( sp2 ) >= NotNullSp1 ( sp1 )) == ( sp2 >= sp1 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullCustomPtrComparison\" ) { int ints [ 2 ] = { 42 , 43 }; CustomPtr < int > p1 ( & ints [ 0 ]); CustomPtr < const int > p2 ( & ints [ 1 ]); using NotNull1 = not_null < decltype ( p1 ) > ; using NotNull2 = not_null < decltype ( p2 ) > ; CHECK (( NotNull1 ( p1 ) == NotNull1 ( p1 )) == \"true\" ); CHECK (( NotNull1 ( p1 ) == NotNull2 ( p2 )) == \"false\" ); CHECK (( NotNull1 ( p1 ) != NotNull1 ( p1 )) == \"false\" ); CHECK (( NotNull1 ( p1 ) != NotNull2 ( p2 )) == \"true\" ); CHECK (( NotNull1 ( p1 ) < NotNull1 ( p1 )) == \"false\" ); CHECK (( NotNull1 ( p1 ) < NotNull2 ( p2 )) == ( p1 < p2 )); CHECK (( NotNull2 ( p2 ) < NotNull1 ( p1 )) == ( p2 < p1 )); CHECK (( NotNull1 ( p1 ) > NotNull1 ( p1 )) == \"false\" ); CHECK (( NotNull1 ( p1 ) > NotNull2 ( p2 )) == ( p1 > p2 )); CHECK (( NotNull2 ( p2 ) > NotNull1 ( p1 )) == ( p2 > p1 )); CHECK (( NotNull1 ( p1 ) <= NotNull1 ( p1 )) == \"true\" ); CHECK (( NotNull1 ( p1 ) <= NotNull2 ( p2 )) == ( p1 <= p2 )); CHECK (( NotNull2 ( p2 ) <= NotNull1 ( p1 )) == ( p2 <= p1 )); CHECK (( NotNull1 ( p1 ) >= NotNull1 ( p1 )) == \"true\" ); CHECK (( NotNull1 ( p1 ) >= NotNull2 ( p2 )) == ( p1 >= p2 )); CHECK (( NotNull2 ( p2 ) >= NotNull1 ( p1 )) == ( p2 >= p1 )); } #if defined(__cplusplus) && (__cplusplus >= 201703L) GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestNotNullConstructorTypeDeduction\" ) { { int i = 42 ; not_null x { & i }; helper ( not_null { & i }); helper_const ( not_null { & i }); CHECK ( * x == 42 ); } { int i = 42 ; int * p = & i ; not_null x { p }; helper ( not_null { p }); helper_const ( not_null { p }); CHECK ( * x == 42 ); } { auto workaround_macro = []() { int * p1 = nullptr ; const not_null x { p1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const int * p1 = nullptr ; const not_null x { p1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; CHECK_THROWS_AS ( helper ( not_null { p }), fail_fast ); CHECK_THROWS_AS ( helper_const ( not_null { p }), fail_fast ); } #ifdef CONFIRM_COMPILATION_ERRORS { not_null x { nullptr }; helper ( not_null { nullptr }); helper_const ( not_null { nullptr }); } #endif } #endif // #if defined(__cplusplus) && (__cplusplus >= 201703L) TEST_CASE ( \"TestMakeNotNull\" ) { { int i = 42 ; const auto x = make_not_null ( & i ); helper ( make_not_null ( & i )); helper_const ( make_not_null ( & i )); CHECK ( * x == 42 ); } { int i = 42 ; int * p = & i ; const auto x = make_not_null ( p ); helper ( make_not_null ( p )); helper_const ( make_not_null ( p )); CHECK ( * x == 42 ); } { const auto workaround_macro = []() { int * p1 = nullptr ; const auto x = make_not_null ( p1 ); CHECK ( * x == 42 ); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { const auto workaround_macro = []() { const int * p1 = nullptr ; const auto x = make_not_null ( p1 ); CHECK ( * x == 42 ); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; CHECK_THROWS_AS ( helper ( make_not_null ( p )), fail_fast ); CHECK_THROWS_AS ( helper_const ( make_not_null ( p )), fail_fast ); } #ifdef CONFIRM_COMPILATION_ERRORS { CHECK_THROWS_AS ( make_not_null ( nullptr ), fail_fast ); CHECK_THROWS_AS ( helper ( make_not_null ( nullptr )), fail_fast ); CHECK_THROWS_AS ( helper_const ( make_not_null ( nullptr )), fail_fast ); } #endif } static_assert ( std :: is_nothrow_move_constructible < not_null < void *>>:: value , \"not_null must be no-throw move constructible\" );","title":"File notnull_tests.cpp"},{"location":"owner__tests_8cpp/","text":"File owner_tests.cpp \u00b6 File List > external > guideline > tests > owner_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/pointers> Public Functions \u00b6 Type Name GSL_SUPPRESS (f. 23) GSL_SUPPRESS (r. 11) TEST_CASE (\"check_pointer_constraint\") Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( f . 23 ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( r . 11 ) function TEST_CASE \u00b6 TEST_CASE ( \"check_pointer_constraint\" ) The documentation for this class was generated from the following file external/guideline/tests/owner_tests.cpp","title":"File owner\\_tests.cpp"},{"location":"owner__tests_8cpp/#file-owner95testscpp","text":"File List > external > guideline > tests > owner_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/pointers>","title":"File owner_tests.cpp"},{"location":"owner__tests_8cpp/#public-functions","text":"Type Name GSL_SUPPRESS (f. 23) GSL_SUPPRESS (r. 11) TEST_CASE (\"check_pointer_constraint\")","title":"Public Functions"},{"location":"owner__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"owner__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( f . 23 )","title":"function GSL_SUPPRESS"},{"location":"owner__tests_8cpp/#function-gsl95suppress_1","text":"GSL_SUPPRESS ( r . 11 )","title":"function GSL_SUPPRESS"},{"location":"owner__tests_8cpp/#function-test95case","text":"TEST_CASE ( \"check_pointer_constraint\" ) The documentation for this class was generated from the following file external/guideline/tests/owner_tests.cpp","title":"function TEST_CASE"},{"location":"owner__tests_8cpp_source/","text":"File owner_tests.cpp \u00b6 File List > external > guideline > tests > owner_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/pointers> // for owner using namespace gsl ; GSL_SUPPRESS ( f .23 ) // NO-FORMAT: attribute void f ( int * i ) { * i += 1 ; } GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute // TODO: false positive GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute TEST_CASE ( \"basic_test\" ) { owner < int *> p = new int ( 120 ); CHECK ( * p == 120 ); f ( p ); CHECK ( * p == 121 ); delete p ; } TEST_CASE ( \"check_pointer_constraint\" ) { #ifdef CONFIRM_COMPILATION_ERRORS { owner < int > integerTest = 10 ; owner < std :: shared_ptr < int >> sharedPtrTest ( new int ( 10 )); } #endif }","title":"File owner\\_tests.cpp"},{"location":"owner__tests_8cpp_source/#file-owner95testscpp","text":"File List > external > guideline > tests > owner_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/pointers> // for owner using namespace gsl ; GSL_SUPPRESS ( f .23 ) // NO-FORMAT: attribute void f ( int * i ) { * i += 1 ; } GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute // TODO: false positive GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute TEST_CASE ( \"basic_test\" ) { owner < int *> p = new int ( 120 ); CHECK ( * p == 120 ); f ( p ); CHECK ( * p == 121 ); delete p ; } TEST_CASE ( \"check_pointer_constraint\" ) { #ifdef CONFIRM_COMPILATION_ERRORS { owner < int > integerTest = 10 ; owner < std :: shared_ptr < int >> sharedPtrTest ( new int ( 10 )); } #endif }","title":"File owner_tests.cpp"},{"location":"pages/","text":"Related Pages \u00b6 Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"pages/#related-pages","text":"Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"pthread_8cpp/","text":"File pthread.cpp \u00b6 File List > modules > thread > pthread.cpp Go to the source code of this file. #include <coroutine/thread.h> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/thread/pthread.cpp","title":"File pthread.cpp"},{"location":"pthread_8cpp/#file-pthreadcpp","text":"File List > modules > thread > pthread.cpp Go to the source code of this file. #include <coroutine/thread.h>","title":"File pthread.cpp"},{"location":"pthread_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/thread/pthread.cpp","title":"Namespaces"},{"location":"pthread_8cpp_source/","text":"File pthread.cpp \u00b6 File List > modules > thread > pthread.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/thread.h> namespace coro { void * coroutine_pthread_resume ( void * ptr ) noexcept ( false ) { // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } void pthread_spawner_t :: resume_on_pthread ( coroutine_handle < void > rh ) // noexcept ( false ) { if ( auto ec = pthread_create ( this -> tid , this -> attr , coroutine_pthread_resume , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_joiner_t :: try_join () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; void * ptr {}; // we must acquire `tid` before the destruction if ( auto ec = pthread_join ( tid , & ptr )) { throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )) { frame . destroy (); } } pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_detacher_t :: try_detach () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; if ( auto ec = pthread_detach ( tid )) { throw system_error { ec , system_category (), \"pthread_join\" }; } } } // namespace coro","title":"File pthread.cpp"},{"location":"pthread_8cpp_source/#file-pthreadcpp","text":"File List > modules > thread > pthread.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/thread.h> namespace coro { void * coroutine_pthread_resume ( void * ptr ) noexcept ( false ) { // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } void pthread_spawner_t :: resume_on_pthread ( coroutine_handle < void > rh ) // noexcept ( false ) { if ( auto ec = pthread_create ( this -> tid , this -> attr , coroutine_pthread_resume , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_joiner_t :: try_join () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; void * ptr {}; // we must acquire `tid` before the destruction if ( auto ec = pthread_join ( tid , & ptr )) { throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )) { frame . destroy (); } } pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_detacher_t :: try_detach () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; if ( auto ec = pthread_detach ( tid )) { throw system_error { ec , system_category (), \"pthread_join\" }; } } } // namespace coro","title":"File pthread.cpp"},{"location":"resolver_8cpp/","text":"File resolver.cpp \u00b6 File List > modules > net > resolver.cpp Go to the source code of this file. #include <coroutine/net.h> #include <gsl/gsl> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/net/resolver.cpp","title":"File resolver.cpp"},{"location":"resolver_8cpp/#file-resolvercpp","text":"File List > modules > net > resolver.cpp Go to the source code of this file. #include <coroutine/net.h> #include <gsl/gsl>","title":"File resolver.cpp"},{"location":"resolver_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/net/resolver.cpp","title":"Namespaces"},{"location":"resolver_8cpp_source/","text":"File resolver.cpp \u00b6 File List > modules > net > resolver.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/net.h> #include <gsl/gsl> using namespace std ; namespace coro { GSL_SUPPRESS ( type .1 ) int32_t get_name ( const sockaddr_in & addr , zstring_host name , zstring_serv serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } GSL_SUPPRESS ( type .1 ) int32_t get_name ( const sockaddr_in6 & addr , zstring_host name , zstring_serv serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in6 ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } auto resolve_error ( int32_t ec ) noexcept -> system_error { return std :: system_error { ec , system_category (), :: gai_strerror ( ec )}; } auto enumerate_addrinfo ( gsl :: not_null < addrinfo *> list ) noexcept -> enumerable < sockaddr > { // RAII clean up for the assigned addrinfo // This holder guarantees clean up // when the generator is destroyed auto d1 = gsl :: finally ([ list ]() noexcept { :: freeaddrinfo ( list ); }); for ( addrinfo * it = list ; it != nullptr ; it = it -> ai_next ) { if ( it -> ai_addr ) co_yield * ( it -> ai_addr ); } } int32_t resolve ( enumerable < sockaddr >& g , const addrinfo & hint , // czstring_host name , czstring_serv serv ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( name , serv , // addressof ( hint ), addressof ( list ))) return ec ; g = enumerate_addrinfo ( gsl :: make_not_null ( list )); return 0 ; } } // namespace coro","title":"File resolver.cpp"},{"location":"resolver_8cpp_source/#file-resolvercpp","text":"File List > modules > net > resolver.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/net.h> #include <gsl/gsl> using namespace std ; namespace coro { GSL_SUPPRESS ( type .1 ) int32_t get_name ( const sockaddr_in & addr , zstring_host name , zstring_serv serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } GSL_SUPPRESS ( type .1 ) int32_t get_name ( const sockaddr_in6 & addr , zstring_host name , zstring_serv serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in6 ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } auto resolve_error ( int32_t ec ) noexcept -> system_error { return std :: system_error { ec , system_category (), :: gai_strerror ( ec )}; } auto enumerate_addrinfo ( gsl :: not_null < addrinfo *> list ) noexcept -> enumerable < sockaddr > { // RAII clean up for the assigned addrinfo // This holder guarantees clean up // when the generator is destroyed auto d1 = gsl :: finally ([ list ]() noexcept { :: freeaddrinfo ( list ); }); for ( addrinfo * it = list ; it != nullptr ; it = it -> ai_next ) { if ( it -> ai_addr ) co_yield * ( it -> ai_addr ); } } int32_t resolve ( enumerable < sockaddr >& g , const addrinfo & hint , // czstring_host name , czstring_serv serv ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( name , serv , // addressof ( hint ), addressof ( list ))) return ec ; g = enumerate_addrinfo ( gsl :: make_not_null ( list )); return 0 ; } } // namespace coro","title":"File resolver.cpp"},{"location":"return_8h/","text":"File return.h \u00b6 File List > coroutine > return.h Go to the source code of this file. Utility to define return types for coroutine. More... #include <type_traits> #include <coroutine/frame.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type class promise_aa class promise_an class promise_na class promise_nn Macros \u00b6 Type Name define COROUTINE_PROMISE_AND_RETURN_TYPES_H Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/ Macro Definition Documentation \u00b6 define COROUTINE_PROMISE_AND_RETURN_TYPES_H \u00b6 #define COROUTINE_PROMISE_AND_RETURN_TYPES_H The documentation for this class was generated from the following file interface/coroutine/return.h","title":"File return.h"},{"location":"return_8h/#file-returnh","text":"File List > coroutine > return.h Go to the source code of this file. Utility to define return types for coroutine. More... #include <type_traits> #include <coroutine/frame.h>","title":"File return.h"},{"location":"return_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"return_8h/#classes","text":"Type Name class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type class promise_aa class promise_an class promise_na class promise_nn","title":"Classes"},{"location":"return_8h/#macros","text":"Type Name define COROUTINE_PROMISE_AND_RETURN_TYPES_H","title":"Macros"},{"location":"return_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/","title":"Detailed Description"},{"location":"return_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"return_8h/#define-coroutine95promise95and95return95types95h","text":"#define COROUTINE_PROMISE_AND_RETURN_TYPES_H The documentation for this class was generated from the following file interface/coroutine/return.h","title":"define COROUTINE_PROMISE_AND_RETURN_TYPES_H"},{"location":"return_8h_source/","text":"File return.h \u00b6 File List > coroutine > return.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_PROMISE_AND_RETURN_TYPES_H #define COROUTINE_PROMISE_AND_RETURN_TYPES_H #include <type_traits> #include <coroutine/frame.h> namespace coro { #if __has_include(<coroutine>) // C++ 20 using namespace std ; #elif __has_include(<experimental/coroutine>) // C++ 17 using namespace std ; using namespace std :: experimental ; #endif class promise_nn { public : auto initial_suspend () noexcept { return suspend_never {}; // no suspend after invoke } auto final_suspend () noexcept { return suspend_never {}; // no suspend after return } }; class promise_na { public : auto initial_suspend () noexcept { return suspend_never {}; // no suspend after invoke } auto final_suspend () noexcept { return suspend_always {}; // suspend after return } }; class promise_an { public : auto initial_suspend () noexcept { return suspend_always {}; // suspend after invoke } auto final_suspend () noexcept { return suspend_never {}; // no suspend after return } }; class promise_aa { public : auto initial_suspend () noexcept { return suspend_always {}; // suspend after invoke } auto final_suspend () noexcept { return suspend_always {}; // suspend after return } }; class frame_t final : public coroutine_handle < void > { public : class promise_type final : public coro :: promise_aa { public : void unhandled_exception () noexcept ( false ) { throw ; } void return_void () noexcept { } auto get_return_object () noexcept { frame_t frame {}; coroutine_handle < void >& ref = frame ; ref = coroutine_handle < promise_type >:: from_promise ( * this ); return frame ; } }; }; #if defined(__cpp_concepts) template < typename T , typename R = void > concept awaitable = requires ( T a , coroutine_handle < void > h ) { { a . await_ready () } -> bool ; { a . await_suspend ( h ) } -> void ; { a . await_resume () } -> R ; }; template < typename P > concept promise_requirement_basic = requires ( P p ) { { p . initial_suspend () } -> awaitable ; { p . final_suspend () } -> awaitable ; { p . unhandled_exception () } -> void ; }; #endif } // namespace coro #endif // COROUTINE_PROMISE_AND_RETURN_TYPES_H","title":"File return.h"},{"location":"return_8h_source/#file-returnh","text":"File List > coroutine > return.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_PROMISE_AND_RETURN_TYPES_H #define COROUTINE_PROMISE_AND_RETURN_TYPES_H #include <type_traits> #include <coroutine/frame.h> namespace coro { #if __has_include(<coroutine>) // C++ 20 using namespace std ; #elif __has_include(<experimental/coroutine>) // C++ 17 using namespace std ; using namespace std :: experimental ; #endif class promise_nn { public : auto initial_suspend () noexcept { return suspend_never {}; // no suspend after invoke } auto final_suspend () noexcept { return suspend_never {}; // no suspend after return } }; class promise_na { public : auto initial_suspend () noexcept { return suspend_never {}; // no suspend after invoke } auto final_suspend () noexcept { return suspend_always {}; // suspend after return } }; class promise_an { public : auto initial_suspend () noexcept { return suspend_always {}; // suspend after invoke } auto final_suspend () noexcept { return suspend_never {}; // no suspend after return } }; class promise_aa { public : auto initial_suspend () noexcept { return suspend_always {}; // suspend after invoke } auto final_suspend () noexcept { return suspend_always {}; // suspend after return } }; class frame_t final : public coroutine_handle < void > { public : class promise_type final : public coro :: promise_aa { public : void unhandled_exception () noexcept ( false ) { throw ; } void return_void () noexcept { } auto get_return_object () noexcept { frame_t frame {}; coroutine_handle < void >& ref = frame ; ref = coroutine_handle < promise_type >:: from_promise ( * this ); return frame ; } }; }; #if defined(__cpp_concepts) template < typename T , typename R = void > concept awaitable = requires ( T a , coroutine_handle < void > h ) { { a . await_ready () } -> bool ; { a . await_suspend ( h ) } -> void ; { a . await_resume () } -> R ; }; template < typename P > concept promise_requirement_basic = requires ( P p ) { { p . initial_suspend () } -> awaitable ; { p . final_suspend () } -> awaitable ; { p . unhandled_exception () } -> void ; }; #endif } // namespace coro #endif // COROUTINE_PROMISE_AND_RETURN_TYPES_H","title":"File return.h"},{"location":"section__pthread_8cpp/","text":"File section_pthread.cpp \u00b6 File List > concrt > section_pthread.cpp Go to the source code of this file. #include <cstdio> #include <system_error> #include <concurrency_helper.h> Macros \u00b6 Type Name define LIB_EPILOGUE __attribute__((destructor)) define LIB_PROLOGUE __attribute__((constructor)) Macro Definition Documentation \u00b6 define LIB_EPILOGUE \u00b6 #define LIB_EPILOGUE __attribute__((destructor)) define LIB_PROLOGUE \u00b6 #define LIB_PROLOGUE __attribute__((constructor)) The documentation for this class was generated from the following file modules/concrt/section_pthread.cpp","title":"File section\\_pthread.cpp"},{"location":"section__pthread_8cpp/#file-section95pthreadcpp","text":"File List > concrt > section_pthread.cpp Go to the source code of this file. #include <cstdio> #include <system_error> #include <concurrency_helper.h>","title":"File section_pthread.cpp"},{"location":"section__pthread_8cpp/#macros","text":"Type Name define LIB_EPILOGUE __attribute__((destructor)) define LIB_PROLOGUE __attribute__((constructor))","title":"Macros"},{"location":"section__pthread_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"section__pthread_8cpp/#define-lib95epilogue","text":"#define LIB_EPILOGUE __attribute__((destructor))","title":"define LIB_EPILOGUE"},{"location":"section__pthread_8cpp/#define-lib95prologue","text":"#define LIB_PROLOGUE __attribute__((constructor)) The documentation for this class was generated from the following file modules/concrt/section_pthread.cpp","title":"define LIB_PROLOGUE"},{"location":"section__pthread_8cpp_source/","text":"File section_pthread.cpp \u00b6 File List > concrt > section_pthread.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <cstdio> #include <system_error> #include <concurrency_helper.h> #define LIB_PROLOGUE __attribute__((constructor)) #define LIB_EPILOGUE __attribute__((destructor)) using namespace std ; section :: section () noexcept ( false ) : rwlock {} { if ( auto ec = pthread_rwlock_init ( & rwlock , nullptr )) throw system_error { ec , system_category (), \"pthread_rwlock_init\" }; } section ::~ section () noexcept { try { if ( auto ec = pthread_rwlock_destroy ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_destroy\" }; } catch ( const system_error & e ) { perror ( e . what ()); } catch (...) { perror ( \"Unknown exception in section dtor\" ); } } bool section :: try_lock () noexcept { // EBUSY // possible error // EINVAL // EDEADLK auto ec = pthread_rwlock_trywrlock ( & rwlock ); return ec == 0 ; } // - Note // // There was an issue with `pthread_mutex_` // it returned EINVAL for lock operation // replacing it the rwlock // void section :: lock () noexcept ( false ) { if ( auto ec = pthread_rwlock_wrlock ( & rwlock )) // EINVAL ? throw system_error { ec , system_category (), \"pthread_rwlock_wrlock\" }; } void section :: unlock () noexcept ( false ) { if ( auto ec = pthread_rwlock_unlock ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_unlock\" }; }","title":"File section\\_pthread.cpp"},{"location":"section__pthread_8cpp_source/#file-section95pthreadcpp","text":"File List > concrt > section_pthread.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <cstdio> #include <system_error> #include <concurrency_helper.h> #define LIB_PROLOGUE __attribute__((constructor)) #define LIB_EPILOGUE __attribute__((destructor)) using namespace std ; section :: section () noexcept ( false ) : rwlock {} { if ( auto ec = pthread_rwlock_init ( & rwlock , nullptr )) throw system_error { ec , system_category (), \"pthread_rwlock_init\" }; } section ::~ section () noexcept { try { if ( auto ec = pthread_rwlock_destroy ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_destroy\" }; } catch ( const system_error & e ) { perror ( e . what ()); } catch (...) { perror ( \"Unknown exception in section dtor\" ); } } bool section :: try_lock () noexcept { // EBUSY // possible error // EINVAL // EDEADLK auto ec = pthread_rwlock_trywrlock ( & rwlock ); return ec == 0 ; } // - Note // // There was an issue with `pthread_mutex_` // it returned EINVAL for lock operation // replacing it the rwlock // void section :: lock () noexcept ( false ) { if ( auto ec = pthread_rwlock_wrlock ( & rwlock )) // EINVAL ? throw system_error { ec , system_category (), \"pthread_rwlock_wrlock\" }; } void section :: unlock () noexcept ( false ) { if ( auto ec = pthread_rwlock_unlock ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_unlock\" }; }","title":"File section_pthread.cpp"},{"location":"section__win32_8cpp/","text":"File section_win32.cpp \u00b6 File List > concrt > section_win32.cpp Go to the source code of this file. #include <concurrency_helper.h> The documentation for this class was generated from the following file modules/concrt/section_win32.cpp","title":"File section\\_win32.cpp"},{"location":"section__win32_8cpp/#file-section95win32cpp","text":"File List > concrt > section_win32.cpp Go to the source code of this file. #include <concurrency_helper.h> The documentation for this class was generated from the following file modules/concrt/section_win32.cpp","title":"File section_win32.cpp"},{"location":"section__win32_8cpp_source/","text":"File section_win32.cpp \u00b6 File List > concrt > section_win32.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <concurrency_helper.h> using namespace std ; static_assert ( is_move_assignable_v < section > == false ); static_assert ( is_move_constructible_v < section > == false ); static_assert ( is_copy_assignable_v < section > == false ); static_assert ( is_copy_constructible_v < section > == false ); section :: section () noexcept ( false ) { InitializeCriticalSectionAndSpinCount ( this , 0600 ); } section ::~ section () noexcept { DeleteCriticalSection ( this ); } bool section :: try_lock () noexcept { return TryEnterCriticalSection ( this ); } void section :: lock () noexcept ( false ) { EnterCriticalSection ( this ); } void section :: unlock () noexcept ( false ) { LeaveCriticalSection ( this ); }","title":"File section\\_win32.cpp"},{"location":"section__win32_8cpp_source/#file-section95win32cpp","text":"File List > concrt > section_win32.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <concurrency_helper.h> using namespace std ; static_assert ( is_move_assignable_v < section > == false ); static_assert ( is_move_constructible_v < section > == false ); static_assert ( is_copy_assignable_v < section > == false ); static_assert ( is_copy_constructible_v < section > == false ); section :: section () noexcept ( false ) { InitializeCriticalSectionAndSpinCount ( this , 0600 ); } section ::~ section () noexcept { DeleteCriticalSection ( this ); } bool section :: try_lock () noexcept { return TryEnterCriticalSection ( this ); } void section :: lock () noexcept ( false ) { EnterCriticalSection ( this ); } void section :: unlock () noexcept ( false ) { LeaveCriticalSection ( this ); }","title":"File section_win32.cpp"},{"location":"span__tests_8cpp/","text":"File span_tests.cpp \u00b6 File List > external > guideline > tests > span_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_byte> #include <gsl/gsl_util> #include <gsl/span> #include <array> #include <iostream> #include <iterator> #include <memory> #include <regex> #include <stddef.h> #include <string> #include <type_traits> #include <vector> Namespaces \u00b6 Type Name namespace gsl Public Functions \u00b6 Type Name GSL_SUPPRESS (con. 4) TEST_CASE (\"from_array_constructor\") TEST_CASE (\"default_constructible\") Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( con . 4 ) function TEST_CASE \u00b6 TEST_CASE ( \"from_array_constructor\" ) function TEST_CASE \u00b6 TEST_CASE ( \"default_constructible\" ) The documentation for this class was generated from the following file external/guideline/tests/span_tests.cpp","title":"File span\\_tests.cpp"},{"location":"span__tests_8cpp/#file-span95testscpp","text":"File List > external > guideline > tests > span_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_byte> #include <gsl/gsl_util> #include <gsl/span> #include <array> #include <iostream> #include <iterator> #include <memory> #include <regex> #include <stddef.h> #include <string> #include <type_traits> #include <vector>","title":"File span_tests.cpp"},{"location":"span__tests_8cpp/#namespaces","text":"Type Name namespace gsl","title":"Namespaces"},{"location":"span__tests_8cpp/#public-functions","text":"Type Name GSL_SUPPRESS (con. 4) TEST_CASE (\"from_array_constructor\") TEST_CASE (\"default_constructible\")","title":"Public Functions"},{"location":"span__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"span__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( con . 4 )","title":"function GSL_SUPPRESS"},{"location":"span__tests_8cpp/#function-test95case","text":"TEST_CASE ( \"from_array_constructor\" )","title":"function TEST_CASE"},{"location":"span__tests_8cpp/#function-test95case_1","text":"TEST_CASE ( \"default_constructible\" ) The documentation for this class was generated from the following file external/guideline/tests/span_tests.cpp","title":"function TEST_CASE"},{"location":"span__tests_8cpp_source/","text":"File span_tests.cpp \u00b6 File List > external > guideline > tests > span_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426 26497) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/gsl_byte> // for byte #include <gsl/gsl_util> // for narrow_cast, at #include <gsl/span> // for span, span_iterator, operator==, operator!= #include <array> // for array #include <iostream> // for ptrdiff_t #include <iterator> // for reverse_iterator, operator-, operator== #include <memory> // for unique_ptr, shared_ptr, make_unique, allo... #include <regex> // for match_results, sub_match, match_results<>... #include <stddef.h> // for ptrdiff_t #include <string> // for string #include <type_traits> // for integral_constant<>::value, is_default_co... #include <vector> // for vector namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; namespace { struct BaseClass { }; struct DerivedClass : BaseClass { }; struct AddressOverloaded { #if (__cplusplus > 201402L) [[ maybe_unused ]] #endif AddressOverloaded operator & () const { return {}; } }; } // namespace GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"default_constructor\" ) { { span < int > s ; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int > cs ; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } { span < int , 0 > s ; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int , 0 > cs ; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } { #ifdef CONFIRM_COMPILATION_ERRORS span < int , 1 > s ; CHECK (( s . size () == 1 && s . data () == nullptr )); // explains why it can't compile #endif } { span < int > s {}; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int > cs {}; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"size_optimization\" ) { { span < int > s ; CHECK ( sizeof ( s ) == sizeof ( int * ) + sizeof ( ptrdiff_t )); } { span < int , 0 > s ; CHECK ( sizeof ( s ) == sizeof ( int * )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_nullptr_size_constructor\" ) { { span < int > s { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int > cs { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } { span < int , 0 > s { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int , 0 > cs { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } { auto workaround_macro = []() { const span < int , 1 > s { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const span < int > s { nullptr , 1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); auto const_workaround_macro = []() { const span < const int > cs { nullptr , 1 }; }; CHECK_THROWS_AS ( const_workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const span < int , 0 > s { nullptr , 1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); auto const_workaround_macro = []() { const span < const int , 0 > s { nullptr , 1 }; }; CHECK_THROWS_AS ( const_workaround_macro (), fail_fast ); } { span < int *> s { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int *> cs { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"from_pointer_length_constructor\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { for ( int i = 0 ; i < 4 ; ++ i ) { { span < int > s = { & arr [ 0 ], i }; CHECK ( s . size () == i ); CHECK ( s . data () == & arr [ 0 ]); CHECK ( s . empty () == ( i == 0 )); for ( int j = 0 ; j < i ; ++ j ) { CHECK ( arr [ j ] == s [ j ]); CHECK ( arr [ j ] == s . at ( j )); CHECK ( arr [ j ] == s ( j )); } } { span < int > s = { & arr [ i ], 4 - narrow_cast < ptrdiff_t > ( i ) }; CHECK ( s . size () == 4 - i ); CHECK ( s . data () == & arr [ i ]); CHECK ( s . empty () == ( 4 - i == 0 )); for ( int j = 0 ; j < 4 - i ; ++ j ) { CHECK ( arr [ j + i ] == s [ j ]); CHECK ( arr [ j + i ] == s . at ( j )); CHECK ( arr [ j + i ] == s ( j )); } } } } { span < int , 2 > s { & arr [ 0 ], 2 }; CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { int * p = nullptr ; span < int > s { p , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( s . size () == 0 && s . data () == nullptr )); } { int * p = nullptr ; auto workaround_macro = [ = ]() { const span < int > s { p , 2 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { auto s = make_span ( & arr [ 0 ], 2 ); CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { int * p = nullptr ; auto s = make_span ( p , narrow_cast < span < int >:: index_type > ( 0 )); CHECK (( s . size () == 0 && s . data () == nullptr )); } { int * p = nullptr ; auto workaround_macro = [ = ]() { make_span ( p , 2 ); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_pointer_pointer_constructor\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { span < int > s { & arr [ 0 ], & arr [ 2 ]}; CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { span < int , 2 > s { & arr [ 0 ], & arr [ 2 ]}; CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { span < int > s { & arr [ 0 ], & arr [ 0 ]}; CHECK (( s . size () == 0 && s . data () == & arr [ 0 ])); } { span < int , 0 > s { & arr [ 0 ], & arr [ 0 ]}; CHECK (( s . size () == 0 && s . data () == & arr [ 0 ])); } // this will fail the std::distance() precondition, which asserts on MSVC debug builds //{ // auto workaround_macro = [&]() { span<int> s{&arr[1], &arr[0]}; }; // CHECK_THROWS_AS(workaround_macro(), fail_fast); //} // this will fail the std::distance() precondition, which asserts on MSVC debug builds //{ // int* p = nullptr; // auto workaround_macro = [&]() { span<int> s{&arr[0], p}; }; // CHECK_THROWS_AS(workaround_macro(), fail_fast); //} { int * p = nullptr ; span < int > s { p , p }; CHECK (( s . size () == 0 && s . data () == nullptr )); } { int * p = nullptr ; span < int , 0 > s { p , p }; CHECK (( s . size () == 0 && s . data () == nullptr )); } // this will fail the std::distance() precondition, which asserts on MSVC debug builds //{ // int* p = nullptr; // auto workaround_macro = [&]() { span<int> s{&arr[0], p}; }; // CHECK_THROWS_AS(workaround_macro(), fail_fast); //} { auto s = make_span ( & arr [ 0 ], & arr [ 2 ]); CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { auto s = make_span ( & arr [ 0 ], & arr [ 0 ]); CHECK (( s . size () == 0 && s . data () == & arr [ 0 ])); } { int * p = nullptr ; auto s = make_span ( p , p ); CHECK (( s . size () == 0 && s . data () == nullptr )); } } TEST_CASE ( \"from_array_constructor\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { const span < int > s { arr }; CHECK (( s . size () == 5 && s . data () == & arr [ 0 ])); } { const span < int , 5 > s { arr }; CHECK (( s . size () == 5 && s . data () == & arr [ 0 ])); } int arr2d [ 2 ][ 3 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; #ifdef CONFIRM_COMPILATION_ERRORS { span < int , 6 > s { arr }; } { span < int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == & arr [ 0 ])); } { span < int > s { arr2d }; CHECK (( s . size () == 6 && s . data () == & arr2d [ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } { span < int , 0 > s { arr2d }; CHECK (( s . size () == 0 && s . data () == & arr2d [ 0 ][ 0 ])); } { span < int , 6 > s { arr2d }; } #endif { const span < int [ 3 ] > s { std :: addressof ( arr2d [ 0 ]), 1 }; CHECK (( s . size () == 1 && s . data () == std :: addressof ( arr2d [ 0 ]))); } int arr3d [ 2 ][ 3 ][ 2 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 }; #ifdef CONFIRM_COMPILATION_ERRORS { span < int > s { arr3d }; CHECK (( s . size () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 11 ] == 12 )); } { span < int , 0 > s { arr3d }; CHECK (( s . size () == 0 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); } { span < int , 11 > s { arr3d }; } { span < int , 12 > s { arr3d }; CHECK (( s . size () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } #endif { const span < int [ 3 ][ 2 ] > s { std :: addressof ( arr3d [ 0 ]), 1 }; CHECK (( s . size () == 1 && s . data () == std :: addressof ( arr3d [ 0 ]))); } { const auto s = make_span ( arr ); CHECK (( s . size () == 5 && s . data () == std :: addressof ( arr [ 0 ]))); } { const auto s = make_span ( std :: addressof ( arr2d [ 0 ]), 1 ); CHECK (( s . size () == 1 && s . data () == std :: addressof ( arr2d [ 0 ]))); } { const auto s = make_span ( std :: addressof ( arr3d [ 0 ]), 1 ); CHECK (( s . size () == 1 && s . data () == std :: addressof ( arr3d [ 0 ]))); } AddressOverloaded ao_arr [ 5 ] = {}; { const span < AddressOverloaded , 5 > s { ao_arr }; CHECK (( s . size () == 5 && s . data () == std :: addressof ( ao_arr [ 0 ]))); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"from_dynamic_array_constructor\" ) { double ( * arr )[ 3 ][ 4 ] = new double [ 100 ][ 3 ][ 4 ]; { span < double > s ( & arr [ 0 ][ 0 ][ 0 ], 10 ); CHECK (( s . size () == 10 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } { auto s = make_span ( & arr [ 0 ][ 0 ][ 0 ], 10 ); CHECK (( s . size () == 10 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_std_array_constructor\" ) { std :: array < int , 4 > arr = { 1 , 2 , 3 , 4 }; { span < int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); span < const int > cs { arr }; CHECK (( cs . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && cs . data () == arr . data ())); } { span < int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); span < const int , 4 > cs { arr }; CHECK (( cs . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && cs . data () == arr . data ())); } { std :: array < int , 0 > empty_arr {}; span < int > s { empty_arr }; CHECK (( s . size () == 0 && s . empty ())); } std :: array < AddressOverloaded , 4 > ao_arr {}; { span < AddressOverloaded , 4 > fs { ao_arr }; CHECK (( fs . size () == narrow_cast < ptrdiff_t > ( ao_arr . size ()) && ao_arr . data () == fs . data ())); } #ifdef CONFIRM_COMPILATION_ERRORS { span < int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); span < const int , 2 > cs { arr }; CHECK (( cs . size () == 2 && cs . data () == arr . data ())); } { span < int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); span < const int , 0 > cs { arr }; CHECK (( cs . size () == 0 && cs . data () == arr . data ())); } { span < int , 5 > s { arr }; } { auto get_an_array = []() -> std :: array < int , 4 > { return { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( span < int > s ) { static_cast < void > ( s ); }; // try to take a temporary std::array take_a_span ( get_an_array ()); } #endif { auto get_an_array = []() -> std :: array < int , 4 > { return { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( span < const int > s ) { static_cast < void > ( s ); }; // try to take a temporary std::array take_a_span ( get_an_array ()); } { auto s = make_span ( arr ); CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } // This test checks for the bug found in gcc 6.1, 6.2, 6.3, 6.4, 6.5 7.1, 7.2, 7.3 - issue #590 { span < int > s1 = make_span ( arr ); static span < int > s2 ; s2 = s1 ; #if defined(__GNUC__) && __GNUC__ == 6 && (__GNUC_MINOR__ == 4 || __GNUC_MINOR__ == 5) && \\ __GNUC_PATCHLEVEL__ == 0 && defined(__OPTIMIZE__) // Known to be broken in gcc 6.4 and 6.5 with optimizations // Issue in gcc: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83116 CHECK ( s1 . size () == 4 ); CHECK ( s2 . size () == 0 ); #else CHECK ( s1 . size () == s2 . size ()); #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_const_std_array_constructor\" ) { const std :: array < int , 4 > arr = { 1 , 2 , 3 , 4 }; { span < const int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } { span < const int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } const std :: array < AddressOverloaded , 4 > ao_arr {}; { span < const AddressOverloaded , 4 > s { ao_arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( ao_arr . size ()) && s . data () == ao_arr . data ())); } #ifdef CONFIRM_COMPILATION_ERRORS { span < const int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); } { span < const int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); } { span < const int , 5 > s { arr }; } #endif { auto get_an_array = []() -> const std :: array < int , 4 > { return { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( span < const int > s ) { static_cast < void > ( s ); }; // try to take a temporary std::array take_a_span ( get_an_array ()); } { auto s = make_span ( arr ); CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_std_array_const_constructor\" ) { std :: array < const int , 4 > arr = { 1 , 2 , 3 , 4 }; { span < const int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } { span < const int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } #ifdef CONFIRM_COMPILATION_ERRORS { span < const int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); } { span < const int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); } { span < const int , 5 > s { arr }; } { span < int , 4 > s { arr }; } #endif { auto s = make_span ( arr ); CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_container_constructor\" ) { std :: vector < int > v = { 1 , 2 , 3 }; const std :: vector < int > cv = v ; { span < int > s { v }; CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && s . data () == v . data ())); span < const int > cs { v }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && cs . data () == v . data ())); } std :: string str = \"hello\" ; const std :: string cstr = \"hello\" ; { #ifdef CONFIRM_COMPILATION_ERRORS span < char > s { str }; CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( str . size ()) && s . data () == str . data ())); #endif span < const char > cs { str }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( str . size ()) && cs . data () == str . data ())); } { #ifdef CONFIRM_COMPILATION_ERRORS span < char > s { cstr }; #endif span < const char > cs { cstr }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( cstr . size ()) && cs . data () == cstr . data ())); } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_vector = []() -> std :: vector < int > { return {}; }; auto use_span = []( span < int > s ) { static_cast < void > ( s ); }; use_span ( get_temp_vector ()); #endif } { auto get_temp_vector = []() -> std :: vector < int > { return {}; }; auto use_span = []( span < const int > s ) { static_cast < void > ( s ); }; use_span ( get_temp_vector ()); } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_string = []() -> std :: string { return {}; }; auto use_span = []( span < char > s ) { static_cast < void > ( s ); }; use_span ( get_temp_string ()); #endif } { auto get_temp_string = []() -> std :: string { return {}; }; auto use_span = []( span < const char > s ) { static_cast < void > ( s ); }; use_span ( get_temp_string ()); } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_vector = []() -> const std :: vector < int > { return {}; }; auto use_span = []( span < const char > s ) { static_cast < void > ( s ); }; use_span ( get_temp_vector ()); #endif } { auto get_temp_string = []() -> const std :: string { return {}; }; auto use_span = []( span < const char > s ) { static_cast < void > ( s ); }; use_span ( get_temp_string ()); } { #ifdef CONFIRM_COMPILATION_ERRORS std :: map < int , int > m ; span < int > s { m }; #endif } { auto s = make_span ( v ); CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && s . data () == v . data ())); auto cs = make_span ( cv ); CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( cv . size ()) && cs . data () == cv . data ())); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_convertible_span_constructor\" ) { { span < DerivedClass > avd ; span < const DerivedClass > avcd = avd ; static_cast < void > ( avcd ); } { #ifdef CONFIRM_COMPILATION_ERRORS span < DerivedClass > avd ; span < BaseClass > avb = avd ; static_cast < void > ( avb ); #endif } #ifdef CONFIRM_COMPILATION_ERRORS { span < int > s ; span < unsigned int > s2 = s ; static_cast < void > ( s2 ); } { span < int > s ; span < const unsigned int > s2 = s ; static_cast < void > ( s2 ); } { span < int > s ; span < short > s2 = s ; static_cast < void > ( s2 ); } #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"copy_move_and_assignment\" ) { span < int > s1 ; CHECK ( s1 . empty ()); int arr [] = { 3 , 4 , 5 }; span < const int > s2 = arr ; CHECK (( s2 . size () == 3 && s2 . data () == & arr [ 0 ])); s2 = s1 ; CHECK ( s2 . empty ()); auto get_temp_span = [ & ]() -> span < int > { return { & arr [ 1 ], 2 }; }; auto use_span = [ & ]( span < const int > s ) { CHECK (( s . size () == 2 && s . data () == & arr [ 1 ])); }; use_span ( get_temp_span ()); s1 = get_temp_span (); CHECK (( s1 . size () == 2 && s1 . data () == & arr [ 1 ])); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"first\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { span < int , 5 > av = arr ; CHECK ( av . first < 2 > (). size () == 2 ); CHECK ( av . first ( 2 ). size () == 2 ); } { span < int , 5 > av = arr ; CHECK ( av . first < 0 > (). size () == 0 ); CHECK ( av . first ( 0 ). size () == 0 ); } { span < int , 5 > av = arr ; CHECK ( av . first < 5 > (). size () == 5 ); CHECK ( av . first ( 5 ). size () == 5 ); } { span < int , 5 > av = arr ; #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( av . first < 6 > (). size () == 6 ); CHECK ( av . first <- 1 > (). size () == - 1 ); #endif CHECK_THROWS_AS ( av . first ( 6 ). size (), fail_fast ); } { span < int > av ; CHECK ( av . first < 0 > (). size () == 0 ); CHECK ( av . first ( 0 ). size () == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"last\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { span < int , 5 > av = arr ; CHECK ( av . last < 2 > (). size () == 2 ); CHECK ( av . last ( 2 ). size () == 2 ); } { span < int , 5 > av = arr ; CHECK ( av . last < 0 > (). size () == 0 ); CHECK ( av . last ( 0 ). size () == 0 ); } { span < int , 5 > av = arr ; CHECK ( av . last < 5 > (). size () == 5 ); CHECK ( av . last ( 5 ). size () == 5 ); } { span < int , 5 > av = arr ; #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( av . last < 6 > (). size () == 6 ); #endif CHECK_THROWS_AS ( av . last ( 6 ). size (), fail_fast ); } { span < int > av ; CHECK ( av . last < 0 > (). size () == 0 ); CHECK ( av . last ( 0 ). size () == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"subspan\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { span < int , 5 > av = arr ; CHECK (( av . subspan < 2 , 2 > (). size () == 2 )); CHECK ( decltype ( av . subspan < 2 , 2 > ()) :: extent == 2 ); CHECK ( av . subspan ( 2 , 2 ). size () == 2 ); CHECK ( av . subspan ( 2 , 3 ). size () == 3 ); } { span < int , 5 > av = arr ; CHECK (( av . subspan < 0 , 0 > (). size () == 0 )); CHECK ( decltype ( av . subspan < 0 , 0 > ()) :: extent == 0 ); CHECK ( av . subspan ( 0 , 0 ). size () == 0 ); } { span < int , 5 > av = arr ; CHECK (( av . subspan < 0 , 5 > (). size () == 5 )); CHECK ( decltype ( av . subspan < 0 , 5 > ()) :: extent == 5 ); CHECK ( av . subspan ( 0 , 5 ). size () == 5 ); CHECK_THROWS_AS ( av . subspan ( 0 , 6 ). size (), fail_fast ); CHECK_THROWS_AS ( av . subspan ( 1 , 5 ). size (), fail_fast ); } { span < int , 5 > av = arr ; CHECK (( av . subspan < 4 , 0 > (). size () == 0 )); CHECK ( decltype ( av . subspan < 4 , 0 > ()) :: extent == 0 ); CHECK ( av . subspan ( 4 , 0 ). size () == 0 ); CHECK ( av . subspan ( 5 , 0 ). size () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 , 0 ). size (), fail_fast ); } { span < int , 5 > av = arr ; CHECK (( av . subspan < 1 > (). size () == 4 )); CHECK ( decltype ( av . subspan < 1 > ()) :: extent == 4 ); } { span < int > av ; CHECK (( av . subspan < 0 , 0 > (). size () == 0 )); CHECK (( decltype ( av . subspan < 0 , 0 > ()) :: extent == 0 )); CHECK ( av . subspan ( 0 , 0 ). size () == 0 ); CHECK_THROWS_AS (( av . subspan < 1 , 0 > (). size ()), fail_fast ); } { span < int > av ; CHECK ( av . subspan ( 0 ). size () == 0 ); CHECK_THROWS_AS ( av . subspan ( 1 ). size (), fail_fast ); } { span < int > av = arr ; CHECK ( av . subspan ( 0 ). size () == 5 ); CHECK ( av . subspan ( 1 ). size () == 4 ); CHECK ( av . subspan ( 4 ). size () == 1 ); CHECK ( av . subspan ( 5 ). size () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 ). size (), fail_fast ); const auto av2 = av . subspan ( 1 ); for ( int i = 0 ; i < 4 ; ++ i ) CHECK ( av2 [ i ] == i + 2 ); } { span < int , 5 > av = arr ; CHECK ( av . subspan ( 0 ). size () == 5 ); CHECK ( av . subspan ( 1 ). size () == 4 ); CHECK ( av . subspan ( 4 ). size () == 1 ); CHECK ( av . subspan ( 5 ). size () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 ). size (), fail_fast ); const auto av2 = av . subspan ( 1 ); for ( int i = 0 ; i < 4 ; ++ i ) CHECK ( av2 [ i ] == i + 2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"at_call\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { span < int > s = arr ; CHECK ( s . at ( 0 ) == 1 ); CHECK_THROWS_AS ( s . at ( 5 ), fail_fast ); } { int arr2d [ 2 ] = { 1 , 6 }; span < int , 2 > s = arr2d ; CHECK ( s . at ( 0 ) == 1 ); CHECK ( s . at ( 1 ) == 6 ); CHECK_THROWS_AS ( s . at ( 2 ), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"operator_function_call\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { span < int > s = arr ; CHECK ( s ( 0 ) == 1 ); CHECK_THROWS_AS ( s ( 5 ), fail_fast ); } { int arr2d [ 2 ] = { 1 , 6 }; span < int , 2 > s = arr2d ; CHECK ( s ( 0 ) == 1 ); CHECK ( s ( 1 ) == 6 ); CHECK_THROWS_AS ( s ( 2 ), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"iterator_default_init\" ) { span < int >:: iterator it1 ; span < int >:: iterator it2 ; CHECK ( it1 == it2 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"const_iterator_default_init\" ) { span < int >:: const_iterator it1 ; span < int >:: const_iterator it2 ; CHECK ( it1 == it2 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"iterator_conversions\" ) { span < int >:: iterator badIt ; span < int >:: const_iterator badConstIt ; CHECK ( badIt == badConstIt ); int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . begin (); auto cit = s . cbegin (); CHECK ( it == cit ); CHECK ( cit == it ); span < int >:: const_iterator cit2 = it ; CHECK ( cit2 == cit ); span < int >:: const_iterator cit3 = it + 4 ; CHECK ( cit3 == s . cend ()); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"iterator_comparisons\" ) { int a [] = { 1 , 2 , 3 , 4 }; { span < int > s = a ; span < int >:: iterator it = s . begin (); auto it2 = it + 1 ; span < int >:: const_iterator cit = s . cbegin (); CHECK ( it == cit ); CHECK ( cit == it ); CHECK ( it == it ); CHECK ( cit == cit ); CHECK ( cit == s . begin ()); CHECK ( s . begin () == cit ); CHECK ( s . cbegin () == cit ); CHECK ( it == s . begin ()); CHECK ( s . begin () == it ); CHECK ( it != it2 ); CHECK ( it2 != it ); CHECK ( it != s . end ()); CHECK ( it2 != s . end ()); CHECK ( s . end () != it ); CHECK ( it2 != cit ); CHECK ( cit != it2 ); CHECK ( it < it2 ); CHECK ( it <= it2 ); CHECK ( it2 <= s . end ()); CHECK ( it < s . end ()); CHECK ( it <= cit ); CHECK ( cit <= it ); CHECK ( cit < it2 ); CHECK ( cit <= it2 ); CHECK ( cit < s . end ()); CHECK ( cit <= s . end ()); CHECK ( it2 > it ); CHECK ( it2 >= it ); CHECK ( s . end () > it2 ); CHECK ( s . end () >= it2 ); CHECK ( it2 > cit ); CHECK ( it2 >= cit ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"begin_end\" ) { { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; span < int >:: iterator it = s . begin (); span < int >:: iterator it2 = std :: begin ( s ); CHECK ( it == it2 ); it = s . end (); it2 = std :: end ( s ); CHECK ( it == it2 ); } { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . begin (); auto first = it ; CHECK ( it == first ); CHECK ( * it == 1 ); auto beyond = s . end (); CHECK ( it != beyond ); CHECK_THROWS_AS ( * beyond , fail_fast ); CHECK ( beyond - first == 4 ); CHECK ( first - first == 0 ); CHECK ( beyond - beyond == 0 ); ++ it ; CHECK ( it - first == 1 ); CHECK ( * it == 2 ); * it = 22 ; CHECK ( * it == 22 ); CHECK ( beyond - it == 3 ); it = first ; CHECK ( it == first ); while ( it != s . end ()) { * it = 5 ; ++ it ; } CHECK ( it == beyond ); CHECK ( it - beyond == 0 ); for ( const auto & n : s ) { CHECK ( n == 5 ); } } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"cbegin_cend\" ) { { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; span < int >:: const_iterator cit = s . cbegin (); span < int >:: const_iterator cit2 = std :: cbegin ( s ); CHECK ( cit == cit2 ); cit = s . cend (); cit2 = std :: cend ( s ); CHECK ( cit == cit2 ); } { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . cbegin (); auto first = it ; CHECK ( it == first ); CHECK ( * it == 1 ); auto beyond = s . cend (); CHECK ( it != beyond ); CHECK_THROWS_AS ( * beyond , fail_fast ); CHECK ( beyond - first == 4 ); CHECK ( first - first == 0 ); CHECK ( beyond - beyond == 0 ); ++ it ; CHECK ( it - first == 1 ); CHECK ( * it == 2 ); CHECK ( beyond - it == 3 ); int last = 0 ; it = first ; CHECK ( it == first ); while ( it != s . cend ()) { CHECK ( * it == last + 1 ); last = * it ; ++ it ; } CHECK ( it == beyond ); CHECK ( it - beyond == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"rbegin_rend\" ) { { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . rbegin (); auto first = it ; CHECK ( it == first ); CHECK ( * it == 4 ); auto beyond = s . rend (); CHECK ( it != beyond ); CHECK_THROWS_AS ( * beyond , fail_fast ); CHECK ( beyond - first == 4 ); CHECK ( first - first == 0 ); CHECK ( beyond - beyond == 0 ); ++ it ; CHECK ( it - first == 1 ); CHECK ( * it == 3 ); * it = 22 ; CHECK ( * it == 22 ); CHECK ( beyond - it == 3 ); it = first ; CHECK ( it == first ); while ( it != s . rend ()) { * it = 5 ; ++ it ; } CHECK ( it == beyond ); CHECK ( it - beyond == 0 ); for ( const auto & n : s ) { CHECK ( n == 5 ); } } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"crbegin_crend\" ) { { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . crbegin (); auto first = it ; CHECK ( it == first ); CHECK ( * it == 4 ); auto beyond = s . crend (); CHECK ( it != beyond ); CHECK_THROWS_AS ( * beyond , fail_fast ); CHECK ( beyond - first == 4 ); CHECK ( first - first == 0 ); CHECK ( beyond - beyond == 0 ); ++ it ; CHECK ( it - first == 1 ); CHECK ( * it == 3 ); CHECK ( beyond - it == 3 ); it = first ; CHECK ( it == first ); int last = 5 ; while ( it != s . crend ()) { CHECK ( * it == last - 1 ); last = * it ; ++ it ; } CHECK ( it == beyond ); CHECK ( it - beyond == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"comparison_operators\" ) { { span < int > s1 ; span < int > s2 ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 2 , 1 }; span < int > s1 = arr ; span < int > s2 = arr ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 2 , 1 }; // bigger span < int > s1 ; span < int > s2 = arr ; CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } { int arr1 [] = { 1 , 2 }; int arr2 [] = { 1 , 2 }; span < int > s1 = arr1 ; span < int > s2 = arr2 ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 1 , 2 , 3 }; span < int > s1 = { & arr [ 0 ], 2 }; // shorter span < int > s2 = arr ; // longer CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } { int arr1 [] = { 1 , 2 }; // smaller int arr2 [] = { 2 , 1 }; // bigger span < int > s1 = arr1 ; span < int > s2 = arr2 ; CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_bytes\" ) { int a [] = { 1 , 2 , 3 , 4 }; { const span < const int > s = a ; CHECK ( s . size () == 4 ); const span < const byte > bs = as_bytes ( s ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); } { span < int > s ; const auto bs = as_bytes ( s ); CHECK ( bs . size () == s . size ()); CHECK ( bs . size () == 0 ); CHECK ( bs . size_bytes () == 0 ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . data () == nullptr ); } { span < int > s = a ; const auto bs = as_bytes ( s ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_writeable_bytes\" ) { int a [] = { 1 , 2 , 3 , 4 }; { #ifdef CONFIRM_COMPILATION_ERRORS // you should not be able to get writeable bytes for const objects span < const int > s = a ; CHECK ( s . size () == 4 ); span < const byte > bs = as_writeable_bytes ( s ); CHECK ( static_cast < void *> ( bs . data ()) == static_cast < void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); #endif } { span < int > s ; const auto bs = as_writeable_bytes ( s ); CHECK ( bs . size () == s . size ()); CHECK ( bs . size () == 0 ); CHECK ( bs . size_bytes () == 0 ); CHECK ( static_cast < void *> ( bs . data ()) == static_cast < void *> ( s . data ())); CHECK ( bs . data () == nullptr ); } { span < int > s = a ; const auto bs = as_writeable_bytes ( s ); CHECK ( static_cast < void *> ( bs . data ()) == static_cast < void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"fixed_size_conversions\" ) { int arr [] = { 1 , 2 , 3 , 4 }; // converting to an span from an equal size array is ok span < int , 4 > s4 = arr ; CHECK ( s4 . size () == 4 ); // converting to dynamic_range is always ok { span < int > s = s4 ; CHECK ( s . size () == s4 . size ()); static_cast < void > ( s ); } // initialization or assignment to static span that REDUCES size is NOT ok #ifdef CONFIRM_COMPILATION_ERRORS { span < int , 2 > s = arr ; } { span < int , 2 > s2 = s4 ; static_cast < void > ( s2 ); } #endif // even when done dynamically { span < int > s = arr ; auto f = [ & ]() { const span < int , 2 > s2 = s ; static_cast < void > ( s2 ); }; CHECK_THROWS_AS ( f (), fail_fast ); } // but doing so explicitly is ok // you can convert statically { const span < int , 2 > s2 = { & arr [ 0 ], 2 }; static_cast < void > ( s2 ); } { const span < int , 1 > s1 = s4 . first < 1 > (); static_cast < void > ( s1 ); } // ...or dynamically { // NB: implicit conversion to span<int,1> from span<int> span < int , 1 > s1 = s4 . first ( 1 ); static_cast < void > ( s1 ); } // initialization or assignment to static span that requires size INCREASE is not ok. int arr2 [ 2 ] = { 1 , 2 }; #ifdef CONFIRM_COMPILATION_ERRORS { span < int , 4 > s3 = arr2 ; } { span < int , 2 > s2 = arr2 ; span < int , 4 > s4a = s2 ; } #endif { auto f = [ & ]() { const span < int , 4 > _s4 = { arr2 , 2 }; static_cast < void > ( _s4 ); }; CHECK_THROWS_AS ( f (), fail_fast ); } // this should fail - we are trying to assign a small dynamic span to a fixed_size larger one span < int > av = arr2 ; auto f = [ & ]() { const span < int , 4 > _s4 = av ; static_cast < void > ( _s4 ); }; CHECK_THROWS_AS ( f (), fail_fast ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"interop_with_std_regex\" ) { char lat [] = { '1' , '2' , '3' , '4' , '5' , '6' , 'E' , 'F' , 'G' }; span < char > s = lat ; const auto f_it = s . begin () + 7 ; std :: match_results < span < char >:: iterator > match ; std :: regex_match ( s . begin (), s . end (), match , std :: regex ( \".*\" )); CHECK ( match . ready ()); CHECK ( ! match . empty ()); CHECK ( match [ 0 ]. matched ); CHECK ( match [ 0 ]. first == s . begin ()); CHECK ( match [ 0 ]. second == s . end ()); std :: regex_search ( s . begin (), s . end (), match , std :: regex ( \"F\" )); CHECK ( match . ready ()); CHECK ( ! match . empty ()); CHECK ( match [ 0 ]. matched ); CHECK ( match [ 0 ]. first == f_it ); CHECK ( match [ 0 ]. second == ( f_it + 1 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"interop_with_gsl_at\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; span < int > s { arr }; CHECK (( at ( s , 0 ) == 1 && at ( s , 1 ) == 2 )); } TEST_CASE ( \"default_constructible\" ) { CHECK (( std :: is_default_constructible < span < int >>:: value )); CHECK (( std :: is_default_constructible < span < int , 0 >>:: value )); CHECK (( ! std :: is_default_constructible < span < int , 42 >>:: value )); }","title":"File span\\_tests.cpp"},{"location":"span__tests_8cpp_source/#file-span95testscpp","text":"File List > external > guideline > tests > span_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426 26497) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/gsl_byte> // for byte #include <gsl/gsl_util> // for narrow_cast, at #include <gsl/span> // for span, span_iterator, operator==, operator!= #include <array> // for array #include <iostream> // for ptrdiff_t #include <iterator> // for reverse_iterator, operator-, operator== #include <memory> // for unique_ptr, shared_ptr, make_unique, allo... #include <regex> // for match_results, sub_match, match_results<>... #include <stddef.h> // for ptrdiff_t #include <string> // for string #include <type_traits> // for integral_constant<>::value, is_default_co... #include <vector> // for vector namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; namespace { struct BaseClass { }; struct DerivedClass : BaseClass { }; struct AddressOverloaded { #if (__cplusplus > 201402L) [[ maybe_unused ]] #endif AddressOverloaded operator & () const { return {}; } }; } // namespace GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"default_constructor\" ) { { span < int > s ; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int > cs ; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } { span < int , 0 > s ; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int , 0 > cs ; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } { #ifdef CONFIRM_COMPILATION_ERRORS span < int , 1 > s ; CHECK (( s . size () == 1 && s . data () == nullptr )); // explains why it can't compile #endif } { span < int > s {}; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int > cs {}; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"size_optimization\" ) { { span < int > s ; CHECK ( sizeof ( s ) == sizeof ( int * ) + sizeof ( ptrdiff_t )); } { span < int , 0 > s ; CHECK ( sizeof ( s ) == sizeof ( int * )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_nullptr_size_constructor\" ) { { span < int > s { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int > cs { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } { span < int , 0 > s { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int , 0 > cs { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } { auto workaround_macro = []() { const span < int , 1 > s { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const span < int > s { nullptr , 1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); auto const_workaround_macro = []() { const span < const int > cs { nullptr , 1 }; }; CHECK_THROWS_AS ( const_workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const span < int , 0 > s { nullptr , 1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); auto const_workaround_macro = []() { const span < const int , 0 > s { nullptr , 1 }; }; CHECK_THROWS_AS ( const_workaround_macro (), fail_fast ); } { span < int *> s { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( s . size () == 0 && s . data () == nullptr )); span < const int *> cs { nullptr , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( cs . size () == 0 && cs . data () == nullptr )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"from_pointer_length_constructor\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { for ( int i = 0 ; i < 4 ; ++ i ) { { span < int > s = { & arr [ 0 ], i }; CHECK ( s . size () == i ); CHECK ( s . data () == & arr [ 0 ]); CHECK ( s . empty () == ( i == 0 )); for ( int j = 0 ; j < i ; ++ j ) { CHECK ( arr [ j ] == s [ j ]); CHECK ( arr [ j ] == s . at ( j )); CHECK ( arr [ j ] == s ( j )); } } { span < int > s = { & arr [ i ], 4 - narrow_cast < ptrdiff_t > ( i ) }; CHECK ( s . size () == 4 - i ); CHECK ( s . data () == & arr [ i ]); CHECK ( s . empty () == ( 4 - i == 0 )); for ( int j = 0 ; j < 4 - i ; ++ j ) { CHECK ( arr [ j + i ] == s [ j ]); CHECK ( arr [ j + i ] == s . at ( j )); CHECK ( arr [ j + i ] == s ( j )); } } } } { span < int , 2 > s { & arr [ 0 ], 2 }; CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { int * p = nullptr ; span < int > s { p , narrow_cast < span < int >:: index_type > ( 0 )}; CHECK (( s . size () == 0 && s . data () == nullptr )); } { int * p = nullptr ; auto workaround_macro = [ = ]() { const span < int > s { p , 2 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { auto s = make_span ( & arr [ 0 ], 2 ); CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { int * p = nullptr ; auto s = make_span ( p , narrow_cast < span < int >:: index_type > ( 0 )); CHECK (( s . size () == 0 && s . data () == nullptr )); } { int * p = nullptr ; auto workaround_macro = [ = ]() { make_span ( p , 2 ); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_pointer_pointer_constructor\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { span < int > s { & arr [ 0 ], & arr [ 2 ]}; CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { span < int , 2 > s { & arr [ 0 ], & arr [ 2 ]}; CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { span < int > s { & arr [ 0 ], & arr [ 0 ]}; CHECK (( s . size () == 0 && s . data () == & arr [ 0 ])); } { span < int , 0 > s { & arr [ 0 ], & arr [ 0 ]}; CHECK (( s . size () == 0 && s . data () == & arr [ 0 ])); } // this will fail the std::distance() precondition, which asserts on MSVC debug builds //{ // auto workaround_macro = [&]() { span<int> s{&arr[1], &arr[0]}; }; // CHECK_THROWS_AS(workaround_macro(), fail_fast); //} // this will fail the std::distance() precondition, which asserts on MSVC debug builds //{ // int* p = nullptr; // auto workaround_macro = [&]() { span<int> s{&arr[0], p}; }; // CHECK_THROWS_AS(workaround_macro(), fail_fast); //} { int * p = nullptr ; span < int > s { p , p }; CHECK (( s . size () == 0 && s . data () == nullptr )); } { int * p = nullptr ; span < int , 0 > s { p , p }; CHECK (( s . size () == 0 && s . data () == nullptr )); } // this will fail the std::distance() precondition, which asserts on MSVC debug builds //{ // int* p = nullptr; // auto workaround_macro = [&]() { span<int> s{&arr[0], p}; }; // CHECK_THROWS_AS(workaround_macro(), fail_fast); //} { auto s = make_span ( & arr [ 0 ], & arr [ 2 ]); CHECK (( s . size () == 2 && s . data () == & arr [ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 1 ] == 2 )); } { auto s = make_span ( & arr [ 0 ], & arr [ 0 ]); CHECK (( s . size () == 0 && s . data () == & arr [ 0 ])); } { int * p = nullptr ; auto s = make_span ( p , p ); CHECK (( s . size () == 0 && s . data () == nullptr )); } } TEST_CASE ( \"from_array_constructor\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { const span < int > s { arr }; CHECK (( s . size () == 5 && s . data () == & arr [ 0 ])); } { const span < int , 5 > s { arr }; CHECK (( s . size () == 5 && s . data () == & arr [ 0 ])); } int arr2d [ 2 ][ 3 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; #ifdef CONFIRM_COMPILATION_ERRORS { span < int , 6 > s { arr }; } { span < int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == & arr [ 0 ])); } { span < int > s { arr2d }; CHECK (( s . size () == 6 && s . data () == & arr2d [ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } { span < int , 0 > s { arr2d }; CHECK (( s . size () == 0 && s . data () == & arr2d [ 0 ][ 0 ])); } { span < int , 6 > s { arr2d }; } #endif { const span < int [ 3 ] > s { std :: addressof ( arr2d [ 0 ]), 1 }; CHECK (( s . size () == 1 && s . data () == std :: addressof ( arr2d [ 0 ]))); } int arr3d [ 2 ][ 3 ][ 2 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 }; #ifdef CONFIRM_COMPILATION_ERRORS { span < int > s { arr3d }; CHECK (( s . size () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 11 ] == 12 )); } { span < int , 0 > s { arr3d }; CHECK (( s . size () == 0 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); } { span < int , 11 > s { arr3d }; } { span < int , 12 > s { arr3d }; CHECK (( s . size () == 12 && s . data () == & arr3d [ 0 ][ 0 ][ 0 ])); CHECK (( s [ 0 ] == 1 && s [ 5 ] == 6 )); } #endif { const span < int [ 3 ][ 2 ] > s { std :: addressof ( arr3d [ 0 ]), 1 }; CHECK (( s . size () == 1 && s . data () == std :: addressof ( arr3d [ 0 ]))); } { const auto s = make_span ( arr ); CHECK (( s . size () == 5 && s . data () == std :: addressof ( arr [ 0 ]))); } { const auto s = make_span ( std :: addressof ( arr2d [ 0 ]), 1 ); CHECK (( s . size () == 1 && s . data () == std :: addressof ( arr2d [ 0 ]))); } { const auto s = make_span ( std :: addressof ( arr3d [ 0 ]), 1 ); CHECK (( s . size () == 1 && s . data () == std :: addressof ( arr3d [ 0 ]))); } AddressOverloaded ao_arr [ 5 ] = {}; { const span < AddressOverloaded , 5 > s { ao_arr }; CHECK (( s . size () == 5 && s . data () == std :: addressof ( ao_arr [ 0 ]))); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( i .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"from_dynamic_array_constructor\" ) { double ( * arr )[ 3 ][ 4 ] = new double [ 100 ][ 3 ][ 4 ]; { span < double > s ( & arr [ 0 ][ 0 ][ 0 ], 10 ); CHECK (( s . size () == 10 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } { auto s = make_span ( & arr [ 0 ][ 0 ][ 0 ], 10 ); CHECK (( s . size () == 10 && s . data () == & arr [ 0 ][ 0 ][ 0 ])); } delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_std_array_constructor\" ) { std :: array < int , 4 > arr = { 1 , 2 , 3 , 4 }; { span < int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); span < const int > cs { arr }; CHECK (( cs . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && cs . data () == arr . data ())); } { span < int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); span < const int , 4 > cs { arr }; CHECK (( cs . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && cs . data () == arr . data ())); } { std :: array < int , 0 > empty_arr {}; span < int > s { empty_arr }; CHECK (( s . size () == 0 && s . empty ())); } std :: array < AddressOverloaded , 4 > ao_arr {}; { span < AddressOverloaded , 4 > fs { ao_arr }; CHECK (( fs . size () == narrow_cast < ptrdiff_t > ( ao_arr . size ()) && ao_arr . data () == fs . data ())); } #ifdef CONFIRM_COMPILATION_ERRORS { span < int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); span < const int , 2 > cs { arr }; CHECK (( cs . size () == 2 && cs . data () == arr . data ())); } { span < int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); span < const int , 0 > cs { arr }; CHECK (( cs . size () == 0 && cs . data () == arr . data ())); } { span < int , 5 > s { arr }; } { auto get_an_array = []() -> std :: array < int , 4 > { return { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( span < int > s ) { static_cast < void > ( s ); }; // try to take a temporary std::array take_a_span ( get_an_array ()); } #endif { auto get_an_array = []() -> std :: array < int , 4 > { return { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( span < const int > s ) { static_cast < void > ( s ); }; // try to take a temporary std::array take_a_span ( get_an_array ()); } { auto s = make_span ( arr ); CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } // This test checks for the bug found in gcc 6.1, 6.2, 6.3, 6.4, 6.5 7.1, 7.2, 7.3 - issue #590 { span < int > s1 = make_span ( arr ); static span < int > s2 ; s2 = s1 ; #if defined(__GNUC__) && __GNUC__ == 6 && (__GNUC_MINOR__ == 4 || __GNUC_MINOR__ == 5) && \\ __GNUC_PATCHLEVEL__ == 0 && defined(__OPTIMIZE__) // Known to be broken in gcc 6.4 and 6.5 with optimizations // Issue in gcc: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83116 CHECK ( s1 . size () == 4 ); CHECK ( s2 . size () == 0 ); #else CHECK ( s1 . size () == s2 . size ()); #endif } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_const_std_array_constructor\" ) { const std :: array < int , 4 > arr = { 1 , 2 , 3 , 4 }; { span < const int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } { span < const int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } const std :: array < AddressOverloaded , 4 > ao_arr {}; { span < const AddressOverloaded , 4 > s { ao_arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( ao_arr . size ()) && s . data () == ao_arr . data ())); } #ifdef CONFIRM_COMPILATION_ERRORS { span < const int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); } { span < const int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); } { span < const int , 5 > s { arr }; } #endif { auto get_an_array = []() -> const std :: array < int , 4 > { return { 1 , 2 , 3 , 4 }; }; auto take_a_span = []( span < const int > s ) { static_cast < void > ( s ); }; // try to take a temporary std::array take_a_span ( get_an_array ()); } { auto s = make_span ( arr ); CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_std_array_const_constructor\" ) { std :: array < const int , 4 > arr = { 1 , 2 , 3 , 4 }; { span < const int > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } { span < const int , 4 > s { arr }; CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } #ifdef CONFIRM_COMPILATION_ERRORS { span < const int , 2 > s { arr }; CHECK (( s . size () == 2 && s . data () == arr . data ())); } { span < const int , 0 > s { arr }; CHECK (( s . size () == 0 && s . data () == arr . data ())); } { span < const int , 5 > s { arr }; } { span < int , 4 > s { arr }; } #endif { auto s = make_span ( arr ); CHECK (( s . size () == narrow_cast < ptrdiff_t > ( arr . size ()) && s . data () == arr . data ())); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_container_constructor\" ) { std :: vector < int > v = { 1 , 2 , 3 }; const std :: vector < int > cv = v ; { span < int > s { v }; CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && s . data () == v . data ())); span < const int > cs { v }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && cs . data () == v . data ())); } std :: string str = \"hello\" ; const std :: string cstr = \"hello\" ; { #ifdef CONFIRM_COMPILATION_ERRORS span < char > s { str }; CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( str . size ()) && s . data () == str . data ())); #endif span < const char > cs { str }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( str . size ()) && cs . data () == str . data ())); } { #ifdef CONFIRM_COMPILATION_ERRORS span < char > s { cstr }; #endif span < const char > cs { cstr }; CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( cstr . size ()) && cs . data () == cstr . data ())); } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_vector = []() -> std :: vector < int > { return {}; }; auto use_span = []( span < int > s ) { static_cast < void > ( s ); }; use_span ( get_temp_vector ()); #endif } { auto get_temp_vector = []() -> std :: vector < int > { return {}; }; auto use_span = []( span < const int > s ) { static_cast < void > ( s ); }; use_span ( get_temp_vector ()); } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_string = []() -> std :: string { return {}; }; auto use_span = []( span < char > s ) { static_cast < void > ( s ); }; use_span ( get_temp_string ()); #endif } { auto get_temp_string = []() -> std :: string { return {}; }; auto use_span = []( span < const char > s ) { static_cast < void > ( s ); }; use_span ( get_temp_string ()); } { #ifdef CONFIRM_COMPILATION_ERRORS auto get_temp_vector = []() -> const std :: vector < int > { return {}; }; auto use_span = []( span < const char > s ) { static_cast < void > ( s ); }; use_span ( get_temp_vector ()); #endif } { auto get_temp_string = []() -> const std :: string { return {}; }; auto use_span = []( span < const char > s ) { static_cast < void > ( s ); }; use_span ( get_temp_string ()); } { #ifdef CONFIRM_COMPILATION_ERRORS std :: map < int , int > m ; span < int > s { m }; #endif } { auto s = make_span ( v ); CHECK (( s . size () == narrow_cast < std :: ptrdiff_t > ( v . size ()) && s . data () == v . data ())); auto cs = make_span ( cv ); CHECK (( cs . size () == narrow_cast < std :: ptrdiff_t > ( cv . size ()) && cs . data () == cv . data ())); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"from_convertible_span_constructor\" ) { { span < DerivedClass > avd ; span < const DerivedClass > avcd = avd ; static_cast < void > ( avcd ); } { #ifdef CONFIRM_COMPILATION_ERRORS span < DerivedClass > avd ; span < BaseClass > avb = avd ; static_cast < void > ( avb ); #endif } #ifdef CONFIRM_COMPILATION_ERRORS { span < int > s ; span < unsigned int > s2 = s ; static_cast < void > ( s2 ); } { span < int > s ; span < const unsigned int > s2 = s ; static_cast < void > ( s2 ); } { span < int > s ; span < short > s2 = s ; static_cast < void > ( s2 ); } #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"copy_move_and_assignment\" ) { span < int > s1 ; CHECK ( s1 . empty ()); int arr [] = { 3 , 4 , 5 }; span < const int > s2 = arr ; CHECK (( s2 . size () == 3 && s2 . data () == & arr [ 0 ])); s2 = s1 ; CHECK ( s2 . empty ()); auto get_temp_span = [ & ]() -> span < int > { return { & arr [ 1 ], 2 }; }; auto use_span = [ & ]( span < const int > s ) { CHECK (( s . size () == 2 && s . data () == & arr [ 1 ])); }; use_span ( get_temp_span ()); s1 = get_temp_span (); CHECK (( s1 . size () == 2 && s1 . data () == & arr [ 1 ])); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"first\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { span < int , 5 > av = arr ; CHECK ( av . first < 2 > (). size () == 2 ); CHECK ( av . first ( 2 ). size () == 2 ); } { span < int , 5 > av = arr ; CHECK ( av . first < 0 > (). size () == 0 ); CHECK ( av . first ( 0 ). size () == 0 ); } { span < int , 5 > av = arr ; CHECK ( av . first < 5 > (). size () == 5 ); CHECK ( av . first ( 5 ). size () == 5 ); } { span < int , 5 > av = arr ; #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( av . first < 6 > (). size () == 6 ); CHECK ( av . first <- 1 > (). size () == - 1 ); #endif CHECK_THROWS_AS ( av . first ( 6 ). size (), fail_fast ); } { span < int > av ; CHECK ( av . first < 0 > (). size () == 0 ); CHECK ( av . first ( 0 ). size () == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"last\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { span < int , 5 > av = arr ; CHECK ( av . last < 2 > (). size () == 2 ); CHECK ( av . last ( 2 ). size () == 2 ); } { span < int , 5 > av = arr ; CHECK ( av . last < 0 > (). size () == 0 ); CHECK ( av . last ( 0 ). size () == 0 ); } { span < int , 5 > av = arr ; CHECK ( av . last < 5 > (). size () == 5 ); CHECK ( av . last ( 5 ). size () == 5 ); } { span < int , 5 > av = arr ; #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( av . last < 6 > (). size () == 6 ); #endif CHECK_THROWS_AS ( av . last ( 6 ). size (), fail_fast ); } { span < int > av ; CHECK ( av . last < 0 > (). size () == 0 ); CHECK ( av . last ( 0 ). size () == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"subspan\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; { span < int , 5 > av = arr ; CHECK (( av . subspan < 2 , 2 > (). size () == 2 )); CHECK ( decltype ( av . subspan < 2 , 2 > ()) :: extent == 2 ); CHECK ( av . subspan ( 2 , 2 ). size () == 2 ); CHECK ( av . subspan ( 2 , 3 ). size () == 3 ); } { span < int , 5 > av = arr ; CHECK (( av . subspan < 0 , 0 > (). size () == 0 )); CHECK ( decltype ( av . subspan < 0 , 0 > ()) :: extent == 0 ); CHECK ( av . subspan ( 0 , 0 ). size () == 0 ); } { span < int , 5 > av = arr ; CHECK (( av . subspan < 0 , 5 > (). size () == 5 )); CHECK ( decltype ( av . subspan < 0 , 5 > ()) :: extent == 5 ); CHECK ( av . subspan ( 0 , 5 ). size () == 5 ); CHECK_THROWS_AS ( av . subspan ( 0 , 6 ). size (), fail_fast ); CHECK_THROWS_AS ( av . subspan ( 1 , 5 ). size (), fail_fast ); } { span < int , 5 > av = arr ; CHECK (( av . subspan < 4 , 0 > (). size () == 0 )); CHECK ( decltype ( av . subspan < 4 , 0 > ()) :: extent == 0 ); CHECK ( av . subspan ( 4 , 0 ). size () == 0 ); CHECK ( av . subspan ( 5 , 0 ). size () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 , 0 ). size (), fail_fast ); } { span < int , 5 > av = arr ; CHECK (( av . subspan < 1 > (). size () == 4 )); CHECK ( decltype ( av . subspan < 1 > ()) :: extent == 4 ); } { span < int > av ; CHECK (( av . subspan < 0 , 0 > (). size () == 0 )); CHECK (( decltype ( av . subspan < 0 , 0 > ()) :: extent == 0 )); CHECK ( av . subspan ( 0 , 0 ). size () == 0 ); CHECK_THROWS_AS (( av . subspan < 1 , 0 > (). size ()), fail_fast ); } { span < int > av ; CHECK ( av . subspan ( 0 ). size () == 0 ); CHECK_THROWS_AS ( av . subspan ( 1 ). size (), fail_fast ); } { span < int > av = arr ; CHECK ( av . subspan ( 0 ). size () == 5 ); CHECK ( av . subspan ( 1 ). size () == 4 ); CHECK ( av . subspan ( 4 ). size () == 1 ); CHECK ( av . subspan ( 5 ). size () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 ). size (), fail_fast ); const auto av2 = av . subspan ( 1 ); for ( int i = 0 ; i < 4 ; ++ i ) CHECK ( av2 [ i ] == i + 2 ); } { span < int , 5 > av = arr ; CHECK ( av . subspan ( 0 ). size () == 5 ); CHECK ( av . subspan ( 1 ). size () == 4 ); CHECK ( av . subspan ( 4 ). size () == 1 ); CHECK ( av . subspan ( 5 ). size () == 0 ); CHECK_THROWS_AS ( av . subspan ( 6 ). size (), fail_fast ); const auto av2 = av . subspan ( 1 ); for ( int i = 0 ; i < 4 ; ++ i ) CHECK ( av2 [ i ] == i + 2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"at_call\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { span < int > s = arr ; CHECK ( s . at ( 0 ) == 1 ); CHECK_THROWS_AS ( s . at ( 5 ), fail_fast ); } { int arr2d [ 2 ] = { 1 , 6 }; span < int , 2 > s = arr2d ; CHECK ( s . at ( 0 ) == 1 ); CHECK ( s . at ( 1 ) == 6 ); CHECK_THROWS_AS ( s . at ( 2 ), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"operator_function_call\" ) { int arr [ 4 ] = { 1 , 2 , 3 , 4 }; { span < int > s = arr ; CHECK ( s ( 0 ) == 1 ); CHECK_THROWS_AS ( s ( 5 ), fail_fast ); } { int arr2d [ 2 ] = { 1 , 6 }; span < int , 2 > s = arr2d ; CHECK ( s ( 0 ) == 1 ); CHECK ( s ( 1 ) == 6 ); CHECK_THROWS_AS ( s ( 2 ), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"iterator_default_init\" ) { span < int >:: iterator it1 ; span < int >:: iterator it2 ; CHECK ( it1 == it2 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"const_iterator_default_init\" ) { span < int >:: const_iterator it1 ; span < int >:: const_iterator it2 ; CHECK ( it1 == it2 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"iterator_conversions\" ) { span < int >:: iterator badIt ; span < int >:: const_iterator badConstIt ; CHECK ( badIt == badConstIt ); int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . begin (); auto cit = s . cbegin (); CHECK ( it == cit ); CHECK ( cit == it ); span < int >:: const_iterator cit2 = it ; CHECK ( cit2 == cit ); span < int >:: const_iterator cit3 = it + 4 ; CHECK ( cit3 == s . cend ()); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"iterator_comparisons\" ) { int a [] = { 1 , 2 , 3 , 4 }; { span < int > s = a ; span < int >:: iterator it = s . begin (); auto it2 = it + 1 ; span < int >:: const_iterator cit = s . cbegin (); CHECK ( it == cit ); CHECK ( cit == it ); CHECK ( it == it ); CHECK ( cit == cit ); CHECK ( cit == s . begin ()); CHECK ( s . begin () == cit ); CHECK ( s . cbegin () == cit ); CHECK ( it == s . begin ()); CHECK ( s . begin () == it ); CHECK ( it != it2 ); CHECK ( it2 != it ); CHECK ( it != s . end ()); CHECK ( it2 != s . end ()); CHECK ( s . end () != it ); CHECK ( it2 != cit ); CHECK ( cit != it2 ); CHECK ( it < it2 ); CHECK ( it <= it2 ); CHECK ( it2 <= s . end ()); CHECK ( it < s . end ()); CHECK ( it <= cit ); CHECK ( cit <= it ); CHECK ( cit < it2 ); CHECK ( cit <= it2 ); CHECK ( cit < s . end ()); CHECK ( cit <= s . end ()); CHECK ( it2 > it ); CHECK ( it2 >= it ); CHECK ( s . end () > it2 ); CHECK ( s . end () >= it2 ); CHECK ( it2 > cit ); CHECK ( it2 >= cit ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"begin_end\" ) { { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; span < int >:: iterator it = s . begin (); span < int >:: iterator it2 = std :: begin ( s ); CHECK ( it == it2 ); it = s . end (); it2 = std :: end ( s ); CHECK ( it == it2 ); } { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . begin (); auto first = it ; CHECK ( it == first ); CHECK ( * it == 1 ); auto beyond = s . end (); CHECK ( it != beyond ); CHECK_THROWS_AS ( * beyond , fail_fast ); CHECK ( beyond - first == 4 ); CHECK ( first - first == 0 ); CHECK ( beyond - beyond == 0 ); ++ it ; CHECK ( it - first == 1 ); CHECK ( * it == 2 ); * it = 22 ; CHECK ( * it == 22 ); CHECK ( beyond - it == 3 ); it = first ; CHECK ( it == first ); while ( it != s . end ()) { * it = 5 ; ++ it ; } CHECK ( it == beyond ); CHECK ( it - beyond == 0 ); for ( const auto & n : s ) { CHECK ( n == 5 ); } } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"cbegin_cend\" ) { { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; span < int >:: const_iterator cit = s . cbegin (); span < int >:: const_iterator cit2 = std :: cbegin ( s ); CHECK ( cit == cit2 ); cit = s . cend (); cit2 = std :: cend ( s ); CHECK ( cit == cit2 ); } { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . cbegin (); auto first = it ; CHECK ( it == first ); CHECK ( * it == 1 ); auto beyond = s . cend (); CHECK ( it != beyond ); CHECK_THROWS_AS ( * beyond , fail_fast ); CHECK ( beyond - first == 4 ); CHECK ( first - first == 0 ); CHECK ( beyond - beyond == 0 ); ++ it ; CHECK ( it - first == 1 ); CHECK ( * it == 2 ); CHECK ( beyond - it == 3 ); int last = 0 ; it = first ; CHECK ( it == first ); while ( it != s . cend ()) { CHECK ( * it == last + 1 ); last = * it ; ++ it ; } CHECK ( it == beyond ); CHECK ( it - beyond == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"rbegin_rend\" ) { { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . rbegin (); auto first = it ; CHECK ( it == first ); CHECK ( * it == 4 ); auto beyond = s . rend (); CHECK ( it != beyond ); CHECK_THROWS_AS ( * beyond , fail_fast ); CHECK ( beyond - first == 4 ); CHECK ( first - first == 0 ); CHECK ( beyond - beyond == 0 ); ++ it ; CHECK ( it - first == 1 ); CHECK ( * it == 3 ); * it = 22 ; CHECK ( * it == 22 ); CHECK ( beyond - it == 3 ); it = first ; CHECK ( it == first ); while ( it != s . rend ()) { * it = 5 ; ++ it ; } CHECK ( it == beyond ); CHECK ( it - beyond == 0 ); for ( const auto & n : s ) { CHECK ( n == 5 ); } } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"crbegin_crend\" ) { { int a [] = { 1 , 2 , 3 , 4 }; span < int > s = a ; auto it = s . crbegin (); auto first = it ; CHECK ( it == first ); CHECK ( * it == 4 ); auto beyond = s . crend (); CHECK ( it != beyond ); CHECK_THROWS_AS ( * beyond , fail_fast ); CHECK ( beyond - first == 4 ); CHECK ( first - first == 0 ); CHECK ( beyond - beyond == 0 ); ++ it ; CHECK ( it - first == 1 ); CHECK ( * it == 3 ); CHECK ( beyond - it == 3 ); it = first ; CHECK ( it == first ); int last = 5 ; while ( it != s . crend ()) { CHECK ( * it == last - 1 ); last = * it ; ++ it ; } CHECK ( it == beyond ); CHECK ( it - beyond == 0 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"comparison_operators\" ) { { span < int > s1 ; span < int > s2 ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 2 , 1 }; span < int > s1 = arr ; span < int > s2 = arr ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 2 , 1 }; // bigger span < int > s1 ; span < int > s2 = arr ; CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } { int arr1 [] = { 1 , 2 }; int arr2 [] = { 1 , 2 }; span < int > s1 = arr1 ; span < int > s2 = arr2 ; CHECK ( s1 == s2 ); CHECK ( ! ( s1 != s2 )); CHECK ( ! ( s1 < s2 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s1 > s2 )); CHECK ( s1 >= s2 ); CHECK ( s2 == s1 ); CHECK ( ! ( s2 != s1 )); CHECK ( ! ( s2 < s1 )); CHECK ( s2 <= s1 ); CHECK ( ! ( s2 > s1 )); CHECK ( s2 >= s1 ); } { int arr [] = { 1 , 2 , 3 }; span < int > s1 = { & arr [ 0 ], 2 }; // shorter span < int > s2 = arr ; // longer CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } { int arr1 [] = { 1 , 2 }; // smaller int arr2 [] = { 2 , 1 }; // bigger span < int > s1 = arr1 ; span < int > s2 = arr2 ; CHECK ( s1 != s2 ); CHECK ( s2 != s1 ); CHECK ( ! ( s1 == s2 )); CHECK ( ! ( s2 == s1 )); CHECK ( s1 < s2 ); CHECK ( ! ( s2 < s1 )); CHECK ( s1 <= s2 ); CHECK ( ! ( s2 <= s1 )); CHECK ( s2 > s1 ); CHECK ( ! ( s1 > s2 )); CHECK ( s2 >= s1 ); CHECK ( ! ( s1 >= s2 )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_bytes\" ) { int a [] = { 1 , 2 , 3 , 4 }; { const span < const int > s = a ; CHECK ( s . size () == 4 ); const span < const byte > bs = as_bytes ( s ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); } { span < int > s ; const auto bs = as_bytes ( s ); CHECK ( bs . size () == s . size ()); CHECK ( bs . size () == 0 ); CHECK ( bs . size_bytes () == 0 ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . data () == nullptr ); } { span < int > s = a ; const auto bs = as_bytes ( s ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_writeable_bytes\" ) { int a [] = { 1 , 2 , 3 , 4 }; { #ifdef CONFIRM_COMPILATION_ERRORS // you should not be able to get writeable bytes for const objects span < const int > s = a ; CHECK ( s . size () == 4 ); span < const byte > bs = as_writeable_bytes ( s ); CHECK ( static_cast < void *> ( bs . data ()) == static_cast < void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); #endif } { span < int > s ; const auto bs = as_writeable_bytes ( s ); CHECK ( bs . size () == s . size ()); CHECK ( bs . size () == 0 ); CHECK ( bs . size_bytes () == 0 ); CHECK ( static_cast < void *> ( bs . data ()) == static_cast < void *> ( s . data ())); CHECK ( bs . data () == nullptr ); } { span < int > s = a ; const auto bs = as_writeable_bytes ( s ); CHECK ( static_cast < void *> ( bs . data ()) == static_cast < void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"fixed_size_conversions\" ) { int arr [] = { 1 , 2 , 3 , 4 }; // converting to an span from an equal size array is ok span < int , 4 > s4 = arr ; CHECK ( s4 . size () == 4 ); // converting to dynamic_range is always ok { span < int > s = s4 ; CHECK ( s . size () == s4 . size ()); static_cast < void > ( s ); } // initialization or assignment to static span that REDUCES size is NOT ok #ifdef CONFIRM_COMPILATION_ERRORS { span < int , 2 > s = arr ; } { span < int , 2 > s2 = s4 ; static_cast < void > ( s2 ); } #endif // even when done dynamically { span < int > s = arr ; auto f = [ & ]() { const span < int , 2 > s2 = s ; static_cast < void > ( s2 ); }; CHECK_THROWS_AS ( f (), fail_fast ); } // but doing so explicitly is ok // you can convert statically { const span < int , 2 > s2 = { & arr [ 0 ], 2 }; static_cast < void > ( s2 ); } { const span < int , 1 > s1 = s4 . first < 1 > (); static_cast < void > ( s1 ); } // ...or dynamically { // NB: implicit conversion to span<int,1> from span<int> span < int , 1 > s1 = s4 . first ( 1 ); static_cast < void > ( s1 ); } // initialization or assignment to static span that requires size INCREASE is not ok. int arr2 [ 2 ] = { 1 , 2 }; #ifdef CONFIRM_COMPILATION_ERRORS { span < int , 4 > s3 = arr2 ; } { span < int , 2 > s2 = arr2 ; span < int , 4 > s4a = s2 ; } #endif { auto f = [ & ]() { const span < int , 4 > _s4 = { arr2 , 2 }; static_cast < void > ( _s4 ); }; CHECK_THROWS_AS ( f (), fail_fast ); } // this should fail - we are trying to assign a small dynamic span to a fixed_size larger one span < int > av = arr2 ; auto f = [ & ]() { const span < int , 4 > _s4 = av ; static_cast < void > ( _s4 ); }; CHECK_THROWS_AS ( f (), fail_fast ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"interop_with_std_regex\" ) { char lat [] = { '1' , '2' , '3' , '4' , '5' , '6' , 'E' , 'F' , 'G' }; span < char > s = lat ; const auto f_it = s . begin () + 7 ; std :: match_results < span < char >:: iterator > match ; std :: regex_match ( s . begin (), s . end (), match , std :: regex ( \".*\" )); CHECK ( match . ready ()); CHECK ( ! match . empty ()); CHECK ( match [ 0 ]. matched ); CHECK ( match [ 0 ]. first == s . begin ()); CHECK ( match [ 0 ]. second == s . end ()); std :: regex_search ( s . begin (), s . end (), match , std :: regex ( \"F\" )); CHECK ( match . ready ()); CHECK ( ! match . empty ()); CHECK ( match [ 0 ]. matched ); CHECK ( match [ 0 ]. first == f_it ); CHECK ( match [ 0 ]. second == ( f_it + 1 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"interop_with_gsl_at\" ) { int arr [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; span < int > s { arr }; CHECK (( at ( s , 0 ) == 1 && at ( s , 1 ) == 2 )); } TEST_CASE ( \"default_constructible\" ) { CHECK (( std :: is_default_constructible < span < int >>:: value )); CHECK (( std :: is_default_constructible < span < int , 0 >>:: value )); CHECK (( ! std :: is_default_constructible < span < int , 42 >>:: value )); }","title":"File span_tests.cpp"},{"location":"strict__notnull__tests_8cpp/","text":"File strict_notnull_tests.cpp \u00b6 File List > external > guideline > tests > strict_notnull_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/pointers> Namespaces \u00b6 Type Name namespace gsl Public Functions \u00b6 Type Name GSL_SUPPRESS (f. 4) GSL_SUPPRESS (con. 4) int * return_pointer () const int * return_pointer_const () Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( f . 4 ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( con . 4 ) function return_pointer \u00b6 int * return_pointer () function return_pointer_const \u00b6 const int * return_pointer_const () The documentation for this class was generated from the following file external/guideline/tests/strict_notnull_tests.cpp","title":"File strict\\_notnull\\_tests.cpp"},{"location":"strict__notnull__tests_8cpp/#file-strict95notnull95testscpp","text":"File List > external > guideline > tests > strict_notnull_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/pointers>","title":"File strict_notnull_tests.cpp"},{"location":"strict__notnull__tests_8cpp/#namespaces","text":"Type Name namespace gsl","title":"Namespaces"},{"location":"strict__notnull__tests_8cpp/#public-functions","text":"Type Name GSL_SUPPRESS (f. 4) GSL_SUPPRESS (con. 4) int * return_pointer () const int * return_pointer_const ()","title":"Public Functions"},{"location":"strict__notnull__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"strict__notnull__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( f . 4 )","title":"function GSL_SUPPRESS"},{"location":"strict__notnull__tests_8cpp/#function-gsl95suppress_1","text":"GSL_SUPPRESS ( con . 4 )","title":"function GSL_SUPPRESS"},{"location":"strict__notnull__tests_8cpp/#function-return95pointer","text":"int * return_pointer ()","title":"function return_pointer"},{"location":"strict__notnull__tests_8cpp/#function-return95pointer95const","text":"const int * return_pointer_const () The documentation for this class was generated from the following file external/guideline/tests/strict_notnull_tests.cpp","title":"function return_pointer_const"},{"location":"strict__notnull__tests_8cpp_source/","text":"File strict_notnull_tests.cpp \u00b6 File List > external > guideline > tests > strict_notnull_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch // Fix VS2015 build breaks in Release #pragma warning(disable : 4702) // unreachable code #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/pointers> // for not_null, operator<, operator<=, operator> namespace gsl { struct fail_fast ; } // namespace gsl using namespace gsl ; GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool helper ( not_null < int *> p ) { return * p == 12 ; } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool helper_const ( not_null < const int *> p ) { return * p == 12 ; } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool strict_helper ( strict_not_null < int *> p ) { return * p == 12 ; } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool strict_helper_const ( strict_not_null < const int *> p ) { return * p == 12 ; } int * return_pointer () { return nullptr ; } const int * return_pointer_const () { return nullptr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestStrictNotNull\" ) { { // raw ptr <-> strict_not_null int x = 42 ; #ifdef CONFIRM_COMPILATION_ERRORS strict_not_null < int *> snn = & x ; strict_helper ( & x ); strict_helper_const ( & x ); strict_helper ( return_pointer ()); strict_helper_const ( return_pointer_const ()); #endif const strict_not_null < int *> snn1 { & x }; helper ( snn1 ); helper_const ( snn1 ); CHECK ( * snn1 == 42 ); } { // strict_not_null -> strict_not_null int x = 42 ; strict_not_null < int *> snn1 { & x }; const strict_not_null < int *> snn2 { & x }; strict_helper ( snn1 ); strict_helper_const ( snn1 ); strict_helper_const ( snn2 ); CHECK ( snn1 == snn2 ); } { // strict_not_null -> not_null int x = 42 ; strict_not_null < int *> snn { & x }; const not_null < int *> nn1 = snn ; const not_null < int *> nn2 { snn }; helper ( snn ); helper_const ( snn ); CHECK ( snn == nn1 ); CHECK ( snn == nn2 ); } { // not_null -> strict_not_null int x = 42 ; not_null < int *> nn { & x }; const strict_not_null < int *> snn1 { nn }; const strict_not_null < int *> snn2 { nn }; strict_helper ( nn ); strict_helper_const ( nn ); CHECK ( snn1 == nn ); CHECK ( snn2 == nn ); std :: hash < strict_not_null < int *>> hash_snn ; std :: hash < not_null < int *>> hash_nn ; CHECK ( hash_nn ( snn1 ) == hash_nn ( nn )); CHECK ( hash_snn ( snn1 ) == hash_nn ( nn )); CHECK ( hash_nn ( snn1 ) == hash_nn ( snn2 )); CHECK ( hash_snn ( snn1 ) == hash_snn ( nn )); } #ifdef CONFIRM_COMPILATION_ERRORS { strict_not_null < int *> p { nullptr }; } #endif } #if defined(__cplusplus) && (__cplusplus >= 201703L) GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestStrictNotNullConstructorTypeDeduction\" ) { { int i = 42 ; strict_not_null x { & i }; helper ( strict_not_null { & i }); helper_const ( strict_not_null { & i }); CHECK ( * x == 42 ); } { int i = 42 ; int * p = & i ; strict_not_null x { p }; helper ( strict_not_null { p }); helper_const ( strict_not_null { p }); CHECK ( * x == 42 ); } { auto workaround_macro = []() { int * p1 = nullptr ; const strict_not_null x { p1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const int * p1 = nullptr ; const strict_not_null x { p1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; CHECK_THROWS_AS ( helper ( strict_not_null { p }), fail_fast ); CHECK_THROWS_AS ( helper_const ( strict_not_null { p }), fail_fast ); } #ifdef CONFIRM_COMPILATION_ERRORS { strict_not_null x { nullptr }; helper ( strict_not_null { nullptr }); helper_const ( strict_not_null { nullptr }); } #endif } #endif // #if defined(__cplusplus) && (__cplusplus >= 201703L) static_assert ( std :: is_nothrow_move_constructible < strict_not_null < void *>>:: value , \"strict_not_null must be no-throw move constructible\" );","title":"File strict\\_notnull\\_tests.cpp"},{"location":"strict__notnull__tests_8cpp_source/#file-strict95notnull95testscpp","text":"File List > external > guideline > tests > strict_notnull_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch // Fix VS2015 build breaks in Release #pragma warning(disable : 4702) // unreachable code #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/pointers> // for not_null, operator<, operator<=, operator> namespace gsl { struct fail_fast ; } // namespace gsl using namespace gsl ; GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool helper ( not_null < int *> p ) { return * p == 12 ; } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool helper_const ( not_null < const int *> p ) { return * p == 12 ; } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool strict_helper ( strict_not_null < int *> p ) { return * p == 12 ; } GSL_SUPPRESS ( f .4 ) // NO-FORMAT: attribute bool strict_helper_const ( strict_not_null < const int *> p ) { return * p == 12 ; } int * return_pointer () { return nullptr ; } const int * return_pointer_const () { return nullptr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestStrictNotNull\" ) { { // raw ptr <-> strict_not_null int x = 42 ; #ifdef CONFIRM_COMPILATION_ERRORS strict_not_null < int *> snn = & x ; strict_helper ( & x ); strict_helper_const ( & x ); strict_helper ( return_pointer ()); strict_helper_const ( return_pointer_const ()); #endif const strict_not_null < int *> snn1 { & x }; helper ( snn1 ); helper_const ( snn1 ); CHECK ( * snn1 == 42 ); } { // strict_not_null -> strict_not_null int x = 42 ; strict_not_null < int *> snn1 { & x }; const strict_not_null < int *> snn2 { & x }; strict_helper ( snn1 ); strict_helper_const ( snn1 ); strict_helper_const ( snn2 ); CHECK ( snn1 == snn2 ); } { // strict_not_null -> not_null int x = 42 ; strict_not_null < int *> snn { & x }; const not_null < int *> nn1 = snn ; const not_null < int *> nn2 { snn }; helper ( snn ); helper_const ( snn ); CHECK ( snn == nn1 ); CHECK ( snn == nn2 ); } { // not_null -> strict_not_null int x = 42 ; not_null < int *> nn { & x }; const strict_not_null < int *> snn1 { nn }; const strict_not_null < int *> snn2 { nn }; strict_helper ( nn ); strict_helper_const ( nn ); CHECK ( snn1 == nn ); CHECK ( snn2 == nn ); std :: hash < strict_not_null < int *>> hash_snn ; std :: hash < not_null < int *>> hash_nn ; CHECK ( hash_nn ( snn1 ) == hash_nn ( nn )); CHECK ( hash_snn ( snn1 ) == hash_nn ( nn )); CHECK ( hash_nn ( snn1 ) == hash_nn ( snn2 )); CHECK ( hash_snn ( snn1 ) == hash_snn ( nn )); } #ifdef CONFIRM_COMPILATION_ERRORS { strict_not_null < int *> p { nullptr }; } #endif } #if defined(__cplusplus) && (__cplusplus >= 201703L) GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestStrictNotNullConstructorTypeDeduction\" ) { { int i = 42 ; strict_not_null x { & i }; helper ( strict_not_null { & i }); helper_const ( strict_not_null { & i }); CHECK ( * x == 42 ); } { int i = 42 ; int * p = & i ; strict_not_null x { p }; helper ( strict_not_null { p }); helper_const ( strict_not_null { p }); CHECK ( * x == 42 ); } { auto workaround_macro = []() { int * p1 = nullptr ; const strict_not_null x { p1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { auto workaround_macro = []() { const int * p1 = nullptr ; const strict_not_null x { p1 }; }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } { int * p = nullptr ; CHECK_THROWS_AS ( helper ( strict_not_null { p }), fail_fast ); CHECK_THROWS_AS ( helper_const ( strict_not_null { p }), fail_fast ); } #ifdef CONFIRM_COMPILATION_ERRORS { strict_not_null x { nullptr }; helper ( strict_not_null { nullptr }); helper_const ( strict_not_null { nullptr }); } #endif } #endif // #if defined(__cplusplus) && (__cplusplus >= 201703L) static_assert ( std :: is_nothrow_move_constructible < strict_not_null < void *>>:: value , \"strict_not_null must be no-throw move constructible\" );","title":"File strict_notnull_tests.cpp"},{"location":"strided__span__tests_8cpp/","text":"File strided_span_tests.cpp \u00b6 File List > external > guideline > tests > strided_span_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_byte> #include <gsl/gsl_util> #include <gsl/multi_span> #include <iostream> #include <iterator> #include <numeric> #include <type_traits> #include <vector> Namespaces \u00b6 Type Name namespace gsl Public Attributes \u00b6 Type Name dynamic_range av = { auto length = av.size() / 2<br> | | auto | bounds = = strided_bounds<1>(multi_span_index<1>{length}, multi_span_index<1>{2}) | | | dynamic_range | | int | i = = 0 | | int | idx = = 0 | | auto | section = = av.section({0, 1, 0}, {3, 1, 2}) | Public Functions \u00b6 Type Name CHECK (strided. size==length) CHECK (strided. bounds==length) GSL_SUPPRESS (con. 4) GSL_SUPPRESS (bounds. 1) TEST_CASE (\"span_section_test\") TEST_CASE (\"span_section\") strided_span< int, 1 > strided & av () for () for (auto num :strided) for (const auto num :section) Public Attributes Documentation \u00b6 variable av \u00b6 dynamic_range av ; variable bounds \u00b6 auto bounds ; variable dynamic_range \u00b6 dynamic_range ; variable i \u00b6 int i ; variable idx \u00b6 int idx ; variable section \u00b6 auto section ; Public Functions Documentation \u00b6 function CHECK \u00b6 CHECK ( strided . size == length ) function CHECK \u00b6 CHECK ( strided . bounds == length ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( con . 4 ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( bounds . 1 ) function TEST_CASE \u00b6 TEST_CASE ( \"span_section_test\" ) function TEST_CASE \u00b6 TEST_CASE ( \"span_section\" ) function av \u00b6 strided_span < int , 1 > strided & av () function for \u00b6 for () function for \u00b6 for ( auto num : strided ) function for \u00b6 for ( const auto num : section ) The documentation for this class was generated from the following file external/guideline/tests/strided_span_tests.cpp","title":"File strided\\_span\\_tests.cpp"},{"location":"strided__span__tests_8cpp/#file-strided95span95testscpp","text":"File List > external > guideline > tests > strided_span_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_byte> #include <gsl/gsl_util> #include <gsl/multi_span> #include <iostream> #include <iterator> #include <numeric> #include <type_traits> #include <vector>","title":"File strided_span_tests.cpp"},{"location":"strided__span__tests_8cpp/#namespaces","text":"Type Name namespace gsl","title":"Namespaces"},{"location":"strided__span__tests_8cpp/#public-attributes","text":"Type Name dynamic_range av = { auto length = av.size() / 2<br> | | auto | bounds = = strided_bounds<1>(multi_span_index<1>{length}, multi_span_index<1>{2}) | | | dynamic_range | | int | i = = 0 | | int | idx = = 0 | | auto | section = = av.section({0, 1, 0}, {3, 1, 2}) |","title":"Public Attributes"},{"location":"strided__span__tests_8cpp/#public-functions","text":"Type Name CHECK (strided. size==length) CHECK (strided. bounds==length) GSL_SUPPRESS (con. 4) GSL_SUPPRESS (bounds. 1) TEST_CASE (\"span_section_test\") TEST_CASE (\"span_section\") strided_span< int, 1 > strided & av () for () for (auto num :strided) for (const auto num :section)","title":"Public Functions"},{"location":"strided__span__tests_8cpp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"strided__span__tests_8cpp/#variable-av","text":"dynamic_range av ;","title":"variable av"},{"location":"strided__span__tests_8cpp/#variable-bounds","text":"auto bounds ;","title":"variable bounds"},{"location":"strided__span__tests_8cpp/#variable-dynamic95range","text":"dynamic_range ;","title":"variable dynamic_range"},{"location":"strided__span__tests_8cpp/#variable-i","text":"int i ;","title":"variable i"},{"location":"strided__span__tests_8cpp/#variable-idx","text":"int idx ;","title":"variable idx"},{"location":"strided__span__tests_8cpp/#variable-section","text":"auto section ;","title":"variable section"},{"location":"strided__span__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"strided__span__tests_8cpp/#function-check","text":"CHECK ( strided . size == length )","title":"function CHECK"},{"location":"strided__span__tests_8cpp/#function-check_1","text":"CHECK ( strided . bounds == length )","title":"function CHECK"},{"location":"strided__span__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( con . 4 )","title":"function GSL_SUPPRESS"},{"location":"strided__span__tests_8cpp/#function-gsl95suppress_1","text":"GSL_SUPPRESS ( bounds . 1 )","title":"function GSL_SUPPRESS"},{"location":"strided__span__tests_8cpp/#function-test95case","text":"TEST_CASE ( \"span_section_test\" )","title":"function TEST_CASE"},{"location":"strided__span__tests_8cpp/#function-test95case_1","text":"TEST_CASE ( \"span_section\" )","title":"function TEST_CASE"},{"location":"strided__span__tests_8cpp/#function-av","text":"strided_span < int , 1 > strided & av ()","title":"function av"},{"location":"strided__span__tests_8cpp/#function-for","text":"for ()","title":"function for"},{"location":"strided__span__tests_8cpp/#function-for_1","text":"for ( auto num : strided )","title":"function for"},{"location":"strided__span__tests_8cpp/#function-for_2","text":"for ( const auto num : section ) The documentation for this class was generated from the following file external/guideline/tests/strided_span_tests.cpp","title":"function for"},{"location":"strided__span__tests_8cpp_source/","text":"File strided_span_tests.cpp \u00b6 File List > external > guideline > tests > strided_span_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch deprecated #pragma warning(disable : 4996) // strided_span is in the process of being deprecated. // Suppressing warnings until it is completely removed #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\" #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, CHECK... #include <gsl/gsl_byte> // for byte #include <gsl/gsl_util> // for narrow_cast #include <gsl/multi_span> // for strided_span, index, multi_span, strided_... #include <iostream> // for size_t #include <iterator> // for begin, end #include <numeric> // for iota #include <type_traits> // for integral_constant<>::value, is_convertible #include <vector> // for vector namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; namespace { struct BaseClass { }; struct DerivedClass : BaseClass { }; } TEST_CASE ( \"span_section_test\" ) { int a [ 30 ][ 4 ][ 5 ]; const auto av = as_multi_span ( a ); const auto sub = av . section ({ 15 , 0 , 0 }, gsl :: multi_span_index < 3 > { 2 , 2 , 2 }); const auto subsub = sub . section ({ 1 , 0 , 0 }, gsl :: multi_span_index < 3 > { 1 , 1 , 1 }); ( void ) subsub ; } TEST_CASE ( \"span_section\" ) { std :: vector < int > data ( 5 * 10 ); std :: iota ( begin ( data ), end ( data ), 0 ); const multi_span < int , 5 , 10 > av = as_multi_span ( multi_span < int > { data }, dim < 5 > (), dim < 10 > ()); const strided_span < int , 2 > av_section_1 = av . section ({ 1 , 2 }, { 3 , 4 }); CHECK ( ! av_section_1 . empty ()); CHECK (( av_section_1 [{ 0 , 0 }] == 12 )); CHECK (( av_section_1 [{ 0 , 1 }] == 13 )); CHECK (( av_section_1 [{ 1 , 0 }] == 22 )); CHECK (( av_section_1 [{ 2 , 3 }] == 35 )); const strided_span < int , 2 > av_section_2 = av_section_1 . section ({ 1 , 2 }, { 2 , 2 }); CHECK ( ! av_section_2 . empty ()); CHECK (( av_section_2 [{ 0 , 0 }] == 24 )); CHECK (( av_section_2 [{ 0 , 1 }] == 25 )); CHECK (( av_section_2 [{ 1 , 0 }] == 34 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_constructors\" ) { // Check stride constructor { int arr [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; const int carr [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; strided_span < int , 1 > sav1 { arr , {{ 9 }, { 1 }}}; // T -> T CHECK ( sav1 . bounds (). index_bounds () == multi_span_index < 1 > { 9 }); CHECK ( sav1 . bounds (). stride () == 1 ); CHECK (( sav1 [ 0 ] == 1 && sav1 [ 8 ] == 9 )); strided_span < const int , 1 > sav2 { carr , {{ 4 }, { 2 }}}; // const T -> const T CHECK ( sav2 . bounds (). index_bounds () == multi_span_index < 1 > { 4 }); CHECK ( sav2 . bounds (). strides () == multi_span_index < 1 > { 2 }); CHECK (( sav2 [ 0 ] == 1 && sav2 [ 3 ] == 7 )); strided_span < int , 2 > sav3 { arr , {{ 2 , 2 }, { 6 , 2 }}}; // T -> const T CHECK (( sav3 . bounds (). index_bounds () == multi_span_index < 2 > { 2 , 2 })); CHECK (( sav3 . bounds (). strides () == multi_span_index < 2 > { 6 , 2 })); CHECK (( sav3 [{ 0 , 0 }] == 1 && sav3 [{ 0 , 1 }] == 3 && sav3 [{ 1 , 0 }] == 7 )); } // Check multi_span constructor { int arr [] = { 1 , 2 }; // From non-cv-qualified source { const multi_span < int > src = arr ; strided_span < int , 1 > sav { src , { 2 , 1 }}; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 // strided_span<const int, 1> sav_c{ {src}, {2, 1} }; strided_span < const int , 1 > sav_c { multi_span < const int > { src }, strided_bounds < 1 > { 2 , 1 }}; #else strided_span < const int , 1 > sav_c { multi_span < const int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_c . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_c . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_c [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 strided_span < volatile int , 1 > sav_v { src , { 2 , 1 }}; #else strided_span < volatile int , 1 > sav_v { multi_span < volatile int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_v . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_v . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_v [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 strided_span < const volatile int , 1 > sav_cv { src , { 2 , 1 }}; #else strided_span < const volatile int , 1 > sav_cv { multi_span < const volatile int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_cv . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_cv . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_cv [ 1 ] == 2 ); } // From const-qualified source { const multi_span < const int > src { arr }; strided_span < const int , 1 > sav_c { src , { 2 , 1 }}; CHECK ( sav_c . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_c . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_c [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 strided_span < const volatile int , 1 > sav_cv { src , { 2 , 1 }}; #else strided_span < const volatile int , 1 > sav_cv { multi_span < const volatile int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_cv . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_cv . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_cv [ 1 ] == 2 ); } // From volatile-qualified source { const multi_span < volatile int > src { arr }; strided_span < volatile int , 1 > sav_v { src , { 2 , 1 }}; CHECK ( sav_v . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_v . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_v [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 strided_span < const volatile int , 1 > sav_cv { src , { 2 , 1 }}; #else strided_span < const volatile int , 1 > sav_cv { multi_span < const volatile int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_cv . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_cv . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_cv [ 1 ] == 2 ); } // From cv-qualified source { const multi_span < const volatile int > src { arr }; strided_span < const volatile int , 1 > sav_cv { src , { 2 , 1 }}; CHECK ( sav_cv . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_cv . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_cv [ 1 ] == 2 ); } } // Check const-casting constructor { int arr [ 2 ] = { 4 , 5 }; const multi_span < int , 2 > av ( arr , 2 ); multi_span < const int , 2 > av2 { av }; CHECK ( av2 [ 1 ] == 5 ); static_assert ( std :: is_convertible < const multi_span < int , 2 > , multi_span < const int , 2 >>:: value , \"ctor is not implicit!\" ); const strided_span < int , 1 > src { arr , { 2 , 1 }}; strided_span < const int , 1 > sav { src }; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav . bounds (). stride () == 1 ); CHECK ( sav [ 1 ] == 5 ); static_assert ( std :: is_convertible < const strided_span < int , 1 > , strided_span < const int , 1 >>:: value , \"ctor is not implicit!\" ); } // Check copy constructor { int arr1 [ 2 ] = { 3 , 4 }; const strided_span < int , 1 > src1 { arr1 , { 2 , 1 }}; strided_span < int , 1 > sav1 { src1 }; CHECK ( sav1 . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav1 . bounds (). stride () == 1 ); CHECK ( sav1 [ 0 ] == 3 ); int arr2 [ 6 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; const strided_span < const int , 2 > src2 { arr2 , {{ 3 , 2 }, { 2 , 1 }}}; strided_span < const int , 2 > sav2 { src2 }; CHECK (( sav2 . bounds (). index_bounds () == multi_span_index < 2 > { 3 , 2 })); CHECK (( sav2 . bounds (). strides () == multi_span_index < 2 > { 2 , 1 })); CHECK (( sav2 [{ 0 , 0 }] == 1 && sav2 [{ 2 , 0 }] == 5 )); } // Check const-casting assignment operator { int arr1 [ 2 ] = { 1 , 2 }; int arr2 [ 6 ] = { 3 , 4 , 5 , 6 , 7 , 8 }; const strided_span < int , 1 > src { arr1 , {{ 2 }, { 1 }}}; strided_span < const int , 1 > sav { arr2 , {{ 3 }, { 2 }}}; strided_span < const int , 1 >& sav_ref = ( sav = src ); CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav [ 0 ] == 1 ); CHECK ( & sav_ref == & sav ); } // Check copy assignment operator { int arr1 [ 2 ] = { 3 , 4 }; int arr1b [ 1 ] = { 0 }; const strided_span < int , 1 > src1 { arr1 , { 2 , 1 }}; strided_span < int , 1 > sav1 { arr1b , { 1 , 1 }}; strided_span < int , 1 >& sav1_ref = ( sav1 = src1 ); CHECK ( sav1 . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav1 . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav1 [ 0 ] == 3 ); CHECK ( & sav1_ref == & sav1 ); const int arr2 [ 6 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; const int arr2b [ 1 ] = { 0 }; const strided_span < const int , 2 > src2 { arr2 , {{ 3 , 2 }, { 2 , 1 }}}; strided_span < const int , 2 > sav2 { arr2b , {{ 1 , 1 }, { 1 , 1 }}}; strided_span < const int , 2 >& sav2_ref = ( sav2 = src2 ); CHECK (( sav2 . bounds (). index_bounds () == multi_span_index < 2 > { 3 , 2 })); CHECK (( sav2 . bounds (). strides () == multi_span_index < 2 > { 2 , 1 })); CHECK (( sav2 [{ 0 , 0 }] == 1 && sav2 [{ 2 , 0 }] == 5 )); CHECK ( & sav2_ref == & sav2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_slice\" ) { std :: vector < int > data ( 5 * 10 ); std :: iota ( begin ( data ), end ( data ), 0 ); const multi_span < int , 5 , 10 > src = as_multi_span ( multi_span < int > { data }, dim < 5 > (), dim < 10 > ()); const strided_span < int , 2 > sav { src , {{ 5 , 10 }, { 10 , 1 }}}; #ifdef CONFIRM_COMPILATION_ERRORS const strided_span < const int , 2 > csav {{ src }, {{ 5 , 10 }, { 10 , 1 }}}; #endif const strided_span < const int , 2 > csav { multi_span < const int , 5 , 10 > { src }, {{ 5 , 10 }, { 10 , 1 }}}; strided_span < int , 1 > sav_sl = sav [ 2 ]; CHECK ( sav_sl [ 0 ] == 20 ); CHECK ( sav_sl [ 9 ] == 29 ); strided_span < const int , 1 > csav_sl = sav [ 3 ]; CHECK ( csav_sl [ 0 ] == 30 ); CHECK ( csav_sl [ 9 ] == 39 ); CHECK ( sav [ 4 ][ 0 ] == 40 ); CHECK ( sav [ 4 ][ 9 ] == 49 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_column_major\" ) { // strided_span may be used to accommodate more peculiar // use cases, such as column-major multidimensional array // (aka. \"FORTRAN\" layout). int cm_array [ 3 * 5 ] = { 1 , 4 , 7 , 10 , 13 , 2 , 5 , 8 , 11 , 14 , 3 , 6 , 9 , 12 , 15 }; strided_span < int , 2 > cm_sav { cm_array , {{ 5 , 3 }, { 1 , 5 }}}; // Accessing elements CHECK (( cm_sav [{ 0 , 0 }] == 1 )); CHECK (( cm_sav [{ 0 , 1 }] == 2 )); CHECK (( cm_sav [{ 1 , 0 }] == 4 )); CHECK (( cm_sav [{ 4 , 2 }] == 15 )); // Slice strided_span < int , 1 > cm_sl = cm_sav [ 3 ]; CHECK ( cm_sl [ 0 ] == 10 ); CHECK ( cm_sl [ 1 ] == 11 ); CHECK ( cm_sl [ 2 ] == 12 ); // Section strided_span < int , 2 > cm_sec = cm_sav . section ({ 2 , 1 }, { 3 , 2 }); CHECK (( cm_sec . bounds (). index_bounds () == multi_span_index < 2 > { 3 , 2 })); CHECK (( cm_sec [{ 0 , 0 }] == 8 )); CHECK (( cm_sec [{ 0 , 1 }] == 9 )); CHECK (( cm_sec [{ 1 , 0 }] == 11 )); CHECK (( cm_sec [{ 2 , 1 }] == 15 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_bounds\" ) { int arr [] = { 0 , 1 , 2 , 3 }; multi_span < int > av ( arr ); { // incorrect sections CHECK_THROWS_AS ( av . section ( 0 , 0 )[ 0 ], fail_fast ); CHECK_THROWS_AS ( av . section ( 1 , 0 )[ 0 ], fail_fast ); CHECK_THROWS_AS ( av . section ( 1 , 1 )[ 1 ], fail_fast ); CHECK_THROWS_AS ( av . section ( 2 , 5 ), fail_fast ); CHECK_THROWS_AS ( av . section ( 5 , 2 ), fail_fast ); CHECK_THROWS_AS ( av . section ( 5 , 0 ), fail_fast ); CHECK_THROWS_AS ( av . section ( 0 , 5 ), fail_fast ); CHECK_THROWS_AS ( av . section ( 5 , 5 ), fail_fast ); } { // zero stride strided_span < int , 1 > sav { av , {{ 4 }, {}}}; CHECK ( sav [ 0 ] == 0 ); CHECK ( sav [ 3 ] == 0 ); CHECK_THROWS_AS ( sav [ 4 ], fail_fast ); } { // zero extent strided_span < int , 1 > sav { av , {{}, { 1 }}}; CHECK_THROWS_AS ( sav [ 0 ], fail_fast ); } { // zero extent and stride strided_span < int , 1 > sav { av , {{}, {}}}; CHECK_THROWS_AS ( sav [ 0 ], fail_fast ); } { // strided array ctor with matching strided bounds strided_span < int , 1 > sav { arr , { 4 , 1 }}; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 4 }); CHECK ( sav [ 3 ] == 3 ); CHECK_THROWS_AS ( sav [ 4 ], fail_fast ); } { // strided array ctor with smaller strided bounds strided_span < int , 1 > sav { arr , { 2 , 1 }}; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav [ 1 ] == 1 ); CHECK_THROWS_AS ( sav [ 2 ], fail_fast ); } { // strided array ctor with fitting irregular bounds strided_span < int , 1 > sav { arr , { 2 , 3 }}; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav [ 0 ] == 0 ); CHECK ( sav [ 1 ] == 3 ); CHECK_THROWS_AS ( sav [ 2 ], fail_fast ); } { // bounds cross data boundaries - from static arrays CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 3 , 2 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 3 , 3 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 4 , 5 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 5 , 1 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 5 , 5 }}), fail_fast ); } { // bounds cross data boundaries - from array view CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 3 , 2 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 3 , 3 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 4 , 5 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 5 , 1 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 5 , 5 }}), fail_fast ); } { // bounds cross data boundaries - from dynamic arrays CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 3 , 2 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 3 , 3 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 4 , 5 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 5 , 1 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 5 , 5 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 2 , { 2 , 2 }}), fail_fast ); } #ifdef CONFIRM_COMPILATION_ERRORS { strided_span < int , 1 > sav0 { av . data (), { 3 , 2 }}; strided_span < int , 1 > sav1 { arr , { 1 }}; strided_span < int , 1 > sav2 { arr , { 1 , 1 , 1 }}; strided_span < int , 1 > sav3 { av , { 1 }}; strided_span < int , 1 > sav4 { av , { 1 , 1 , 1 }}; strided_span < int , 2 > sav5 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), { 1 }}; strided_span < int , 2 > sav6 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), { 1 , 1 , 1 }}; strided_span < int , 2 > sav7 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), {{ 1 , 1 }, { 1 , 1 }, { 1 , 1 }}}; multi_span_index < 1 > index { 0 , 1 }; strided_span < int , 1 > sav8 { arr , { 1 , { 1 , 1 }}}; strided_span < int , 1 > sav9 { arr , {{ 1 , 1 }, { 1 , 1 }}}; strided_span < int , 1 > sav10 { av , { 1 , { 1 , 1 }}}; strided_span < int , 1 > sav11 { av , {{ 1 , 1 }, { 1 , 1 }}}; strided_span < int , 2 > sav12 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), {{ 1 }, { 1 }}}; strided_span < int , 2 > sav13 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), {{ 1 }, { 1 , 1 , 1 }}}; strided_span < int , 2 > sav14 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), {{ 1 , 1 , 1 }, { 1 }}}; } #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_type_conversion\" ) { int arr [] = { 0 , 1 , 2 , 3 }; multi_span < int > av ( arr ); { strided_span < int , 1 > sav { av . data (), av . size (), { av . size () / 2 , 2 }}; #ifdef CONFIRM_COMPILATION_ERRORS strided_span < long , 1 > lsav1 = sav . as_strided_span < long , 1 > (); #endif } { strided_span < int , 1 > sav { av , { av . size () / 2 , 2 }}; #ifdef CONFIRM_COMPILATION_ERRORS strided_span < long , 1 > lsav1 = sav . as_strided_span < long , 1 > (); #endif } multi_span < const byte , dynamic_range > bytes = as_bytes ( av ); // retype strided array with regular strides - from raw data { strided_bounds < 2 > bounds {{ 2 , bytes . size () / 4 }, { bytes . size () / 2 , 1 }}; strided_span < const byte , 2 > sav2 { bytes . data (), bytes . size (), bounds }; strided_span < const int , 2 > sav3 = sav2 . as_strided_span < const int > (); CHECK ( sav3 [ 0 ][ 0 ] == 0 ); CHECK ( sav3 [ 1 ][ 0 ] == 2 ); CHECK_THROWS_AS ( sav3 [ 1 ][ 1 ], fail_fast ); CHECK_THROWS_AS ( sav3 [ 0 ][ 1 ], fail_fast ); } // retype strided array with regular strides - from multi_span { strided_bounds < 2 > bounds {{ 2 , bytes . size () / 4 }, { bytes . size () / 2 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; strided_span < int , 2 > sav3 = sav2 . as_strided_span < int > (); CHECK ( sav3 [ 0 ][ 0 ] == 0 ); CHECK ( sav3 [ 1 ][ 0 ] == 2 ); CHECK_THROWS_AS ( sav3 [ 1 ][ 1 ], fail_fast ); CHECK_THROWS_AS ( sav3 [ 0 ][ 1 ], fail_fast ); } // retype strided array with not enough elements - last dimension of the array is too small { strided_bounds < 2 > bounds {{ 4 , 2 }, { 4 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with not enough elements - strides are too small { strided_bounds < 2 > bounds {{ 4 , 2 }, { 2 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with not enough elements - last dimension does not divide by the new // typesize { strided_bounds < 2 > bounds {{ 2 , 6 }, { 4 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with not enough elements - strides does not divide by the new // typesize { strided_bounds < 2 > bounds {{ 2 , 1 }, { 6 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with irregular strides - from raw data { strided_bounds < 1 > bounds { bytes . size () / 2 , 2 }; strided_span < const byte , 1 > sav2 { bytes . data (), bytes . size (), bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with irregular strides - from multi_span { strided_bounds < 1 > bounds { bytes . size () / 2 , 2 }; strided_span < const byte , 1 > sav2 { bytes , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute TEST_CASE ( \"empty_strided_spans\" ) { { multi_span < int , 0 > empty_av ( nullptr ); strided_span < int , 1 > empty_sav { empty_av , { 0 , 1 }}; CHECK ( empty_sav . bounds (). index_bounds () == multi_span_index < 1 > { 0 }); CHECK ( empty_sav . empty ()); CHECK_THROWS_AS ( empty_sav [ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_sav . begin ()[ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_sav . cbegin ()[ 0 ], fail_fast ); for ( const auto & v : empty_sav ) { ( void ) v ; CHECK ( false ); } } { strided_span < int , 1 > empty_sav { nullptr , 0 , { 0 , 1 }}; CHECK ( empty_sav . bounds (). index_bounds () == multi_span_index < 1 > { 0 }); CHECK_THROWS_AS ( empty_sav [ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_sav . begin ()[ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_sav . cbegin ()[ 0 ], fail_fast ); for ( const auto & v : empty_sav ) { ( void ) v ; CHECK ( false ); } } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute void iterate_every_other_element ( multi_span < int , dynamic_range > av ) { // pick every other element auto length = av . size () / 2 ; #if defined(_MSC_VER) && _MSC_VER > 1800 auto bounds = strided_bounds < 1 > ({ length }, { 2 }); #else auto bounds = strided_bounds < 1 > ( multi_span_index < 1 > { length }, multi_span_index < 1 > { 2 }); #endif strided_span < int , 1 > strided ( & av . data ()[ 1 ], av . size () - 1 , bounds ); CHECK ( strided . size () == length ); CHECK ( strided . bounds (). index_bounds ()[ 0 ] == length ); for ( auto i = 0 ; i < strided . size (); ++ i ) { CHECK ( strided [ i ] == av [ 2 * i + 1 ]); } int idx = 0 ; for ( auto num : strided ) { CHECK ( num == av [ 2 * idx + 1 ]); idx ++ ; } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_section_iteration\" ) { int arr [ 8 ] = { 4 , 0 , 5 , 1 , 6 , 2 , 7 , 3 }; // static bounds { multi_span < int , 8 > av ( arr , 8 ); iterate_every_other_element ( av ); } // dynamic bounds { multi_span < int , dynamic_range > av ( arr , 8 ); iterate_every_other_element ( av ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"dynamic_strided_span_section_iteration\" ) { auto arr = new int [ 8 ]; for ( int i = 0 ; i < 4 ; ++ i ) { arr [ 2 * i ] = 4 + i ; arr [ 2 * i + 1 ] = i ; } auto av = as_multi_span ( arr , 8 ); iterate_every_other_element ( av ); delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute // TODO: does not work void iterate_second_slice ( multi_span < int , dynamic_range , dynamic_range , dynamic_range > av ) { const int expected [ 6 ] = { 2 , 3 , 10 , 11 , 18 , 19 }; auto section = av . section ({ 0 , 1 , 0 }, { 3 , 1 , 2 }); for ( auto i = 0 ; i < section . extent < 0 > (); ++ i ) { for ( auto j = 0 ; j < section . extent < 1 > (); ++ j ) for ( auto k = 0 ; k < section . extent < 2 > (); ++ k ) { auto idx = multi_span_index < 3 > { i , j , k }; // avoid braces in the CHECK macro CHECK ( section [ idx ] == expected [ 2 * i + 2 * j + k ]); } } for ( auto i = 0 ; i < section . extent < 0 > (); ++ i ) { for ( auto j = 0 ; j < section . extent < 1 > (); ++ j ) for ( auto k = 0 ; k < section . extent < 2 > (); ++ k ) CHECK ( section [ i ][ j ][ k ] == expected [ 2 * i + 2 * j + k ]); } int i = 0 ; for ( const auto num : section ) { CHECK ( num == expected [ i ]); i ++ ; } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_section_iteration_3d\" ) { int arr [ 3 ][ 4 ][ 2 ]{}; for ( auto i = 0 ; i < 3 ; ++ i ) { for ( auto j = 0 ; j < 4 ; ++ j ) for ( auto k = 0 ; k < 2 ; ++ k ) arr [ i ][ j ][ k ] = 8 * i + 2 * j + k ; } { multi_span < int , 3 , 4 , 2 > av = arr ; iterate_second_slice ( av ); } } GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"dynamic_strided_span_section_iteration_3d\" ) { const auto height = 12 , width = 2 ; const auto size = height * width ; auto arr = new int [ static_cast < std :: size_t > ( size )]; for ( auto i = 0 ; i < size ; ++ i ) { arr [ i ] = i ; } { auto av = as_multi_span ( as_multi_span ( arr , 24 ), dim < 3 > (), dim < 4 > (), dim < 2 > ()); iterate_second_slice ( av ); } { auto av = as_multi_span ( as_multi_span ( arr , 24 ), dim ( 3 ), dim < 4 > (), dim < 2 > ()); iterate_second_slice ( av ); } { auto av = as_multi_span ( as_multi_span ( arr , 24 ), dim < 3 > (), dim ( 4 ), dim < 2 > ()); iterate_second_slice ( av ); } { auto av = as_multi_span ( as_multi_span ( arr , 24 ), dim < 3 > (), dim < 4 > (), dim ( 2 )); iterate_second_slice ( av ); } delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_conversion\" ) { // get an multi_span of 'c' values from the list of X's struct X { int a ; int b ; int c ; }; X arr [ 4 ] = {{ 0 , 1 , 2 }, { 3 , 4 , 5 }, { 6 , 7 , 8 }, { 9 , 10 , 11 }}; int s = sizeof ( int ) / sizeof ( byte ); auto d2 = 3 * s ; auto d1 = narrow_cast < int > ( sizeof ( int )) * 12 / d2 ; // convert to 4x12 array of bytes auto av = as_multi_span ( as_bytes ( as_multi_span ( & arr [ 0 ], 4 )), dim ( d1 ), dim ( d2 )); CHECK ( av . bounds (). index_bounds ()[ 0 ] == 4 ); CHECK ( av . bounds (). index_bounds ()[ 1 ] == 12 ); // get the last 4 columns auto section = av . section ({ 0 , 2 * s }, { 4 , s }); // { { arr[0].c[0], arr[0].c[1], arr[0].c[2], // arr[0].c[3] } , { arr[1].c[0], ... } , ... // } // convert to array 4x1 array of integers auto cs = section . as_strided_span < int > (); // { { arr[0].c }, {arr[1].c } , ... } CHECK ( cs . bounds (). index_bounds ()[ 0 ] == 4 ); CHECK ( cs . bounds (). index_bounds ()[ 1 ] == 1 ); // transpose to 1x4 array strided_bounds < 2 > reverse_bounds { { cs . bounds (). index_bounds ()[ 1 ], cs . bounds (). index_bounds ()[ 0 ]}, { cs . bounds (). strides ()[ 1 ], cs . bounds (). strides ()[ 0 ]}}; strided_span < int , 2 > transposed { cs . data (), cs . bounds (). total_size (), reverse_bounds }; // slice to get a one-dimensional array of c's strided_span < int , 1 > result = transposed [ 0 ]; CHECK ( result . bounds (). index_bounds ()[ 0 ] == 4 ); CHECK_THROWS_AS ( result . bounds (). index_bounds ()[ 1 ], fail_fast ); int i = 0 ; for ( auto & num : result ) { CHECK ( num == arr [ i ]. c ); i ++ ; } } #if __clang__ || __GNUC__ #pragma GCC diagnostic pop #endif","title":"File strided\\_span\\_tests.cpp"},{"location":"strided__span__tests_8cpp_source/#file-strided95span95testscpp","text":"File List > external > guideline > tests > strided_span_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch deprecated #pragma warning(disable : 4996) // strided_span is in the process of being deprecated. // Suppressing warnings until it is completely removed #endif #if __clang__ || __GNUC__ #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\" #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, CHECK... #include <gsl/gsl_byte> // for byte #include <gsl/gsl_util> // for narrow_cast #include <gsl/multi_span> // for strided_span, index, multi_span, strided_... #include <iostream> // for size_t #include <iterator> // for begin, end #include <numeric> // for iota #include <type_traits> // for integral_constant<>::value, is_convertible #include <vector> // for vector namespace gsl { struct fail_fast ; } // namespace gsl using namespace std ; using namespace gsl ; namespace { struct BaseClass { }; struct DerivedClass : BaseClass { }; } TEST_CASE ( \"span_section_test\" ) { int a [ 30 ][ 4 ][ 5 ]; const auto av = as_multi_span ( a ); const auto sub = av . section ({ 15 , 0 , 0 }, gsl :: multi_span_index < 3 > { 2 , 2 , 2 }); const auto subsub = sub . section ({ 1 , 0 , 0 }, gsl :: multi_span_index < 3 > { 1 , 1 , 1 }); ( void ) subsub ; } TEST_CASE ( \"span_section\" ) { std :: vector < int > data ( 5 * 10 ); std :: iota ( begin ( data ), end ( data ), 0 ); const multi_span < int , 5 , 10 > av = as_multi_span ( multi_span < int > { data }, dim < 5 > (), dim < 10 > ()); const strided_span < int , 2 > av_section_1 = av . section ({ 1 , 2 }, { 3 , 4 }); CHECK ( ! av_section_1 . empty ()); CHECK (( av_section_1 [{ 0 , 0 }] == 12 )); CHECK (( av_section_1 [{ 0 , 1 }] == 13 )); CHECK (( av_section_1 [{ 1 , 0 }] == 22 )); CHECK (( av_section_1 [{ 2 , 3 }] == 35 )); const strided_span < int , 2 > av_section_2 = av_section_1 . section ({ 1 , 2 }, { 2 , 2 }); CHECK ( ! av_section_2 . empty ()); CHECK (( av_section_2 [{ 0 , 0 }] == 24 )); CHECK (( av_section_2 [{ 0 , 1 }] == 25 )); CHECK (( av_section_2 [{ 1 , 0 }] == 34 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_constructors\" ) { // Check stride constructor { int arr [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; const int carr [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; strided_span < int , 1 > sav1 { arr , {{ 9 }, { 1 }}}; // T -> T CHECK ( sav1 . bounds (). index_bounds () == multi_span_index < 1 > { 9 }); CHECK ( sav1 . bounds (). stride () == 1 ); CHECK (( sav1 [ 0 ] == 1 && sav1 [ 8 ] == 9 )); strided_span < const int , 1 > sav2 { carr , {{ 4 }, { 2 }}}; // const T -> const T CHECK ( sav2 . bounds (). index_bounds () == multi_span_index < 1 > { 4 }); CHECK ( sav2 . bounds (). strides () == multi_span_index < 1 > { 2 }); CHECK (( sav2 [ 0 ] == 1 && sav2 [ 3 ] == 7 )); strided_span < int , 2 > sav3 { arr , {{ 2 , 2 }, { 6 , 2 }}}; // T -> const T CHECK (( sav3 . bounds (). index_bounds () == multi_span_index < 2 > { 2 , 2 })); CHECK (( sav3 . bounds (). strides () == multi_span_index < 2 > { 6 , 2 })); CHECK (( sav3 [{ 0 , 0 }] == 1 && sav3 [{ 0 , 1 }] == 3 && sav3 [{ 1 , 0 }] == 7 )); } // Check multi_span constructor { int arr [] = { 1 , 2 }; // From non-cv-qualified source { const multi_span < int > src = arr ; strided_span < int , 1 > sav { src , { 2 , 1 }}; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 // strided_span<const int, 1> sav_c{ {src}, {2, 1} }; strided_span < const int , 1 > sav_c { multi_span < const int > { src }, strided_bounds < 1 > { 2 , 1 }}; #else strided_span < const int , 1 > sav_c { multi_span < const int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_c . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_c . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_c [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 strided_span < volatile int , 1 > sav_v { src , { 2 , 1 }}; #else strided_span < volatile int , 1 > sav_v { multi_span < volatile int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_v . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_v . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_v [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 strided_span < const volatile int , 1 > sav_cv { src , { 2 , 1 }}; #else strided_span < const volatile int , 1 > sav_cv { multi_span < const volatile int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_cv . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_cv . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_cv [ 1 ] == 2 ); } // From const-qualified source { const multi_span < const int > src { arr }; strided_span < const int , 1 > sav_c { src , { 2 , 1 }}; CHECK ( sav_c . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_c . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_c [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 strided_span < const volatile int , 1 > sav_cv { src , { 2 , 1 }}; #else strided_span < const volatile int , 1 > sav_cv { multi_span < const volatile int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_cv . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_cv . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_cv [ 1 ] == 2 ); } // From volatile-qualified source { const multi_span < volatile int > src { arr }; strided_span < volatile int , 1 > sav_v { src , { 2 , 1 }}; CHECK ( sav_v . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_v . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_v [ 1 ] == 2 ); #if defined(_MSC_VER) && _MSC_VER > 1800 strided_span < const volatile int , 1 > sav_cv { src , { 2 , 1 }}; #else strided_span < const volatile int , 1 > sav_cv { multi_span < const volatile int > { src }, strided_bounds < 1 > { 2 , 1 }}; #endif CHECK ( sav_cv . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_cv . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_cv [ 1 ] == 2 ); } // From cv-qualified source { const multi_span < const volatile int > src { arr }; strided_span < const volatile int , 1 > sav_cv { src , { 2 , 1 }}; CHECK ( sav_cv . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav_cv . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav_cv [ 1 ] == 2 ); } } // Check const-casting constructor { int arr [ 2 ] = { 4 , 5 }; const multi_span < int , 2 > av ( arr , 2 ); multi_span < const int , 2 > av2 { av }; CHECK ( av2 [ 1 ] == 5 ); static_assert ( std :: is_convertible < const multi_span < int , 2 > , multi_span < const int , 2 >>:: value , \"ctor is not implicit!\" ); const strided_span < int , 1 > src { arr , { 2 , 1 }}; strided_span < const int , 1 > sav { src }; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav . bounds (). stride () == 1 ); CHECK ( sav [ 1 ] == 5 ); static_assert ( std :: is_convertible < const strided_span < int , 1 > , strided_span < const int , 1 >>:: value , \"ctor is not implicit!\" ); } // Check copy constructor { int arr1 [ 2 ] = { 3 , 4 }; const strided_span < int , 1 > src1 { arr1 , { 2 , 1 }}; strided_span < int , 1 > sav1 { src1 }; CHECK ( sav1 . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav1 . bounds (). stride () == 1 ); CHECK ( sav1 [ 0 ] == 3 ); int arr2 [ 6 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; const strided_span < const int , 2 > src2 { arr2 , {{ 3 , 2 }, { 2 , 1 }}}; strided_span < const int , 2 > sav2 { src2 }; CHECK (( sav2 . bounds (). index_bounds () == multi_span_index < 2 > { 3 , 2 })); CHECK (( sav2 . bounds (). strides () == multi_span_index < 2 > { 2 , 1 })); CHECK (( sav2 [{ 0 , 0 }] == 1 && sav2 [{ 2 , 0 }] == 5 )); } // Check const-casting assignment operator { int arr1 [ 2 ] = { 1 , 2 }; int arr2 [ 6 ] = { 3 , 4 , 5 , 6 , 7 , 8 }; const strided_span < int , 1 > src { arr1 , {{ 2 }, { 1 }}}; strided_span < const int , 1 > sav { arr2 , {{ 3 }, { 2 }}}; strided_span < const int , 1 >& sav_ref = ( sav = src ); CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav [ 0 ] == 1 ); CHECK ( & sav_ref == & sav ); } // Check copy assignment operator { int arr1 [ 2 ] = { 3 , 4 }; int arr1b [ 1 ] = { 0 }; const strided_span < int , 1 > src1 { arr1 , { 2 , 1 }}; strided_span < int , 1 > sav1 { arr1b , { 1 , 1 }}; strided_span < int , 1 >& sav1_ref = ( sav1 = src1 ); CHECK ( sav1 . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav1 . bounds (). strides () == multi_span_index < 1 > { 1 }); CHECK ( sav1 [ 0 ] == 3 ); CHECK ( & sav1_ref == & sav1 ); const int arr2 [ 6 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; const int arr2b [ 1 ] = { 0 }; const strided_span < const int , 2 > src2 { arr2 , {{ 3 , 2 }, { 2 , 1 }}}; strided_span < const int , 2 > sav2 { arr2b , {{ 1 , 1 }, { 1 , 1 }}}; strided_span < const int , 2 >& sav2_ref = ( sav2 = src2 ); CHECK (( sav2 . bounds (). index_bounds () == multi_span_index < 2 > { 3 , 2 })); CHECK (( sav2 . bounds (). strides () == multi_span_index < 2 > { 2 , 1 })); CHECK (( sav2 [{ 0 , 0 }] == 1 && sav2 [{ 2 , 0 }] == 5 )); CHECK ( & sav2_ref == & sav2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_slice\" ) { std :: vector < int > data ( 5 * 10 ); std :: iota ( begin ( data ), end ( data ), 0 ); const multi_span < int , 5 , 10 > src = as_multi_span ( multi_span < int > { data }, dim < 5 > (), dim < 10 > ()); const strided_span < int , 2 > sav { src , {{ 5 , 10 }, { 10 , 1 }}}; #ifdef CONFIRM_COMPILATION_ERRORS const strided_span < const int , 2 > csav {{ src }, {{ 5 , 10 }, { 10 , 1 }}}; #endif const strided_span < const int , 2 > csav { multi_span < const int , 5 , 10 > { src }, {{ 5 , 10 }, { 10 , 1 }}}; strided_span < int , 1 > sav_sl = sav [ 2 ]; CHECK ( sav_sl [ 0 ] == 20 ); CHECK ( sav_sl [ 9 ] == 29 ); strided_span < const int , 1 > csav_sl = sav [ 3 ]; CHECK ( csav_sl [ 0 ] == 30 ); CHECK ( csav_sl [ 9 ] == 39 ); CHECK ( sav [ 4 ][ 0 ] == 40 ); CHECK ( sav [ 4 ][ 9 ] == 49 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_column_major\" ) { // strided_span may be used to accommodate more peculiar // use cases, such as column-major multidimensional array // (aka. \"FORTRAN\" layout). int cm_array [ 3 * 5 ] = { 1 , 4 , 7 , 10 , 13 , 2 , 5 , 8 , 11 , 14 , 3 , 6 , 9 , 12 , 15 }; strided_span < int , 2 > cm_sav { cm_array , {{ 5 , 3 }, { 1 , 5 }}}; // Accessing elements CHECK (( cm_sav [{ 0 , 0 }] == 1 )); CHECK (( cm_sav [{ 0 , 1 }] == 2 )); CHECK (( cm_sav [{ 1 , 0 }] == 4 )); CHECK (( cm_sav [{ 4 , 2 }] == 15 )); // Slice strided_span < int , 1 > cm_sl = cm_sav [ 3 ]; CHECK ( cm_sl [ 0 ] == 10 ); CHECK ( cm_sl [ 1 ] == 11 ); CHECK ( cm_sl [ 2 ] == 12 ); // Section strided_span < int , 2 > cm_sec = cm_sav . section ({ 2 , 1 }, { 3 , 2 }); CHECK (( cm_sec . bounds (). index_bounds () == multi_span_index < 2 > { 3 , 2 })); CHECK (( cm_sec [{ 0 , 0 }] == 8 )); CHECK (( cm_sec [{ 0 , 1 }] == 9 )); CHECK (( cm_sec [{ 1 , 0 }] == 11 )); CHECK (( cm_sec [{ 2 , 1 }] == 15 )); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_bounds\" ) { int arr [] = { 0 , 1 , 2 , 3 }; multi_span < int > av ( arr ); { // incorrect sections CHECK_THROWS_AS ( av . section ( 0 , 0 )[ 0 ], fail_fast ); CHECK_THROWS_AS ( av . section ( 1 , 0 )[ 0 ], fail_fast ); CHECK_THROWS_AS ( av . section ( 1 , 1 )[ 1 ], fail_fast ); CHECK_THROWS_AS ( av . section ( 2 , 5 ), fail_fast ); CHECK_THROWS_AS ( av . section ( 5 , 2 ), fail_fast ); CHECK_THROWS_AS ( av . section ( 5 , 0 ), fail_fast ); CHECK_THROWS_AS ( av . section ( 0 , 5 ), fail_fast ); CHECK_THROWS_AS ( av . section ( 5 , 5 ), fail_fast ); } { // zero stride strided_span < int , 1 > sav { av , {{ 4 }, {}}}; CHECK ( sav [ 0 ] == 0 ); CHECK ( sav [ 3 ] == 0 ); CHECK_THROWS_AS ( sav [ 4 ], fail_fast ); } { // zero extent strided_span < int , 1 > sav { av , {{}, { 1 }}}; CHECK_THROWS_AS ( sav [ 0 ], fail_fast ); } { // zero extent and stride strided_span < int , 1 > sav { av , {{}, {}}}; CHECK_THROWS_AS ( sav [ 0 ], fail_fast ); } { // strided array ctor with matching strided bounds strided_span < int , 1 > sav { arr , { 4 , 1 }}; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 4 }); CHECK ( sav [ 3 ] == 3 ); CHECK_THROWS_AS ( sav [ 4 ], fail_fast ); } { // strided array ctor with smaller strided bounds strided_span < int , 1 > sav { arr , { 2 , 1 }}; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav [ 1 ] == 1 ); CHECK_THROWS_AS ( sav [ 2 ], fail_fast ); } { // strided array ctor with fitting irregular bounds strided_span < int , 1 > sav { arr , { 2 , 3 }}; CHECK ( sav . bounds (). index_bounds () == multi_span_index < 1 > { 2 }); CHECK ( sav [ 0 ] == 0 ); CHECK ( sav [ 1 ] == 3 ); CHECK_THROWS_AS ( sav [ 2 ], fail_fast ); } { // bounds cross data boundaries - from static arrays CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 3 , 2 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 3 , 3 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 4 , 5 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 5 , 1 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { arr , { 5 , 5 }}), fail_fast ); } { // bounds cross data boundaries - from array view CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 3 , 2 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 3 , 3 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 4 , 5 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 5 , 1 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av , { 5 , 5 }}), fail_fast ); } { // bounds cross data boundaries - from dynamic arrays CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 3 , 2 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 3 , 3 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 4 , 5 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 5 , 1 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 4 , { 5 , 5 }}), fail_fast ); CHECK_THROWS_AS (( strided_span < int , 1 > { av . data (), 2 , { 2 , 2 }}), fail_fast ); } #ifdef CONFIRM_COMPILATION_ERRORS { strided_span < int , 1 > sav0 { av . data (), { 3 , 2 }}; strided_span < int , 1 > sav1 { arr , { 1 }}; strided_span < int , 1 > sav2 { arr , { 1 , 1 , 1 }}; strided_span < int , 1 > sav3 { av , { 1 }}; strided_span < int , 1 > sav4 { av , { 1 , 1 , 1 }}; strided_span < int , 2 > sav5 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), { 1 }}; strided_span < int , 2 > sav6 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), { 1 , 1 , 1 }}; strided_span < int , 2 > sav7 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), {{ 1 , 1 }, { 1 , 1 }, { 1 , 1 }}}; multi_span_index < 1 > index { 0 , 1 }; strided_span < int , 1 > sav8 { arr , { 1 , { 1 , 1 }}}; strided_span < int , 1 > sav9 { arr , {{ 1 , 1 }, { 1 , 1 }}}; strided_span < int , 1 > sav10 { av , { 1 , { 1 , 1 }}}; strided_span < int , 1 > sav11 { av , {{ 1 , 1 }, { 1 , 1 }}}; strided_span < int , 2 > sav12 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), {{ 1 }, { 1 }}}; strided_span < int , 2 > sav13 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), {{ 1 }, { 1 , 1 , 1 }}}; strided_span < int , 2 > sav14 { av . as_multi_span ( dim < 2 > (), dim < 2 > ()), {{ 1 , 1 , 1 }, { 1 }}}; } #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_type_conversion\" ) { int arr [] = { 0 , 1 , 2 , 3 }; multi_span < int > av ( arr ); { strided_span < int , 1 > sav { av . data (), av . size (), { av . size () / 2 , 2 }}; #ifdef CONFIRM_COMPILATION_ERRORS strided_span < long , 1 > lsav1 = sav . as_strided_span < long , 1 > (); #endif } { strided_span < int , 1 > sav { av , { av . size () / 2 , 2 }}; #ifdef CONFIRM_COMPILATION_ERRORS strided_span < long , 1 > lsav1 = sav . as_strided_span < long , 1 > (); #endif } multi_span < const byte , dynamic_range > bytes = as_bytes ( av ); // retype strided array with regular strides - from raw data { strided_bounds < 2 > bounds {{ 2 , bytes . size () / 4 }, { bytes . size () / 2 , 1 }}; strided_span < const byte , 2 > sav2 { bytes . data (), bytes . size (), bounds }; strided_span < const int , 2 > sav3 = sav2 . as_strided_span < const int > (); CHECK ( sav3 [ 0 ][ 0 ] == 0 ); CHECK ( sav3 [ 1 ][ 0 ] == 2 ); CHECK_THROWS_AS ( sav3 [ 1 ][ 1 ], fail_fast ); CHECK_THROWS_AS ( sav3 [ 0 ][ 1 ], fail_fast ); } // retype strided array with regular strides - from multi_span { strided_bounds < 2 > bounds {{ 2 , bytes . size () / 4 }, { bytes . size () / 2 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; strided_span < int , 2 > sav3 = sav2 . as_strided_span < int > (); CHECK ( sav3 [ 0 ][ 0 ] == 0 ); CHECK ( sav3 [ 1 ][ 0 ] == 2 ); CHECK_THROWS_AS ( sav3 [ 1 ][ 1 ], fail_fast ); CHECK_THROWS_AS ( sav3 [ 0 ][ 1 ], fail_fast ); } // retype strided array with not enough elements - last dimension of the array is too small { strided_bounds < 2 > bounds {{ 4 , 2 }, { 4 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with not enough elements - strides are too small { strided_bounds < 2 > bounds {{ 4 , 2 }, { 2 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with not enough elements - last dimension does not divide by the new // typesize { strided_bounds < 2 > bounds {{ 2 , 6 }, { 4 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with not enough elements - strides does not divide by the new // typesize { strided_bounds < 2 > bounds {{ 2 , 1 }, { 6 , 1 }}; multi_span < const byte , 2 , dynamic_range > bytes2 = as_multi_span ( bytes , dim < 2 > (), dim ( bytes . size () / 2 )); strided_span < const byte , 2 > sav2 { bytes2 , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with irregular strides - from raw data { strided_bounds < 1 > bounds { bytes . size () / 2 , 2 }; strided_span < const byte , 1 > sav2 { bytes . data (), bytes . size (), bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } // retype strided array with irregular strides - from multi_span { strided_bounds < 1 > bounds { bytes . size () / 2 , 2 }; strided_span < const byte , 1 > sav2 { bytes , bounds }; CHECK_THROWS_AS ( sav2 . as_strided_span < int > (), fail_fast ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute TEST_CASE ( \"empty_strided_spans\" ) { { multi_span < int , 0 > empty_av ( nullptr ); strided_span < int , 1 > empty_sav { empty_av , { 0 , 1 }}; CHECK ( empty_sav . bounds (). index_bounds () == multi_span_index < 1 > { 0 }); CHECK ( empty_sav . empty ()); CHECK_THROWS_AS ( empty_sav [ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_sav . begin ()[ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_sav . cbegin ()[ 0 ], fail_fast ); for ( const auto & v : empty_sav ) { ( void ) v ; CHECK ( false ); } } { strided_span < int , 1 > empty_sav { nullptr , 0 , { 0 , 1 }}; CHECK ( empty_sav . bounds (). index_bounds () == multi_span_index < 1 > { 0 }); CHECK_THROWS_AS ( empty_sav [ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_sav . begin ()[ 0 ], fail_fast ); CHECK_THROWS_AS ( empty_sav . cbegin ()[ 0 ], fail_fast ); for ( const auto & v : empty_sav ) { ( void ) v ; CHECK ( false ); } } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute void iterate_every_other_element ( multi_span < int , dynamic_range > av ) { // pick every other element auto length = av . size () / 2 ; #if defined(_MSC_VER) && _MSC_VER > 1800 auto bounds = strided_bounds < 1 > ({ length }, { 2 }); #else auto bounds = strided_bounds < 1 > ( multi_span_index < 1 > { length }, multi_span_index < 1 > { 2 }); #endif strided_span < int , 1 > strided ( & av . data ()[ 1 ], av . size () - 1 , bounds ); CHECK ( strided . size () == length ); CHECK ( strided . bounds (). index_bounds ()[ 0 ] == length ); for ( auto i = 0 ; i < strided . size (); ++ i ) { CHECK ( strided [ i ] == av [ 2 * i + 1 ]); } int idx = 0 ; for ( auto num : strided ) { CHECK ( num == av [ 2 * idx + 1 ]); idx ++ ; } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_section_iteration\" ) { int arr [ 8 ] = { 4 , 0 , 5 , 1 , 6 , 2 , 7 , 3 }; // static bounds { multi_span < int , 8 > av ( arr , 8 ); iterate_every_other_element ( av ); } // dynamic bounds { multi_span < int , dynamic_range > av ( arr , 8 ); iterate_every_other_element ( av ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"dynamic_strided_span_section_iteration\" ) { auto arr = new int [ 8 ]; for ( int i = 0 ; i < 4 ; ++ i ) { arr [ 2 * i ] = 4 + i ; arr [ 2 * i + 1 ] = i ; } auto av = as_multi_span ( arr , 8 ); iterate_every_other_element ( av ); delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute // TODO: does not work void iterate_second_slice ( multi_span < int , dynamic_range , dynamic_range , dynamic_range > av ) { const int expected [ 6 ] = { 2 , 3 , 10 , 11 , 18 , 19 }; auto section = av . section ({ 0 , 1 , 0 }, { 3 , 1 , 2 }); for ( auto i = 0 ; i < section . extent < 0 > (); ++ i ) { for ( auto j = 0 ; j < section . extent < 1 > (); ++ j ) for ( auto k = 0 ; k < section . extent < 2 > (); ++ k ) { auto idx = multi_span_index < 3 > { i , j , k }; // avoid braces in the CHECK macro CHECK ( section [ idx ] == expected [ 2 * i + 2 * j + k ]); } } for ( auto i = 0 ; i < section . extent < 0 > (); ++ i ) { for ( auto j = 0 ; j < section . extent < 1 > (); ++ j ) for ( auto k = 0 ; k < section . extent < 2 > (); ++ k ) CHECK ( section [ i ][ j ][ k ] == expected [ 2 * i + 2 * j + k ]); } int i = 0 ; for ( const auto num : section ) { CHECK ( num == expected [ i ]); i ++ ; } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_section_iteration_3d\" ) { int arr [ 3 ][ 4 ][ 2 ]{}; for ( auto i = 0 ; i < 3 ; ++ i ) { for ( auto j = 0 ; j < 4 ; ++ j ) for ( auto k = 0 ; k < 2 ; ++ k ) arr [ i ][ j ][ k ] = 8 * i + 2 * j + k ; } { multi_span < int , 3 , 4 , 2 > av = arr ; iterate_second_slice ( av ); } } GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute TEST_CASE ( \"dynamic_strided_span_section_iteration_3d\" ) { const auto height = 12 , width = 2 ; const auto size = height * width ; auto arr = new int [ static_cast < std :: size_t > ( size )]; for ( auto i = 0 ; i < size ; ++ i ) { arr [ i ] = i ; } { auto av = as_multi_span ( as_multi_span ( arr , 24 ), dim < 3 > (), dim < 4 > (), dim < 2 > ()); iterate_second_slice ( av ); } { auto av = as_multi_span ( as_multi_span ( arr , 24 ), dim ( 3 ), dim < 4 > (), dim < 2 > ()); iterate_second_slice ( av ); } { auto av = as_multi_span ( as_multi_span ( arr , 24 ), dim < 3 > (), dim ( 4 ), dim < 2 > ()); iterate_second_slice ( av ); } { auto av = as_multi_span ( as_multi_span ( arr , 24 ), dim < 3 > (), dim < 4 > (), dim ( 2 )); iterate_second_slice ( av ); } delete [] arr ; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .2 ) // NO-FORMAT: attribute TEST_CASE ( \"strided_span_conversion\" ) { // get an multi_span of 'c' values from the list of X's struct X { int a ; int b ; int c ; }; X arr [ 4 ] = {{ 0 , 1 , 2 }, { 3 , 4 , 5 }, { 6 , 7 , 8 }, { 9 , 10 , 11 }}; int s = sizeof ( int ) / sizeof ( byte ); auto d2 = 3 * s ; auto d1 = narrow_cast < int > ( sizeof ( int )) * 12 / d2 ; // convert to 4x12 array of bytes auto av = as_multi_span ( as_bytes ( as_multi_span ( & arr [ 0 ], 4 )), dim ( d1 ), dim ( d2 )); CHECK ( av . bounds (). index_bounds ()[ 0 ] == 4 ); CHECK ( av . bounds (). index_bounds ()[ 1 ] == 12 ); // get the last 4 columns auto section = av . section ({ 0 , 2 * s }, { 4 , s }); // { { arr[0].c[0], arr[0].c[1], arr[0].c[2], // arr[0].c[3] } , { arr[1].c[0], ... } , ... // } // convert to array 4x1 array of integers auto cs = section . as_strided_span < int > (); // { { arr[0].c }, {arr[1].c } , ... } CHECK ( cs . bounds (). index_bounds ()[ 0 ] == 4 ); CHECK ( cs . bounds (). index_bounds ()[ 1 ] == 1 ); // transpose to 1x4 array strided_bounds < 2 > reverse_bounds { { cs . bounds (). index_bounds ()[ 1 ], cs . bounds (). index_bounds ()[ 0 ]}, { cs . bounds (). strides ()[ 1 ], cs . bounds (). strides ()[ 0 ]}}; strided_span < int , 2 > transposed { cs . data (), cs . bounds (). total_size (), reverse_bounds }; // slice to get a one-dimensional array of c's strided_span < int , 1 > result = transposed [ 0 ]; CHECK ( result . bounds (). index_bounds ()[ 0 ] == 4 ); CHECK_THROWS_AS ( result . bounds (). index_bounds ()[ 1 ], fail_fast ); int i = 0 ; for ( auto & num : result ) { CHECK ( num == arr [ i ]. c ); i ++ ; } } #if __clang__ || __GNUC__ #pragma GCC diagnostic pop #endif","title":"File strided_span_tests.cpp"},{"location":"string__span__tests_8cpp/","text":"File string_span_tests.cpp \u00b6 File List > external > guideline > tests > string_span_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_assert> #include <gsl/pointers> #include <gsl/span> #include <gsl/string_span> #include <algorithm> #include <cstddef> #include <map> #include <string> #include <type_traits> #include <vector> Namespaces \u00b6 Type Name namespace generic Public Functions \u00b6 Type Name czstring_span CreateTempName (string_span<> span) cu16zstring_span CreateTempNameU16 (u16string_span<> span) cu32zstring_span CreateTempNameU32 (u32string_span<> span) cwzstring_span CreateTempNameW (wstring_span<> span) GSL_SUPPRESS (con. 4) TEST_CASE (\"MoveConstructors\") TEST_CASE (\"Conversion\") TEST_CASE (\"Issue305\") T create () T move_wrapper (T && t) void use (basic_string_span< T, gsl::dynamic_extent >) Public Functions Documentation \u00b6 function CreateTempName \u00b6 czstring_span CreateTempName ( string_span <> span ) function CreateTempNameU16 \u00b6 cu16zstring_span CreateTempNameU16 ( u16string_span <> span ) function CreateTempNameU32 \u00b6 cu32zstring_span CreateTempNameU32 ( u32string_span <> span ) function CreateTempNameW \u00b6 cwzstring_span CreateTempNameW ( wstring_span <> span ) function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( con . 4 ) function TEST_CASE \u00b6 TEST_CASE ( \"MoveConstructors\" ) function TEST_CASE \u00b6 TEST_CASE ( \"Conversion\" ) function TEST_CASE \u00b6 TEST_CASE ( \"Issue305\" ) function create \u00b6 template < class T class T > T create () function move_wrapper \u00b6 template < typename T typename T > T move_wrapper ( T && t ) function use \u00b6 template < class T class T > void use ( basic_string_span < T , gsl :: dynamic_extent > ) The documentation for this class was generated from the following file external/guideline/tests/string_span_tests.cpp","title":"File string\\_span\\_tests.cpp"},{"location":"string__span__tests_8cpp/#file-string95span95testscpp","text":"File List > external > guideline > tests > string_span_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_assert> #include <gsl/pointers> #include <gsl/span> #include <gsl/string_span> #include <algorithm> #include <cstddef> #include <map> #include <string> #include <type_traits> #include <vector>","title":"File string_span_tests.cpp"},{"location":"string__span__tests_8cpp/#namespaces","text":"Type Name namespace generic","title":"Namespaces"},{"location":"string__span__tests_8cpp/#public-functions","text":"Type Name czstring_span CreateTempName (string_span<> span) cu16zstring_span CreateTempNameU16 (u16string_span<> span) cu32zstring_span CreateTempNameU32 (u32string_span<> span) cwzstring_span CreateTempNameW (wstring_span<> span) GSL_SUPPRESS (con. 4) TEST_CASE (\"MoveConstructors\") TEST_CASE (\"Conversion\") TEST_CASE (\"Issue305\") T create () T move_wrapper (T && t) void use (basic_string_span< T, gsl::dynamic_extent >)","title":"Public Functions"},{"location":"string__span__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"string__span__tests_8cpp/#function-createtempname","text":"czstring_span CreateTempName ( string_span <> span )","title":"function CreateTempName"},{"location":"string__span__tests_8cpp/#function-createtempnameu16","text":"cu16zstring_span CreateTempNameU16 ( u16string_span <> span )","title":"function CreateTempNameU16"},{"location":"string__span__tests_8cpp/#function-createtempnameu32","text":"cu32zstring_span CreateTempNameU32 ( u32string_span <> span )","title":"function CreateTempNameU32"},{"location":"string__span__tests_8cpp/#function-createtempnamew","text":"cwzstring_span CreateTempNameW ( wstring_span <> span )","title":"function CreateTempNameW"},{"location":"string__span__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( con . 4 )","title":"function GSL_SUPPRESS"},{"location":"string__span__tests_8cpp/#function-test95case","text":"TEST_CASE ( \"MoveConstructors\" )","title":"function TEST_CASE"},{"location":"string__span__tests_8cpp/#function-test95case_1","text":"TEST_CASE ( \"Conversion\" )","title":"function TEST_CASE"},{"location":"string__span__tests_8cpp/#function-test95case_2","text":"TEST_CASE ( \"Issue305\" )","title":"function TEST_CASE"},{"location":"string__span__tests_8cpp/#function-create","text":"template < class T class T > T create ()","title":"function create"},{"location":"string__span__tests_8cpp/#function-move95wrapper","text":"template < typename T typename T > T move_wrapper ( T && t )","title":"function move_wrapper"},{"location":"string__span__tests_8cpp/#function-use","text":"template < class T class T > void use ( basic_string_span < T , gsl :: dynamic_extent > ) The documentation for this class was generated from the following file external/guideline/tests/string_span_tests.cpp","title":"function use"},{"location":"string__span__tests_8cpp_source/","text":"File string_span_tests.cpp \u00b6 File List > external > guideline > tests > string_span_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/gsl_assert> // for Expects, fail_fast (ptr only) #include <gsl/pointers> // for owner #include <gsl/span> // for span, dynamic_extent #include <gsl/string_span> // for basic_string_span, operator==, ensure_z #include <algorithm> // for move, find #include <cstddef> // for size_t #include <map> // for map #include <string> // for basic_string, string, char_traits, operat... #include <type_traits> // for remove_reference<>::type #include <vector> // for vector, allocator using namespace std ; using namespace gsl ; // Generic string functions namespace generic { template < typename CharT > GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( f .23 ) // NO-FORMAT: attribute auto strlen ( const CharT * s ) { auto p = s ; while ( * p ) ++ p ; return p - s ; } template < typename CharT > GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute auto strnlen ( const CharT * s , std :: size_t n ) { return std :: find ( s , s + n , CharT { 0 }) - s ; } } // namespace generic GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestLiteralConstruction\" ) { cwstring_span <> v = ensure_z ( L \"Hello\" ); CHECK ( 5 == v . length ()); #ifdef CONFIRM_COMPILATION_ERRORS wstring_span <> v2 = ensure0 ( L \"Hello\" ); #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConstructFromStdString\" ) { std :: string s = \"Hello there world\" ; cstring_span <> v = s ; CHECK ( v . length () == static_cast < cstring_span <>:: index_type > ( s . length ())); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConstructFromStdVector\" ) { std :: vector < char > vec ( 5 , 'h' ); string_span <> v { vec }; CHECK ( v . length () == static_cast < string_span <>:: index_type > ( vec . size ())); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestStackArrayConstruction\" ) { wchar_t stack_string [] = L \"Hello\" ; { cwstring_span <> v = ensure_z ( stack_string ); CHECK ( v . length () == 5 ); } { cwstring_span <> v = stack_string ; CHECK ( v . length () == 5 ); } { wstring_span <> v = ensure_z ( stack_string ); CHECK ( v . length () == 5 ); } { wstring_span <> v = stack_string ; CHECK ( v . length () == 5 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConstructFromConstCharPointer\" ) { const char * s = \"Hello\" ; cstring_span <> v = ensure_z ( s ); CHECK ( v . length () == 5 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConversionToConst\" ) { char stack_string [] = \"Hello\" ; string_span <> v = ensure_z ( stack_string ); cstring_span <> v2 = v ; CHECK ( v . length () == v2 . length ()); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConversionFromConst\" ) { char stack_string [] = \"Hello\" ; cstring_span <> v = ensure_z ( stack_string ); ( void ) v ; #ifdef CONFIRM_COMPILATION_ERRORS string_span <> v2 = v ; string_span <> v3 = \"Hello\" ; #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestToString\" ) { auto s = gsl :: to_string ( cstring_span <> {}); CHECK ( s . length () == 0 ); char stack_string [] = \"Hello\" ; cstring_span <> v = ensure_z ( stack_string ); auto s2 = gsl :: to_string ( v ); CHECK ( static_cast < cstring_span <>:: index_type > ( s2 . length ()) == v . length ()); CHECK ( s2 . length () == 5 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestToBasicString\" ) { auto s = gsl :: to_basic_string < char , std :: char_traits < char > , :: std :: allocator < char >> ( cstring_span <> {}); CHECK ( s . length () == 0 ); char stack_string [] = \"Hello\" ; cstring_span <> v = ensure_z ( stack_string ); auto s2 = gsl :: to_basic_string < char , std :: char_traits < char > , :: std :: allocator < char >> ( v ); CHECK ( static_cast < cstring_span <>:: index_type > ( s2 . length ()) == v . length ()); CHECK ( s2 . length () == 5 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"EqualityAndImplicitConstructors\" ) { { cstring_span <> span = \"Hello\" ; cstring_span <> span1 ; // comparison to empty span CHECK ( span1 != span ); CHECK ( span != span1 ); } { cstring_span <> span = \"Hello\" ; cstring_span <> span1 = \"Hello1\" ; // comparison to different span CHECK ( span1 != span ); CHECK ( span != span1 ); } { cstring_span <> span = \"Hello\" ; const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; const char ar1 [] = \"Hello\" ; const char ar2 [ 10 ] = \"Hello\" ; const char * ptr = \"Hello\" ; const std :: string str = \"Hello\" ; const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; gsl :: span < const char > sp = ensure_z ( \"Hello\" ); // comparison to literal CHECK ( span == cstring_span <> ( \"Hello\" )); // comparison to static array with no null termination CHECK ( span == cstring_span <> ( ar )); // comparison to static array with null at the end CHECK ( span == cstring_span <> ( ar1 )); // comparison to static array with null in the middle CHECK ( span == cstring_span <> ( ar2 )); // comparison to null-terminated c string CHECK ( span == cstring_span <> ( ptr , 5 )); // comparison to string CHECK ( span == cstring_span <> ( str )); // comparison to vector of charaters with no null termination CHECK ( span == cstring_span <> ( vec )); // comparison to span CHECK ( span == cstring_span <> ( sp )); // comparison to string_span CHECK ( span == span ); } { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = ar ; char ar1 [] = \"Hello\" ; char ar2 [ 10 ] = \"Hello\" ; char * ptr = ar ; std :: string str = \"Hello\" ; std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; gsl :: span < char > sp = ensure_z ( ar1 ); // comparison to static array with no null termination CHECK ( span == string_span <> ( ar )); // comparison to static array with null at the end CHECK ( span == string_span <> ( ar1 )); // comparison to static array with null in the middle CHECK ( span == string_span <> ( ar2 )); // comparison to null-terminated c string CHECK ( span == string_span <> ( ptr , 5 )); // comparison to string CHECK ( span == string_span <> ( str )); // comparison to vector of charaters with no null termination CHECK ( span == string_span <> ( vec )); // comparison to span CHECK ( span == string_span <> ( sp )); // comparison to string_span CHECK ( span == span ); } { const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; const char ar1 [] = \"Hello\" ; const char ar2 [ 10 ] = \"Hello\" ; const std :: string str = \"Hello\" ; const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const gsl :: span < const char > sp = ensure_z ( \"Hello\" ); cstring_span <> span = \"Hello\" ; // const span, const other type CHECK ( span == \"Hello\" ); CHECK ( span == ar ); CHECK ( span == ar1 ); CHECK ( span == ar2 ); #ifdef CONFIRM_COMPILATION_ERRORS const char * ptr = \"Hello\" ; CHECK ( span == ptr ); #endif CHECK ( span == str ); CHECK ( span == vec ); CHECK ( span == sp ); CHECK ( \"Hello\" == span ); CHECK ( ar == span ); CHECK ( ar1 == span ); CHECK ( ar2 == span ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( ptr == span ); #endif CHECK ( str == span ); CHECK ( vec == span ); CHECK ( sp == span ); // const span, non-const other type char _ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; char _ar1 [] = \"Hello\" ; char _ar2 [ 10 ] = \"Hello\" ; char * _ptr = _ar ; std :: string _str = \"Hello\" ; std :: vector < char > _vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; gsl :: span < char > _sp { _ar , 5 }; CHECK ( span == _ar ); CHECK ( span == _ar1 ); CHECK ( span == _ar2 ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( span == _ptr ); #endif CHECK ( span == _str ); CHECK ( span == _vec ); CHECK ( span == _sp ); CHECK ( _ar == span ); CHECK ( _ar1 == span ); CHECK ( _ar2 == span ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( _ptr == span ); #endif CHECK ( _str == span ); CHECK ( _vec == span ); CHECK ( _sp == span ); string_span <> _span { _ptr , 5 }; // non-const span, non-const other type CHECK ( _span == _ar ); CHECK ( _span == _ar1 ); CHECK ( _span == _ar2 ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( _span == _ptr ); #endif CHECK ( _span == _str ); CHECK ( _span == _vec ); CHECK ( _span == _sp ); CHECK ( _ar == _span ); CHECK ( _ar1 == _span ); CHECK ( _ar2 == _span ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( _ptr == _span ); #endif CHECK ( _str == _span ); CHECK ( _vec == _span ); CHECK ( _sp == _span ); // non-const span, const other type CHECK ( _span == \"Hello\" ); CHECK ( _span == ar ); CHECK ( _span == ar1 ); CHECK ( _span == ar2 ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( _span == ptr ); #endif CHECK ( _span == str ); CHECK ( _span == vec ); CHECK ( _span == sp ); CHECK ( \"Hello\" == _span ); CHECK ( ar == _span ); CHECK ( ar1 == _span ); CHECK ( ar2 == _span ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( ptr == _span ); #endif CHECK ( str == _span ); CHECK ( vec == _span ); CHECK ( sp == _span ); // two spans CHECK ( _span == span ); CHECK ( span == _span ); } { std :: vector < char > str1 = { 'H' , 'e' , 'l' , 'l' , 'o' }; cstring_span <> span1 = str1 ; std :: vector < char > str2 = std :: move ( str1 ); cstring_span <> span2 = str2 ; // comparison of spans from the same vector before and after move (ok) CHECK ( span1 == span2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"ComparisonAndImplicitConstructors\" ) { { cstring_span <> span = \"Hello\" ; const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; const char ar1 [] = \"Hello\" ; const char ar2 [ 10 ] = \"Hello\" ; const char * ptr = \"Hello\" ; const std :: string str = \"Hello\" ; const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; // comparison to literal CHECK ( span < cstring_span <> ( \"Helloo\" )); CHECK ( span > cstring_span <> ( \"Hell\" )); // comparison to static array with no null termination CHECK ( span >= cstring_span <> ( ar )); // comparison to static array with null at the end CHECK ( span <= cstring_span <> ( ar1 )); // comparison to static array with null in the middle CHECK ( span >= cstring_span <> ( ar2 )); // comparison to null-terminated c string CHECK ( span <= cstring_span <> ( ptr , 5 )); // comparison to string CHECK ( span >= cstring_span <> ( str )); // comparison to vector of charaters with no null termination CHECK ( span <= cstring_span <> ( vec )); } { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = ar ; char larr [] = \"Hell\" ; char rarr [] = \"Helloo\" ; char ar1 [] = \"Hello\" ; char ar2 [ 10 ] = \"Hello\" ; char * ptr = ar ; std :: string str = \"Hello\" ; std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; // comparison to static array with no null termination CHECK ( span <= string_span <> ( ar )); CHECK ( span < string_span <> ( rarr )); CHECK ( span > string_span <> ( larr )); // comparison to static array with null at the end CHECK ( span >= string_span <> ( ar1 )); // comparison to static array with null in the middle CHECK ( span <= string_span <> ( ar2 )); // comparison to null-terminated c string CHECK ( span >= string_span <> ( ptr , 5 )); // comparison to string CHECK ( span <= string_span <> ( str )); // comparison to vector of charaters with no null termination CHECK ( span >= string_span <> ( vec )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"ConstrutorsEnsureZ\" ) { // remove z from literals { cstring_span <> sp = \"hello\" ; CHECK (( sp . length () == 5 )); } // take the string as is { auto str = std :: string ( \"hello\" ); cstring_span <> sp = str ; CHECK (( sp . length () == 5 )); } // ensure z on c strings { gsl :: owner < char *> ptr = new char [ 3 ]; ptr [ 0 ] = 'a' ; ptr [ 1 ] = 'b' ; ptr [ 2 ] = '\\0' ; string_span <> span = ensure_z ( ptr ); CHECK ( span . length () == 2 ); delete [] ptr ; } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"Constructors\" ) { // creating cstring_span // from span of a final extent { span < const char , 6 > sp = \"Hello\" ; cstring_span <> span = sp ; CHECK ( span . length () == 6 ); } // from const span of a final extent to non-const string_span #ifdef CONFIRM_COMPILATION_ERRORS { span < const char , 6 > sp = \"Hello\" ; string_span <> span = sp ; CHECK ( span . length () == 6 ); } #endif // from string temporary #ifdef CONFIRM_COMPILATION_ERRORS { cstring_span <> span = std :: string ( \"Hello\" ); } #endif // default { cstring_span <> span ; CHECK ( span . length () == 0 ); } // from string literal { cstring_span <> span = \"Hello\" ; CHECK ( span . length () == 5 ); } // from const static array { const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; cstring_span <> span = ar ; CHECK ( span . length () == 5 ); } // from non-const static array { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; cstring_span <> span = ar ; CHECK ( span . length () == 5 ); } // from const ptr and length { const char * ptr = \"Hello\" ; cstring_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from const ptr and length, include 0 { const char * ptr = \"Hello\" ; cstring_span <> span { ptr , 6 }; CHECK ( span . length () == 6 ); } // from const ptr and length, 0 inside { const char * ptr = \"He \\0 lo\" ; cstring_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from non-const ptr and length { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; char * ptr = ar ; cstring_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from non-const ptr and length, 0 inside { char ar [] = { 'H' , 'e' , '\\0' , 'l' , 'o' }; char * ptr = ar ; cstring_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from const string { const std :: string str = \"Hello\" ; const cstring_span <> span = str ; CHECK ( span . length () == 5 ); } // from non-const string { std :: string str = \"Hello\" ; const cstring_span <> span = str ; CHECK ( span . length () == 5 ); } // from const vector { const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const cstring_span <> span = vec ; CHECK ( span . length () == 5 ); } // from non-const vector { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const cstring_span <> span = vec ; CHECK ( span . length () == 5 ); } // from const span { const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const span < const char > inner = vec ; const cstring_span <> span = inner ; CHECK ( span . length () == 5 ); } // from non-const span { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const span < char > inner = vec ; const cstring_span <> span = inner ; CHECK ( span . length () == 5 ); } // from const string_span { const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const cstring_span <> tmp = vec ; const cstring_span <> span = tmp ; CHECK ( span . length () == 5 ); } // from non-const string_span { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> tmp = vec ; cstring_span <> span = tmp ; CHECK ( span . length () == 5 ); } // creating string_span // from string literal { #ifdef CONFIRM_COMPILATION_ERRORS string_span <> span = \"Hello\" ; #endif } // from const static array { #ifdef CONFIRM_COMPILATION_ERRORS const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = ar ; CHECK ( span . length () == 5 ); #endif } // from non-const static array { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = ar ; CHECK ( span . length () == 5 ); } // from const ptr and length { #ifdef CONFIRM_COMPILATION_ERRORS const char * ptr = \"Hello\" ; string_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); #endif } // from non-const ptr and length { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; char * ptr = ar ; string_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from const string { #ifdef CONFIRM_COMPILATION_ERRORS const std :: string str = \"Hello\" ; string_span <> span = str ; CHECK ( span . length () == 5 ); #endif } // from non-const string { std :: string str = \"Hello\" ; string_span <> span = str ; CHECK ( span . length () == 5 ); } // from const vector { #ifdef CONFIRM_COMPILATION_ERRORS const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = vec ; CHECK ( span . length () == 5 ); #endif } // from non-const vector { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = vec ; CHECK ( span . length () == 5 ); } // from const span { #ifdef CONFIRM_COMPILATION_ERRORS std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const span < const char > inner = vec ; string_span <> span = inner ; CHECK ( span . length () == 5 ); #endif } // from non-const span { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; span < char > inner = vec ; string_span <> span = inner ; CHECK ( span . length () == 5 ); } // from non-const span of non-const data from const vector { #ifdef CONFIRM_COMPILATION_ERRORS const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const span < char > inner = vec ; string_span <> span = inner ; CHECK ( span . length () == 5 ); #endif } // from const string_span { #ifdef CONFIRM_COMPILATION_ERRORS std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; cstring_span <> tmp = vec ; string_span <> span = tmp ; CHECK ( span . length () == 5 ); #endif } // from non-const string_span { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const string_span <> tmp = vec ; const string_span <> span = tmp ; CHECK ( span . length () == 5 ); } // from non-const string_span from const vector { #ifdef CONFIRM_COMPILATION_ERRORS const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> tmp = vec ; string_span <> span = tmp ; CHECK ( span . length () == 5 ); #endif } // from const string_span of non-const data { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const string_span <> tmp = vec ; const string_span <> span = tmp ; CHECK ( span . length () == 5 ); } } template < typename T > T move_wrapper ( T && t ) { return std :: move ( t ); } template < class T > T create () { return T {}; } template < class T > void use ( basic_string_span < T , gsl :: dynamic_extent > ) { } TEST_CASE ( \"MoveConstructors\" ) { // move string_span { cstring_span <> span = \"Hello\" ; const auto span1 = std :: move ( span ); CHECK ( span1 . length () == 5 ); } { cstring_span <> span = \"Hello\" ; const auto span1 = move_wrapper ( std :: move ( span )); CHECK ( span1 . length () == 5 ); } { cstring_span <> span = \"Hello\" ; const auto span1 = move_wrapper ( std :: move ( span )); CHECK ( span1 . length () == 5 ); } // move span { span < const char > span = ensure_z ( \"Hello\" ); const cstring_span <> span1 = std :: move ( span ); CHECK ( span1 . length () == 5 ); } { span < const char > span = ensure_z ( \"Hello\" ); const cstring_span <> span2 = move_wrapper ( std :: move ( span )); CHECK ( span2 . length () == 5 ); } // move string { #ifdef CONFIRM_COMPILATION_ERRORS std :: string str = \"Hello\" ; string_span <> span = std :: move ( str ); CHECK ( span . length () == 5 ); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS std :: string str = \"Hello\" ; string_span <> span = move_wrapper < std :: string > ( std :: move ( str )); CHECK ( span . length () == 5 ); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS use < char > ( create < string > ()); #endif } // move container { #ifdef CONFIRM_COMPILATION_ERRORS std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = std :: move ( vec ); CHECK ( span . length () == 5 ); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = move_wrapper < std :: vector < char >> ( std :: move ( vec )); CHECK ( span . length () == 5 ); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS use < char > ( create < std :: vector < char >> ()); #endif } } TEST_CASE ( \"Conversion\" ) { #ifdef CONFIRM_COMPILATION_ERRORS cstring_span <> span = \"Hello\" ; cwstring_span <> wspan { span }; CHECK ( wspan . length () == 5 ); #endif } czstring_span <> CreateTempName ( string_span <> span ) { Expects ( span . size () > 1 ); int last = 0 ; if ( span . size () > 4 ) { span [ 0 ] = 't' ; span [ 1 ] = 'm' ; span [ 2 ] = 'p' ; last = 3 ; } span [ last ] = '\\0' ; auto ret = span . subspan ( 0 , 4 ); return { ret }; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"zstring\" ) { // create zspan from zero terminated string { char buf [ 1 ]; buf [ 0 ] = '\\0' ; zstring_span <> zspan ({ buf , 1 }); CHECK ( generic :: strlen ( zspan . assume_z ()) == 0 ); CHECK ( zspan . as_string_span (). size () == 0 ); CHECK ( zspan . ensure_z (). size () == 0 ); } // create zspan from non-zero terminated string { char buf [ 1 ]; buf [ 0 ] = 'a' ; auto workaround_macro = [ & ]() { const zstring_span <> zspan ({ buf , 1 }); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } // usage scenario: create zero-terminated temp file name and pass to a legacy API { char buf [ 10 ]; auto name = CreateTempName ({ buf , 10 }); if ( ! name . empty ()) { czstring <> str = name . assume_z (); CHECK ( generic :: strlen ( str ) == 3 ); CHECK ( * ( str + 3 ) == '\\0' ); } } } cwzstring_span <> CreateTempNameW ( wstring_span <> span ) { Expects ( span . size () > 1 ); int last = 0 ; if ( span . size () > 4 ) { span [ 0 ] = L 't' ; span [ 1 ] = L 'm' ; span [ 2 ] = L 'p' ; last = 3 ; } span [ last ] = L '\\0' ; auto ret = span . subspan ( 0 , 4 ); return { ret }; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"wzstring\" ) { // create zspan from zero terminated string { wchar_t buf [ 1 ]; buf [ 0 ] = L '\\0' ; wzstring_span <> zspan ({ buf , 1 }); CHECK ( generic :: strnlen ( zspan . assume_z (), 1 ) == 0 ); CHECK ( zspan . as_string_span (). size () == 0 ); CHECK ( zspan . ensure_z (). size () == 0 ); } // create zspan from non-zero terminated string { wchar_t buf [ 1 ]; buf [ 0 ] = L 'a' ; const auto workaround_macro = [ & ]() { const wzstring_span <> zspan ({ buf , 1 }); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } // usage scenario: create zero-terminated temp file name and pass to a legacy API { wchar_t buf [ 10 ]; const auto name = CreateTempNameW ({ buf , 10 }); if ( ! name . empty ()) { cwzstring <> str = name . assume_z (); CHECK ( generic :: strnlen ( str , 10 ) == 3 ); CHECK ( * ( str + 3 ) == L '\\0' ); } } } cu16zstring_span <> CreateTempNameU16 ( u16string_span <> span ) { Expects ( span . size () > 1 ); int last = 0 ; if ( span . size () > 4 ) { span [ 0 ] = u 't' ; span [ 1 ] = u 'm' ; span [ 2 ] = u 'p' ; last = 3 ; } span [ last ] = u '\\0' ; auto ret = span . subspan ( 0 , 4 ); return { ret }; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"u16zstring\" ) { // create zspan from zero terminated string { char16_t buf [ 1 ]; buf [ 0 ] = L '\\0' ; u16zstring_span <> zspan ({ buf , 1 }); CHECK ( generic :: strnlen ( zspan . assume_z (), 1 ) == 0 ); CHECK ( zspan . as_string_span (). size () == 0 ); CHECK ( zspan . ensure_z (). size () == 0 ); } // create zspan from non-zero terminated string { char16_t buf [ 1 ]; buf [ 0 ] = u 'a' ; const auto workaround_macro = [ & ]() { const u16zstring_span <> zspan ({ buf , 1 }); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } // usage scenario: create zero-terminated temp file name and pass to a legacy API { char16_t buf [ 10 ]; const auto name = CreateTempNameU16 ({ buf , 10 }); if ( ! name . empty ()) { cu16zstring <> str = name . assume_z (); CHECK ( generic :: strnlen ( str , 10 ) == 3 ); CHECK ( * ( str + 3 ) == L '\\0' ); } } } cu32zstring_span <> CreateTempNameU32 ( u32string_span <> span ) { Expects ( span . size () > 1 ); int last = 0 ; if ( span . size () > 4 ) { span [ 0 ] = U 't' ; span [ 1 ] = U 'm' ; span [ 2 ] = U 'p' ; last = 3 ; } span [ last ] = U '\\0' ; auto ret = span . subspan ( 0 , 4 ); return { ret }; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"u32zstring\" ) { // create zspan from zero terminated string { char32_t buf [ 1 ]; buf [ 0 ] = L '\\0' ; u32zstring_span <> zspan ({ buf , 1 }); CHECK ( generic :: strnlen ( zspan . assume_z (), 1 ) == 0 ); CHECK ( zspan . as_string_span (). size () == 0 ); CHECK ( zspan . ensure_z (). size () == 0 ); } // create zspan from non-zero terminated string { char32_t buf [ 1 ]; buf [ 0 ] = u 'a' ; const auto workaround_macro = [ & ]() { const u32zstring_span <> zspan ({ buf , 1 }); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } // usage scenario: create zero-terminated temp file name and pass to a legacy API { char32_t buf [ 10 ]; const auto name = CreateTempNameU32 ({ buf , 10 }); if ( ! name . empty ()) { cu32zstring <> str = name . assume_z (); CHECK ( generic :: strnlen ( str , 10 ) == 3 ); CHECK ( * ( str + 3 ) == L '\\0' ); } } } TEST_CASE ( \"Issue305\" ) { std :: map < gsl :: cstring_span <> , int > foo = {{ \"foo\" , 0 }, { \"bar\" , 1 }}; CHECK ( foo [ \"foo\" ] == 0 ); CHECK ( foo [ \"bar\" ] == 1 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"char16_t type\" ) { gsl :: cu16string_span <> ss1 = gsl :: ensure_z ( u \"abc\" ); CHECK ( ss1 . size () == 3 ); CHECK ( ss1 . size_bytes () == 6 ); std :: u16string s1 = gsl :: to_string ( ss1 ); CHECK ( s1 == u \"abc\" ); std :: u16string s2 = u \"abc\" ; gsl :: u16string_span <> ss2 = s2 ; CHECK ( ss2 . size () == 3 ); gsl :: u16string_span <> ss3 = ss2 . subspan ( 1 , 1 ); CHECK ( ss3 . size () == 1 ); CHECK ( ss3 [ 0 ] == u 'b' ); char16_t buf [ 4 ]{ u 'a' , u 'b' , u 'c' , u '\\0' }; gsl :: u16string_span <> ss4 { buf , 4 }; CHECK ( ss4 [ 3 ] == u '\\0' ); gsl :: cu16zstring_span <> ss5 ( u \"abc\" ); CHECK ( ss5 . as_string_span (). size () == 3 ); gsl :: cu16string_span <> ss6 = ss5 . as_string_span (); CHECK ( ss6 == ss1 ); std :: vector < char16_t > v7 = { u 'a' , u 'b' , u 'c' }; gsl :: cu16string_span <> ss7 { v7 }; CHECK ( ss7 == ss1 ); gsl :: cu16string_span <> ss8 = gsl :: ensure_z ( u \"abc\" ); gsl :: cu16string_span <> ss9 = gsl :: ensure_z ( u \"abc\" ); CHECK ( ss8 == ss9 ); ss9 = gsl :: ensure_z ( u \"abd\" ); CHECK ( ss8 < ss9 ); CHECK ( ss8 <= ss9 ); CHECK ( ss8 != ss9 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"char32_t type\" ) { gsl :: cu32string_span <> ss1 = gsl :: ensure_z ( U \"abc\" ); CHECK ( ss1 . size () == 3 ); CHECK ( ss1 . size_bytes () == 12 ); std :: u32string s1 = gsl :: to_string ( ss1 ); CHECK ( s1 == U \"abc\" ); std :: u32string s2 = U \"abc\" ; gsl :: u32string_span <> ss2 = s2 ; CHECK ( ss2 . size () == 3 ); gsl :: u32string_span <> ss3 = ss2 . subspan ( 1 , 1 ); CHECK ( ss3 . size () == 1 ); CHECK ( ss3 [ 0 ] == U 'b' ); char32_t buf [ 4 ]{ U 'a' , U 'b' , U 'c' , U '\\0' }; gsl :: u32string_span <> ss4 { buf , 4 }; CHECK ( ss4 [ 3 ] == u '\\0' ); gsl :: cu32zstring_span <> ss5 ( U \"abc\" ); CHECK ( ss5 . as_string_span (). size () == 3 ); gsl :: cu32string_span <> ss6 = ss5 . as_string_span (); CHECK ( ss6 == ss1 ); gsl :: cu32string_span <> ss8 = gsl :: ensure_z ( U \"abc\" ); gsl :: cu32string_span <> ss9 = gsl :: ensure_z ( U \"abc\" ); CHECK ( ss8 == ss9 ); ss9 = gsl :: ensure_z ( U \"abd\" ); CHECK ( ss8 < ss9 ); CHECK ( ss8 <= ss9 ); CHECK ( ss8 != ss9 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_bytes\" ) { cwzstring_span <> v ( L \"qwerty\" ); const auto s = v . as_string_span (); const auto bs = as_bytes ( s ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_writeable_bytes\" ) { wchar_t buf []{ L \"qwerty\" }; wzstring_span <> v ( buf ); const auto s = v . as_string_span (); const auto bs = as_writeable_bytes ( s ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); }","title":"File string\\_span\\_tests.cpp"},{"location":"string__span__tests_8cpp_source/#file-string95span95testscpp","text":"File List > external > guideline > tests > string_span_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/gsl_assert> // for Expects, fail_fast (ptr only) #include <gsl/pointers> // for owner #include <gsl/span> // for span, dynamic_extent #include <gsl/string_span> // for basic_string_span, operator==, ensure_z #include <algorithm> // for move, find #include <cstddef> // for size_t #include <map> // for map #include <string> // for basic_string, string, char_traits, operat... #include <type_traits> // for remove_reference<>::type #include <vector> // for vector, allocator using namespace std ; using namespace gsl ; // Generic string functions namespace generic { template < typename CharT > GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute GSL_SUPPRESS ( f .23 ) // NO-FORMAT: attribute auto strlen ( const CharT * s ) { auto p = s ; while ( * p ) ++ p ; return p - s ; } template < typename CharT > GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute auto strnlen ( const CharT * s , std :: size_t n ) { return std :: find ( s , s + n , CharT { 0 }) - s ; } } // namespace generic GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestLiteralConstruction\" ) { cwstring_span <> v = ensure_z ( L \"Hello\" ); CHECK ( 5 == v . length ()); #ifdef CONFIRM_COMPILATION_ERRORS wstring_span <> v2 = ensure0 ( L \"Hello\" ); #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConstructFromStdString\" ) { std :: string s = \"Hello there world\" ; cstring_span <> v = s ; CHECK ( v . length () == static_cast < cstring_span <>:: index_type > ( s . length ())); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConstructFromStdVector\" ) { std :: vector < char > vec ( 5 , 'h' ); string_span <> v { vec }; CHECK ( v . length () == static_cast < string_span <>:: index_type > ( vec . size ())); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestStackArrayConstruction\" ) { wchar_t stack_string [] = L \"Hello\" ; { cwstring_span <> v = ensure_z ( stack_string ); CHECK ( v . length () == 5 ); } { cwstring_span <> v = stack_string ; CHECK ( v . length () == 5 ); } { wstring_span <> v = ensure_z ( stack_string ); CHECK ( v . length () == 5 ); } { wstring_span <> v = stack_string ; CHECK ( v . length () == 5 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConstructFromConstCharPointer\" ) { const char * s = \"Hello\" ; cstring_span <> v = ensure_z ( s ); CHECK ( v . length () == 5 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConversionToConst\" ) { char stack_string [] = \"Hello\" ; string_span <> v = ensure_z ( stack_string ); cstring_span <> v2 = v ; CHECK ( v . length () == v2 . length ()); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestConversionFromConst\" ) { char stack_string [] = \"Hello\" ; cstring_span <> v = ensure_z ( stack_string ); ( void ) v ; #ifdef CONFIRM_COMPILATION_ERRORS string_span <> v2 = v ; string_span <> v3 = \"Hello\" ; #endif } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestToString\" ) { auto s = gsl :: to_string ( cstring_span <> {}); CHECK ( s . length () == 0 ); char stack_string [] = \"Hello\" ; cstring_span <> v = ensure_z ( stack_string ); auto s2 = gsl :: to_string ( v ); CHECK ( static_cast < cstring_span <>:: index_type > ( s2 . length ()) == v . length ()); CHECK ( s2 . length () == 5 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"TestToBasicString\" ) { auto s = gsl :: to_basic_string < char , std :: char_traits < char > , :: std :: allocator < char >> ( cstring_span <> {}); CHECK ( s . length () == 0 ); char stack_string [] = \"Hello\" ; cstring_span <> v = ensure_z ( stack_string ); auto s2 = gsl :: to_basic_string < char , std :: char_traits < char > , :: std :: allocator < char >> ( v ); CHECK ( static_cast < cstring_span <>:: index_type > ( s2 . length ()) == v . length ()); CHECK ( s2 . length () == 5 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"EqualityAndImplicitConstructors\" ) { { cstring_span <> span = \"Hello\" ; cstring_span <> span1 ; // comparison to empty span CHECK ( span1 != span ); CHECK ( span != span1 ); } { cstring_span <> span = \"Hello\" ; cstring_span <> span1 = \"Hello1\" ; // comparison to different span CHECK ( span1 != span ); CHECK ( span != span1 ); } { cstring_span <> span = \"Hello\" ; const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; const char ar1 [] = \"Hello\" ; const char ar2 [ 10 ] = \"Hello\" ; const char * ptr = \"Hello\" ; const std :: string str = \"Hello\" ; const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; gsl :: span < const char > sp = ensure_z ( \"Hello\" ); // comparison to literal CHECK ( span == cstring_span <> ( \"Hello\" )); // comparison to static array with no null termination CHECK ( span == cstring_span <> ( ar )); // comparison to static array with null at the end CHECK ( span == cstring_span <> ( ar1 )); // comparison to static array with null in the middle CHECK ( span == cstring_span <> ( ar2 )); // comparison to null-terminated c string CHECK ( span == cstring_span <> ( ptr , 5 )); // comparison to string CHECK ( span == cstring_span <> ( str )); // comparison to vector of charaters with no null termination CHECK ( span == cstring_span <> ( vec )); // comparison to span CHECK ( span == cstring_span <> ( sp )); // comparison to string_span CHECK ( span == span ); } { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = ar ; char ar1 [] = \"Hello\" ; char ar2 [ 10 ] = \"Hello\" ; char * ptr = ar ; std :: string str = \"Hello\" ; std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; gsl :: span < char > sp = ensure_z ( ar1 ); // comparison to static array with no null termination CHECK ( span == string_span <> ( ar )); // comparison to static array with null at the end CHECK ( span == string_span <> ( ar1 )); // comparison to static array with null in the middle CHECK ( span == string_span <> ( ar2 )); // comparison to null-terminated c string CHECK ( span == string_span <> ( ptr , 5 )); // comparison to string CHECK ( span == string_span <> ( str )); // comparison to vector of charaters with no null termination CHECK ( span == string_span <> ( vec )); // comparison to span CHECK ( span == string_span <> ( sp )); // comparison to string_span CHECK ( span == span ); } { const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; const char ar1 [] = \"Hello\" ; const char ar2 [ 10 ] = \"Hello\" ; const std :: string str = \"Hello\" ; const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const gsl :: span < const char > sp = ensure_z ( \"Hello\" ); cstring_span <> span = \"Hello\" ; // const span, const other type CHECK ( span == \"Hello\" ); CHECK ( span == ar ); CHECK ( span == ar1 ); CHECK ( span == ar2 ); #ifdef CONFIRM_COMPILATION_ERRORS const char * ptr = \"Hello\" ; CHECK ( span == ptr ); #endif CHECK ( span == str ); CHECK ( span == vec ); CHECK ( span == sp ); CHECK ( \"Hello\" == span ); CHECK ( ar == span ); CHECK ( ar1 == span ); CHECK ( ar2 == span ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( ptr == span ); #endif CHECK ( str == span ); CHECK ( vec == span ); CHECK ( sp == span ); // const span, non-const other type char _ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; char _ar1 [] = \"Hello\" ; char _ar2 [ 10 ] = \"Hello\" ; char * _ptr = _ar ; std :: string _str = \"Hello\" ; std :: vector < char > _vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; gsl :: span < char > _sp { _ar , 5 }; CHECK ( span == _ar ); CHECK ( span == _ar1 ); CHECK ( span == _ar2 ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( span == _ptr ); #endif CHECK ( span == _str ); CHECK ( span == _vec ); CHECK ( span == _sp ); CHECK ( _ar == span ); CHECK ( _ar1 == span ); CHECK ( _ar2 == span ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( _ptr == span ); #endif CHECK ( _str == span ); CHECK ( _vec == span ); CHECK ( _sp == span ); string_span <> _span { _ptr , 5 }; // non-const span, non-const other type CHECK ( _span == _ar ); CHECK ( _span == _ar1 ); CHECK ( _span == _ar2 ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( _span == _ptr ); #endif CHECK ( _span == _str ); CHECK ( _span == _vec ); CHECK ( _span == _sp ); CHECK ( _ar == _span ); CHECK ( _ar1 == _span ); CHECK ( _ar2 == _span ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( _ptr == _span ); #endif CHECK ( _str == _span ); CHECK ( _vec == _span ); CHECK ( _sp == _span ); // non-const span, const other type CHECK ( _span == \"Hello\" ); CHECK ( _span == ar ); CHECK ( _span == ar1 ); CHECK ( _span == ar2 ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( _span == ptr ); #endif CHECK ( _span == str ); CHECK ( _span == vec ); CHECK ( _span == sp ); CHECK ( \"Hello\" == _span ); CHECK ( ar == _span ); CHECK ( ar1 == _span ); CHECK ( ar2 == _span ); #ifdef CONFIRM_COMPILATION_ERRORS CHECK ( ptr == _span ); #endif CHECK ( str == _span ); CHECK ( vec == _span ); CHECK ( sp == _span ); // two spans CHECK ( _span == span ); CHECK ( span == _span ); } { std :: vector < char > str1 = { 'H' , 'e' , 'l' , 'l' , 'o' }; cstring_span <> span1 = str1 ; std :: vector < char > str2 = std :: move ( str1 ); cstring_span <> span2 = str2 ; // comparison of spans from the same vector before and after move (ok) CHECK ( span1 == span2 ); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"ComparisonAndImplicitConstructors\" ) { { cstring_span <> span = \"Hello\" ; const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; const char ar1 [] = \"Hello\" ; const char ar2 [ 10 ] = \"Hello\" ; const char * ptr = \"Hello\" ; const std :: string str = \"Hello\" ; const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; // comparison to literal CHECK ( span < cstring_span <> ( \"Helloo\" )); CHECK ( span > cstring_span <> ( \"Hell\" )); // comparison to static array with no null termination CHECK ( span >= cstring_span <> ( ar )); // comparison to static array with null at the end CHECK ( span <= cstring_span <> ( ar1 )); // comparison to static array with null in the middle CHECK ( span >= cstring_span <> ( ar2 )); // comparison to null-terminated c string CHECK ( span <= cstring_span <> ( ptr , 5 )); // comparison to string CHECK ( span >= cstring_span <> ( str )); // comparison to vector of charaters with no null termination CHECK ( span <= cstring_span <> ( vec )); } { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = ar ; char larr [] = \"Hell\" ; char rarr [] = \"Helloo\" ; char ar1 [] = \"Hello\" ; char ar2 [ 10 ] = \"Hello\" ; char * ptr = ar ; std :: string str = \"Hello\" ; std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; // comparison to static array with no null termination CHECK ( span <= string_span <> ( ar )); CHECK ( span < string_span <> ( rarr )); CHECK ( span > string_span <> ( larr )); // comparison to static array with null at the end CHECK ( span >= string_span <> ( ar1 )); // comparison to static array with null in the middle CHECK ( span <= string_span <> ( ar2 )); // comparison to null-terminated c string CHECK ( span >= string_span <> ( ptr , 5 )); // comparison to string CHECK ( span <= string_span <> ( str )); // comparison to vector of charaters with no null termination CHECK ( span >= string_span <> ( vec )); } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .11 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .3 ) // NO-FORMAT: attribute GSL_SUPPRESS ( r .5 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"ConstrutorsEnsureZ\" ) { // remove z from literals { cstring_span <> sp = \"hello\" ; CHECK (( sp . length () == 5 )); } // take the string as is { auto str = std :: string ( \"hello\" ); cstring_span <> sp = str ; CHECK (( sp . length () == 5 )); } // ensure z on c strings { gsl :: owner < char *> ptr = new char [ 3 ]; ptr [ 0 ] = 'a' ; ptr [ 1 ] = 'b' ; ptr [ 2 ] = '\\0' ; string_span <> span = ensure_z ( ptr ); CHECK ( span . length () == 2 ); delete [] ptr ; } } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"Constructors\" ) { // creating cstring_span // from span of a final extent { span < const char , 6 > sp = \"Hello\" ; cstring_span <> span = sp ; CHECK ( span . length () == 6 ); } // from const span of a final extent to non-const string_span #ifdef CONFIRM_COMPILATION_ERRORS { span < const char , 6 > sp = \"Hello\" ; string_span <> span = sp ; CHECK ( span . length () == 6 ); } #endif // from string temporary #ifdef CONFIRM_COMPILATION_ERRORS { cstring_span <> span = std :: string ( \"Hello\" ); } #endif // default { cstring_span <> span ; CHECK ( span . length () == 0 ); } // from string literal { cstring_span <> span = \"Hello\" ; CHECK ( span . length () == 5 ); } // from const static array { const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; cstring_span <> span = ar ; CHECK ( span . length () == 5 ); } // from non-const static array { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; cstring_span <> span = ar ; CHECK ( span . length () == 5 ); } // from const ptr and length { const char * ptr = \"Hello\" ; cstring_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from const ptr and length, include 0 { const char * ptr = \"Hello\" ; cstring_span <> span { ptr , 6 }; CHECK ( span . length () == 6 ); } // from const ptr and length, 0 inside { const char * ptr = \"He \\0 lo\" ; cstring_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from non-const ptr and length { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; char * ptr = ar ; cstring_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from non-const ptr and length, 0 inside { char ar [] = { 'H' , 'e' , '\\0' , 'l' , 'o' }; char * ptr = ar ; cstring_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from const string { const std :: string str = \"Hello\" ; const cstring_span <> span = str ; CHECK ( span . length () == 5 ); } // from non-const string { std :: string str = \"Hello\" ; const cstring_span <> span = str ; CHECK ( span . length () == 5 ); } // from const vector { const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const cstring_span <> span = vec ; CHECK ( span . length () == 5 ); } // from non-const vector { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const cstring_span <> span = vec ; CHECK ( span . length () == 5 ); } // from const span { const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const span < const char > inner = vec ; const cstring_span <> span = inner ; CHECK ( span . length () == 5 ); } // from non-const span { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const span < char > inner = vec ; const cstring_span <> span = inner ; CHECK ( span . length () == 5 ); } // from const string_span { const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const cstring_span <> tmp = vec ; const cstring_span <> span = tmp ; CHECK ( span . length () == 5 ); } // from non-const string_span { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> tmp = vec ; cstring_span <> span = tmp ; CHECK ( span . length () == 5 ); } // creating string_span // from string literal { #ifdef CONFIRM_COMPILATION_ERRORS string_span <> span = \"Hello\" ; #endif } // from const static array { #ifdef CONFIRM_COMPILATION_ERRORS const char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = ar ; CHECK ( span . length () == 5 ); #endif } // from non-const static array { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = ar ; CHECK ( span . length () == 5 ); } // from const ptr and length { #ifdef CONFIRM_COMPILATION_ERRORS const char * ptr = \"Hello\" ; string_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); #endif } // from non-const ptr and length { char ar [] = { 'H' , 'e' , 'l' , 'l' , 'o' }; char * ptr = ar ; string_span <> span { ptr , 5 }; CHECK ( span . length () == 5 ); } // from const string { #ifdef CONFIRM_COMPILATION_ERRORS const std :: string str = \"Hello\" ; string_span <> span = str ; CHECK ( span . length () == 5 ); #endif } // from non-const string { std :: string str = \"Hello\" ; string_span <> span = str ; CHECK ( span . length () == 5 ); } // from const vector { #ifdef CONFIRM_COMPILATION_ERRORS const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = vec ; CHECK ( span . length () == 5 ); #endif } // from non-const vector { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = vec ; CHECK ( span . length () == 5 ); } // from const span { #ifdef CONFIRM_COMPILATION_ERRORS std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const span < const char > inner = vec ; string_span <> span = inner ; CHECK ( span . length () == 5 ); #endif } // from non-const span { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; span < char > inner = vec ; string_span <> span = inner ; CHECK ( span . length () == 5 ); } // from non-const span of non-const data from const vector { #ifdef CONFIRM_COMPILATION_ERRORS const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const span < char > inner = vec ; string_span <> span = inner ; CHECK ( span . length () == 5 ); #endif } // from const string_span { #ifdef CONFIRM_COMPILATION_ERRORS std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; cstring_span <> tmp = vec ; string_span <> span = tmp ; CHECK ( span . length () == 5 ); #endif } // from non-const string_span { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const string_span <> tmp = vec ; const string_span <> span = tmp ; CHECK ( span . length () == 5 ); } // from non-const string_span from const vector { #ifdef CONFIRM_COMPILATION_ERRORS const std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> tmp = vec ; string_span <> span = tmp ; CHECK ( span . length () == 5 ); #endif } // from const string_span of non-const data { std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; const string_span <> tmp = vec ; const string_span <> span = tmp ; CHECK ( span . length () == 5 ); } } template < typename T > T move_wrapper ( T && t ) { return std :: move ( t ); } template < class T > T create () { return T {}; } template < class T > void use ( basic_string_span < T , gsl :: dynamic_extent > ) { } TEST_CASE ( \"MoveConstructors\" ) { // move string_span { cstring_span <> span = \"Hello\" ; const auto span1 = std :: move ( span ); CHECK ( span1 . length () == 5 ); } { cstring_span <> span = \"Hello\" ; const auto span1 = move_wrapper ( std :: move ( span )); CHECK ( span1 . length () == 5 ); } { cstring_span <> span = \"Hello\" ; const auto span1 = move_wrapper ( std :: move ( span )); CHECK ( span1 . length () == 5 ); } // move span { span < const char > span = ensure_z ( \"Hello\" ); const cstring_span <> span1 = std :: move ( span ); CHECK ( span1 . length () == 5 ); } { span < const char > span = ensure_z ( \"Hello\" ); const cstring_span <> span2 = move_wrapper ( std :: move ( span )); CHECK ( span2 . length () == 5 ); } // move string { #ifdef CONFIRM_COMPILATION_ERRORS std :: string str = \"Hello\" ; string_span <> span = std :: move ( str ); CHECK ( span . length () == 5 ); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS std :: string str = \"Hello\" ; string_span <> span = move_wrapper < std :: string > ( std :: move ( str )); CHECK ( span . length () == 5 ); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS use < char > ( create < string > ()); #endif } // move container { #ifdef CONFIRM_COMPILATION_ERRORS std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = std :: move ( vec ); CHECK ( span . length () == 5 ); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS std :: vector < char > vec = { 'H' , 'e' , 'l' , 'l' , 'o' }; string_span <> span = move_wrapper < std :: vector < char >> ( std :: move ( vec )); CHECK ( span . length () == 5 ); #endif } { #ifdef CONFIRM_COMPILATION_ERRORS use < char > ( create < std :: vector < char >> ()); #endif } } TEST_CASE ( \"Conversion\" ) { #ifdef CONFIRM_COMPILATION_ERRORS cstring_span <> span = \"Hello\" ; cwstring_span <> wspan { span }; CHECK ( wspan . length () == 5 ); #endif } czstring_span <> CreateTempName ( string_span <> span ) { Expects ( span . size () > 1 ); int last = 0 ; if ( span . size () > 4 ) { span [ 0 ] = 't' ; span [ 1 ] = 'm' ; span [ 2 ] = 'p' ; last = 3 ; } span [ last ] = '\\0' ; auto ret = span . subspan ( 0 , 4 ); return { ret }; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"zstring\" ) { // create zspan from zero terminated string { char buf [ 1 ]; buf [ 0 ] = '\\0' ; zstring_span <> zspan ({ buf , 1 }); CHECK ( generic :: strlen ( zspan . assume_z ()) == 0 ); CHECK ( zspan . as_string_span (). size () == 0 ); CHECK ( zspan . ensure_z (). size () == 0 ); } // create zspan from non-zero terminated string { char buf [ 1 ]; buf [ 0 ] = 'a' ; auto workaround_macro = [ & ]() { const zstring_span <> zspan ({ buf , 1 }); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } // usage scenario: create zero-terminated temp file name and pass to a legacy API { char buf [ 10 ]; auto name = CreateTempName ({ buf , 10 }); if ( ! name . empty ()) { czstring <> str = name . assume_z (); CHECK ( generic :: strlen ( str ) == 3 ); CHECK ( * ( str + 3 ) == '\\0' ); } } } cwzstring_span <> CreateTempNameW ( wstring_span <> span ) { Expects ( span . size () > 1 ); int last = 0 ; if ( span . size () > 4 ) { span [ 0 ] = L 't' ; span [ 1 ] = L 'm' ; span [ 2 ] = L 'p' ; last = 3 ; } span [ last ] = L '\\0' ; auto ret = span . subspan ( 0 , 4 ); return { ret }; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"wzstring\" ) { // create zspan from zero terminated string { wchar_t buf [ 1 ]; buf [ 0 ] = L '\\0' ; wzstring_span <> zspan ({ buf , 1 }); CHECK ( generic :: strnlen ( zspan . assume_z (), 1 ) == 0 ); CHECK ( zspan . as_string_span (). size () == 0 ); CHECK ( zspan . ensure_z (). size () == 0 ); } // create zspan from non-zero terminated string { wchar_t buf [ 1 ]; buf [ 0 ] = L 'a' ; const auto workaround_macro = [ & ]() { const wzstring_span <> zspan ({ buf , 1 }); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } // usage scenario: create zero-terminated temp file name and pass to a legacy API { wchar_t buf [ 10 ]; const auto name = CreateTempNameW ({ buf , 10 }); if ( ! name . empty ()) { cwzstring <> str = name . assume_z (); CHECK ( generic :: strnlen ( str , 10 ) == 3 ); CHECK ( * ( str + 3 ) == L '\\0' ); } } } cu16zstring_span <> CreateTempNameU16 ( u16string_span <> span ) { Expects ( span . size () > 1 ); int last = 0 ; if ( span . size () > 4 ) { span [ 0 ] = u 't' ; span [ 1 ] = u 'm' ; span [ 2 ] = u 'p' ; last = 3 ; } span [ last ] = u '\\0' ; auto ret = span . subspan ( 0 , 4 ); return { ret }; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"u16zstring\" ) { // create zspan from zero terminated string { char16_t buf [ 1 ]; buf [ 0 ] = L '\\0' ; u16zstring_span <> zspan ({ buf , 1 }); CHECK ( generic :: strnlen ( zspan . assume_z (), 1 ) == 0 ); CHECK ( zspan . as_string_span (). size () == 0 ); CHECK ( zspan . ensure_z (). size () == 0 ); } // create zspan from non-zero terminated string { char16_t buf [ 1 ]; buf [ 0 ] = u 'a' ; const auto workaround_macro = [ & ]() { const u16zstring_span <> zspan ({ buf , 1 }); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } // usage scenario: create zero-terminated temp file name and pass to a legacy API { char16_t buf [ 10 ]; const auto name = CreateTempNameU16 ({ buf , 10 }); if ( ! name . empty ()) { cu16zstring <> str = name . assume_z (); CHECK ( generic :: strnlen ( str , 10 ) == 3 ); CHECK ( * ( str + 3 ) == L '\\0' ); } } } cu32zstring_span <> CreateTempNameU32 ( u32string_span <> span ) { Expects ( span . size () > 1 ); int last = 0 ; if ( span . size () > 4 ) { span [ 0 ] = U 't' ; span [ 1 ] = U 'm' ; span [ 2 ] = U 'p' ; last = 3 ; } span [ last ] = U '\\0' ; auto ret = span . subspan ( 0 , 4 ); return { ret }; } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .1 ) // NO-FORMAT: attribute TEST_CASE ( \"u32zstring\" ) { // create zspan from zero terminated string { char32_t buf [ 1 ]; buf [ 0 ] = L '\\0' ; u32zstring_span <> zspan ({ buf , 1 }); CHECK ( generic :: strnlen ( zspan . assume_z (), 1 ) == 0 ); CHECK ( zspan . as_string_span (). size () == 0 ); CHECK ( zspan . ensure_z (). size () == 0 ); } // create zspan from non-zero terminated string { char32_t buf [ 1 ]; buf [ 0 ] = u 'a' ; const auto workaround_macro = [ & ]() { const u32zstring_span <> zspan ({ buf , 1 }); }; CHECK_THROWS_AS ( workaround_macro (), fail_fast ); } // usage scenario: create zero-terminated temp file name and pass to a legacy API { char32_t buf [ 10 ]; const auto name = CreateTempNameU32 ({ buf , 10 }); if ( ! name . empty ()) { cu32zstring <> str = name . assume_z (); CHECK ( generic :: strnlen ( str , 10 ) == 3 ); CHECK ( * ( str + 3 ) == L '\\0' ); } } } TEST_CASE ( \"Issue305\" ) { std :: map < gsl :: cstring_span <> , int > foo = {{ \"foo\" , 0 }, { \"bar\" , 1 }}; CHECK ( foo [ \"foo\" ] == 0 ); CHECK ( foo [ \"bar\" ] == 1 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"char16_t type\" ) { gsl :: cu16string_span <> ss1 = gsl :: ensure_z ( u \"abc\" ); CHECK ( ss1 . size () == 3 ); CHECK ( ss1 . size_bytes () == 6 ); std :: u16string s1 = gsl :: to_string ( ss1 ); CHECK ( s1 == u \"abc\" ); std :: u16string s2 = u \"abc\" ; gsl :: u16string_span <> ss2 = s2 ; CHECK ( ss2 . size () == 3 ); gsl :: u16string_span <> ss3 = ss2 . subspan ( 1 , 1 ); CHECK ( ss3 . size () == 1 ); CHECK ( ss3 [ 0 ] == u 'b' ); char16_t buf [ 4 ]{ u 'a' , u 'b' , u 'c' , u '\\0' }; gsl :: u16string_span <> ss4 { buf , 4 }; CHECK ( ss4 [ 3 ] == u '\\0' ); gsl :: cu16zstring_span <> ss5 ( u \"abc\" ); CHECK ( ss5 . as_string_span (). size () == 3 ); gsl :: cu16string_span <> ss6 = ss5 . as_string_span (); CHECK ( ss6 == ss1 ); std :: vector < char16_t > v7 = { u 'a' , u 'b' , u 'c' }; gsl :: cu16string_span <> ss7 { v7 }; CHECK ( ss7 == ss1 ); gsl :: cu16string_span <> ss8 = gsl :: ensure_z ( u \"abc\" ); gsl :: cu16string_span <> ss9 = gsl :: ensure_z ( u \"abc\" ); CHECK ( ss8 == ss9 ); ss9 = gsl :: ensure_z ( u \"abd\" ); CHECK ( ss8 < ss9 ); CHECK ( ss8 <= ss9 ); CHECK ( ss8 != ss9 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute GSL_SUPPRESS ( bounds .3 ) // NO-FORMAT: attribute TEST_CASE ( \"char32_t type\" ) { gsl :: cu32string_span <> ss1 = gsl :: ensure_z ( U \"abc\" ); CHECK ( ss1 . size () == 3 ); CHECK ( ss1 . size_bytes () == 12 ); std :: u32string s1 = gsl :: to_string ( ss1 ); CHECK ( s1 == U \"abc\" ); std :: u32string s2 = U \"abc\" ; gsl :: u32string_span <> ss2 = s2 ; CHECK ( ss2 . size () == 3 ); gsl :: u32string_span <> ss3 = ss2 . subspan ( 1 , 1 ); CHECK ( ss3 . size () == 1 ); CHECK ( ss3 [ 0 ] == U 'b' ); char32_t buf [ 4 ]{ U 'a' , U 'b' , U 'c' , U '\\0' }; gsl :: u32string_span <> ss4 { buf , 4 }; CHECK ( ss4 [ 3 ] == u '\\0' ); gsl :: cu32zstring_span <> ss5 ( U \"abc\" ); CHECK ( ss5 . as_string_span (). size () == 3 ); gsl :: cu32string_span <> ss6 = ss5 . as_string_span (); CHECK ( ss6 == ss1 ); gsl :: cu32string_span <> ss8 = gsl :: ensure_z ( U \"abc\" ); gsl :: cu32string_span <> ss9 = gsl :: ensure_z ( U \"abc\" ); CHECK ( ss8 == ss9 ); ss9 = gsl :: ensure_z ( U \"abd\" ); CHECK ( ss8 < ss9 ); CHECK ( ss8 <= ss9 ); CHECK ( ss8 != ss9 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_bytes\" ) { cwzstring_span <> v ( L \"qwerty\" ); const auto s = v . as_string_span (); const auto bs = as_bytes ( s ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"as_writeable_bytes\" ) { wchar_t buf []{ L \"qwerty\" }; wzstring_span <> v ( buf ); const auto s = v . as_string_span (); const auto bs = as_writeable_bytes ( s ); CHECK ( static_cast < const void *> ( bs . data ()) == static_cast < const void *> ( s . data ())); CHECK ( bs . size () == s . size_bytes ()); }","title":"File string_span_tests.cpp"},{"location":"struct_custom_ptr/","text":"Struct CustomPtr \u00b6 template <typename T typename T> Class List > CustomPtr Public Attributes \u00b6 Type Name T * p_ = = nullptr Public Functions \u00b6 Type Name CustomPtr (T * p) operator T* () bool operator!= (std::nullptr_t) const Public Attributes Documentation \u00b6 variable p_ \u00b6 T * CustomPtr < T >:: p_ ; Public Functions Documentation \u00b6 function CustomPtr \u00b6 inline CustomPtr :: CustomPtr ( T * p ) function operator T* \u00b6 inline CustomPtr :: operator T * () function operator!= \u00b6 inline bool CustomPtr :: operator != ( std :: nullptr_t ) const The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"Struct CustomPtr"},{"location":"struct_custom_ptr/#struct-customptr","text":"template <typename T typename T> Class List > CustomPtr","title":"Struct CustomPtr"},{"location":"struct_custom_ptr/#public-attributes","text":"Type Name T * p_ = = nullptr","title":"Public Attributes"},{"location":"struct_custom_ptr/#public-functions","text":"Type Name CustomPtr (T * p) operator T* () bool operator!= (std::nullptr_t) const","title":"Public Functions"},{"location":"struct_custom_ptr/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"struct_custom_ptr/#variable-p95","text":"T * CustomPtr < T >:: p_ ;","title":"variable p_"},{"location":"struct_custom_ptr/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"struct_custom_ptr/#function-customptr","text":"inline CustomPtr :: CustomPtr ( T * p )","title":"function CustomPtr"},{"location":"struct_custom_ptr/#function-operator-t42","text":"inline CustomPtr :: operator T * ()","title":"function operator T*"},{"location":"struct_custom_ptr/#function-operator","text":"inline bool CustomPtr :: operator != ( std :: nullptr_t ) const The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"function operator!="},{"location":"struct_my_base/","text":"Struct MyBase \u00b6 Class List > MyBase Inherited by the following classes: MyDerived The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"Struct MyBase"},{"location":"struct_my_base/#struct-mybase","text":"Class List > MyBase Inherited by the following classes: MyDerived The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"Struct MyBase"},{"location":"struct_my_derived/","text":"Struct MyDerived \u00b6 Class List > MyDerived Inherits the following classes: MyBase The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"Struct MyDerived"},{"location":"struct_my_derived/#struct-myderived","text":"Class List > MyDerived Inherits the following classes: MyBase The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"Struct MyDerived"},{"location":"struct_non_copyable_non_movable/","text":"Struct NonCopyableNonMovable \u00b6 Class List > NonCopyableNonMovable Public Functions \u00b6 Type Name NonCopyableNonMovable () = default NonCopyableNonMovable (const NonCopyableNonMovable &) = delete NonCopyableNonMovable ( NonCopyableNonMovable &&) = delete NonCopyableNonMovable & operator= (const NonCopyableNonMovable &) = delete NonCopyableNonMovable & operator= ( NonCopyableNonMovable &&) = delete Public Functions Documentation \u00b6 function NonCopyableNonMovable [1/3] \u00b6 NonCopyableNonMovable :: NonCopyableNonMovable () = default function NonCopyableNonMovable [2/3] \u00b6 NonCopyableNonMovable :: NonCopyableNonMovable ( const NonCopyableNonMovable & ) = delete function NonCopyableNonMovable [3/3] \u00b6 NonCopyableNonMovable :: NonCopyableNonMovable ( NonCopyableNonMovable && ) = delete function operator= \u00b6 NonCopyableNonMovable & NonCopyableNonMovable :: operator = ( const NonCopyableNonMovable & ) = delete function operator= \u00b6 NonCopyableNonMovable & NonCopyableNonMovable :: operator = ( NonCopyableNonMovable && ) = delete The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"Struct NonCopyableNonMovable"},{"location":"struct_non_copyable_non_movable/#struct-noncopyablenonmovable","text":"Class List > NonCopyableNonMovable","title":"Struct NonCopyableNonMovable"},{"location":"struct_non_copyable_non_movable/#public-functions","text":"Type Name NonCopyableNonMovable () = default NonCopyableNonMovable (const NonCopyableNonMovable &) = delete NonCopyableNonMovable ( NonCopyableNonMovable &&) = delete NonCopyableNonMovable & operator= (const NonCopyableNonMovable &) = delete NonCopyableNonMovable & operator= ( NonCopyableNonMovable &&) = delete","title":"Public Functions"},{"location":"struct_non_copyable_non_movable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"struct_non_copyable_non_movable/#function-noncopyablenonmovable-13","text":"NonCopyableNonMovable :: NonCopyableNonMovable () = default","title":"function NonCopyableNonMovable [1/3]"},{"location":"struct_non_copyable_non_movable/#function-noncopyablenonmovable-23","text":"NonCopyableNonMovable :: NonCopyableNonMovable ( const NonCopyableNonMovable & ) = delete","title":"function NonCopyableNonMovable [2/3]"},{"location":"struct_non_copyable_non_movable/#function-noncopyablenonmovable-33","text":"NonCopyableNonMovable :: NonCopyableNonMovable ( NonCopyableNonMovable && ) = delete","title":"function NonCopyableNonMovable [3/3]"},{"location":"struct_non_copyable_non_movable/#function-operator","text":"NonCopyableNonMovable & NonCopyableNonMovable :: operator = ( const NonCopyableNonMovable & ) = delete","title":"function operator="},{"location":"struct_non_copyable_non_movable/#function-operator_1","text":"NonCopyableNonMovable & NonCopyableNonMovable :: operator = ( NonCopyableNonMovable && ) = delete The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"function operator="},{"location":"struct_ref_counted/","text":"Struct RefCounted \u00b6 template <typename T typename T> Class List > RefCounted Public Attributes \u00b6 Type Name T * p_ Public Functions \u00b6 Type Name RefCounted (T * p) operator T* () Public Attributes Documentation \u00b6 variable p_ \u00b6 T * RefCounted < T >:: p_ ; Public Functions Documentation \u00b6 function RefCounted \u00b6 inline RefCounted :: RefCounted ( T * p ) function operator T* \u00b6 inline RefCounted :: operator T * () The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"Struct RefCounted"},{"location":"struct_ref_counted/#struct-refcounted","text":"template <typename T typename T> Class List > RefCounted","title":"Struct RefCounted"},{"location":"struct_ref_counted/#public-attributes","text":"Type Name T * p_","title":"Public Attributes"},{"location":"struct_ref_counted/#public-functions","text":"Type Name RefCounted (T * p) operator T* ()","title":"Public Functions"},{"location":"struct_ref_counted/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"struct_ref_counted/#variable-p95","text":"T * RefCounted < T >:: p_ ;","title":"variable p_"},{"location":"struct_ref_counted/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"struct_ref_counted/#function-refcounted","text":"inline RefCounted :: RefCounted ( T * p )","title":"function RefCounted"},{"location":"struct_ref_counted/#function-operator-t42","text":"inline RefCounted :: operator T * () The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"function operator T*"},{"location":"struct_unrelated/","text":"Struct Unrelated \u00b6 Class List > Unrelated The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"Struct Unrelated"},{"location":"struct_unrelated/#struct-unrelated","text":"Class List > Unrelated The documentation for this class was generated from the following file external/guideline/tests/notnull_tests.cpp","title":"Struct Unrelated"},{"location":"structclang__frame__prefix/","text":"Struct clang_frame_prefix \u00b6 Class List > clang_frame_prefix Public Attributes \u00b6 Type Name procedure_t factivate procedure_t fdestroy Public Attributes Documentation \u00b6 variable factivate \u00b6 procedure_t clang_frame_prefix :: factivate ; variable fdestroy \u00b6 procedure_t clang_frame_prefix :: fdestroy ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct clang\\_frame\\_prefix"},{"location":"structclang__frame__prefix/#struct-clang95frame95prefix","text":"Class List > clang_frame_prefix","title":"Struct clang_frame_prefix"},{"location":"structclang__frame__prefix/#public-attributes","text":"Type Name procedure_t factivate procedure_t fdestroy","title":"Public Attributes"},{"location":"structclang__frame__prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structclang__frame__prefix/#variable-factivate","text":"procedure_t clang_frame_prefix :: factivate ;","title":"variable factivate"},{"location":"structclang__frame__prefix/#variable-fdestroy","text":"procedure_t clang_frame_prefix :: fdestroy ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable fdestroy"},{"location":"structcoro_1_1bypass__lock/","text":"Struct coro::bypass_lock \u00b6 Class List > coro > bypass_lock Public Functions \u00b6 Type Name constexpr void lock () noexcept constexpr bool try_lock () noexcept constexpr void unlock () noexcept Public Functions Documentation \u00b6 function lock \u00b6 inline constexpr void coro :: bypass_lock :: lock () noexcept function try_lock \u00b6 inline constexpr bool coro :: bypass_lock :: try_lock () noexcept function unlock \u00b6 inline constexpr void coro :: bypass_lock :: unlock () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Struct coro::bypass\\_lock"},{"location":"structcoro_1_1bypass__lock/#struct-corobypass95lock","text":"Class List > coro > bypass_lock","title":"Struct coro::bypass_lock"},{"location":"structcoro_1_1bypass__lock/#public-functions","text":"Type Name constexpr void lock () noexcept constexpr bool try_lock () noexcept constexpr void unlock () noexcept","title":"Public Functions"},{"location":"structcoro_1_1bypass__lock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structcoro_1_1bypass__lock/#function-lock","text":"inline constexpr void coro :: bypass_lock :: lock () noexcept","title":"function lock"},{"location":"structcoro_1_1bypass__lock/#function-try95lock","text":"inline constexpr bool coro :: bypass_lock :: try_lock () noexcept","title":"function try_lock"},{"location":"structcoro_1_1bypass__lock/#function-unlock","text":"inline constexpr void coro :: bypass_lock :: unlock () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function unlock"},{"location":"structcoro_1_1darwin__event/","text":"Struct coro::darwin_event \u00b6 Class List > coro > darwin_event Public Attributes \u00b6 Type Name sockaddr_un local int64_t msg int64_t sd Public Functions \u00b6 Type Name void close () noexcept darwin_event () noexcept bool is_signaled () noexcept void reset () noexcept void signal () noexcept ~darwin_event () noexcept Public Attributes Documentation \u00b6 variable local \u00b6 sockaddr_un coro :: darwin_event :: local ; variable msg \u00b6 int64_t coro :: darwin_event :: msg ; variable sd \u00b6 int64_t coro :: darwin_event :: sd ; Public Functions Documentation \u00b6 function close \u00b6 inline void coro :: darwin_event :: close () noexcept function darwin_event [3/3] \u00b6 inline coro :: darwin_event :: darwin_event () noexcept function is_signaled \u00b6 inline bool coro :: darwin_event :: is_signaled () noexcept function reset \u00b6 inline void coro :: darwin_event :: reset () noexcept function signal \u00b6 inline void coro :: darwin_event :: signal () noexcept function ~darwin_event \u00b6 inline coro :: darwin_event ::~ darwin_event () noexcept The documentation for this class was generated from the following file modules/event/event_darwin.cpp","title":"Struct coro::darwin\\_event"},{"location":"structcoro_1_1darwin__event/#struct-corodarwin95event","text":"Class List > coro > darwin_event","title":"Struct coro::darwin_event"},{"location":"structcoro_1_1darwin__event/#public-attributes","text":"Type Name sockaddr_un local int64_t msg int64_t sd","title":"Public Attributes"},{"location":"structcoro_1_1darwin__event/#public-functions","text":"Type Name void close () noexcept darwin_event () noexcept bool is_signaled () noexcept void reset () noexcept void signal () noexcept ~darwin_event () noexcept","title":"Public Functions"},{"location":"structcoro_1_1darwin__event/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structcoro_1_1darwin__event/#variable-local","text":"sockaddr_un coro :: darwin_event :: local ;","title":"variable local"},{"location":"structcoro_1_1darwin__event/#variable-msg","text":"int64_t coro :: darwin_event :: msg ;","title":"variable msg"},{"location":"structcoro_1_1darwin__event/#variable-sd","text":"int64_t coro :: darwin_event :: sd ;","title":"variable sd"},{"location":"structcoro_1_1darwin__event/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structcoro_1_1darwin__event/#function-close","text":"inline void coro :: darwin_event :: close () noexcept","title":"function close"},{"location":"structcoro_1_1darwin__event/#function-darwin95event-33","text":"inline coro :: darwin_event :: darwin_event () noexcept","title":"function darwin_event [3/3]"},{"location":"structcoro_1_1darwin__event/#function-is95signaled","text":"inline bool coro :: darwin_event :: is_signaled () noexcept","title":"function is_signaled"},{"location":"structcoro_1_1darwin__event/#function-reset","text":"inline void coro :: darwin_event :: reset () noexcept","title":"function reset"},{"location":"structcoro_1_1darwin__event/#function-signal","text":"inline void coro :: darwin_event :: signal () noexcept","title":"function signal"},{"location":"structcoro_1_1darwin__event/#function-darwin95event","text":"inline coro :: darwin_event ::~ darwin_event () noexcept The documentation for this class was generated from the following file modules/event/event_darwin.cpp","title":"function ~darwin_event"},{"location":"structcoro_1_1event__poll__t/","text":"Struct coro::event_poll_t \u00b6 Class List > coro > event_poll_t Public Attributes \u00b6 Type Name const size_t capacity int epfd std::unique_ptr< epoll_event[]> events Public Functions \u00b6 Type Name event_poll_t () noexcept void remove (uint64_t fd) void try_add (uint64_t fd, epoll_event & req) noexcept auto wait (int timeout) noexcept ~event_poll_t () noexcept Public Attributes Documentation \u00b6 variable capacity \u00b6 const size_t coro :: event_poll_t :: capacity ; variable epfd \u00b6 int coro :: event_poll_t :: epfd ; variable events \u00b6 std :: unique_ptr < epoll_event [] > coro :: event_poll_t :: events ; Public Functions Documentation \u00b6 function event_poll_t \u00b6 coro :: event_poll_t :: event_poll_t () noexcept function remove \u00b6 void coro :: event_poll_t :: remove ( uint64_t fd ) function try_add \u00b6 void coro :: event_poll_t :: try_add ( uint64_t fd , epoll_event & req ) noexcept function wait \u00b6 auto coro :: event_poll_t :: wait ( int timeout ) noexcept function ~event_poll_t \u00b6 coro :: event_poll_t ::~ event_poll_t () noexcept The documentation for this class was generated from the following file modules/event/event_poll.h","title":"Struct coro::event\\_poll\\_t"},{"location":"structcoro_1_1event__poll__t/#struct-coroevent95poll95t","text":"Class List > coro > event_poll_t","title":"Struct coro::event_poll_t"},{"location":"structcoro_1_1event__poll__t/#public-attributes","text":"Type Name const size_t capacity int epfd std::unique_ptr< epoll_event[]> events","title":"Public Attributes"},{"location":"structcoro_1_1event__poll__t/#public-functions","text":"Type Name event_poll_t () noexcept void remove (uint64_t fd) void try_add (uint64_t fd, epoll_event & req) noexcept auto wait (int timeout) noexcept ~event_poll_t () noexcept","title":"Public Functions"},{"location":"structcoro_1_1event__poll__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structcoro_1_1event__poll__t/#variable-capacity","text":"const size_t coro :: event_poll_t :: capacity ;","title":"variable capacity"},{"location":"structcoro_1_1event__poll__t/#variable-epfd","text":"int coro :: event_poll_t :: epfd ;","title":"variable epfd"},{"location":"structcoro_1_1event__poll__t/#variable-events","text":"std :: unique_ptr < epoll_event [] > coro :: event_poll_t :: events ;","title":"variable events"},{"location":"structcoro_1_1event__poll__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structcoro_1_1event__poll__t/#function-event95poll95t","text":"coro :: event_poll_t :: event_poll_t () noexcept","title":"function event_poll_t"},{"location":"structcoro_1_1event__poll__t/#function-remove","text":"void coro :: event_poll_t :: remove ( uint64_t fd )","title":"function remove"},{"location":"structcoro_1_1event__poll__t/#function-try95add","text":"void coro :: event_poll_t :: try_add ( uint64_t fd , epoll_event & req ) noexcept","title":"function try_add"},{"location":"structcoro_1_1event__poll__t/#function-wait","text":"auto coro :: event_poll_t :: wait ( int timeout ) noexcept","title":"function wait"},{"location":"structcoro_1_1event__poll__t/#function-event95poll95t_1","text":"coro :: event_poll_t ::~ event_poll_t () noexcept The documentation for this class was generated from the following file modules/event/event_poll.h","title":"function ~event_poll_t"},{"location":"structcoro_1_1kernel__queue__t/","text":"Struct coro::kernel_queue_t \u00b6 Class List > coro > kernel_queue_t Public Attributes \u00b6 Type Name const size_t capacity std::unique_ptr< kevent64_s[]> events int kqfd Public Functions \u00b6 Type Name void change (kevent64_s & req) noexcept kernel_queue_t () noexcept auto wait (const timespec & ts) noexcept ~kernel_queue_t () noexcept Public Attributes Documentation \u00b6 variable capacity \u00b6 const size_t coro :: kernel_queue_t :: capacity ; variable events \u00b6 std :: unique_ptr < kevent64_s [] > coro :: kernel_queue_t :: events ; variable kqfd \u00b6 int coro :: kernel_queue_t :: kqfd ; Public Functions Documentation \u00b6 function change \u00b6 void coro :: kernel_queue_t :: change ( kevent64_s & req ) noexcept function kernel_queue_t \u00b6 coro :: kernel_queue_t :: kernel_queue_t () noexcept function wait \u00b6 auto coro :: kernel_queue_t :: wait ( const timespec & ts ) noexcept function ~kernel_queue_t \u00b6 coro :: kernel_queue_t ::~ kernel_queue_t () noexcept The documentation for this class was generated from the following file modules/event/kernel_queue.h","title":"Struct coro::kernel\\_queue\\_t"},{"location":"structcoro_1_1kernel__queue__t/#struct-corokernel95queue95t","text":"Class List > coro > kernel_queue_t","title":"Struct coro::kernel_queue_t"},{"location":"structcoro_1_1kernel__queue__t/#public-attributes","text":"Type Name const size_t capacity std::unique_ptr< kevent64_s[]> events int kqfd","title":"Public Attributes"},{"location":"structcoro_1_1kernel__queue__t/#public-functions","text":"Type Name void change (kevent64_s & req) noexcept kernel_queue_t () noexcept auto wait (const timespec & ts) noexcept ~kernel_queue_t () noexcept","title":"Public Functions"},{"location":"structcoro_1_1kernel__queue__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structcoro_1_1kernel__queue__t/#variable-capacity","text":"const size_t coro :: kernel_queue_t :: capacity ;","title":"variable capacity"},{"location":"structcoro_1_1kernel__queue__t/#variable-events","text":"std :: unique_ptr < kevent64_s [] > coro :: kernel_queue_t :: events ;","title":"variable events"},{"location":"structcoro_1_1kernel__queue__t/#variable-kqfd","text":"int coro :: kernel_queue_t :: kqfd ;","title":"variable kqfd"},{"location":"structcoro_1_1kernel__queue__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structcoro_1_1kernel__queue__t/#function-change","text":"void coro :: kernel_queue_t :: change ( kevent64_s & req ) noexcept","title":"function change"},{"location":"structcoro_1_1kernel__queue__t/#function-kernel95queue95t","text":"coro :: kernel_queue_t :: kernel_queue_t () noexcept","title":"function kernel_queue_t"},{"location":"structcoro_1_1kernel__queue__t/#function-wait","text":"auto coro :: kernel_queue_t :: wait ( const timespec & ts ) noexcept","title":"function wait"},{"location":"structcoro_1_1kernel__queue__t/#function-kernel95queue95t_1","text":"coro :: kernel_queue_t ::~ kernel_queue_t () noexcept The documentation for this class was generated from the following file modules/event/kernel_queue.h","title":"function ~kernel_queue_t"},{"location":"structgcc__frame__prefix/","text":"Struct gcc_frame_prefix \u00b6 Class List > gcc_frame_prefix Public Attributes \u00b6 Type Name void * _unknown1 void * _unknown2 Public Attributes Documentation \u00b6 variable _unknown1 \u00b6 void * gcc_frame_prefix :: _unknown1 ; variable _unknown2 \u00b6 void * gcc_frame_prefix :: _unknown2 ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct gcc\\_frame\\_prefix"},{"location":"structgcc__frame__prefix/#struct-gcc95frame95prefix","text":"Class List > gcc_frame_prefix","title":"Struct gcc_frame_prefix"},{"location":"structgcc__frame__prefix/#public-attributes","text":"Type Name void * _unknown1 void * _unknown2","title":"Public Attributes"},{"location":"structgcc__frame__prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structgcc__frame__prefix/#variable-95unknown1","text":"void * gcc_frame_prefix :: _unknown1 ;","title":"variable _unknown1"},{"location":"structgcc__frame__prefix/#variable-95unknown2","text":"void * gcc_frame_prefix :: _unknown2 ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable _unknown2"},{"location":"structmsvc__frame__prefix/","text":"Struct msvc_frame_prefix \u00b6 Class List > msvc_frame_prefix Public Attributes \u00b6 Type Name procedure_t factivate uint16_t flag uint16_t index Public Attributes Documentation \u00b6 variable factivate \u00b6 procedure_t msvc_frame_prefix :: factivate ; variable flag \u00b6 uint16_t msvc_frame_prefix :: flag ; variable index \u00b6 uint16_t msvc_frame_prefix :: index ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct msvc\\_frame\\_prefix"},{"location":"structmsvc__frame__prefix/#struct-msvc95frame95prefix","text":"Class List > msvc_frame_prefix","title":"Struct msvc_frame_prefix"},{"location":"structmsvc__frame__prefix/#public-attributes","text":"Type Name procedure_t factivate uint16_t flag uint16_t index","title":"Public Attributes"},{"location":"structmsvc__frame__prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structmsvc__frame__prefix/#variable-factivate","text":"procedure_t msvc_frame_prefix :: factivate ;","title":"variable factivate"},{"location":"structmsvc__frame__prefix/#variable-flag","text":"uint16_t msvc_frame_prefix :: flag ;","title":"variable flag"},{"location":"structmsvc__frame__prefix/#variable-index","text":"uint16_t msvc_frame_prefix :: index ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable index"},{"location":"structstd_1_1experimental_1_1coroutine__traits/","text":"Struct std::experimental::coroutine_traits \u00b6 template <typename ReturnType typename ReturnType, typename... Args> Class List > std > experimental > coroutine_traits Public Types \u00b6 Type Name typedef typename ReturnType::promise_type promise_type Public Types Documentation \u00b6 typedef promise_type \u00b6 using std :: experimental :: coroutine_traits < ReturnType , Args >:: promise_type = typename ReturnType :: promise_type ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct std::experimental::coroutine\\_traits"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#struct-stdexperimentalcoroutine95traits","text":"template <typename ReturnType typename ReturnType, typename... Args> Class List > std > experimental > coroutine_traits","title":"Struct std::experimental::coroutine_traits"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#public-types","text":"Type Name typedef typename ReturnType::promise_type promise_type","title":"Public Types"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#typedef-promise95type","text":"using std :: experimental :: coroutine_traits < ReturnType , Args >:: promise_type = typename ReturnType :: promise_type ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"typedef promise_type"},{"location":"structstd_1_1experimental_1_1noop__coroutine__promise/","text":"Struct std::experimental::noop_coroutine_promise \u00b6 Class List > std > experimental > noop_coroutine_promise The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct std::experimental::noop\\_coroutine\\_promise"},{"location":"structstd_1_1experimental_1_1noop__coroutine__promise/#struct-stdexperimentalnoop95coroutine95promise","text":"Class List > std > experimental > noop_coroutine_promise The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct std::experimental::noop_coroutine_promise"},{"location":"test_8cpp/","text":"File test.cpp \u00b6 File List > external > guideline > tests > test.cpp Go to the source code of this file. #include <catch/catch.hpp> Macros \u00b6 Type Name define CATCH_CONFIG_MAIN Macro Definition Documentation \u00b6 define CATCH_CONFIG_MAIN \u00b6 #define CATCH_CONFIG_MAIN The documentation for this class was generated from the following file external/guideline/tests/test.cpp","title":"File test.cpp"},{"location":"test_8cpp/#file-testcpp","text":"File List > external > guideline > tests > test.cpp Go to the source code of this file. #include <catch/catch.hpp>","title":"File test.cpp"},{"location":"test_8cpp/#macros","text":"Type Name define CATCH_CONFIG_MAIN","title":"Macros"},{"location":"test_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"test_8cpp/#define-catch95config95main","text":"#define CATCH_CONFIG_MAIN The documentation for this class was generated from the following file external/guideline/tests/test.cpp","title":"define CATCH_CONFIG_MAIN"},{"location":"test_8cpp_source/","text":"File test.cpp \u00b6 File List > external > guideline > tests > test.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #define CATCH_CONFIG_MAIN #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #include <CodeAnalysis/Warnings.h> #pragma warning(disable : ALL_CODE_ANALYSIS_WARNINGS) // from catch #endif // _MSC_VER #include <catch/catch.hpp>","title":"File test.cpp"},{"location":"test_8cpp_source/#file-testcpp","text":"File List > external > guideline > tests > test.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #define CATCH_CONFIG_MAIN #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #include <CodeAnalysis/Warnings.h> #pragma warning(disable : ALL_CODE_ANALYSIS_WARNINGS) // from catch #endif // _MSC_VER #include <catch/catch.hpp>","title":"File test.cpp"},{"location":"thread_2libmain_8cpp/","text":"File libmain.cpp \u00b6 File List > modules > thread > libmain.cpp Go to the source code of this file. Macros \u00b6 Type Name define EPILOGUE __attribute__((destructor)) define PROLOGUE __attribute__((constructor)) Macro Definition Documentation \u00b6 define EPILOGUE \u00b6 #define EPILOGUE __attribute__((destructor)) define PROLOGUE \u00b6 #define PROLOGUE __attribute__((constructor)) The documentation for this class was generated from the following file modules/thread/libmain.cpp","title":"File libmain.cpp"},{"location":"thread_2libmain_8cpp/#file-libmaincpp","text":"File List > modules > thread > libmain.cpp Go to the source code of this file.","title":"File libmain.cpp"},{"location":"thread_2libmain_8cpp/#macros","text":"Type Name define EPILOGUE __attribute__((destructor)) define PROLOGUE __attribute__((constructor))","title":"Macros"},{"location":"thread_2libmain_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"thread_2libmain_8cpp/#define-epilogue","text":"#define EPILOGUE __attribute__((destructor))","title":"define EPILOGUE"},{"location":"thread_2libmain_8cpp/#define-prologue","text":"#define PROLOGUE __attribute__((constructor)) The documentation for this class was generated from the following file modules/thread/libmain.cpp","title":"define PROLOGUE"},{"location":"thread_2libmain_8cpp_source/","text":"File libmain.cpp \u00b6 File List > modules > thread > libmain.cpp Go to the documentation of this file. #ifdef _WIN32 #define PROLOGUE #define EPILOGUE #else #define PROLOGUE __attribute__((constructor)) #define EPILOGUE __attribute__((destructor)) #endif #ifdef _WIN32 #include <Windows.h> // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx BOOL WINAPI DllMain ( HINSTANCE , DWORD , LPVOID ) noexcept { return TRUE ; } #endif","title":"File libmain.cpp"},{"location":"thread_2libmain_8cpp_source/#file-libmaincpp","text":"File List > modules > thread > libmain.cpp Go to the documentation of this file. #ifdef _WIN32 #define PROLOGUE #define EPILOGUE #else #define PROLOGUE __attribute__((constructor)) #define EPILOGUE __attribute__((destructor)) #endif #ifdef _WIN32 #include <Windows.h> // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx BOOL WINAPI DllMain ( HINSTANCE , DWORD , LPVOID ) noexcept { return TRUE ; } #endif","title":"File libmain.cpp"},{"location":"thread_8h/","text":"File thread.h \u00b6 File List > coroutine > thread.h Go to the source code of this file. #include <system_error> Macros \u00b6 Type Name define COROUTINE_THREAD_UTILITY_H Macro Definition Documentation \u00b6 define COROUTINE_THREAD_UTILITY_H \u00b6 #define COROUTINE_THREAD_UTILITY_H The documentation for this class was generated from the following file interface/coroutine/thread.h","title":"File thread.h"},{"location":"thread_8h/#file-threadh","text":"File List > coroutine > thread.h Go to the source code of this file. #include <system_error>","title":"File thread.h"},{"location":"thread_8h/#macros","text":"Type Name define COROUTINE_THREAD_UTILITY_H","title":"Macros"},{"location":"thread_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"thread_8h/#define-coroutine95thread95utility95h","text":"#define COROUTINE_THREAD_UTILITY_H The documentation for this class was generated from the following file interface/coroutine/thread.h","title":"define COROUTINE_THREAD_UTILITY_H"},{"location":"thread_8h_source/","text":"File thread.h \u00b6 File List > coroutine > thread.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once // clang-format off #if defined(FORCE_STATIC_LINK) # define _INTERFACE_ # define _HIDDEN_ #elif defined(_MSC_VER) // MSVC or clang-cl # define _HIDDEN_ # ifdef _WINDLL # define _INTERFACE_ __declspec(dllexport) # else # define _INTERFACE_ __declspec(dllimport) # endif #elif defined(__GNUC__) || defined(__clang__) # define _INTERFACE_ __attribute__((visibility(\"default\"))) # define _HIDDEN_ __attribute__((visibility(\"hidden\"))) #else # error \"unexpected linking configuration\" #endif // clang-format on #ifndef COROUTINE_THREAD_UTILITY_H #define COROUTINE_THREAD_UTILITY_H #include <system_error> #if __has_include(<coroutine>) // C++ 20 #include <coroutine> #elif __has_include(<coroutine/frame.h>) #include <coroutine/frame.h> #elif __has_include(<experimental/coroutine>) // C++ 17 #include <experimental/coroutine> #else #error \"expect header <experimental/coroutine> or <coroutine/frame.h>\" #endif #if __has_include(<threadpoolapiset.h>) #include <Windows.h> #include <threadpoolapiset.h> namespace coro { using namespace std ; using namespace std :: experimental ; // Move into the win32 thread pool and continue the routine class ptp_work final { // Callback for CreateThreadpoolWork static void __stdcall resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); _INTERFACE_ auto create_and_submit_work ( coroutine_handle < void > ) noexcept -> uint32_t ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { // nothing to do for this implementation } // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = create_and_submit_work ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; // Move into the designated thread's APC queue and and continue the routine class procedure_call_on final { // Callback for QueueUserAPC static void __stdcall resume_on_apc ( ULONG_PTR ); _INTERFACE_ auto queue_user_apc ( coroutine_handle < void > ) noexcept -> uint32_t ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = queue_user_apc ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"QueueUserAPC\" }; } public : explicit procedure_call_on ( HANDLE hThread ) noexcept : thread { hThread } { } private : HANDLE thread ; }; } // namespace coro #elif __has_include(<pthread.h>) #include <pthread.h> namespace coro { using namespace std ; using namespace std :: experimental ; // Creates a new POSIX Thread and resume the given coroutine handle on it. class pthread_spawner_t { _INTERFACE_ void resume_on_pthread ( coroutine_handle < void > rh ) noexcept ( false ); public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { return resume_on_pthread ( rh ); } public : pthread_spawner_t ( pthread_t * _tid , // const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr } { } ~ pthread_spawner_t () noexcept = default ; private : pthread_t * const tid ; const pthread_attr_t * const attr ; }; // Works like the `ptp_work` of win32 based interface, but rely on the pthread class ptp_work final : public pthread_spawner_t { pthread_t tid ; public : ptp_work () noexcept : pthread_spawner_t { & tid , nullptr }, tid {} {}; }; // This is a special promise type which allows `pthread_attr_t*` as an // operand of `co_await` operator. // The type wraps `pthread_create` function. After spawn, it contains thread id // of the brand-new thread. class pthread_spawn_promise { public : pthread_t tid {}; public : auto initial_suspend () noexcept { return suspend_never {}; } void unhandled_exception () noexcept ( false ) { throw ; // the activator is responsible for the exception handling } auto await_transform ( const pthread_attr_t * attr ) noexcept ( false ) { if ( tid ) // already created. throw logic_error { \"pthread's spawn must be used once\" }; // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } // general co_await template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; // A proxy to `pthread_spawn_promise`. // The type must ensure the promise contains a valid `pthread_t` when it is // constructed. class pthread_knower_t { public : operator pthread_t () const noexcept { // we can access to the `tid` through the pointer return promise -> tid ; } protected : explicit pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept : promise { _promise } { } protected : pthread_spawn_promise * promise ; }; // Special return type that wraps `pthread_join` class pthread_joiner_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : auto final_suspend () noexcept { return suspend_always {}; } void return_void () noexcept { // we already returns coroutine's frame. // so `co_return` can't have its operand } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : // throws `system_error` _INTERFACE_ void try_join () noexcept ( false ); public : ~ pthread_joiner_t () noexcept ( false ) { this -> try_join (); } // throws `invalid_argument` for `nullptr` _INTERFACE_ pthread_joiner_t ( promise_type * p ) noexcept ( false ); }; // Special return type that wraps `pthread_detach` class pthread_detacher_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : // detacher doesn't care about the coroutine frame's life cycle // it does nothing after `co_return` auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : // throws `system_error` _INTERFACE_ void try_detach () noexcept ( false ); public : ~ pthread_detacher_t () noexcept ( false ) { this -> try_detach (); } // throws `invalid_argument` for `nullptr` _INTERFACE_ pthread_detacher_t ( promise_type * p ) noexcept ( false ); }; } // namespace coro #endif #endif // COROUTINE_THREAD_UTILITY_H","title":"File thread.h"},{"location":"thread_8h_source/#file-threadh","text":"File List > coroutine > thread.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #pragma once // clang-format off #if defined(FORCE_STATIC_LINK) # define _INTERFACE_ # define _HIDDEN_ #elif defined(_MSC_VER) // MSVC or clang-cl # define _HIDDEN_ # ifdef _WINDLL # define _INTERFACE_ __declspec(dllexport) # else # define _INTERFACE_ __declspec(dllimport) # endif #elif defined(__GNUC__) || defined(__clang__) # define _INTERFACE_ __attribute__((visibility(\"default\"))) # define _HIDDEN_ __attribute__((visibility(\"hidden\"))) #else # error \"unexpected linking configuration\" #endif // clang-format on #ifndef COROUTINE_THREAD_UTILITY_H #define COROUTINE_THREAD_UTILITY_H #include <system_error> #if __has_include(<coroutine>) // C++ 20 #include <coroutine> #elif __has_include(<coroutine/frame.h>) #include <coroutine/frame.h> #elif __has_include(<experimental/coroutine>) // C++ 17 #include <experimental/coroutine> #else #error \"expect header <experimental/coroutine> or <coroutine/frame.h>\" #endif #if __has_include(<threadpoolapiset.h>) #include <Windows.h> #include <threadpoolapiset.h> namespace coro { using namespace std ; using namespace std :: experimental ; // Move into the win32 thread pool and continue the routine class ptp_work final { // Callback for CreateThreadpoolWork static void __stdcall resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); _INTERFACE_ auto create_and_submit_work ( coroutine_handle < void > ) noexcept -> uint32_t ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { // nothing to do for this implementation } // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = create_and_submit_work ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; // Move into the designated thread's APC queue and and continue the routine class procedure_call_on final { // Callback for QueueUserAPC static void __stdcall resume_on_apc ( ULONG_PTR ); _INTERFACE_ auto queue_user_apc ( coroutine_handle < void > ) noexcept -> uint32_t ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = queue_user_apc ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"QueueUserAPC\" }; } public : explicit procedure_call_on ( HANDLE hThread ) noexcept : thread { hThread } { } private : HANDLE thread ; }; } // namespace coro #elif __has_include(<pthread.h>) #include <pthread.h> namespace coro { using namespace std ; using namespace std :: experimental ; // Creates a new POSIX Thread and resume the given coroutine handle on it. class pthread_spawner_t { _INTERFACE_ void resume_on_pthread ( coroutine_handle < void > rh ) noexcept ( false ); public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { return resume_on_pthread ( rh ); } public : pthread_spawner_t ( pthread_t * _tid , // const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr } { } ~ pthread_spawner_t () noexcept = default ; private : pthread_t * const tid ; const pthread_attr_t * const attr ; }; // Works like the `ptp_work` of win32 based interface, but rely on the pthread class ptp_work final : public pthread_spawner_t { pthread_t tid ; public : ptp_work () noexcept : pthread_spawner_t { & tid , nullptr }, tid {} {}; }; // This is a special promise type which allows `pthread_attr_t*` as an // operand of `co_await` operator. // The type wraps `pthread_create` function. After spawn, it contains thread id // of the brand-new thread. class pthread_spawn_promise { public : pthread_t tid {}; public : auto initial_suspend () noexcept { return suspend_never {}; } void unhandled_exception () noexcept ( false ) { throw ; // the activator is responsible for the exception handling } auto await_transform ( const pthread_attr_t * attr ) noexcept ( false ) { if ( tid ) // already created. throw logic_error { \"pthread's spawn must be used once\" }; // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } // general co_await template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; // A proxy to `pthread_spawn_promise`. // The type must ensure the promise contains a valid `pthread_t` when it is // constructed. class pthread_knower_t { public : operator pthread_t () const noexcept { // we can access to the `tid` through the pointer return promise -> tid ; } protected : explicit pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept : promise { _promise } { } protected : pthread_spawn_promise * promise ; }; // Special return type that wraps `pthread_join` class pthread_joiner_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : auto final_suspend () noexcept { return suspend_always {}; } void return_void () noexcept { // we already returns coroutine's frame. // so `co_return` can't have its operand } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : // throws `system_error` _INTERFACE_ void try_join () noexcept ( false ); public : ~ pthread_joiner_t () noexcept ( false ) { this -> try_join (); } // throws `invalid_argument` for `nullptr` _INTERFACE_ pthread_joiner_t ( promise_type * p ) noexcept ( false ); }; // Special return type that wraps `pthread_detach` class pthread_detacher_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : // detacher doesn't care about the coroutine frame's life cycle // it does nothing after `co_return` auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : // throws `system_error` _INTERFACE_ void try_detach () noexcept ( false ); public : ~ pthread_detacher_t () noexcept ( false ) { this -> try_detach (); } // throws `invalid_argument` for `nullptr` _INTERFACE_ pthread_detacher_t ( promise_type * p ) noexcept ( false ); }; } // namespace coro #endif #endif // COROUTINE_THREAD_UTILITY_H","title":"File thread.h"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/","text":"Union std::experimental::coroutine_handle< void >::prefix_t \u00b6 Class List > std > experimental > coroutine_handle< void > > prefix_t Public Attributes \u00b6 Type Name clang_frame_prefix * c gcc_frame_prefix * g msvc_frame_prefix * m void * v = {} Public Attributes Documentation \u00b6 variable c \u00b6 clang_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: c ; variable g \u00b6 gcc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: g ; variable m \u00b6 msvc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: m ; variable v \u00b6 void * std :: experimental :: coroutine_handle < void >:: prefix_t :: v ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Union std::experimental::coroutine\\_handle&lt; void &gt;::prefix\\_t"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#union-stdexperimentalcoroutine95handle-void-prefix95t","text":"Class List > std > experimental > coroutine_handle< void > > prefix_t","title":"Union std::experimental::coroutine_handle&lt; void &gt;::prefix_t"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#public-attributes","text":"Type Name clang_frame_prefix * c gcc_frame_prefix * g msvc_frame_prefix * m void * v = {}","title":"Public Attributes"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-c","text":"clang_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: c ;","title":"variable c"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-g","text":"gcc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: g ;","title":"variable g"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-m","text":"msvc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: m ;","title":"variable m"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-v","text":"void * std :: experimental :: coroutine_handle < void >:: prefix_t :: v ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable v"},{"location":"utils__tests_8cpp/","text":"File utils_tests.cpp \u00b6 File List > external > guideline > tests > utils_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_util> #include <algorithm> #include <functional> #include <limits> #include <stdint.h> #include <type_traits> Public Static Attributes \u00b6 Type Name int j = = 0 Public Functions \u00b6 Type Name GSL_SUPPRESS (con. 4) TEST_CASE (\"sanity check for gsl::index typedef\") TEST_CASE (\"finally_lambda\") TEST_CASE (\"finally_lambda_move\") TEST_CASE (\"finally_function_with_bind\") TEST_CASE (\"finally_function_ptr\") void f (int & i) void g () Public Static Attributes Documentation \u00b6 variable j \u00b6 int j ; Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 GSL_SUPPRESS ( con . 4 ) function TEST_CASE \u00b6 TEST_CASE ( \"sanity check for gsl::index typedef\" ) function TEST_CASE \u00b6 TEST_CASE ( \"finally_lambda\" ) function TEST_CASE \u00b6 TEST_CASE ( \"finally_lambda_move\" ) function TEST_CASE \u00b6 TEST_CASE ( \"finally_function_with_bind\" ) function TEST_CASE \u00b6 TEST_CASE ( \"finally_function_ptr\" ) function f \u00b6 void f ( int & i ) function g \u00b6 void g () The documentation for this class was generated from the following file external/guideline/tests/utils_tests.cpp","title":"File utils\\_tests.cpp"},{"location":"utils__tests_8cpp/#file-utils95testscpp","text":"File List > external > guideline > tests > utils_tests.cpp Go to the source code of this file. #include <catch/catch.hpp> #include <gsl/gsl_util> #include <algorithm> #include <functional> #include <limits> #include <stdint.h> #include <type_traits>","title":"File utils_tests.cpp"},{"location":"utils__tests_8cpp/#public-static-attributes","text":"Type Name int j = = 0","title":"Public Static Attributes"},{"location":"utils__tests_8cpp/#public-functions","text":"Type Name GSL_SUPPRESS (con. 4) TEST_CASE (\"sanity check for gsl::index typedef\") TEST_CASE (\"finally_lambda\") TEST_CASE (\"finally_lambda_move\") TEST_CASE (\"finally_function_with_bind\") TEST_CASE (\"finally_function_ptr\") void f (int & i) void g ()","title":"Public Functions"},{"location":"utils__tests_8cpp/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"utils__tests_8cpp/#variable-j","text":"int j ;","title":"variable j"},{"location":"utils__tests_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"utils__tests_8cpp/#function-gsl95suppress","text":"GSL_SUPPRESS ( con . 4 )","title":"function GSL_SUPPRESS"},{"location":"utils__tests_8cpp/#function-test95case","text":"TEST_CASE ( \"sanity check for gsl::index typedef\" )","title":"function TEST_CASE"},{"location":"utils__tests_8cpp/#function-test95case_1","text":"TEST_CASE ( \"finally_lambda\" )","title":"function TEST_CASE"},{"location":"utils__tests_8cpp/#function-test95case_2","text":"TEST_CASE ( \"finally_lambda_move\" )","title":"function TEST_CASE"},{"location":"utils__tests_8cpp/#function-test95case_3","text":"TEST_CASE ( \"finally_function_with_bind\" )","title":"function TEST_CASE"},{"location":"utils__tests_8cpp/#function-test95case_4","text":"TEST_CASE ( \"finally_function_ptr\" )","title":"function TEST_CASE"},{"location":"utils__tests_8cpp/#function-f","text":"void f ( int & i )","title":"function f"},{"location":"utils__tests_8cpp/#function-g","text":"void g () The documentation for this class was generated from the following file external/guideline/tests/utils_tests.cpp","title":"function g"},{"location":"utils__tests_8cpp_source/","text":"File utils_tests.cpp \u00b6 File List > external > guideline > tests > utils_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/gsl_util> // for narrow, finally, narrow_cast, narrowing_e... #include <algorithm> // for move #include <functional> // for reference_wrapper, _Bind_helper<>::type #include <limits> // for numeric_limits #include <stdint.h> // for uint32_t, int32_t #include <type_traits> // for is_same using namespace gsl ; TEST_CASE ( \"sanity check for gsl::index typedef\" ) { static_assert ( std :: is_same < gsl :: index , std :: ptrdiff_t >:: value , \"gsl::index represents wrong arithmetic type\" ); } void f ( int & i ) { i += 1 ; } TEST_CASE ( \"finally_lambda\" ) { int i = 0 ; { auto _ = finally ([ & ]() { f ( i ); }); CHECK ( i == 0 ); } CHECK ( i == 1 ); } TEST_CASE ( \"finally_lambda_move\" ) { int i = 0 ; { auto _1 = finally ([ & ]() { f ( i ); }); { auto _2 = std :: move ( _1 ); CHECK ( i == 0 ); } CHECK ( i == 1 ); { auto _2 = std :: move ( _1 ); CHECK ( i == 1 ); } CHECK ( i == 1 ); } CHECK ( i == 1 ); } TEST_CASE ( \"finally_function_with_bind\" ) { int i = 0 ; { auto _ = finally ( std :: bind ( & f , std :: ref ( i ))); CHECK ( i == 0 ); } CHECK ( i == 1 ); } static int j = 0 ; void g () { j += 1 ; } TEST_CASE ( \"finally_function_ptr\" ) { j = 0 ; { auto _ = finally ( & g ); CHECK ( j == 0 ); } CHECK ( j == 1 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"narrow_cast\" ) { int n = 120 ; char c = narrow_cast < char > ( n ); CHECK ( c == 120 ); n = 300 ; unsigned char uc = narrow_cast < unsigned char > ( n ); CHECK ( uc == 44 ); } GSL_SUPPRESS ( con .5 ) // NO-FORMAT: attribute TEST_CASE ( \"narrow\" ) { int n = 120 ; const char c = narrow < char > ( n ); CHECK ( c == 120 ); n = 300 ; CHECK_THROWS_AS ( narrow < char > ( n ), narrowing_error ); const auto int32_max = std :: numeric_limits < int32_t >:: max (); const auto int32_min = std :: numeric_limits < int32_t >:: min (); CHECK ( narrow < uint32_t > ( int32_t ( 0 )) == 0 ); CHECK ( narrow < uint32_t > ( int32_t ( 1 )) == 1 ); CHECK ( narrow < uint32_t > ( int32_max ) == static_cast < uint32_t > ( int32_max )); CHECK_THROWS_AS ( narrow < uint32_t > ( int32_t ( - 1 )), narrowing_error ); CHECK_THROWS_AS ( narrow < uint32_t > ( int32_min ), narrowing_error ); n = - 42 ; CHECK_THROWS_AS ( narrow < unsigned > ( n ), narrowing_error ); #if GSL_CONSTEXPR_NARROW static_assert ( narrow < char > ( 120 ) == 120 , \"Fix GSL_CONSTEXPR_NARROW\" ); #endif }","title":"File utils\\_tests.cpp"},{"location":"utils__tests_8cpp_source/#file-utils95testscpp","text":"File List > external > guideline > tests > utils_tests.cpp Go to the documentation of this file. // // Copyright (c) 2015 Microsoft Corporation. All rights reserved. // // This code is licensed under the MIT License (MIT). // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE. // #ifdef _MSC_VER // blanket turn off warnings from CppCoreCheck from catch // so people aren't annoyed by them when running the tool. #pragma warning(disable : 26440 26426) // from catch #endif #include <catch/catch.hpp> // for AssertionHandler, StringRef, CHECK, TEST_... #include <gsl/gsl_util> // for narrow, finally, narrow_cast, narrowing_e... #include <algorithm> // for move #include <functional> // for reference_wrapper, _Bind_helper<>::type #include <limits> // for numeric_limits #include <stdint.h> // for uint32_t, int32_t #include <type_traits> // for is_same using namespace gsl ; TEST_CASE ( \"sanity check for gsl::index typedef\" ) { static_assert ( std :: is_same < gsl :: index , std :: ptrdiff_t >:: value , \"gsl::index represents wrong arithmetic type\" ); } void f ( int & i ) { i += 1 ; } TEST_CASE ( \"finally_lambda\" ) { int i = 0 ; { auto _ = finally ([ & ]() { f ( i ); }); CHECK ( i == 0 ); } CHECK ( i == 1 ); } TEST_CASE ( \"finally_lambda_move\" ) { int i = 0 ; { auto _1 = finally ([ & ]() { f ( i ); }); { auto _2 = std :: move ( _1 ); CHECK ( i == 0 ); } CHECK ( i == 1 ); { auto _2 = std :: move ( _1 ); CHECK ( i == 1 ); } CHECK ( i == 1 ); } CHECK ( i == 1 ); } TEST_CASE ( \"finally_function_with_bind\" ) { int i = 0 ; { auto _ = finally ( std :: bind ( & f , std :: ref ( i ))); CHECK ( i == 0 ); } CHECK ( i == 1 ); } static int j = 0 ; void g () { j += 1 ; } TEST_CASE ( \"finally_function_ptr\" ) { j = 0 ; { auto _ = finally ( & g ); CHECK ( j == 0 ); } CHECK ( j == 1 ); } GSL_SUPPRESS ( con .4 ) // NO-FORMAT: attribute TEST_CASE ( \"narrow_cast\" ) { int n = 120 ; char c = narrow_cast < char > ( n ); CHECK ( c == 120 ); n = 300 ; unsigned char uc = narrow_cast < unsigned char > ( n ); CHECK ( uc == 44 ); } GSL_SUPPRESS ( con .5 ) // NO-FORMAT: attribute TEST_CASE ( \"narrow\" ) { int n = 120 ; const char c = narrow < char > ( n ); CHECK ( c == 120 ); n = 300 ; CHECK_THROWS_AS ( narrow < char > ( n ), narrowing_error ); const auto int32_max = std :: numeric_limits < int32_t >:: max (); const auto int32_min = std :: numeric_limits < int32_t >:: min (); CHECK ( narrow < uint32_t > ( int32_t ( 0 )) == 0 ); CHECK ( narrow < uint32_t > ( int32_t ( 1 )) == 1 ); CHECK ( narrow < uint32_t > ( int32_max ) == static_cast < uint32_t > ( int32_max )); CHECK_THROWS_AS ( narrow < uint32_t > ( int32_t ( - 1 )), narrowing_error ); CHECK_THROWS_AS ( narrow < uint32_t > ( int32_min ), narrowing_error ); n = - 42 ; CHECK_THROWS_AS ( narrow < unsigned > ( n ), narrowing_error ); #if GSL_CONSTEXPR_NARROW static_assert ( narrow < char > ( 120 ) == 120 , \"Fix GSL_CONSTEXPR_NARROW\" ); #endif }","title":"File utils_tests.cpp"},{"location":"variables/","text":"Variables \u00b6 a \u00b6 av ( multi_span_tests.cpp , strided_span_tests.cpp ) aligned_size_v ( frame.h ) b \u00b6 bounds ( strided_span_tests.cpp ) c \u00b6 check_sum ( multi_span_tests.cpp ) d \u00b6 dynamic_range ( multi_span_tests.cpp , strided_span_tests.cpp ) i \u00b6 info_arch ( CMakeCXXCompilerId.cpp ) info_compiler ( CMakeCXXCompilerId.cpp ) info_language_dialect_default ( CMakeCXXCompilerId.cpp ) info_platform ( CMakeCXXCompilerId.cpp ) i ( strided_span_tests.cpp ) idx ( strided_span_tests.cpp ) j \u00b6 j ( utils_tests.cpp ) s \u00b6 section ( multi_span_tests.cpp , strided_span_tests.cpp ) sum ( multi_span_tests.cpp )","title":"Variables"},{"location":"variables/#variables","text":"","title":"Variables"},{"location":"variables/#a","text":"av ( multi_span_tests.cpp , strided_span_tests.cpp ) aligned_size_v ( frame.h )","title":"a"},{"location":"variables/#b","text":"bounds ( strided_span_tests.cpp )","title":"b"},{"location":"variables/#c","text":"check_sum ( multi_span_tests.cpp )","title":"c"},{"location":"variables/#d","text":"dynamic_range ( multi_span_tests.cpp , strided_span_tests.cpp )","title":"d"},{"location":"variables/#i","text":"info_arch ( CMakeCXXCompilerId.cpp ) info_compiler ( CMakeCXXCompilerId.cpp ) info_language_dialect_default ( CMakeCXXCompilerId.cpp ) info_platform ( CMakeCXXCompilerId.cpp ) i ( strided_span_tests.cpp ) idx ( strided_span_tests.cpp )","title":"i"},{"location":"variables/#j","text":"j ( utils_tests.cpp )","title":"j"},{"location":"variables/#s","text":"section ( multi_span_tests.cpp , strided_span_tests.cpp ) sum ( multi_span_tests.cpp )","title":"s"},{"location":"win32__thread__pool_8cpp/","text":"File win32_thread_pool.cpp \u00b6 File List > modules > thread > win32_thread_pool.cpp Go to the source code of this file. #include <coroutine/thread.h> #include <coroutine/yield.hpp> #include <gsl/gsl> #include <TlHelp32.h> #include <synchapi.h> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/thread/win32_thread_pool.cpp","title":"File win32\\_thread\\_pool.cpp"},{"location":"win32__thread__pool_8cpp/#file-win3295thread95poolcpp","text":"File List > modules > thread > win32_thread_pool.cpp Go to the source code of this file. #include <coroutine/thread.h> #include <coroutine/yield.hpp> #include <gsl/gsl> #include <TlHelp32.h> #include <synchapi.h>","title":"File win32_thread_pool.cpp"},{"location":"win32__thread__pool_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/thread/win32_thread_pool.cpp","title":"Namespaces"},{"location":"win32__thread__pool_8cpp_source/","text":"File win32_thread_pool.cpp \u00b6 File List > modules > thread > win32_thread_pool.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/thread.h> #include <coroutine/yield.hpp> #include <gsl/gsl> #include <TlHelp32.h> #include <synchapi.h> //#include <threadpoolapiset.h> namespace coro { auto get_threads_of ( DWORD pid ) noexcept ( false ) -> enumerable < DWORD > { // for current process auto snapshot = CreateToolhelp32Snapshot ( TH32CS_SNAPTHREAD , 0 ); if ( snapshot == INVALID_HANDLE_VALUE ) co_return ; auto h = gsl :: finally ([ = ]() noexcept { CloseHandle ( snapshot ); }); THREADENTRY32 entry {}; entry . dwSize = sizeof ( THREADENTRY32 ); for ( Thread32First ( snapshot , & entry ); Thread32Next ( snapshot , & entry );) { // filter other process's threads if ( entry . th32OwnerProcessID != pid ) co_yield entry . th32ThreadID ; entry . dwSize = sizeof ( THREADENTRY32 ); } } GSL_SUPPRESS ( con .4 ) void ptp_work :: resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , // PVOID ctx , PTP_WORK work ) { if ( auto coro = coroutine_handle < void >:: from_address ( ctx )) if ( coro . done () == false ) coro . resume (); :: CloseThreadpoolWork ( work ); // one-time work item } auto ptp_work :: create_and_submit_work ( coroutine_handle < void > coro ) noexcept -> uint32_t { // just make sure no data loss in `static_cast` static_assert ( sizeof ( uint32_t ) == sizeof ( DWORD )); auto work = :: CreateThreadpoolWork ( resume_on_thread_pool , coro . address (), nullptr ); if ( work == nullptr ) return GetLastError (); SubmitThreadpoolWork ( work ); return S_OK ; } GSL_SUPPRESS ( type .1 ) void procedure_call_on :: resume_on_apc ( ULONG_PTR param ) { auto ptr = reinterpret_cast < void *> ( param ); if ( auto coro = coroutine_handle < void >:: from_address ( ptr )) coro . resume (); } GSL_SUPPRESS ( type .1 ) auto procedure_call_on :: queue_user_apc ( coroutine_handle < void > coro ) noexcept -> uint32_t { const auto param = reinterpret_cast < ULONG_PTR > ( coro . address ()); if ( QueueUserAPC ( resume_on_apc , this -> thread , param ) == 0 ) return GetLastError (); return S_OK ; } } // namespace coro","title":"File win32\\_thread\\_pool.cpp"},{"location":"win32__thread__pool_8cpp_source/#file-win3295thread95poolcpp","text":"File List > modules > thread > win32_thread_pool.cpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // #include <coroutine/thread.h> #include <coroutine/yield.hpp> #include <gsl/gsl> #include <TlHelp32.h> #include <synchapi.h> //#include <threadpoolapiset.h> namespace coro { auto get_threads_of ( DWORD pid ) noexcept ( false ) -> enumerable < DWORD > { // for current process auto snapshot = CreateToolhelp32Snapshot ( TH32CS_SNAPTHREAD , 0 ); if ( snapshot == INVALID_HANDLE_VALUE ) co_return ; auto h = gsl :: finally ([ = ]() noexcept { CloseHandle ( snapshot ); }); THREADENTRY32 entry {}; entry . dwSize = sizeof ( THREADENTRY32 ); for ( Thread32First ( snapshot , & entry ); Thread32Next ( snapshot , & entry );) { // filter other process's threads if ( entry . th32OwnerProcessID != pid ) co_yield entry . th32ThreadID ; entry . dwSize = sizeof ( THREADENTRY32 ); } } GSL_SUPPRESS ( con .4 ) void ptp_work :: resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , // PVOID ctx , PTP_WORK work ) { if ( auto coro = coroutine_handle < void >:: from_address ( ctx )) if ( coro . done () == false ) coro . resume (); :: CloseThreadpoolWork ( work ); // one-time work item } auto ptp_work :: create_and_submit_work ( coroutine_handle < void > coro ) noexcept -> uint32_t { // just make sure no data loss in `static_cast` static_assert ( sizeof ( uint32_t ) == sizeof ( DWORD )); auto work = :: CreateThreadpoolWork ( resume_on_thread_pool , coro . address (), nullptr ); if ( work == nullptr ) return GetLastError (); SubmitThreadpoolWork ( work ); return S_OK ; } GSL_SUPPRESS ( type .1 ) void procedure_call_on :: resume_on_apc ( ULONG_PTR param ) { auto ptr = reinterpret_cast < void *> ( param ); if ( auto coro = coroutine_handle < void >:: from_address ( ptr )) coro . resume (); } GSL_SUPPRESS ( type .1 ) auto procedure_call_on :: queue_user_apc ( coroutine_handle < void > coro ) noexcept -> uint32_t { const auto param = reinterpret_cast < ULONG_PTR > ( coro . address ()); if ( QueueUserAPC ( resume_on_apc , this -> thread , param ) == 0 ) return GetLastError (); return S_OK ; } } // namespace coro","title":"File win32_thread_pool.cpp"},{"location":"work-in-progress/","text":"","title":"Work in progress"},{"location":"yield_8hpp/","text":"File yield.hpp \u00b6 File List > coroutine > yield.hpp Go to the source code of this file. #include <coroutine/return.h> #include <iterator> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class enumerable <T> class iterator class promise_type The documentation for this class was generated from the following file interface/coroutine/yield.hpp","title":"File yield.hpp"},{"location":"yield_8hpp/#file-yieldhpp","text":"File List > coroutine > yield.hpp Go to the source code of this file. #include <coroutine/return.h> #include <iterator>","title":"File yield.hpp"},{"location":"yield_8hpp/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"yield_8hpp/#classes","text":"Type Name class enumerable <T> class iterator class promise_type The documentation for this class was generated from the following file interface/coroutine/yield.hpp","title":"Classes"},{"location":"yield_8hpp_source/","text":"File yield.hpp \u00b6 File List > coroutine > yield.hpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // `enumerable` is simply a copy of `generator` in VC++ // #ifndef COROUTINE_YIELD_HPP #define COROUTINE_YIELD_HPP #include <coroutine/return.h> #include <iterator> namespace coro { using namespace std :: experimental ; // <experimental/generator> from the VC++ template < typename T > class enumerable { public : class promise_type ; class iterator ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; private : coroutine_handle < promise_type > coro {}; public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( enumerable && rhs ) noexcept : coro { rhs . coro } { rhs . coro = nullptr ; } enumerable & operator = ( enumerable && rhs ) noexcept { std :: swap ( coro , rhs . coro ); return * this ; } enumerable () noexcept = default ; enumerable ( promise_type * ptr ) noexcept : coro { coroutine_handle < promise_type >:: from_promise ( * ptr )} { } ~ enumerable () noexcept { // enumerable will destroy the frame. // promise/iterator are free from those ownership if ( coro ) coro . destroy (); } public : iterator begin () noexcept ( false ) { if ( coro ) // resumeable? { coro . resume (); if ( coro . done ()) // finished? return iterator { nullptr }; } return iterator { coro }; } iterator end () noexcept { return iterator { nullptr }; } public : class promise_type final : public promise_manual_control { friend class iterator ; friend class enumerable ; pointer current = nullptr ; public : promise_type * get_return_object () noexcept { // enumerable will create coroutine handle from the address return this ; } // `co_yield` expression. for reference auto yield_value ( reference ref ) noexcept { current = std :: addressof ( ref ); return suspend_always {}; } // `co_yield` expression. for r-value auto yield_value ( value_type && v ) noexcept { return yield_value ( v ); } // `co_return` expression void return_void () noexcept { // no more access to value current = nullptr ; } }; class iterator final { public : using iterator_category = std :: forward_iterator_tag ; using difference_type = ptrdiff_t ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; public : coroutine_handle < promise_type > coro ; public : // `enumerable::end()` explicit iterator ( std :: nullptr_t ) noexcept : coro { nullptr } { } // `enumerable::begin()` explicit iterator ( coroutine_handle < promise_type > handle ) noexcept : coro { handle } { } public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ) { coro . resume (); if ( coro . done ()) // enumerable will destroy coro = nullptr ; // the frame later... return * this ; } pointer operator -> () noexcept { pointer ptr = coro . promise (). current ; return ptr ; } reference operator * () noexcept { return * ( this -> operator -> ()); } bool operator == ( const iterator & rhs ) const noexcept { return this -> coro == rhs . coro ; } bool operator != ( const iterator & rhs ) const noexcept { return ! ( * this == rhs ); } }; }; } // namespace coro #endif // COROUTINE_YIELD_HPP","title":"File yield.hpp"},{"location":"yield_8hpp_source/#file-yieldhpp","text":"File List > coroutine > yield.hpp Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // `enumerable` is simply a copy of `generator` in VC++ // #ifndef COROUTINE_YIELD_HPP #define COROUTINE_YIELD_HPP #include <coroutine/return.h> #include <iterator> namespace coro { using namespace std :: experimental ; // <experimental/generator> from the VC++ template < typename T > class enumerable { public : class promise_type ; class iterator ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; private : coroutine_handle < promise_type > coro {}; public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( enumerable && rhs ) noexcept : coro { rhs . coro } { rhs . coro = nullptr ; } enumerable & operator = ( enumerable && rhs ) noexcept { std :: swap ( coro , rhs . coro ); return * this ; } enumerable () noexcept = default ; enumerable ( promise_type * ptr ) noexcept : coro { coroutine_handle < promise_type >:: from_promise ( * ptr )} { } ~ enumerable () noexcept { // enumerable will destroy the frame. // promise/iterator are free from those ownership if ( coro ) coro . destroy (); } public : iterator begin () noexcept ( false ) { if ( coro ) // resumeable? { coro . resume (); if ( coro . done ()) // finished? return iterator { nullptr }; } return iterator { coro }; } iterator end () noexcept { return iterator { nullptr }; } public : class promise_type final : public promise_manual_control { friend class iterator ; friend class enumerable ; pointer current = nullptr ; public : promise_type * get_return_object () noexcept { // enumerable will create coroutine handle from the address return this ; } // `co_yield` expression. for reference auto yield_value ( reference ref ) noexcept { current = std :: addressof ( ref ); return suspend_always {}; } // `co_yield` expression. for r-value auto yield_value ( value_type && v ) noexcept { return yield_value ( v ); } // `co_return` expression void return_void () noexcept { // no more access to value current = nullptr ; } }; class iterator final { public : using iterator_category = std :: forward_iterator_tag ; using difference_type = ptrdiff_t ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; public : coroutine_handle < promise_type > coro ; public : // `enumerable::end()` explicit iterator ( std :: nullptr_t ) noexcept : coro { nullptr } { } // `enumerable::begin()` explicit iterator ( coroutine_handle < promise_type > handle ) noexcept : coro { handle } { } public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ) { coro . resume (); if ( coro . done ()) // enumerable will destroy coro = nullptr ; // the frame later... return * this ; } pointer operator -> () noexcept { pointer ptr = coro . promise (). current ; return ptr ; } reference operator * () noexcept { return * ( this -> operator -> ()); } bool operator == ( const iterator & rhs ) const noexcept { return this -> coro == rhs . coro ; } bool operator != ( const iterator & rhs ) const noexcept { return ! ( * this == rhs ); } }; }; } // namespace coro #endif // COROUTINE_YIELD_HPP","title":"File yield.hpp"},{"location":"articles/awaitable-event/","text":"Awaitable event using the coroutine, epoll , and eventfd \u00b6 commit: ad1e682f The note explains the detail of event in coroutine/concrt.h Summary \u00b6 Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); } Note \u00b6 Motivation \u00b6 It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work. Requirement \u00b6 The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that. Design \u00b6 Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor. Concerns \u00b6 You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() . Implementation \u00b6 Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations Wrapping epoll \u00b6 linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :) Polling epoll \u00b6 linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... } Event interface \u00b6 coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd . Event's state managment \u00b6 Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :) Event's await operations \u00b6 The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Summary for the implementation \u00b6 It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details. Conclusion \u00b6 Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Awaitable event using the coroutine, epoll and eventfd"},{"location":"articles/awaitable-event/#awaitable-event-using-the-coroutine-epoll-and-eventfd","text":"commit: ad1e682f The note explains the detail of event in coroutine/concrt.h","title":"Awaitable event using the coroutine, epoll, and eventfd"},{"location":"articles/awaitable-event/#summary","text":"Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Summary"},{"location":"articles/awaitable-event/#note","text":"","title":"Note"},{"location":"articles/awaitable-event/#motivation","text":"It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work.","title":"Motivation"},{"location":"articles/awaitable-event/#requirement","text":"The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that.","title":"Requirement"},{"location":"articles/awaitable-event/#design","text":"Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor.","title":"Design"},{"location":"articles/awaitable-event/#concerns","text":"You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() .","title":"Concerns"},{"location":"articles/awaitable-event/#implementation","text":"Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations","title":"Implementation"},{"location":"articles/awaitable-event/#wrapping-epoll","text":"linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :)","title":"Wrapping epoll"},{"location":"articles/awaitable-event/#polling-epoll","text":"linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... }","title":"Polling epoll"},{"location":"articles/awaitable-event/#event-interface","text":"coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd .","title":"Event interface"},{"location":"articles/awaitable-event/#events-state-managment","text":"Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :)","title":"Event's state managment"},{"location":"articles/awaitable-event/#events-await-operations","text":"The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } }","title":"Event's await operations"},{"location":"articles/awaitable-event/#summary-for-the-implementation","text":"It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details.","title":"Summary for the implementation"},{"location":"articles/awaitable-event/#conclusion","text":"Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Conclusion"},{"location":"articles/combining-coroutines-and-pthread_create/","text":"Combining C++ Coroutines and pthread_create \u00b6 commit: 93ed8748 Some system functions use callback and an argument in void* type. In this article, I'm going to cover how such functions can be wrapped with co_await The base of examples here is my experience to try something like CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" with the POSIX threads. If you are a beginner, please do read the article about promise_type by Lewiss Baker . The article will enhance your understanding greatly. Creating a new thread \u00b6 Design \u00b6 What I'm going to try is creating a new thread in a simple manner. Traditionally we had to separate the step before/after pthread_create . To do so, we must write an additional function which is executed on the new thread. Like the thread_start in the pthread_create manual . But co_await can glue two routines into one. Let's see how it looks like. void per_thread_task (); auto work_on_new_thread ( pthread_t & tid , const pthread_attr_t * attr ) -> no_return { // this line is executed on the spawner thread co_await spawn_pthread ( tid , attr ); // the function is executed on the pthread with 'tid' per_thread_task (); } Since it's an example, it will be differenct when you have to write for your own. What I want to show here is that the look & feel of the wrapping pattern. Implementation \u00b6 start_routine to resume the coroutine \u00b6 Obviously the most important functions are the life cycle functions. pthread_create pthread_join #include <pthread.h> // create a new thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // join with a terminated thread int pthread_join ( pthread_t thread , void ** retval ); Here, we can control 2 parameters. start_routine to designate a routine for the thread arg to forward an argument to the routine With them we can imagine some code in the system will be like this. void pthread_procedure ( void * out , ...){ // ... PC(Program Counter) jumps to here ... out = start_routine ( arg ); // perform `pthread_exit` ... // deliver 'out' to `pthread_join` or somewhere ... } We will define a simple function for the start_routine . It constructs the coroutine_handle from the arg and then resume it after checking with done . void * resume_on_pthread ( void * ptr ){ // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } Forwarding arg from co_await \u00b6 So to make the function work properly, we have to forward coroutine_handle<void> as an argument of arg . This is easy since there is a member fuction, address . await_suspend will give us the handle like the following code. struct pthread_spawner_t { constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } }; Or if you like the simplicity, you can inherit suspend_always in the std::experimental . #include <experimental/coroutine> using std :: experimental :: suspend_always ; struct pthread_spawner_t : public suspend_always { // hide the function of `suspend_always` ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } }; In the meantime, now we have an awaitable type that creates a new thread. So we can trigger it in 1 line. auto work_on_new_thread () -> no_return { co_await pthread_spawner_t {}; // ... } Concerns \u00b6 You might curious about throw in the second pthread_spawner_t::await_suspend . In general, the function is the last point for the error handling. For our case, suppose that pthread_create failed. The callback resume_on_pthread won't be invoked. That means the coroutine's frame can't be resume d and coverage after co_await is going to be lost. So we have to make caller handle the situation before the coroutine becomes suspended state. One of the way is to throw an exception in await_suspend . Dealing with the thread's join \u00b6 Design \u00b6 Now we have to support join for the thread. pthread_join is so simple that we can't misuse it. What we have care is not the function but the behavior after pthread_join returned without an error. Do you remember that I returned the coroutine frame's address for our start_routine ? void * resume_on_pthread ( void * ptr ){ auto task = coroutine_handle < void >:: from_address ( ptr ); // ... return task . address (); } So in somewhere we have to get the address and destroy it. auto join_and_destroy ( pthread_t tid ){ void * ptr {}; if ( auto ec = pthread_join ( tid , & ptr )) throw system_error { ec , system_category (), \"pthread_join\" }; auto coro = coroutine_handle < void >:: from_address ( ptr ); if ( coro ) coro . destroy (); } But this code is dangerous. The reason is that there is no way to know whether the frame is not destroyed. When the frame is final_suspend ed, we can check it is done() == true and then resume / destroy it. But when the corouitine didn't suspended after final_suspend , its co_return will destroy the frame immediately. So the coro.destroy() above is a double-delete situation. Here, our plan is to provide a special return type which guarantees safe destruction of the frame. Implementation \u00b6 Intend of the final suspension \u00b6 A coroutine's frame is preserved if its coroutine_traits<R>::promise_type does final suspension. That means, it intended manual destruction of the frame, like generator<T> . // From VC++, <experimental/generator> namespace experimental { template < typename _Ty , typename _Alloc = allocator < char >> struct generator { struct promise_type { _Ty const * _CurrentValue ; // ... bool final_suspend () { return ( true ); } // ... }; // ... ~ generator () { if ( _Coro ) { // manual destruction of // the generator coroutine's frame _Coro . destroy (); } } private : coroutine_handle < promise_type > _Coro = nullptr ; }; } // namespace experimental You can see destroy() is invoked in its destructor. We will follow the way. Preserving frame for pthread_join \u00b6 There are 2 things that should be guaranteed. Meet the condition final_suspend == true so pthread_join can receive the destroyable frame Perform destroy after pthread_join Here is the type. It will be a return type for the coroutine which co_await s pthread_spawner_t . class pthread_joiner_t final { public : class promise_type final { public : auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ // preserve the frame after `co_return` return suspend_always {}; } void return_void (){ // we already returns coroutine's frame. // so `co_return` can't have its operand } void unhandled_exception (){ // ... } auto get_return_object () -> promise_type * { return this ; } }; private : pthread_t tid ; public : pthread_joiner_t ( promise_type * ) : tid {} { } ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; So if we use it as a return for the coroutine function, it will be like the following. Review the look and feel with the pthread_spawner_t . auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); // It can be useful if the `joiner` supports `operator pthread_t()` // pthread_t worker_id = joiner; } It seems like we are almost done, but it's not. Concerns \u00b6 You may ask that such design is seriously vulnerable when pthread_exit is used explicitly. My answer for that is, most of pthread_exit 's usage is careful enough. You can note for the dangerous point in your comment, document, or even #warn for the issue. And the users are able to redesign/rewrite their own logic with the note. Context-Aware co_await through await_transform \u00b6 Design \u00b6 auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); } This example looks fine, but it will be more safe when pthread_spawner_t is used if and only if the return type is pthread_joiner_t . Fortuantely C++ Coroutines specifies await_transform which can do the work. So our final goal will be like this. Can you find the difference? auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await attr ; // ... } pthread_attr_t can't work alone since it's a reserved type for the pthread_create . So when there is an instance of it, there must be an intent to create a new thread with it. Therefore co_await on it does express something like \"wait for the thread creation and then ...\". Implementation \u00b6 Pairing pthread_joiner_t with pthread_spawner_t \u00b6 Until now, pthread_spawner_t was an global type that can be used anywhere. The first we have to do is to make it available only when pthread_joiner_t is known. Simply nesting it will do the work. class pthread_joiner_t final { public : class promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { // invoke `pthread_create` ... } void await_resume () noexcept { // nothing to do ... } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; }; Defining await_transform \u00b6 As mentioned above, we will define the await_transform in pthread_joiner_t::promise_type . The role of the function is to transform the operand of co_await to an awaitable type. In this case, the awaitable type is pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; // ... private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; class promise_type final { // ... see 'Preserving frame for `pthread_join`' ... // We can consider the `pthread_attr_t*` as an intent to create a new pthread. // Therefore, `promise_type` will transform the type to `pthread_spawner_t` auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr } } }; // ... same with above ... private : pthread_t tid ; }; By doing so we can achieve our design goal. Because typical return types for the coroutines are not aware of how to co_await on pthread_attr_t . Exposing pthread_t \u00b6 Now the last part is to store the new pthread's id in the pthread_joiner_t . This is what I wrote above. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; private : pthread_t tid ; public : // ... ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; However, we call pthread_create in pthread_spawner_t . So we can say there must be some sharing point to get the valid pthread_t from pthread_joiner_t . class pthread_joiner_t final { public : class pthread_spawner_t final { public : // ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())){ throw system_error { ec , system_category (), \"pthread_create\" }; } } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; // <--- duplicate with that of the `pthread_spawner_t` public : // ... ~ pthread_joiner_t () noexcept ( false ); }; At this moment, we must decide where to place the therad's id. In this code pthread_joiner_t is holding it as a member variable. That's pretty general for most of type for subroutines . Think of the implementation that pthread_spawner_t sends thread's id to pthread_joiner_t . If you decide to do so, you have to write a coroutine that aware of it's activator's address. To be more precise, the address of its return type's object. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // Can we know the address of the returned pthread_joiner_t object ? // Even if that is possible, using the address is a sound design ? } Definatly that will lead to the bad(compex) code. Remember that we are preserving the coroutine frame until pthread_join . In other words, it is a valid behavior to access the frame before we invoke pthread_join . With the point, let's save the thread's id in the coroutine's frame, and access to the memory location when the thread's id is needed. Placing the object in the coroutine's frame isn't that hard. Since the promise_type object is placed in the frame , accessing to it can be done with 1 pointer. I already showed you how to get a ponter to promise_type . Let me show you again. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; class promise_type final { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_always {}; } void unhandled_exception (){ } auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr }; } auto get_return_object () -> promise_type * { return this ; } public : pthread_t tid {}; }; public : // we will receive the pointer from `get_return_object` pthread_joiner_t ( promise_type * p ) : promise { p } { } ~ pthread_joiner_t () noexcept ( false ) { // ... join with the thread id ... // ... destroy the coroutine frame ... } // and we can access to the `tid` through the pointer operator pthread_t () const noexcept { return promise -> tid ; } private : promise_type * const promise ; }; So the last job is to update tid in the promise_type . Let's rewrite the pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; public : constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_create ( this -> tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // ... do nothing ... } private : // receives 2 pointer at once pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr }{ } pthread_t * const tid ; // pointer to the memory location in the promise const pthread_attr_t * const attr ; }; class promise_type final { auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // ... pthread_t tid {}; }; // ... }; Whoa, that was a long run ! Conclusion \u00b6 You can run the example with the WandBox. https://wandbox.org/permlink/qQ1vbwshsoujYnI0 In this article we covered 2 things by wrapping pthread_create for the coroutines step by step. How the awaitable can wrap the system function which uses a callback and it has a void* parameter How to define await_transform and which limitation it makes However, we only wrapped 2 pthread life cycle functions. So if the coroutine invokes pthread_exit instead of co_return , the assumption of the pthread_joiner_t will be broken. What I didn't cover here will be a good coroutine design practice for you. Move/Copy handling of the types The detach of a thread Triggering multiple thread createion for 1 pthread_joiner_t After Note \u00b6 Arthur O'Dwyer let me know how to improve the final(WandBox) example using private constructor. I will cover that in later post. Appreciate for his help and opinions! :D Allowing another awaitable types \u00b6 You may need to define more generic await_transform like this . class pthread_joiner_t final { public : class promise_type final { // the original auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // redirect to const pointer inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } // allow general co_await usage template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; // ... };","title":"Combining C++ coroutines and `pthread_create`"},{"location":"articles/combining-coroutines-and-pthread_create/#combining-c-coroutines-and-pthread_create","text":"commit: 93ed8748 Some system functions use callback and an argument in void* type. In this article, I'm going to cover how such functions can be wrapped with co_await The base of examples here is my experience to try something like CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" with the POSIX threads. If you are a beginner, please do read the article about promise_type by Lewiss Baker . The article will enhance your understanding greatly.","title":"Combining C++ Coroutines and pthread_create"},{"location":"articles/combining-coroutines-and-pthread_create/#creating-a-new-thread","text":"","title":"Creating a new thread"},{"location":"articles/combining-coroutines-and-pthread_create/#design","text":"What I'm going to try is creating a new thread in a simple manner. Traditionally we had to separate the step before/after pthread_create . To do so, we must write an additional function which is executed on the new thread. Like the thread_start in the pthread_create manual . But co_await can glue two routines into one. Let's see how it looks like. void per_thread_task (); auto work_on_new_thread ( pthread_t & tid , const pthread_attr_t * attr ) -> no_return { // this line is executed on the spawner thread co_await spawn_pthread ( tid , attr ); // the function is executed on the pthread with 'tid' per_thread_task (); } Since it's an example, it will be differenct when you have to write for your own. What I want to show here is that the look & feel of the wrapping pattern.","title":"Design"},{"location":"articles/combining-coroutines-and-pthread_create/#implementation","text":"","title":"Implementation"},{"location":"articles/combining-coroutines-and-pthread_create/#start_routine-to-resume-the-coroutine","text":"Obviously the most important functions are the life cycle functions. pthread_create pthread_join #include <pthread.h> // create a new thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // join with a terminated thread int pthread_join ( pthread_t thread , void ** retval ); Here, we can control 2 parameters. start_routine to designate a routine for the thread arg to forward an argument to the routine With them we can imagine some code in the system will be like this. void pthread_procedure ( void * out , ...){ // ... PC(Program Counter) jumps to here ... out = start_routine ( arg ); // perform `pthread_exit` ... // deliver 'out' to `pthread_join` or somewhere ... } We will define a simple function for the start_routine . It constructs the coroutine_handle from the arg and then resume it after checking with done . void * resume_on_pthread ( void * ptr ){ // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); }","title":"start_routine to resume the coroutine"},{"location":"articles/combining-coroutines-and-pthread_create/#forwarding-arg-from-co_await","text":"So to make the function work properly, we have to forward coroutine_handle<void> as an argument of arg . This is easy since there is a member fuction, address . await_suspend will give us the handle like the following code. struct pthread_spawner_t { constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } }; Or if you like the simplicity, you can inherit suspend_always in the std::experimental . #include <experimental/coroutine> using std :: experimental :: suspend_always ; struct pthread_spawner_t : public suspend_always { // hide the function of `suspend_always` ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } }; In the meantime, now we have an awaitable type that creates a new thread. So we can trigger it in 1 line. auto work_on_new_thread () -> no_return { co_await pthread_spawner_t {}; // ... }","title":"Forwarding arg from co_await"},{"location":"articles/combining-coroutines-and-pthread_create/#concerns","text":"You might curious about throw in the second pthread_spawner_t::await_suspend . In general, the function is the last point for the error handling. For our case, suppose that pthread_create failed. The callback resume_on_pthread won't be invoked. That means the coroutine's frame can't be resume d and coverage after co_await is going to be lost. So we have to make caller handle the situation before the coroutine becomes suspended state. One of the way is to throw an exception in await_suspend .","title":"Concerns"},{"location":"articles/combining-coroutines-and-pthread_create/#dealing-with-the-threads-join","text":"","title":"Dealing with the thread's join"},{"location":"articles/combining-coroutines-and-pthread_create/#design_1","text":"Now we have to support join for the thread. pthread_join is so simple that we can't misuse it. What we have care is not the function but the behavior after pthread_join returned without an error. Do you remember that I returned the coroutine frame's address for our start_routine ? void * resume_on_pthread ( void * ptr ){ auto task = coroutine_handle < void >:: from_address ( ptr ); // ... return task . address (); } So in somewhere we have to get the address and destroy it. auto join_and_destroy ( pthread_t tid ){ void * ptr {}; if ( auto ec = pthread_join ( tid , & ptr )) throw system_error { ec , system_category (), \"pthread_join\" }; auto coro = coroutine_handle < void >:: from_address ( ptr ); if ( coro ) coro . destroy (); } But this code is dangerous. The reason is that there is no way to know whether the frame is not destroyed. When the frame is final_suspend ed, we can check it is done() == true and then resume / destroy it. But when the corouitine didn't suspended after final_suspend , its co_return will destroy the frame immediately. So the coro.destroy() above is a double-delete situation. Here, our plan is to provide a special return type which guarantees safe destruction of the frame.","title":"Design"},{"location":"articles/combining-coroutines-and-pthread_create/#implementation_1","text":"","title":"Implementation"},{"location":"articles/combining-coroutines-and-pthread_create/#intend-of-the-final-suspension","text":"A coroutine's frame is preserved if its coroutine_traits<R>::promise_type does final suspension. That means, it intended manual destruction of the frame, like generator<T> . // From VC++, <experimental/generator> namespace experimental { template < typename _Ty , typename _Alloc = allocator < char >> struct generator { struct promise_type { _Ty const * _CurrentValue ; // ... bool final_suspend () { return ( true ); } // ... }; // ... ~ generator () { if ( _Coro ) { // manual destruction of // the generator coroutine's frame _Coro . destroy (); } } private : coroutine_handle < promise_type > _Coro = nullptr ; }; } // namespace experimental You can see destroy() is invoked in its destructor. We will follow the way.","title":"Intend of the final suspension"},{"location":"articles/combining-coroutines-and-pthread_create/#preserving-frame-for-pthread_join","text":"There are 2 things that should be guaranteed. Meet the condition final_suspend == true so pthread_join can receive the destroyable frame Perform destroy after pthread_join Here is the type. It will be a return type for the coroutine which co_await s pthread_spawner_t . class pthread_joiner_t final { public : class promise_type final { public : auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ // preserve the frame after `co_return` return suspend_always {}; } void return_void (){ // we already returns coroutine's frame. // so `co_return` can't have its operand } void unhandled_exception (){ // ... } auto get_return_object () -> promise_type * { return this ; } }; private : pthread_t tid ; public : pthread_joiner_t ( promise_type * ) : tid {} { } ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; So if we use it as a return for the coroutine function, it will be like the following. Review the look and feel with the pthread_spawner_t . auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); // It can be useful if the `joiner` supports `operator pthread_t()` // pthread_t worker_id = joiner; } It seems like we are almost done, but it's not.","title":"Preserving frame for pthread_join"},{"location":"articles/combining-coroutines-and-pthread_create/#concerns_1","text":"You may ask that such design is seriously vulnerable when pthread_exit is used explicitly. My answer for that is, most of pthread_exit 's usage is careful enough. You can note for the dangerous point in your comment, document, or even #warn for the issue. And the users are able to redesign/rewrite their own logic with the note.","title":"Concerns"},{"location":"articles/combining-coroutines-and-pthread_create/#context-aware-co_await-through-await_transform","text":"","title":"Context-Aware co_await through await_transform"},{"location":"articles/combining-coroutines-and-pthread_create/#design_2","text":"auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); } This example looks fine, but it will be more safe when pthread_spawner_t is used if and only if the return type is pthread_joiner_t . Fortuantely C++ Coroutines specifies await_transform which can do the work. So our final goal will be like this. Can you find the difference? auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await attr ; // ... } pthread_attr_t can't work alone since it's a reserved type for the pthread_create . So when there is an instance of it, there must be an intent to create a new thread with it. Therefore co_await on it does express something like \"wait for the thread creation and then ...\".","title":"Design"},{"location":"articles/combining-coroutines-and-pthread_create/#implementation_2","text":"","title":"Implementation"},{"location":"articles/combining-coroutines-and-pthread_create/#pairing-pthread_joiner_t-with-pthread_spawner_t","text":"Until now, pthread_spawner_t was an global type that can be used anywhere. The first we have to do is to make it available only when pthread_joiner_t is known. Simply nesting it will do the work. class pthread_joiner_t final { public : class promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { // invoke `pthread_create` ... } void await_resume () noexcept { // nothing to do ... } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; };","title":"Pairing pthread_joiner_t with pthread_spawner_t"},{"location":"articles/combining-coroutines-and-pthread_create/#defining-await_transform","text":"As mentioned above, we will define the await_transform in pthread_joiner_t::promise_type . The role of the function is to transform the operand of co_await to an awaitable type. In this case, the awaitable type is pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; // ... private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; class promise_type final { // ... see 'Preserving frame for `pthread_join`' ... // We can consider the `pthread_attr_t*` as an intent to create a new pthread. // Therefore, `promise_type` will transform the type to `pthread_spawner_t` auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr } } }; // ... same with above ... private : pthread_t tid ; }; By doing so we can achieve our design goal. Because typical return types for the coroutines are not aware of how to co_await on pthread_attr_t .","title":"Defining await_transform"},{"location":"articles/combining-coroutines-and-pthread_create/#exposing-pthread_t","text":"Now the last part is to store the new pthread's id in the pthread_joiner_t . This is what I wrote above. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; private : pthread_t tid ; public : // ... ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; However, we call pthread_create in pthread_spawner_t . So we can say there must be some sharing point to get the valid pthread_t from pthread_joiner_t . class pthread_joiner_t final { public : class pthread_spawner_t final { public : // ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())){ throw system_error { ec , system_category (), \"pthread_create\" }; } } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; // <--- duplicate with that of the `pthread_spawner_t` public : // ... ~ pthread_joiner_t () noexcept ( false ); }; At this moment, we must decide where to place the therad's id. In this code pthread_joiner_t is holding it as a member variable. That's pretty general for most of type for subroutines . Think of the implementation that pthread_spawner_t sends thread's id to pthread_joiner_t . If you decide to do so, you have to write a coroutine that aware of it's activator's address. To be more precise, the address of its return type's object. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // Can we know the address of the returned pthread_joiner_t object ? // Even if that is possible, using the address is a sound design ? } Definatly that will lead to the bad(compex) code. Remember that we are preserving the coroutine frame until pthread_join . In other words, it is a valid behavior to access the frame before we invoke pthread_join . With the point, let's save the thread's id in the coroutine's frame, and access to the memory location when the thread's id is needed. Placing the object in the coroutine's frame isn't that hard. Since the promise_type object is placed in the frame , accessing to it can be done with 1 pointer. I already showed you how to get a ponter to promise_type . Let me show you again. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; class promise_type final { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_always {}; } void unhandled_exception (){ } auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr }; } auto get_return_object () -> promise_type * { return this ; } public : pthread_t tid {}; }; public : // we will receive the pointer from `get_return_object` pthread_joiner_t ( promise_type * p ) : promise { p } { } ~ pthread_joiner_t () noexcept ( false ) { // ... join with the thread id ... // ... destroy the coroutine frame ... } // and we can access to the `tid` through the pointer operator pthread_t () const noexcept { return promise -> tid ; } private : promise_type * const promise ; }; So the last job is to update tid in the promise_type . Let's rewrite the pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; public : constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_create ( this -> tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // ... do nothing ... } private : // receives 2 pointer at once pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr }{ } pthread_t * const tid ; // pointer to the memory location in the promise const pthread_attr_t * const attr ; }; class promise_type final { auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // ... pthread_t tid {}; }; // ... }; Whoa, that was a long run !","title":"Exposing pthread_t"},{"location":"articles/combining-coroutines-and-pthread_create/#conclusion","text":"You can run the example with the WandBox. https://wandbox.org/permlink/qQ1vbwshsoujYnI0 In this article we covered 2 things by wrapping pthread_create for the coroutines step by step. How the awaitable can wrap the system function which uses a callback and it has a void* parameter How to define await_transform and which limitation it makes However, we only wrapped 2 pthread life cycle functions. So if the coroutine invokes pthread_exit instead of co_return , the assumption of the pthread_joiner_t will be broken. What I didn't cover here will be a good coroutine design practice for you. Move/Copy handling of the types The detach of a thread Triggering multiple thread createion for 1 pthread_joiner_t","title":"Conclusion"},{"location":"articles/combining-coroutines-and-pthread_create/#after-note","text":"Arthur O'Dwyer let me know how to improve the final(WandBox) example using private constructor. I will cover that in later post. Appreciate for his help and opinions! :D","title":"After Note"},{"location":"articles/combining-coroutines-and-pthread_create/#allowing-another-awaitable-types","text":"You may need to define more generic await_transform like this . class pthread_joiner_t final { public : class promise_type final { // the original auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // redirect to const pointer inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } // allow general co_await usage template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; // ... };","title":"Allowing another awaitable types"},{"location":"articles/designing-the-channel/","text":"Designing the coroutine channel \u00b6 commit: 1.4.3 This is a design note for the channel<T> . It's one of the oldest feature in this library. In this article, I will write about the design background of the type. Summary \u00b6 John Bandela already talked about the coroutine based channel in CppCon 2016 . However, I designed more limited one on my own. #include <coroutine/channel.hpp> using namespace coro ; constexpr int bye = 0 ; auto consumer ( channel < int >& ch ) -> no_return { // the type doesn't support for-co_await for now for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: we received a value if ( msg == bye ) break ; co_await ch . write ( msg ); // we can write in the reader coroutine } } auto producer_owner () -> no_return { channel < int > ch {}; consumer ( ch ); // start a consumer routine for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ok == true: we sent a value co_await ch . read ( msg ); // we can read in the writer coroutine } } Notice that we are reading before writing values to the channel. You can visit more example(test) codes for the type: test/channel_read_write_nolock.cpp test/channel_read_fail_after_close.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_ownership_consumer.cpp test/channel_ownership_producer.cpp test/channel_race_no_leak.cpp Note \u00b6 Motivation(Background) \u00b6 There are multiple ways to deliver value(normally an object) from a routine to another routine. channel<T> is designed to play a role as one of them. Before the coroutine \u00b6 Before the C++ Coroutines becames available, there were 2 ways. return : from callee subroutine to caller subroutine future<T> since C++11 : return with synchronization(shared state) return forwards a T type object from callee subroutine to caller subroutine. C++ 11 future<T> , do the same work but uses a shared state to provide synchronization. As we know, such a synchronization is for multi-threaded code. One of those methods' limitation is that they can deliver only 1 object (of T type), only 1 time (with the return ). Which makes inconvenience sometimes... After the coroutine \u00b6 By adopting coroutine to our world, now we can suspend, and get a new way of delivery. task<T> : 1 time delivery, from a coroutine to another coroutine generator<T> : multi-time delivery, from the generator coroutine to activator coroutine task<T> is the simplest way to get co_return from a coroutine. The most important design point for a coroutine function is that managing suspension( co_await ). It's because suspension is more general than finalization( co_return ). task<T> deals with the cases and activates(resumes) awaiting coroutine when the activatee coroutine returns. generator<T> uses co_yield to deliver value from activatee(generator coroutine) to activator(resumer subroutine) multiple times. For us, co_yield itself is a syntatic sugar that invokes yield_value and evaluate co_await (therefore, suspend) at the same time. Indeed there is a harmony in the way generator<T> works. However, what if we can't acquire the value from generator<T> immediately? What if advancing its iterator is asynchronous? async_generator<T> : generator<T> + awaitable iterator So async_generator<T> allows us to attach a coroutine which will be resumed when the generator coroutine can yield(perform the delivery). In my perspective, using co_await on its iterator is indeed a good idea for the interface design. Its user code remains very similar to that of the generator<T> The consumer coroutine is resumed automatically, so there is no coverage leak You can review existing implementations. Please let me know if there is another implementations so I can add them :) From the https://github.com/kirkshoop/await In this library, which is based on kirkshoop's work, sequence<T> From the adorable cppcoro Another type of the delivery? \u00b6 At this point, we can recognize that we don't have a bidirectional delivery . generator<T> delivers its co_yield ed value only in 1 direction, and so does async_generator<T> . Also, if we need to write multi-threaded code, there are still needs of the synchronization. It depends on the pattern and can managed well, but it's still hard to the beginners. For nondirectional delivery, there is a good example in the Go language. It's channel . The channel can suspend both producer and consumer goroutines by affecting their scheduling. However, there is a difference between the coroutine in the C++ and Goroutine in the Go language. Goroutine is scheduled by the Go runtime, but coroutine are not. It doesn't have a built-in scheduling. Basically, coroutine_handle<T> itself is a pointer and programmers have to manage them manually. Requirement \u00b6 So the requirement for our new type is like the following. channel<T> Non-directional delivery (at least bidirectional) Optional synchronization Coverage leak prevention Invalidation Zero allocation Non-directional delivery \u00b6 We should be able to write/read to a channel in a same coroutine. It's convenient. And that is important for the beginners. Optional synchronization \u00b6 It supports single-threaded code and there must be zero-cost in the case. Coverage leak prevention \u00b6 The type must prevent coverage leak. That means, it must do its best to make related coroutines reach their ends. Invalidation \u00b6 The channel must be able to notify its invalidation. So its user code can handle the operation failure and prevent undefined behavior while they are writing the code. With the coverage requirement above, user will co_return the coroutine, or delegate its work somehow. Zero allocation \u00b6 new / delete is not allowed to avoid unnecessary cost. Design Concerns \u00b6 Optional synchronization \u00b6 The logic will remain while user applies different synchronization types. So the type will use be template. template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel final { public : using mutex_type = M ; private : mutex_type mtx ; } Also, as you can see above, it will use do nothing lockable by default. // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } }; Invalidation \u00b6 unlike the channel of Go, the type doesn't provide explicit close operation Explicit close is simple enough because we can just check the channel's state and break the loop. But it is highly possible that user will carefully design the value if there is no close . Suppose we have a close for the channel: auto producer ( channel < int >& ch ) -> no_return { int msg {}; // ... while ( ch . closed () == false ){ co_await ch . write ( msg ); // ... if ( cond ) break ; } ch . close (); // ok, no more value co_return ; } auto consumer ( channel < int >& ch ) -> no_return { while ( ch . closed () == false ){ int msg = co_await ch . read (); // ... } } In this case, user will think about the state of the channel. The following questions can be managed by patternized code, but will always arise from the existance of close . Which line should the close placed? When it's already closed, what should I do for read/write? When we don't have a close , users will think about another issue. When should I stop the read/write? The question is about managing the loop, and probably they will use something like EOF (sentinel value). In my perspective, it is more likely to have well-designed space for the value_type of the channel: auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { co_await ch . write ( msg ); // ... } } auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } Implementation \u00b6 Watching the CppCon 2016 talk will help you a lot for the following notes. Making a linked list of the coroutine frames \u00b6 Since coroutine frames are allocated separatly, we can use them like a node in the linked list. By placing next pointer in those frame, we can make zero-allocation channel. Actually they are a kind of pre-allocation since the cost is already paid in the frame construction(invocation) steps. So it will be enough for channel<T> to have 2 linked lists and 1 mutex to operate correctly under multi-threaded code. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... private : mutex_type mtx ; } To make a linked list of the coroutine frames, the type places an objects in the coroutine frame that containes next pointer. // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... public : // place a writer in the coroutine's frame decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // place a reader in the coroutine's frame decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; You can find next pointer in the following writer and reader . Notice that they have a reserved space to receive coroutine_handle<void> from await_suspend . template < typename T , typename M > class writer final { public : using value_type = T ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; union { writer * next = nullptr ; // Next writer in the channel channel_type * chan ; }; }; template < typename T , typename M > class reader { public : using value_type = T ; using channel_type = channel < T , M > ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; union { reader * next = nullptr ; // Next reader in the channel channel_type * chan ; }; }; Because of the design we will place the objects in the frame. Consider: auto temporary_reader_object ( channel < int >& ch ) -> no_return { // co_await ch.read(); reader < int > reader = ch . read (); co_await reader ; } When it's used with for statement, there will be at most 2 read/writes. So it won't be that complicated. // at most 2 operation in 1 for loop auto consumer ( channel < int >& ch ) -> no_return { for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ... } } auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ... } } Preventing Coverage Leak \u00b6 We all know that RAII is the best way to make the type system work for us. Let's consider about it. What is the proper behavior of the linked list on its destruction? Like the std::list<T> , it must delete its existing nodes to prevent memory leak. Unfortunately, this case is really special because the nodes are existing coroutines' frame. That means, if we free the node, it will destroy all objects in the frame. That's really brutal because it can break all existing expectations of the function that manages its frame manually (with customized promise_type ). So the appropriate behavior is to resume those frames and let them recognize that they can't access the channel anymore. In its destructor , channel<T, M> resumes all awaiting coroutines in its linked lists. Notice the destructor is specified noexcept(false) because typically resume operation is not guaranteed noexcept . template < typename T , typename M > class channel { // ... ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; size_t repeat = 1 ; while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); // <-- use a poison value coro . resume (); // <-- resume write operations } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); // <-- resume read operations } } } } With the behavior, user code must be changed like the following. It receive not only a value from the channel but also one bool that notifies the channel is still accessible. // Before auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } // After auto consumer ( channel < int >& ch ) -> no_return { // it's returning tuple, // declare memory objects using structured binding for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: the channel is accessible // ... } } By doing so, if the reader/writer coroutines are written correctly, channel can guarantee there is no dangling coroutines in its linked lists, and prevent coverage leak of them. Using a poison in await_resume \u00b6 I used poison to replace explicit close . Remember that the co_await expression is affected by await_resume . Returning a tuple from the function can constrain user's code. In the implementation, to decide to return true or false , both reader<T, M> and writer<T, M> have to check if the poison is delivered. // Awaitable for channel's read operation template < typename T , typename M > class reader { // ... auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; Unlike reader, writer just returns bool . The signature makes its return can be used in if or while conveniently. // Awaitable for channel's write operation template < typename T , typename M > class writer final { // ... bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; Furthermore, the signature makes user to places a boolean in the coroutine's frame, not in the channel . So it's on-demand cost. Skip: await_ready and await_suspend \u00b6 This part is realted to the requirement, optional synchronization. It will be covered later because they are purely about the implementation. If you are really curious, visit this page . Conclusion \u00b6 The type doesn't weighted for the performance. What I focused was to enforce intuitive code and to guide users' consideration to their behavior (and undelying semantics). It's not replacement nor alternative of the other delivery methods. To summarize each methods, return : 1 time, directional, subroutine to subroutine future<T> : 1 time, directional, subroutine to subroutine, synchronization(shared state) task<T> : 1 time, directional, coroutine to coroutine generator<T> : multi-time, directional, coroutine to coroutine asnyc_generator<T> : multi-time, directional, coroutine to coroutine, awaitable iterator channel<T> : multi-time (with suspend), non-directional, optional synchronization For channel<T> itself... Non-directional delivery \u00b6 You can see the example with the Compiler Explorer(MSVC) or with the WandBox(clang-8) Coverage Leak \u00b6 For the requirement, channel becomes a linked list of each reader and writer. Its operations place reader/writer object in the coroutine frame. In the destructor, all objects in linked lists receive the poison value. Invalidation (Close Status) \u00b6 To detect invalidation of the channel, we check the poison value in the await_resume function. It's signature enforces to make a memory object( ok in the example) to receive channel's status. When the poison is delivered, co_await on the reader/writer will return false , so the user can break the loop. This can be done without use of close operation.","title":"Designing the coroutine channel"},{"location":"articles/designing-the-channel/#designing-the-coroutine-channel","text":"commit: 1.4.3 This is a design note for the channel<T> . It's one of the oldest feature in this library. In this article, I will write about the design background of the type.","title":"Designing the coroutine channel"},{"location":"articles/designing-the-channel/#summary","text":"John Bandela already talked about the coroutine based channel in CppCon 2016 . However, I designed more limited one on my own. #include <coroutine/channel.hpp> using namespace coro ; constexpr int bye = 0 ; auto consumer ( channel < int >& ch ) -> no_return { // the type doesn't support for-co_await for now for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: we received a value if ( msg == bye ) break ; co_await ch . write ( msg ); // we can write in the reader coroutine } } auto producer_owner () -> no_return { channel < int > ch {}; consumer ( ch ); // start a consumer routine for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ok == true: we sent a value co_await ch . read ( msg ); // we can read in the writer coroutine } } Notice that we are reading before writing values to the channel. You can visit more example(test) codes for the type: test/channel_read_write_nolock.cpp test/channel_read_fail_after_close.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_ownership_consumer.cpp test/channel_ownership_producer.cpp test/channel_race_no_leak.cpp","title":"Summary"},{"location":"articles/designing-the-channel/#note","text":"","title":"Note"},{"location":"articles/designing-the-channel/#motivationbackground","text":"There are multiple ways to deliver value(normally an object) from a routine to another routine. channel<T> is designed to play a role as one of them.","title":"Motivation(Background)"},{"location":"articles/designing-the-channel/#before-the-coroutine","text":"Before the C++ Coroutines becames available, there were 2 ways. return : from callee subroutine to caller subroutine future<T> since C++11 : return with synchronization(shared state) return forwards a T type object from callee subroutine to caller subroutine. C++ 11 future<T> , do the same work but uses a shared state to provide synchronization. As we know, such a synchronization is for multi-threaded code. One of those methods' limitation is that they can deliver only 1 object (of T type), only 1 time (with the return ). Which makes inconvenience sometimes...","title":"Before the coroutine"},{"location":"articles/designing-the-channel/#after-the-coroutine","text":"By adopting coroutine to our world, now we can suspend, and get a new way of delivery. task<T> : 1 time delivery, from a coroutine to another coroutine generator<T> : multi-time delivery, from the generator coroutine to activator coroutine task<T> is the simplest way to get co_return from a coroutine. The most important design point for a coroutine function is that managing suspension( co_await ). It's because suspension is more general than finalization( co_return ). task<T> deals with the cases and activates(resumes) awaiting coroutine when the activatee coroutine returns. generator<T> uses co_yield to deliver value from activatee(generator coroutine) to activator(resumer subroutine) multiple times. For us, co_yield itself is a syntatic sugar that invokes yield_value and evaluate co_await (therefore, suspend) at the same time. Indeed there is a harmony in the way generator<T> works. However, what if we can't acquire the value from generator<T> immediately? What if advancing its iterator is asynchronous? async_generator<T> : generator<T> + awaitable iterator So async_generator<T> allows us to attach a coroutine which will be resumed when the generator coroutine can yield(perform the delivery). In my perspective, using co_await on its iterator is indeed a good idea for the interface design. Its user code remains very similar to that of the generator<T> The consumer coroutine is resumed automatically, so there is no coverage leak You can review existing implementations. Please let me know if there is another implementations so I can add them :) From the https://github.com/kirkshoop/await In this library, which is based on kirkshoop's work, sequence<T> From the adorable cppcoro","title":"After the coroutine"},{"location":"articles/designing-the-channel/#another-type-of-the-delivery","text":"At this point, we can recognize that we don't have a bidirectional delivery . generator<T> delivers its co_yield ed value only in 1 direction, and so does async_generator<T> . Also, if we need to write multi-threaded code, there are still needs of the synchronization. It depends on the pattern and can managed well, but it's still hard to the beginners. For nondirectional delivery, there is a good example in the Go language. It's channel . The channel can suspend both producer and consumer goroutines by affecting their scheduling. However, there is a difference between the coroutine in the C++ and Goroutine in the Go language. Goroutine is scheduled by the Go runtime, but coroutine are not. It doesn't have a built-in scheduling. Basically, coroutine_handle<T> itself is a pointer and programmers have to manage them manually.","title":"Another type of the delivery?"},{"location":"articles/designing-the-channel/#requirement","text":"So the requirement for our new type is like the following. channel<T> Non-directional delivery (at least bidirectional) Optional synchronization Coverage leak prevention Invalidation Zero allocation","title":"Requirement"},{"location":"articles/designing-the-channel/#non-directional-delivery","text":"We should be able to write/read to a channel in a same coroutine. It's convenient. And that is important for the beginners.","title":"Non-directional delivery"},{"location":"articles/designing-the-channel/#optional-synchronization","text":"It supports single-threaded code and there must be zero-cost in the case.","title":"Optional synchronization"},{"location":"articles/designing-the-channel/#coverage-leak-prevention","text":"The type must prevent coverage leak. That means, it must do its best to make related coroutines reach their ends.","title":"Coverage leak prevention"},{"location":"articles/designing-the-channel/#invalidation","text":"The channel must be able to notify its invalidation. So its user code can handle the operation failure and prevent undefined behavior while they are writing the code. With the coverage requirement above, user will co_return the coroutine, or delegate its work somehow.","title":"Invalidation"},{"location":"articles/designing-the-channel/#zero-allocation","text":"new / delete is not allowed to avoid unnecessary cost.","title":"Zero allocation"},{"location":"articles/designing-the-channel/#design-concerns","text":"","title":"Design Concerns"},{"location":"articles/designing-the-channel/#optional-synchronization_1","text":"The logic will remain while user applies different synchronization types. So the type will use be template. template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel final { public : using mutex_type = M ; private : mutex_type mtx ; } Also, as you can see above, it will use do nothing lockable by default. // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } };","title":"Optional synchronization"},{"location":"articles/designing-the-channel/#invalidation_1","text":"unlike the channel of Go, the type doesn't provide explicit close operation Explicit close is simple enough because we can just check the channel's state and break the loop. But it is highly possible that user will carefully design the value if there is no close . Suppose we have a close for the channel: auto producer ( channel < int >& ch ) -> no_return { int msg {}; // ... while ( ch . closed () == false ){ co_await ch . write ( msg ); // ... if ( cond ) break ; } ch . close (); // ok, no more value co_return ; } auto consumer ( channel < int >& ch ) -> no_return { while ( ch . closed () == false ){ int msg = co_await ch . read (); // ... } } In this case, user will think about the state of the channel. The following questions can be managed by patternized code, but will always arise from the existance of close . Which line should the close placed? When it's already closed, what should I do for read/write? When we don't have a close , users will think about another issue. When should I stop the read/write? The question is about managing the loop, and probably they will use something like EOF (sentinel value). In my perspective, it is more likely to have well-designed space for the value_type of the channel: auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { co_await ch . write ( msg ); // ... } } auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } }","title":"Invalidation"},{"location":"articles/designing-the-channel/#implementation","text":"Watching the CppCon 2016 talk will help you a lot for the following notes.","title":"Implementation"},{"location":"articles/designing-the-channel/#making-a-linked-list-of-the-coroutine-frames","text":"Since coroutine frames are allocated separatly, we can use them like a node in the linked list. By placing next pointer in those frame, we can make zero-allocation channel. Actually they are a kind of pre-allocation since the cost is already paid in the frame construction(invocation) steps. So it will be enough for channel<T> to have 2 linked lists and 1 mutex to operate correctly under multi-threaded code. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... private : mutex_type mtx ; } To make a linked list of the coroutine frames, the type places an objects in the coroutine frame that containes next pointer. // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... public : // place a writer in the coroutine's frame decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // place a reader in the coroutine's frame decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; You can find next pointer in the following writer and reader . Notice that they have a reserved space to receive coroutine_handle<void> from await_suspend . template < typename T , typename M > class writer final { public : using value_type = T ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; union { writer * next = nullptr ; // Next writer in the channel channel_type * chan ; }; }; template < typename T , typename M > class reader { public : using value_type = T ; using channel_type = channel < T , M > ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; union { reader * next = nullptr ; // Next reader in the channel channel_type * chan ; }; }; Because of the design we will place the objects in the frame. Consider: auto temporary_reader_object ( channel < int >& ch ) -> no_return { // co_await ch.read(); reader < int > reader = ch . read (); co_await reader ; } When it's used with for statement, there will be at most 2 read/writes. So it won't be that complicated. // at most 2 operation in 1 for loop auto consumer ( channel < int >& ch ) -> no_return { for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ... } } auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ... } }","title":"Making a linked list of the coroutine frames"},{"location":"articles/designing-the-channel/#preventing-coverage-leak","text":"We all know that RAII is the best way to make the type system work for us. Let's consider about it. What is the proper behavior of the linked list on its destruction? Like the std::list<T> , it must delete its existing nodes to prevent memory leak. Unfortunately, this case is really special because the nodes are existing coroutines' frame. That means, if we free the node, it will destroy all objects in the frame. That's really brutal because it can break all existing expectations of the function that manages its frame manually (with customized promise_type ). So the appropriate behavior is to resume those frames and let them recognize that they can't access the channel anymore. In its destructor , channel<T, M> resumes all awaiting coroutines in its linked lists. Notice the destructor is specified noexcept(false) because typically resume operation is not guaranteed noexcept . template < typename T , typename M > class channel { // ... ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; size_t repeat = 1 ; while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); // <-- use a poison value coro . resume (); // <-- resume write operations } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); // <-- resume read operations } } } } With the behavior, user code must be changed like the following. It receive not only a value from the channel but also one bool that notifies the channel is still accessible. // Before auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } // After auto consumer ( channel < int >& ch ) -> no_return { // it's returning tuple, // declare memory objects using structured binding for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: the channel is accessible // ... } } By doing so, if the reader/writer coroutines are written correctly, channel can guarantee there is no dangling coroutines in its linked lists, and prevent coverage leak of them.","title":"Preventing Coverage Leak"},{"location":"articles/designing-the-channel/#using-a-poison-in-await_resume","text":"I used poison to replace explicit close . Remember that the co_await expression is affected by await_resume . Returning a tuple from the function can constrain user's code. In the implementation, to decide to return true or false , both reader<T, M> and writer<T, M> have to check if the poison is delivered. // Awaitable for channel's read operation template < typename T , typename M > class reader { // ... auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; Unlike reader, writer just returns bool . The signature makes its return can be used in if or while conveniently. // Awaitable for channel's write operation template < typename T , typename M > class writer final { // ... bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; Furthermore, the signature makes user to places a boolean in the coroutine's frame, not in the channel . So it's on-demand cost.","title":"Using a poison in await_resume"},{"location":"articles/designing-the-channel/#skip-await_ready-and-await_suspend","text":"This part is realted to the requirement, optional synchronization. It will be covered later because they are purely about the implementation. If you are really curious, visit this page .","title":"Skip: await_ready and await_suspend"},{"location":"articles/designing-the-channel/#conclusion","text":"The type doesn't weighted for the performance. What I focused was to enforce intuitive code and to guide users' consideration to their behavior (and undelying semantics). It's not replacement nor alternative of the other delivery methods. To summarize each methods, return : 1 time, directional, subroutine to subroutine future<T> : 1 time, directional, subroutine to subroutine, synchronization(shared state) task<T> : 1 time, directional, coroutine to coroutine generator<T> : multi-time, directional, coroutine to coroutine asnyc_generator<T> : multi-time, directional, coroutine to coroutine, awaitable iterator channel<T> : multi-time (with suspend), non-directional, optional synchronization For channel<T> itself...","title":"Conclusion"},{"location":"articles/designing-the-channel/#non-directional-delivery_1","text":"You can see the example with the Compiler Explorer(MSVC) or with the WandBox(clang-8)","title":"Non-directional delivery"},{"location":"articles/designing-the-channel/#coverage-leak","text":"For the requirement, channel becomes a linked list of each reader and writer. Its operations place reader/writer object in the coroutine frame. In the destructor, all objects in linked lists receive the poison value.","title":"Coverage Leak"},{"location":"articles/designing-the-channel/#invalidation-close-status","text":"To detect invalidation of the channel, we check the poison value in the await_resume function. It's signature enforces to make a memory object( ok in the example) to receive channel's status. When the poison is delivered, co_await on the reader/writer will return false , so the user can break the loop. This can be done without use of close operation.","title":"Invalidation (Close Status)"},{"location":"articles/exploring-msvc-coroutine-kor/","text":"MSVC Coroutine \uc54c\uc544\ubcf4\uae30 \u00b6 Written in 2017/03/02 English \ucc38\uace0\uc790\ub8cc \u00b6 \uc81c\uc548\uc11c \u00b6 N3858 N3977 N4134 N4402 Visual C++ Team Blog \u00b6 Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++ \uc601\uc0c1 \u00b6 CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\" GitHub \uc800\uc7a5\uc18c \u00b6 kirkshoop/ await \uc8fc\uc758\uc0ac\ud56d \u00b6 \uc6b0\uc120 MSVC\uc758 Coroutine\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 3\uac00\uc9c0\uac00 \ud544\uc694\ud558\ub2e4. Visual Studio 2015 Up3 \ud639\uc740 \uadf8 \uc774\uc0c1\uc758 \uac1c\ubc1c\ud658\uacbd /await : \ucef4\ud30c\uc77c \uc635\uc158 <experimental/*> : \uc18c\uc2a4 \ucf54\ub4dc\uc5d0 \ub123\uc744 \ud5e4\ub354\ud30c\uc77c \uc815\uc758 \u00b6 \uadf8\ub798\uc11c, \ucf54\ub8e8\ud2f4\uc774 \ub300\uccb4 \ubb54\uac00\uc694? \uace0\uc2dd(\u53e4\u5f0f) : \uae30\uacc4\ub808\ubca8\uc5d0\uc11c \uc0dd\uac01\ud558\uae30 \u00b6 \uae30\ubcf8\uc801\uc73c\ub85c, \ud504\ub85c\uc2dc\uc800\uc758 \ud638\ucd9c\uc740 goto \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uadf8\ub7f0\ub370 \uc5b4\ub514\ub85c goto \ud55c\ub2e4\ub294 \uac83\uc77c\uae4c? \ub2e4\uc74c\uc5d0 \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc77c \uac83\uc774\ub2e4. \uba85\ub839\uc5b4\ub294 \ub8e8\ud2f4\uacfc \ud504\ub85c\uadf8\ub7a8\uc758 \uc77c\ubd80\uc774\uae30\ub3c4 \ud55c\ub370, \uc7a0\uc2dc \uc5ec\uae30\uc11c \ud55c\ubc88 \uc9da\uc5b4\ubcf4\uaca0\ub2e4. [\ud504\ub85c\uadf8\ub7a8]\uc740 \uc77c\ub828\uc758 [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub4e4\ub85c \ubcfc \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc5ec\uae30\uc11c [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub780, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c \uac83\uc774\uc5b4\uc57c \ud558\uba70, \ud504\ub85c\uadf8\ub7a8\uc744 \uc218\ud589\ud558\ub294 \uae30\uacc4\uc758 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\uc758 \uac12\ub4e4\uc744 \ud569\uce5c \uac83(composition)\uc774\ub2e4. \ubcf4\ud1b5\uc740 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac \uac12\uc758 \uc870\ud569\uc774 \uc720\ud55c\ud558\ub3c4\ub85d \uc124\uacc4\ud55c\ub2e4. Program State = Environment X Memory (\ud568\uc218\uc801 \ud569\uc131 : Cartesian Product) \uc5ec\uae30\uc11c \uba85\ub839\uc5b4\ub4e4\uc740 \uc0c1\ud0dc\uac04\uc758 \uc804\uc774(transition)\ub77c\uace0 \uc815\uc758\ud560 \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc774\ub7ec\ud55c \uc804\uc774\ub4e4\uc744 \uc21c\uc11c\ub300\ub85c \ubb36\uc740 \uac83\uc744 \ub8e8\ud2f4(routine)\uc774\ub77c\uace0 \ud55c\ub2e4. Instruction : \uba85\ub839, \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\uc758 \uc804\uc774 Routine : \uc21c\uc11c\uac00 \uc788\ub294 \uba85\ub839 \ubb36\uc74c \uadf8\ub7ec\uba74 \uc774\uc81c \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc73c\ub85c \ub118\uc5b4\uac08 \ucc28\ub840\ub2e4. \uad00\uacc4 \u00b6 \ubaa8\ub4e0 \ud504\ub85c\uadf8\ub798\uba38\ub4e4\uc740 \ucf54\ub4dc\uc5d0 \ub300\ud574\uc11c \uc790\uc2e0\ub9cc\uc758 \uc2ec\uc0c1(Mental Model)\uc744 \uac16\uae30 \ub9c8\ub828\uc774\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc758 \uba58\ud0c8 \ubaa8\ub378 \ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uace0\uc790 \ud55c\ub2e4. \uc11c\ube0c\ub8e8\ud2f4 : Caller-Callee \u00b6 \uc11c\ube0c\ub8e8\ud2f4\uc758 \uad00\uacc4\ub294 \uc77c\ubc29\uc801\uc774\ub2e4. \ud638\ucd9c\uc790(Caller)\ub294 \uc774\ubbf8 \uc5b4\ub5a4 \uc0c1\ud0dc\uc5d0 \uc788\uace0(\uc774\uc804 \uc870\uac74), \uc5b4\ub5a4 \ub8e8\ud2f4\uc774 \ud544\uc694\ud55c\uc9c0, \ud639\uc740 \ud638\ucd9c\ud560\uc9c0 \uc54c\uace0\uc788\ub2e4. \ud53c\ud638\ucd9c\uc790(Callee)\ub294 \ud504\ub85c\uadf8\ub798\uba38\uc758 \uc758\ub3c4\ub300\ub85c \uc815\uc758\ub41c \ucf54\ub4dc\ub97c \uac00\uc9c0\uace0 \uc788\uace0, \ud638\ucd9c\uc790\uc640 \ubb34\uad00\ud558\uac8c \uba85\ub839\ub4e4\uc744 \uc218\ud589\ud55c\ub2e4. \uc5ec\uae30\uc11c \ubd80\uc218\ud6a8\uacfc(Side-effect)\uac00 \uc788\uc744 \uc218 \uc788\uc9c0\ub9cc, \uadf8\uac74 \uba85\ub839\uc758 \ub0b4\uc6a9\uc5d0 \ub300\ud55c \uac83\uc774\uace0 \uad00\uacc4\uc640\ub294 \ubb34\uad00\ud558\ub2e4. \ucf54\ub8e8\ud2f4 : Activator-Activator \u00b6 \ubcf4\ud1b5 \ucf54\ub8e8\ud2f4\uc740 cooperative\ud55c routine\uc774\ub2e4. \uc774 \ub54c\ubb38\uc5d0 \ud611\ub825\ub8e8\ud2f4\uc774\ub77c\uace0 \ubc88\uc5ed\ub418\uae30\ub3c4 \ud558\ub294\ub370, \uc774\ub7f0 \uc774\ub984\uc740 \ucf54\ub8e8\ud2f4\uc774 \ubb35\uc2dc\uc801\uc73c\ub85c \ub2e4\ub978 \ub8e8\ud2f4\uacfc \ud568\uaed8 \ub3d9\uc791\ud558\ub3c4\ub85d \uc124\uacc4\ub41c \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ub098\uc628 \ub8e8\ud2f4\ub4e4\uc740 \uc11c\ub85c\ub97c \ud65c\uc131\ud654\ud55c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \ud638\ucd9c\uc790(Invoker)\uc640 \uc7ac\uac1c\ub8e8\ud2f4(Resuming routine)\uc5d0 \uc758\ud574\uc11c \ud65c\uc131\ud654 \ub41c\ub2e4. \uc5ed\uc73c\ub85c \uc911\ub2e8\ud558\uac70\ub098 \ubc18\ud658\ud568\uc73c\ub85c\uc368 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\ub978 \ub8e8\ud2f4\uc744 \uc7ac\uac1c\uc2dc\ud0a4\uac8c \ub41c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c\ub294 Suspend/Return\ub4f1\uc73c\ub85c \uad6c\ubd84\ud558\uc600\uc73c\ub098, \ud65c\uc131\ud654\ub77c\ub294 \uac83\uc740 \uc2e4\uc81c\ub85c\ub294 \ub8e8\ud2f4 \uc548\uc758 \uc784\uc758\uc758 \uc9c0\uc810(\uba85\ub839\uc5b4)\uc73c\ub85c \uc810\ud504( goto / jmp )\ud558\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\ub294 \uac83\uc774 \ub2e4\ub978 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uac83\uacfc \uac19\uc744 \uc218 \uc788\uc73c\uba70, \ud568\uc218\uc758 \uc885\ub8cc\uc640 \uc911\ub2e8\uc758 \ucc28\uc774 \ub610\ud55c \ud655\uc5f0\ud558\uc9c0 \uc54a\uc744 \uc218 \uc788\ub2e4. \uc810\ud504\uc758 \ubaa9\ud45c\uc8fc\uc18c\uac00 \ub8e8\ud2f4\uc758 \ub3c4\uc785\ubd80(\ud568\uc218\ub77c\uba74 prologue)\ub77c\uba74 \ud65c\uc131\ud654\ub294 Invocation ( call )\uc774 \ub41c\ub2e4. \ubaa9\ud45c\uc8fc\uc18c\uac00 \ud504\ub85c\uc2dc\uc800\uc758 \ud55c\uac00\uc6b4\ub370 \uc704\uce58\ud558\uba74, \uc774\ub294 Activation ( resume )\uc774 \ub41c\ub2e4. Invocation: \ud638\ucd9c. \ub8e8\ud2f4\uc758 \uc2dc\uc791\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Activation: \ud65c\uc131\ud654. \ub8e8\ud2f4\uc758 \uc784\uc758 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc, \ucf54\ub8e8\ud2f4\uc740 \uc774\uc804 \uc0c1\ud0dc(Pre-condition)\uc640 \uc774\ud6c4 \uc0c1\ud0dc(Post-condition)\uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. \uc774 \ub9d0\uc740, \ucf54\ub8e8\ud2f4 \ub610\ud55c \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\ub97c \uc5b4\ub5bb\uac8c \uc804\uc774\uc2dc\ud0ac\uc9c0 \uc815\uc758\ub418\uc5b4\uc57c \ud55c\ub2e4\ub294 \ub9d0\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc11c\ube0c\ub8e8\ud2f4\uacfc\ub294 \ub2e4\ub974\uac8c, \ucf54\ub8e8\ud2f4\uc740 \uc790\uc2e0\ub9cc\uc758 \uc0c1\ud0dc\ub97c \uc720\uc9c0\ud55c \ucc44\ub85c \ub2e4\ub978 \uc8fc\uc18c\ub85c goto \ud560 \uc218 \uc788\ub2e4. \uc774\ub97c Suspension ( yield )\uc774\ub77c \ud55c\ub2e4. \uacbd\uc6b0\uc5d0 \ub530\ub77c \uc774\ub294 \ud504\ub85c\uc2dc\uc800\uc758 \uc885\ub8cc, \ud639\uc740 \ud568\uc218\uc758 \ubc18\ud658( return )\uc774 \ub420\uc218 \uc788\uc73c\uba70, \uadf8\ub54c\ub294 \uc885\ub8cc(finalization)\ub97c \ud568\uaed8 \uc218\ud589\ud558\uac8c \ub41c\ub2e4. Suspension: \uc911\ub2e8. \uc885\ub8cc\uc791\uc5c5 \uc5c6\uc774 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Finalization: \uc885\ub8cc. \ub8e8\ud2f4\uacfc \uad00\ub828\ub41c \uc790\uc6d0\ub4e4\uc744 \uc815\ub9ac(\ud30c\uad34)\ud558\uace0 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 \ucc28\uc774\uc810? \u00b6 \uc694\ucee8\ub300 \uac00\uc7a5 \ud070 \ucc28\uc774\uc810\uc740, \ucf54\ub8e8\ud2f4\uc740 \uc11c\ube0c\ub8e8\ud2f4\ubcf4\ub2e4 \ub354 \ub9ce\uc740 \ub3d9\uc791(Operation)\uc744 \uc9c0\uc6d0\ud55c\ub2e4\ub294 \uac83\uc774\ub2e4. \uc774\uac83\uc774 \ub3c4\ub110\ub4dc \ud06c\ub204\uc2a4\uac00 The Art of Computer Programming \uc5d0\uc11c \uc774\ub807\uac8c \uc11c\uc220\ud55c \uc774\uc720\ub2e4. \"Subroutines are special cases of ... coroutines\" - Donald Knuth \uc774\ub97c \ud45c\ub85c \uc815\ub9ac\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4. Operation Subroutine Coroutine Invoke o o \ud504\ub85c\uc2dc\uc800\ub97c \uc2dc\uc791\ud55c\ub2e4 Activate x o \ud2b9\uc815\ud55c \uc9c0\uc810\uc73c\ub85c \uc9c4\uc785\ud55c\ub2e4 Suspend x o Control Flow\ub97c \uba48\ucd98\ub2e4. Finalize o o \uc9c0\uc5ed\ubcc0\uc218, \ub9e4\uac1c\ubcc0\uc218\ub4e4\uc744 \uc815\ub9ac\ud558\uace0 return \ud55c\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc774 \uc81c\ud55c\ub418\uc5c8\uc9c0\ub9cc \uad00\uacc4\uc5d0 \ub300\ud55c \uace0\ub824\uac00 \ud544\uc694\uc5c6\uc5b4 \uac04\ub2e8\ud558\ub2e4. \ubc18\uba74\uc5d0 \ucf54\ub8e8\ud2f4\uc740 \ub354 \ub9ce\uc740 \ub3d9\uc791\uc774 \uac00\ub2a5\ud558\uc9c0\ub9cc, \uc911\ub2e8\uacfc \ud65c\uc131\ud654\uc5d0 \ub300\ud55c(\uadf8\ub9ac\uace0 \uac01\uac01\uc758 Pre/Post condition\uc5d0 \ub300\ud55c) \uc815\uc758\uac00 \ud544\uc694\ud558\ubbc0\ub85c \ub354 \ubcf5\uc7a1\ud558\ub2e4. Routine: \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub97c \ubcc0\ud654\uc2dc\ud0a4\ub294 \uba85\ub839\uc5b4 \ubb36\uc74c. \uadf8 \ub0b4\uc6a9\uc740 \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c\ub2e4. Subroutine: \ub3d9\uc791 2\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Finalize Coroutine: \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Activate Suspend Finalize \uc608\uc81c \u00b6 \ud06c\ub204\uc2a4\ub294 \uc774\ub7f0 \uac1c\ub150\uc774 \uc5b4\ub5bb\uac8c \ucf54\ub4dc\ub85c \ud45c\ud604\ub418\ub294\uc9c0 \uadf8\uc758 \ucc45\uc5d0\uc11c \uc124\uba85\ud558\uace0 \uc788\ub2e4. \ub2e4\uc74c \ucf54\ub4dc\ub294 The Art of Computer Programming\uc5d0 \uc788\ub294 MIX \uba85\ub839\uc5b4\ub4e4\uc744 \uadf8\ub300\ub85c \uc62e\uaca8\uc628 \uac83\uc73c\ub85c, \ubaa8\ub450 \uc774\ud574\ud560 \ud544\uc694\ub294 \uc5c6\ub2e4. \uc624\ub298\ub0a0\uc758 call / return \uad6c\uc870\uc640 \ub2ec\ub9ac, \ubaa8\ub4e0 \ub3d9\uc791\ub4e4\uc774 JMP \uba85\ub839\uc5b4\ub85c \uc218\ud589\ub418\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ud575\uc2ec\uc740 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\uc218\uc758 \uc9c4\uc785\uc810\uacfc \uc911\ub2e8\uc810\uc744 \uac00\uc9c4\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub354\ud574\uc11c, \ubb35\uc2dc\uc801\uc778 \uc0c1\ud0dc(\ub808\uc9c0\uc2a4\ud130 \ud639\uc740 \uba54\ubaa8\ub9ac)\ub97c \uac00\uc9c8 \uc218\ub3c4 \uc788\ub2e4. // MIX \uc608\uc81c, \uc8fc\uc11d\uc744 \ubcc0\uacbd\ud558\uc600\uc74c // \uc790\uc138\ud55c \ub0b4\uc6a9\uc740 The Art of Computer Programming 1.4.2 \uc5d0 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF . \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378 \u00b6 \uc2a4\ud0dd\uc774\ub2e4! \u00b6 \"\ud568\uc815\uc774\ub2e4!\" - \uc544\ud06c\ubc14 \uc81c\ub3c5 \uc624\ub298\ub0a0 \ub110\ub9ac \uc0ac\uc6a9\ub418\uace0 \uc788\ub294 High-level \uc5b8\uc5b4\ub4e4\uc740 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c\ub2e4. \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc740 \uc5b8\uc5b4\uc801\uc73c\ub85c \uba85\ud655\ud558\uac8c \uc815\uc758\ub418\uace0, \uc790\ub3d9\uc73c\ub85c \uad00\ub9ac\ub418\uba70, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uac1c\uc785\ud558\uc9c0 \uc54a\uc544\ub3c4 \ubb38\uc81c\uc5c6\uc774 \ub3d9\uc791\ud55c\ub2e4. \uad6c\uc870\uc801 \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc774\ub7f0 \uc2a4\ud0dd\uc911\uc2ec\uc758 \ubaa8\ub378\uacfc \uc870\ud654\ub97c \uc774\ub8e8\uc5b4\uc654\ub2e4. \uc774 \ubaa8\ub378\uc5d0\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uc218\ud559\uc801\uc73c\ub85c \ud45c\ud604\ud560 \uc218 \uc788\ub294 \uc218\uc2dd\ud2b8\ub9ac \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uacb0\uacfc\uc801\uc73c\ub85c main \ud568\uc218\ub294 \uc885\ub8cc\ud558\uba70, \uc801\ub2f9\ud55c \uacb0\uacfc\uac12\uc744 \ubc18\ud658\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ud45c\ud604\ud55c \uac83 \ucc98\ub7fc, \ud2b8\ub9ac\ud615 \ubaa8\ub378\uc5d0\uc11c \ud568\uc218\uc758 \ud750\ub984\uc740 \uc774 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uae4a\uc774-\uc6b0\uc120 \uc21c\uc11c\ub85c \uc21c\ud68c\ud558\uba70, \uc791\uc131\ud558\ub294 \uc2dc\uc810\ubd80\ud130 \uac01 \uad6c\ubb38(Statement)\ub4e4\uc758 \uc2e4\ud589 \uc21c\uc11c\uac00 \uc815\ud574\uc9c4\ub2e4. \uadf8\ub9bc\uc5d0\uc11c B \uad6c\ubb38\uc5d0 \ub3c4\ub2ec\ud558\uae30 \uc704\ud574\uc120, A \uad6c\ubb38\uc744 \ub9c8\uccd0\uc57c \ud55c\ub2e4. \uc774 \uc2dc\uc810\uc5d0 \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub294 \uad6c\ubb38 A\uc758 \uc601\ud5a5\uc744 \ubc1b\uc544 \ubcc0\ud558\uac8c \ub418\uba70, \ub808\uc9c0\uc2a4\ud130/\uba54\ubaa8\ub9ac\ub294 \uc801\ub2f9\ud55c \uac12\uc744 \uac00\uc9c0\uace0 \uc788\uc744 \uac83\uc774\ub2e4. Blocking \u00b6 \uc5ec\uae30\uc11c \ubb38\uc81c\uac00 \ub418\ub294 \uac83\uc740 \uc758\uc874\uc131\uc774\ub2e4. \ud2b8\ub9ac \ubaa8\ub378\uc740 \uc218\ud559\uc744 \ud504\ub85c\uadf8\ub7a8\uc73c\ub85c \uc62e\uaca8\ub193\uc740 \uac83\uc774\ub2e4. \uc218\uc2dd\uc5d0 \ud544\uc694\ud55c \ubaa8\ub4e0 \uac12\uc774 \uba54\ubaa8\ub9ac\uc5d0 \uc788\ub2e4\uba74, \ucef4\ud4e8\ud130\ub294 \uacc4\uc0b0\uc744 \ub3c4\uc911\uc5d0 \uba48\ucd94\uc9c0 \uc54a\uace0\ub3c4 \uc218\ud589\ud560 \uc218 \uc788\ub2e4. \ub2e4\ub9cc \uc6b0\ub9ac\uc758 \uc790\uc6d0\uc740 \ubb34\ud55c\ud558\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \ud504\ub85c\uadf8\ub7a8 \ud750\ub984\uc774 \uc2dc\uc791\ub418\ub294 \uc2dc\uc810\uc5d0 \ubaa8\ub4e0 \uac12\ub4e4\uc744 \uc900\ube44\ud560 \uc218\ub294 \uc5c6\ub2e4. \ub2e4\ub978 \uc6d0\uc778\ub3c4 \uc788\ub2e4. \uac12\uc774 \ubb3c\ub9ac\uc801\uc73c\ub85c \uac81\ub098 \uba3c \uacf3\uc5d0 \uc788\uc5b4\uc11c \uc2e4\uc2dc\uac04 \ud1b5\uc2e0\uc744 \ud574\uc57c\ud560\uc218\ub3c4 \uc788\ub2e4. \uacb0\uad6d \uc6b0\ub9ac\ub294 \ud544\uc5f0\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc744 \ud574\uc57c\ud55c\ub2e4. \uc804\ud1b5\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc740 \ub290\ub9ac\uace0, \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uba48\ucdb0\uc57c \ud588\ub2e4. \ubc18\uc751\uc131(Responsiveness)\uc744 \uc704\ud574 \ud504\ub85c\uadf8\ub7a8\uc774 \uba48\ucd94\uae30\ub97c \uc6d0\ud558\uc9c0 \uc54a\ub294\ub2e4\uba74 \uc5b4\ub5a8\uae4c? Non-blocking\uacfc \ube44\ub3d9\uae30(Asynchronous) \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc5ec\uae30\uc11c \uc2dc\uc791\ud55c\ub2e4. \uc774\ub294 \uc694\uc57d\ud558\uc790\uba74 \uae30\uc874\uc758 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uc77c\ubc18\ud654 \ud574\uc11c, \ud558\ub098\uc758 \uadf8\ub798\ud504\ub97c \uc791\uc131\ud558\ub294 \uac83\uc774\ub2e4. \uc0c1\ud0dc\uae30\uacc4\uac00 \uadf8\ub798\ud504\ub85c \ud45c\ud604\ub41c\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud574\ubcf4\ub77c. \uc774 \uadf8\ub798\ud504 \ubaa8\ub378\uc5d0\uc120 \ud504\ub85c\uadf8\ub7a8\uc740 \uc0c1\ud0dc\ub4e4\ub85c \uc774\ub8e8\uc5b4\uc9c4 \uadf8\ub798\ud504 \uac00 \ub41c\ub2e4. \uadf8\ub9ac\uace0 \ud504\ub85c\uc138\uc11c\ub4e4\uc740 \uc774 \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\ub294 \uac83\uc774\ub2e4. \ud504\ub85c\uc138\uc11c\ub294 \uc6b4\uc601\uccb4\uc81c\uc758 \ud504\ub85c\uc138\uc2a4, \uc2a4\ub808\ub4dc\uc77c \uc218 \uc788\ub2e4. \ub610\ub294 \uc5b8\uc5b4\ub808\ubca8\uc5d0\uc11c \uc9c0\uc6d0\ud558\ub294 \ucd94\uc0c1\ud654, \uac00\ub839 Erlang\uc758 \ud504\ub85c\uc138\uc2a4\ub098 Go\uc5b8\uc5b4\uc758 Goroutine\uc77c \uc218 \uc788\ub2e4. \ub354 \uc774\uc0c1\uc758 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc0dd\ub7b5\ud55c\ub2e4. \uc601\uc18d\uc131 \u00b6 \ud575\uc2ec\uc740, \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\uba74\uc11c \uc5b4\ub5bb\uac8c \uc815\uc810\uac04\uc758 \ubb38\ub9e5(context) \uad50\ud658\uc774 \uac00\ub2a5\ud560\uae4c \ud558\ub294 \uac83\uc774\ub2e4. \uc6b0\uc120 \uc11c\ube0c\ub8e8\ud2f4\uc740 return \uacfc \ub3d9\uc2dc\uc5d0 \ud30c\uad34\ub418\ubbc0\ub85c(\uc0ac\ub77c\uc9c0\ubbc0\ub85c) \uc774\uac83\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. \ub2ec\ub9ac \ub9d0\ud574 \uc11c\ube0c\ub8e8\ud2f4\uc740 \uc601\uc18d\uc131\uc774 \uc5c6\ub2e4. \uc774\ub294 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc774 \ub3d9\uc791\ud558\ub294 \ubc29\uc2dd\uc774\uc9c0\ub9cc, \ub3d9\uc2dc\uc5d0 \uc815\uc810(\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc)\uac04\uc758 \ubb38\ub9e5\uc804\ub2ec\uc744 \uc544\uc8fc \uc5b4\ub835\uac8c \ub9cc\ub4e4\uc5c8\ub2e4. \ucf5c\ubc31 \uc9c0\uc625 \ub3c4 \uacb0\uad6d\uc740 \ubb38\ub9e5\uc804\ub2ec\uc744 \ud558\uae30 \uc704\ud55c \uace0\uc721\uc9c0\ucc45\uc774\ub77c \ud560 \uc218 \uc788\ub2e4. \"\uc81c\uc784\uc2a4, \uc774 \ucf54\ub4dc\uc5d0\ub294 \ubc84\uadf8\uac00 \uc788\uc5b4\uc694. \uace0\uce60 \uc218 \uc788\uaca0\uc5b4\uc694?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); } \uc811\uadfc\ubc95 \u00b6 \uc6b0\ub9ac\uc5d0\uac90 \uc601\uc18d\uc131 \uc788\ub294 \ud568\uc218\uac00 \ud544\uc694\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc(finalization)\ud558\uc9c0 \uc54a\uc73c\uba74\uc11c \uc911\ub2e8(suspend/yield)\uc774 \uac00\ub2a5\ud588\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud558\uba74, \ub2f5\uc740 \uba85\ud655\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc788\uc73c\uba74 \uc774 \ubb38\uc81c\ub97c \ud574\uacb0\ud560 \uc218 \uc788\uc744 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc5b4\ub85c \uad6c\ud604\ud558\ub358 \uac1c\ub150\uc744 \uc5b4\ub5bb\uac8c \uc2a4\ud0dd \uc138\uc0c1\uc73c\ub85c \uac00\uc838\uc62c \uc218 \uc788\uc744\uae4c? \uc9c8\ubb38\uc744 \ubc14\uafd4\ubcf4\uc790. \ubb34\uc5c7\uc774 \uc601\uc18d\uc131\uc744 \uac00\uc838\uc57c \ud558\ub294\uac00?: \ubb38\ub9e5 \ubb38\ub9e5\uc740 \ubb34\uc5c7\uc778\uac00?: \ub8e8\ud2f4\uc758 \uc0c1\ud0dc \uc0c1\ud0dc\ub294 \ubb34\uc5c7\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c0\ub294\uac00?: \ud658\uacbd & \uba54\ubaa8\ub9ac \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\ub294 \uc5b4\ub514\uc5d0 \uc704\uce58\ud558\ub294\uac00?: \ud568\uc218 \ud504\ub808\uc784(Function Frame) \uc815\ub9ac\ud558\uc790\uba74, \uc9c8\ubb38\uc740 \uc5b4\ub5bb\uac8c \ud568\uc218 \ud504\ub808\uc784\ub4e4\uc744 \uc601\uc18d\uc131\uc788\uac8c \ub9cc\ub4e4 \uac83\uc778\uac00 \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc124\uba85\uc740 \uc790\uc138\ud788 \uae30\uc220\ud558\uc9c0\ub294 \uc54a\uaca0\uc9c0\ub9cc, \uc790\uc138\ud55c \uc124\uba85\uc744 \uc6d0\ud55c\ub2e4\uba74 \uc774 \ud398\uc774\uc9c0 \ub97c \ucc38\uace0\ud558\ub77c. \uc2a4\ud0dd \uc548? \ubc16! \u00b6 \"\uc65c \uc740\ud589\uc744 \ud130\ub098\uc694?\" \"\ub3c8\uc774 \uac70\uae30\uc5d0 \uc788\uc796\uc544\uc694\" - \uc5b4\ub290 \uc740\ud589 \uac15\ub3c4 \uc2a4\ud0dd \ub0b4(Stack-ful) \ucf54\ub8e8\ud2f4 / \ubd84\ud560 \uc2a4\ud0dd \u00b6 \uc5b8\uc5b4\ub9c8\ub2e4 \ub2e4\ub974\uaca0\uc9c0\ub9cc, C++\ub294 \ud568\uc218 \ud504\ub808\uc784\uc744 \uc2a4\ud0dd\uc5d0 \ubc30\uce58\ud55c\ub2e4. \uc774\ub7f0 \uc0c1\ud669\uc5d0\uc11c \ud504\ub808\uc784\uc744 \ubcf4\uc874\ud558\ub824\uba74, \ud504\ub808\uc784\uc744 \uadf8\ub300\ub85c \ubcf5\uc0ac\ud574\uc11c \uc5b4\ub518\uac00\uc5d0 \uc800\uc7a5\ud574\ub450\ub294 \uc218 \ubc16\uc5d0 \uc5c6\ub2e4. \ub2e4\ub978 \ubc29\ubc95\uc73c\ub85c\ub294 \uc801\ub2f9\ud55c \uacf5\uac04\uc744 \ub530\ub85c \uc608\uc57d\ud574\uc11c \ub300\uccb4 \uc2a4\ud0dd(side stack)\uc73c\ub85c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc774 \uc788\uc744 \uac83\uc774\ub2e4. \uc774 \ubd80\ubd84\uc740 \uc9c0\ub098\uce58\ub3c4\ub85d \ud558\uaca0\ub2e4. MSVC\ub294 \uc2a4\ud0dd \uc678 \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4. \uc2a4\ud0dd \uc678(Stack-less) \ucf54\ub8e8\ud2f4\uacfc \ud568\uc218 \ud504\ub808\uc784 \u00b6 N3858 \uc81c\uc548\uc11c\uc5d0\ub294 \uc774\ub978\ubc14 '\ub2e4\uc2dc \uc2dc\uc791\ud558\ub294 \ud568\uc218'(Resumable Function, \uc774\ud558 \uc7ac\uac1c\ud568\uc218)\uc758 \uad6c\ud604\uac00\ub2a5\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uadf8 \ubc29\ubc95\ub860 \uc911 \ud558\ub098\ub294 \ud799(Heap)\uc5d0 \ud568\uc218\uc758 \ud65c\uc131 \ud504\ub808\uc784(Activation Frame)\uc744 \ud560\ub2f9\ud558\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud504\ub808\uc784\uc740 \ub2e8\uc21c\ud558\uac8c\ub294 \uad6c\uc870\uccb4\uc77c \ubfd0\uc774\ub2e4. \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791 4\uac1c\ub294 \uc5b4\ub5bb\uac8c \ub41c \uac83\uc77c\uae4c? \uc774\ub4e4\uc740 Compiler Intrinsic \ud615\ud0dc\ub85c MSVC\uac00 \uc790\uccb4\uc801\uc73c\ub85c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... \uadf8\ub7ec\ub2c8 \uc774 \ubd80\ubd84\uc5d0 \ub300\ud574\uc11c\ub294 \uc190\ub308 \uc218 \uc788\ub294 \ubd80\ubd84\uc774 \uc5c6\ub2e4. \ub354 \uc790\uc138\ud55c \uc124\uba85\uc774 \ud544\uc694\ud558\ub2e4\uba74 \ucc38\uace0\uc790\ub8cc\uc5d0\uc11c CppCon \ubc1c\ud45c\ub4e4\uc744 \uc2dc\uccad\ud558\uae30\ub97c \uad8c\ud55c\ub2e4. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block \uc774 intrinsic\ub4e4 \uc911 Frame\uacfc Block\ub4e4\uc758 \uc5ed\ud560\uc5d0 \ub300\ud574\uc11c \uba85\ud655\ud558\uc9c0 \uc54a\uc740 \ubd80\ubd84\uc774 \ub0a8\uc544\uc788\ub294 \uac83 \uac19\uc2b5\ub2c8\ub2e4. \uae30\ud68c\uac00 \ub418\uba74 \uc5c5\ub370\uc774\ud2b8 \ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. The C++ Coroutine : Resumable Function \u00b6 \uc774 \uc2dc\uc810\uc5d0\uc11c \ub450 \uc6a9\uc5b4\ub97c \uc815\ub9ac\ud560 \ud544\uc694\uac00 \uc788\uc744 \uac83 \uac19\ub2e4. Coroutine : \uac1c\ub150 . \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Resumable Function : C++ \uc5b8\uc5b4\uc5d0\uc11c Coroutine\uc758 \uad6c\ud604 \ubc29\ubc95 \ucd94\uac00\ub85c \ub2e4\uc74c \ud45c\ub294 \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791\ub4e4\uc744 \uc5b4\ub5bb\uac8c \uc0ac\uc6a9\ud558\ub294\uc9c0 \uc815\ub9ac\ud55c \uac83\uc774\ub2e4. Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return \ud638\ucd9c(Invoke) \u00b6 \ud568\uc218 \ud638\ucd9c\uc5d0 \ub300\ud574\uc11c\ub294 \ubcc0\uacbd\uc0ac\ud56d\uc774 \uc5c6\ub2e4. \ud558\uc9c0\ub9cc \uc7ac\uac1c\ud568\uc218\ub294 std::future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4. \uc885\ub8cc(Finalize) \u00b6 \uc11c\ube0c\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ubc18\ud658\uc9c0\uc810\uc740 \uc775\ud788 \uc54c\ub824\uc9c4 return \ud0a4\uc6cc\ub4dc\ub97c \uc0ac\uc6a9\ud558\uba74 \ub41c\ub2e4. \ucf54\ub8e8\ud2f4\uc774\ub77c\uba74 co_return \ud0a4\uc6cc\ub4dc\uac00 \uc774 \uc5ed\ud560\uc744 \ub300\uc2e0\ud55c\ub2e4. \uc911\ub2e8(Suspend) \u00b6 \ud568\uc218\ub97c \uc911\ub2e8\ud558\uace0 Control Flow\ub97c \uc591\ubcf4\ud558\ub294 \ubc29\ubc95\uc740 co_yield expression\uacfc co_await \uc5f0\uc0b0\uc790\ub97c \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. \uc774 \ub458 \uc911 \ud558\ub098\ub77c\ub3c4 \uc0ac\uc6a9\ud558\uba74, \uadf8 \uc9c0\uc810\uc740 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc73c\ub85c \uc0ac\uc6a9\ub418\uba70 MSVC\ub294 \uadf8 \ud568\uc218\ub97c \uc7ac\uac1c\ud568\uc218\ub85c \ub9cc\ub4e4\uac8c \ub41c\ub2e4. (\ub354\ud574\uc11c co_return \uad6c\ubb38\ub3c4 \ud568\uc218 \ub0b4\uc5d0 \uc704\uce58\ud558\uba74 \uc7ac\uac1c\ud568\uc218\ub85c \uc778\uc2dd\ub41c\ub2e4.) \ud65c\uc131\ud654(Activate) \u00b6 \uc911\ub2e8\ub41c \ud568\uc218\ub97c \ud65c\uc131\ud654 \ud560 \ub54c\ub294, coroutine_handle \uacfc \uba64\ubc84\ud568\uc218 .resume() \ub97c \uc0ac\uc6a9\ud55c\ub2e4. \uc774 \ud638\ucd9c\uc740 Compiler Intrinsic\uc778 _coro_resume \uc704\uc5d0 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc62c\ub9b0 \uac83\uc774\ub2e4. Code \u00b6 \uc608\uc81c \ucf54\ub4dc\uc640 \uad00\ub828\ud574 kirkshoop\uc758 \uc800\uc7a5\uc18c \uac00 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uc2b5\ub2c8\ub2e4. \ubbf8\ub9ac \uc694\uc57d\ud558\uc790\uba74, MSVC\uc758 \uc694\uad6c\uc0ac\ud56d\uc744 \ub530\ub974\uae30\ub9cc \ud55c\ub2e4\uba74 C++\uc5d0\uc11c\ub3c4 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. \uc81c\uc548\uc11c\uc758 \uc774\ub984\uc774 \uc7ac\uac1c (\ub530\ub77c\uc11c, \uc601\uc18d\uc131 \uc788\ub294) \ud568\uc218 \ub77c\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud558\ub77c. \uc7ac\uac1c\ud568\uc218\uc5d0\ub294 \uba87\uac00\uc9c0 \uc885\ub958\uac00 \uc788\ub294\ub370, \ud568\uc218\uc5d0 \uc5b4\ub5a4 \uc5ed\ud560\uc744 \ub9e1\uae30\uace0\uc790 \ud558\ub290\ub0d0\uc5d0 \ub530\ub77c \ub2ec\ub77c\uc9c4\ub2e4. \uadf8\ub7ec\uba74 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc694\uad6c\uc0ac\ud56d\uc774\ub780 \ubb34\uc5c7\uc77c\uae4c? Promise : \ucef4\ud30c\uc77c\ub7ec\uac00 \uc6d0\ud558\ub294 \uac83 \u00b6 C++11\uc5d0 \ucd94\uac00\ub41c std::future<T> \uc640 std::promise<T> , \uadf8\ub9ac\uace0 \uc774 \ub450 \uc9dd\uad81\uc758 \uad00\uacc4\uc5d0 \ub300\ud574\uc11c \uc54c \uac83\uc774\ub77c \uc804\uc81c\ud558\uaca0\ub2e4. \uc77c\ubc18\uc801\uc73c\ub85c, future<T> \ub294 \" \ub098\uc911\uc5d0 \uac12\uc774\ub098 \uc608\uc678\ub97c \uc904\uac8c\"\ub77c\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. ( std::async \ub97c \ucc38\uace0\ud558\ub77c) \uadf8\ub9ac\uace0 \uac12/\uc608\uc678\ub294 promise<T> \ub97c \ud1b5\ud574\uc11c \uc804\ub2ec\ub41c\ub2e4. \uc774\ub294 \"\uacb0\uacfc\ub97c \uc900\ub2e4\ub294 \uc57d\uc18d \uc744 \uc9c0\ucf30\ub2e4.\"\ub77c\ub294 \uac83\uc774\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\uac00 future<T> \ub97c \ubc18\ud658\ud55c\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \ub9d0 \uadf8\ub300\ub85c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \uc2a4\uc2a4\ub85c \uc911\ub2e8\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0 \ud65c\uc131\ud654\ud55c \ub8e8\ud2f4 \uc785\uc7a5\uc5d0\uc11c\ub294 \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc\ud588\ub294\uc9c0 \uc54c \ubc29\ubc95\uc774 \uc5c6\ub2e4. \ubc18\ud658\uac12\uc774 \uc788\ub2e4\ub294 \uac83\uc744 \uc54c \uc218 \uc5c6\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud568\uc218\uc758 \uc2dc\uadf8\ub2c8\ucc98(Signature)\uc0c1\uc73c\ub85c\ub294, \ub098\uc911\uc5d0 \ub77c\ub294 \uc758\ubbf8\uac00 \ub2f4\uae34 \ud0c0\uc785 future \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud568\uc73c\ub85c\uc368 \uc77c\ubc18\uc801\uc778 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uace0 \uc788\ub2e4. \ub2e4\ub9cc \uae30\uc874\uacfc \ub2ec\ub9ac \uc5ec\uae30\uc11c\uc758 promise \ub294 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c\uac83\uc774\ub2e4. N4402 \ub294 \uc774 \ub0b4\uc6a9\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uc5b4\uc9f8\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uac8c \uc57d\uc18d\uc774 \ud544\uc694\ud55c \uac83\uc77c\uae4c? \uc774\ub294 \uc7ac\uac1c\ud568\uc218\uac00 \ucd94\uc0c1\ud654 \ud55c \uacb0\uacfc\ubb3c\uc774\uae30 \ub54c\ubb38\uc774\ub2e4. \uc2a4\ud0dd \uae30\ubc18\uc758 \ud658\uacbd\ub54c\ubb38\uc5d0, \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud558\uae30\ub294 \ud588\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc640 \uac19\uc774 1\ucc28\uc6d0\uc73c\ub85c \ubc30\uce58\ub41c(flat) \uad6c\ubb38\uad6c\uc870\ub294 \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 \uacb0\uad6d \ud799\uc5d0\uc11c \uc0b4\uc544\uc788\uc73c\uba70, \ud799 \uc601\uc5ed(\ud568\uc218 \ud504\ub808\uc784)\uc5d0\uc11c \uc2a4\ud0dd \uc601\uc5ed( future \ub610\ub294 awaitable)\uc73c\ub85c \uac12\uc744 \uc804\ub2ec\ud574\uc57c \ud558\uace0, \uc774 \uacfc\uc815\uc740 \uc77c\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4 \ub97c \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9c0\ub3c4\ub85d \ud55c \uac83\uc774\ub2e4. \ubb3c\ub860 \uc778\ud130\ud398\uc774\uc2a4\ub294 \ucef4\ud30c\uc77c\ub7ec\uc640 \ud504\ub85c\uadf8\ub798\uba38 \uc591\ucabd \ubaa8\ub450\ub97c \uc704\ud55c \uac83\uc774\ub2e4. Resumable Promise Requirement \u00b6 \uc7ac\uac1c\ud568\uc218\uc758 Promise \uc694\uad6c\uc0ac\ud56d \uadf8 \uc778\ud130\ud398\uc774\uc2a4\uac00 \uc5b4\ub5bb\uac8c \uc4f0\uc774\ub294\uc9c0\ub294 \uc7a0\uc2dc \ud6c4 \uae30\uc220\ud558\uace0, \uadf8\uc5d0 \uc55e\uc11c N4402 \ubb38\uc11c\ub97c \uc0b4\ud3b4\ubcf4\uc790. \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub294 Promise \ud0c0\uc785\uc740 \uc544\ub798 \ud45c\uc5d0 \uc5f4\uac70\ub41c \uba64\ubc84\ud568\uc218\ub4e4\uc744 \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4. \uc81c\uc548\uc11c\ub97c \uc694\uc57d\ud55c \uac83\uc774\ubbc0\ub85c, \ubcf4\ub2e4 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc81c\uc548\uc11c\ub97c \ucc38\uace0\ud558\uae30 \ubc14\ub780\ub2e4. Expression Note P{} \uc774 \ud0c0\uc785\uc740 default constructible \ud574\uc57c\ud55c\ub2e4. p.get_return_object() \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc744 \uacb0\uc815\ud55c\ub2e4. future<T> \ud639\uc740 \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc774 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4. p.return_value(v) co_return \uad6c\ubb38. \uacb0\uacfc\uac12\uc73c\ub85c v \ub97c \uc804\ub2ec\ud558\uba70, \uadf8 \uac12\uc740 \ub098\uc911\uc5d0 \uc0ac\uc6a9(consume)\ub41c\ub2e4. p.return_value() co_return \uad6c\ubb38. void \ud0c0\uc785\uc5d0 \uc0ac\uc6a9\ub418\uba70, \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\uc744 \uc758\ubbf8\ud558\uae30\ub3c4 \ud55c\ub2e4. \uc7ac\uac1c\ud568\uc218\uac00 \uc885\ub8cc\ub420\ub54c \uc0ac\uc6a9\ub41c\ub2e4. \uc774 \ud568\uc218\uac00 \ud638\ucd9c\ub418\ub294 \uac83\uc740 \"\ub354\uc774\uc0c1 \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\"\uc744 \uc758\ubbf8\ud55c\ub2e4. p.set_exception(e) \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. Resumer \uce21\uc5d0\uc11c \uacb0\uacfc\uac12\uc744 \uc0ac\uc6a9\ud558\ub824\uace0 \ud560\ub54c throw \ub41c\ub2e4. p.yield_value(v) co_yield \ud45c\ud604\uc2dd. return_value(v) \uc640 \uc720\uc0ac\ud558\ub2e4. p.initial_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810(initial suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. p.final_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810(final suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. \uc5ec\uae30\uc11c \uc77c\ubd80 \ud568\uc218\ub4e4\uc740 coroutine_traits<T> \uc640 \uc5f0\uad00\ub418\uc5b4\uc788\ub294\ub370, \uc774\ud6c4\uc5d0 \uc774 \ud0c0\uc785\uc758 \uc720\ub3d9\uc131\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\uaca0\ub2e4. \uc774\uc81c C++ \ucf54\ub8e8\ud2f4\uc758 \uc0ac\uc6a9\ubc29\ubc95\uc73c\ub85c \ucd08\uc810\uc744 \uc62e\uaca8\ubcf4\uc790. Generator \u00b6 \uac1c\ub150 \u00b6 Generator = Iterator + Resumable Function \ubc18\ubcf5\uc790\uac00 \ubcf4\uc774\ub294\uac00? generator<T> \ub294 \uac12\uc758 \uc218\uc5f4(sequence)\uc744 \ucd94\uc0c1\ud654 \ud55c \uac83\uc774\ub2e4. \uc774\ub54c \uac12\uc740 \uc7ac\uac1c\ud568\uc218\uc5d0 \uc758\ud574\uc11c \uc0dd\uc131\ub418\ub294\ub370, \uc7ac\uac1c\ud568\uc218\ub294 \uc0c8\ub85c \ud638\ucd9c\ub418\uba74 \ud568\uc218 \ud504\ub808\uc784\uc774 \ud799 \uc601\uc5ed\uc5d0 \uc720\uc9c0\ub418\ubbc0\ub85c, generator \ub9c8\ub2e4 \uace0\uc720\ud55c \ubb38\ub9e5\uc744 \uac00\uc9c0\uac8c \ub41c\ub2e4. Example \u00b6 \ub2e4\uc74c \ucf54\ub4dc\ub294 N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator \ub97c \uc791\uc131\ud55c \uac83\uc774\ub2e4. #include <experimental/generator> // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc9c0\uc815(Set)\ud558\uace0 \uc911\ub2e8(Suspend)\ud55c\ub2e4. co_yield f1 ; // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uad6c\ud55c \ub4a4 Shift \ud55c\ub2e4. int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // \ub354\uc774\uc0c1 \uac12\uc744 \uc0dd\uc131\ud558\uc9c0 \uc54a\ub294\ub2e4. } void usecase () { // 10\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \ubc1b\ub294\ub2e4. for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc5b4\ub5bb\uac8c \uc774\uac8c \uac00\ub2a5\ud55c\uac78\uae4c? generator<T> \uc758 \uc815\uc758\ub97c \uc0b4\ud3b4\ubcf4\uc790. \uc2e4\uccb4(Detail) \u00b6 \uac04\ub7b5\ud558\uac8c generator<T> \ub97c \uc62e\uaca8\uc654\ub2e4. iterator \uc640 promise_type \uc744 \uc9c0\uc6d0\ud558\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ub610\ud55c begin() / end() \ud568\uc218\ub85c Range-based for loop \ub97c \uc9c0\uc6d0\ud558\uace0 \uc788\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud578\ub4e4 coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc788\ub2e4\uba74 \uc7ac\uac1c\ud574\uc11c \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc788\ub2e4. if ( _Coro ) { _Coro . resume (); // \ud568\uc218\uac00 \ubc18\ud658\ub418\uc5c8\ub098? if ( _Coro . done ()) return { nullptr }; // return end(); } // \uc544\uc9c1 \ub05d\ub098\uc9c0 \uc54a\uc558\ub2e4. // \ub2e4\uc74c\uc5d0 \ub2e4\uc2dc resume\ud558\uc790... return { _Coro }; } iterator end () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc5c6\ub2e4\uba74, \uac12\uc744 \ub354 \uac00\uc838\uc62c \uc218 \uc5c6\ub2e4. return { nullptr }; } ~ generator () { // RAII : \ud568\uc218 \ud504\ub808\uc784\uc744 \ud30c\uad34\ud55c\ub2e4. if ( _Coro ) { _Coro . destroy (); } } }; \uc774\ub97c \ubc14\ud0d5\uc73c\ub85c \uc2e4\uc81c\ub85c\ub294 \uc774\ub7f0 \ucf54\ub4dc\uac00 \ub9cc\ub4e4\uc5b4\uc9c8 \uac83\uc774\ub2e4. void usecase () { // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int > gen = fibonacci ( 10 ); // `iter++`\ub294 delete\ub418\uc5c8\uc73c\ubbc0\ub85c \uc0ac\uc6a9\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc77c\ubc18\uc801\uc778 iterator-for \uad6c\ubb38\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. iterator \ub294 \uc5b4\ub5bb\uac8c \ub418\uc5b4\uc788\uc744\uae4c? template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // \ubc18\ubcf5\uc790 \uc778\ud130\ud398\uc774\uc2a4 struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // \ub2e4\uc74c\uc73c\ub85c \uc774\ub3d9\ud560\ub54c... iterator & operator ++ () { // \ud568\uc218\ub97c \uc7ac\uac1c\ud574\uc11c \uac12\uc744 yield\ud558\ub3c4\ub85d \ud55c\ub2e4. _Coro . resume (); // \ub9cc\uc57d \ud568\uc218\uac00 return\ud588\ub2e4\uba74, \uadf8 \ud578\ub4e4\uc740 generator\uac00 \uc18c\uba78\uc2dc\ud0ac \uac83\uc774\ub2e4. if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // MSVC\uc758 \ucf54\uba58\ud2b8\ub294, \uc694\uc57d\ud558\uc790\uba74, // \ud6c4\uc704\uc99d\uac00\uc2dd\uc740 iterator\ub97c \ub36e\uc5b4\uc4f8 \uc218 \uc788\uace0, // \uc774\ub85c\uc778\ud574 handle\uc774 nullptr\ub85c \ubc14\ub00c\uba74\uc11c // \ud568\uc218 \ud504\ub808\uc784 \ub0b4\uc5d0 \ub9c8\uc9c0\ub9c9 \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc5c6\ub2e4\ub294 \uac83\uc774\ub2e4. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // `promise`\uc5d0 \ud3ec\uc778\ud130\uac00 \uc788\ub2e4. \ud3ec\uc778\ud130\ub97c \ucc38\uc870\ud574 \ud504\ub808\uc784 \uc548\uc758 \uac12\uc744 \uac00\uc838\uc628\ub2e4. _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; \uc774 \ucf54\ub4dc\ub97c \ubcf4\uba74 \ubc18\ubcf5\uc790\uac00 \ud568\uc218\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc7ac\uac1c\ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 generator<T> \uc758 promise_type \uc744 \ud1b5\ud574\uc11c \uac12\uc744 \ud68d\ub4dd\ud55c\ub2e4. \uc774 \uacbd\uc6b0\ub294 usecase \ud568\uc218\uac00 generator \uc758 \ud638\ucd9c\uc790\uba74\uc11c \uc7ac\uac1c\uc790\uc778 \uac83\uc774\ub2e4. \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810 \u00b6 \uc774\uc81c \ud575\uc2ec\uc774 \ub418\ub294 promise_type \uc744 \ubcfc \ucc28\ub840\ub2e4. \uae30\uc220\ub41c \uac83 \ubcf4\ub2e4 \ucf54\ub4dc\uac00 \uc880 \ub354 \uc788\uc9c0\ub9cc \ub2e8\uc21c\ud654 \ud558\uc600\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } \uc774 promise_type \uc740 \uc694\uad6c\uc0ac\ud56d \uc911\uc5d0\uc11c 4\uac1c\uc758 \uba64\ubc84\ud568\uc218\ub97c \ub9cc\uc871\ud55c\ub2e4. get_return_object , initial_suspend , final_suspend , \uadf8\ub9ac\uace0 yield_value \uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. co_yield \ub294 \"\uac12\uc744 \uc9c0\uc815\ud558\uace0 \uc911\ub2e8\ud558\ub77c\"\uc640 \uac19\uc740 \uc758\ubbf8\uc778\ub370, \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774\ub97c \uc774\ub807\uac8c \ubcc0\uacbd\ud55c\ub2e4. co_yield : co_await + p.yield_value(x) \ub530\ub77c\uc11c, co_yield \uc5d0 \uc778\uc790 \ud45c\ud604\uc2dd\uc774 \uc5c6\ub2e4\ub294 \uac83\uc740 \ubd88\uac00\ub2a5 \ud558\ub2e4. x \ub294 void \uac00 \ub420 \uc218 \uc5c6\uae30 \ub54c\ubb38\uc774\ub2e4. \uac19\uc740 \uc774\uc720\ub85c generator<void> \ub294 \ucef4\ud30c\uc77c \uc5d0\ub7ec\uac00 \ub418\uba70, \uc5f0\uc18d\ub41c \uac12\uc758 \ucd94\uc0c1\ud654\ub77c\ub294 \uc815\uc758\uc5d0\ub3c4 \uc704\ubc30\ub41c\ub2e4. \uc5c4\ubc00\ud788 \ub9d0\ud574 \uc5ec\uae30\uc11c co_await \ub294 suspend \ub97c \uc758\ubbf8\ud55c\ub2e4. \uc790\uc138\ud55c \uc124\uba85\uc740 \ud6c4\uc220\ud55c\ub2e4. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud45c\ud604\uc2dd\uc744 \uc544\ub798\uc640 \uac19\uc774 \ubc14\uafbc\ub2e4. // co_yield f1; p . yield_value ( f1 ); // \uac12\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc9c0\uc815\ud558\uace0 co_await suspend_always {}; // \uc911\ub2e8\ud55c\ub2e4. // ... } co_return ; // \ub354\uc774\uc0c1 \uac12\uc774 \uc5c6\ub2e4. } \uc774 \ucf54\ub4dc\uc5d0\ub294 promise_type p{} \uac19\uc740 \ubcc0\uc218 \uc120\uc5b8\uc774\ub098, \ub2e4\ub978 \ud568\uc218\ub4e4\uc758 \ud638\ucd9c\uc774 \uc5c6\ub2e4. \uadf8 \uc774\uc720\ub294 \ub2e4\uc74c \ub2e8\uc6d0\uc5d0\uc11c \ub2e4\ub8e8\uaca0\ub2e4. Resumable Function \u00b6 \uc7ac\uac1c \ud568\uc218 \uc774\ubc88\uc5d4 \uc880 \ub354 \uc0c1\ud5a5\uc2dd\uc73c\ub85c \uc54c\uc544\ubcf4\uc790. \uc608\uc81c\ucf54\ub4dc\ub294 Awaitable Concept\ub97c \uc774\ud574\ud55c \ub4a4\uc5d0 \ubd10\uc57c \ud55c\ub2e4. \uac1c\ub150 \u00b6 Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> \ub294 \ub2e8\uc21c\ud55c \uc608\uc81c\uc600\ub2e4. generator \ub294 coroutine_handle \uc744 \uba64\ubc84\ubcc0\uc218\ub85c \uac00\uc9c0\uace0 \uc788\uc5c8\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ubb34\uc5c7\uc778\uc9c0 \uc0b4\ud3b4\ubd10\uc57c \ud55c\ub2e4. \uc0ac\uc2e4, coroutine_handle \uc758 \uc608\uc804 \uc774\ub984\uc740 resumable_handle \uc600\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 C++\uc0c1\uc5d0\uc11c \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud55c \uac83\uc774\ub77c\uace0 \uc124\uba85\ud588\ub294\ub370, coroutine_handle \ub294 \ub2ec\ub9ac \ub9d0\ud558\uba74 \uc7ac\uac1c\ud568\uc218\uc5d0 \ub300\ud55c \ud578\ub4e4(Resumable Function Handle)\uc774\ub2e4. Windows API\ub97c \uc0ac\uc6a9\ud574\ubcf8 \uacbd\ud5d8\uc774 \uc788\ub2e4\uba74 Handle \uc774 \uacb0\uad6d void* \ub77c\ub294 \uac83\uc744 \uc54c \uac83\uc774\ub2e4. \uc5ec\uae30\uc11c\ub3c4 \ub3d9\uc77c\ud558\ub2e4. \uc55e\uc11c \uc124\uba85\ud588\ub358 \uac83 \ucc98\ub7fc MSVC\ub294 \ud799 \uc601\uc5ed\uc5d0 \ud504\ub808\uc784\uc744 \ub3d9\uc801\ud560\ub2f9\ud558\uace0, \uac70\uae30\uc5d0 \uc57d\uac04\uc758 intrinsic\uc744 \ub354\ud558\ub294 \ud615\ud0dc\ub85c \uc2a4\ud0dd \uc678(stack-less) \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4. coroutine_handle \uc740 \uc774\ub4e4\uc744 \ud558\ub098\uc758 \ud0c0\uc785\uc73c\ub85c \ubb36\uc5b4\ub193\uc740 \uac83\uc774\ub2e4. \uc7ac\uac1c\ud568\uc218\uc758 \ud504\ub808\uc784 \u00b6 \uadf8\ub7ec\uba74, Resumable Frame \uc740 \ub300\uccb4 \uc5b4\ub5bb\uac8c \uc0dd\uacbc\uc744\uae4c? \uc77c\ub2e8 \ud504\ub808\uc784\uc740 Head\uc640 Body\ub85c \ub098\ub25c\ub2e4. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Head // - Fn : \uc7ac\uac1c\ud560 \ub54c \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc758 \uc8fc\uc18c // - cdecl : \uc774 Convention\uc5d0\uc11c \ud568\uc218 \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 Caller \uac00 \ub2f4\ub2f9\ud55c\ub2e4. // - Index : Resumption point\uc758 \uc778\ub371\uc2a4 // 0\ubc88\uc740 \ud568\uc218\uac00 \uc885\ub8cc\ub41c(`done()`) \uacbd\uc6b0\uc5d0 \uc0ac\uc6a9\ud55c\ub2e4. // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Body \uc5d0\ub294... // - Promise \ud0c0\uc785 \uac1c\uccb4 // - \ud504\ub808\uc784\uc73c\ub85c \uc774\ub3d9\uc2dc\ud0a8 Arguments // - \ud568\uc218 Body // - \uc9c0\uc5ed/\uc784\uc2dc \ubcc0\uc218\ub4e4 // - Platform \uc804\uc6a9 // - \ub808\uc9c0\uc2a4\ud130 \ub4f1\ub4f1 // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : \uc774\ub984\ucc98\ub7fc _Resumable_frame_prefix \uac00 \ud568\uc218\ud504\ub808\uc784\uc758 \uc55e\ubd80\ubd84\uc774 \ub41c\ub2e4. MSVC \ub294 \uc774 \uacf5\uac04\uc5d0 sizeof(void *) * 2 (x64 \uc5d0\uc11c 16 \ubc14\uc774\ud2b8)\ub9cc\ud07c\uc758 \uace0\uc815\ub41c \ud06c\uae30\ub97c \uc0ac\uc6a9\ud55c\ub2e4. Fn : cdecl \ud638\ucd9c \uaddc\uc57d\uc73c\ub85c \uc120\uc5b8\ub418\uc5b4\uc788\ub2e4\ub294 \uc810\uc774 \ud2b9\uc774\ud55c\ub370, cdecl \uc5d0\uc11c \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 \ud638\ucd9c\uc790\uc758 \uc5ed\ud560\uc774\uba70, \ub530\ub77c\uc11c Fn \uc744 \ud638\ucd9c\ud558\ub294 \uac83\uc740 \uadf8 \uc2dc\uc810\uc758 \uc2a4\ud0dd\uacfc \ud568\uc218 \ud504\ub808\uc784\uc5d0 \uc601\ud5a5\uc744 \ubbf8\uce58\uc9c0 \uc54a\ub294\ub2e4. Index : \uc7ac\uac1c\ud568\uc218\ub294 \ub2e4\uc218\uc758 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\ub4e4\uc744 \uac00\uc9c0\uace0 \uc788\uace0, Index \ub294 \uac01 \uc9c0\uc810\ub4e4\ub85c switch \ud558\ub294\ub370 \uc0ac\uc6a9\ub41c\ub2e4. Flag : ??? \uc774\uac74 \ub300\uccb4 \ubb58\uae4c ??? Body : N4402\uc5d0 \ud568\uc218 \ud504\ub808\uc784\uc758 \uad6c\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. James McNellis\uc758 \ubc1c\ud45c\uc790\ub8cc\uc5d0 \uc758\ud558\uba74, \ucef4\ud30c\uc77c\ub7ec\uac00 \uc0dd\uc131\ud558\ub294 \ud504\ub808\uc784\uc740 \ub2e4\uc74c\uc744 \ud3ec\ud568\ud55c\ub2e4. \uc77c\ubc18\uc801\uc778 \uc2a4\ud0dd \ud504\ub808\uc784\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // `fibonacci` \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784(\uc608\uc2dc) struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci\ub294 `generator<int>`\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int >:: promise_type _p ; // \ud504\ub808\uc784\uc5d0 \uc778\uc790\ub97c \uc800\uc7a5\ud55c\ub2e4. int _n ; // fibonacci(n); int _f1 , _f2 ; // \uc9c0\uc5ed \ubcc0\uc218 int _i , _f3 ; // \uc784\uc2dc \ubcc0\uc218 // Platform \uc804\uc6a9 \uc800\uc7a5\uc18c // \ub808\uc9c0\uc2a4\ud130\ub098 \uc774\uac83\uc800\uac83... }; Coroutine Traits \u00b6 p.get_return_object() \uc5d0 \ub300\ud574\uc11c \ub2e4\ub8e8\uc9c0 \uc54a\uc558\uc5c8\ub294\ub370, \uc5ec\uae30\uc11c \uac19\uc774 \ub2e4\ub8e8\uace0\uc790 \ud55c\ub2e4. \uba3c\uc800 coroutine_traits \ub97c \ub208\uc5ec\uaca8\ubd10\uc57c \ud55c\ub2e4. // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; \uad49\uc7a5\ud788 \ub2e8\uc21c\ud55c\ub370, coroutine_traits \uc774 \uc694\uad6c\ud558\ub294 \uac83\uc740 \uacb0\uad6d promise_type \ub97c \uad6c\ud604\ud558\ub77c\ub294 \uac83\uc774\ub2e4. \uc774\uc5d0 \ub300\ud55c \uac80\uc0ac\ub294 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uc774\ub8e8\uc5b4\uc9c0\uace0, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement \ub97c \ub9cc\uc871\uc2dc\ucf1c\uc57c \ud55c\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\ub294 future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \uc0ac\uc2e4 \uadf8\uac83\uc740 \ubd80\uc815\ud655\ud55c \uc124\uba85\uc774\uc5c8\ub2e4. coroutine_traits \ub97c \ub9cc\uc871\uc2dc\ud0a4\uae30\ub9cc \ud55c\ub2e4\uba74, \uadf8 \ud0c0\uc785\uc740 \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc774 \ub420 \uc218 \uc788\ub2e4. std::future<T> \ub97c \uc704\ud55c coroutine_traits \uc758 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 \ubc84\uc804\uc744 \uc62e\uaca8\uc654\ub2e4. generator<T> \uc758 \uacbd\uc6b0\ub294 \ub0b4\ubd80\uc5d0 promise_type \uc744 \uad6c\ud604\ud558\uace0 \uc788\uc5c8\ub294\ub370, \uc608\uc804\ubd80\ud130 \uc0ac\uc6a9\ud558\ub358 \ud0c0\uc785\ub4e4\uc774\ub098 \ucee4\uc2a4\ud140 \ud0c0\uc785\ub4e4\uc740 \uc774\ub7f0 \ud2b8\ub9ad\uc744 \uc0ac\uc6a9\ud574\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc720\uc5f0\ud558\uac8c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. // <future> \ud5e4\ub354 #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // `std::future<T>`\ub97c \uc704\ud55c \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // `future<_Ty>`\ub97c \ubc18\ud658\ud558\ub294 \uc7ac\uac1c\ud568\uc218\ub4e4\uc744 \uc704\ud55c \ud0c0\uc785\uc815\uc758 struct promise_type { // `std::promise<T>`\ub97c \uadf8\ub300\ub85c \uc0ac\uc6a9\ud55c\ub2e4. promise < _Ty > _MyPromise ; // \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc740 `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // `false`\uc77c \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool initial_suspend () const { return ( false ); } // `false`\uc77c \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool final_suspend () const { return ( false ); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif MSVC\ub294 co_await / co_yield / co_return \ud0a4\uc6cc\ub4dc \uc911 \ud558\ub098\ub97c \ud655\uc778\ud558\uba74, coroutine_traits \ub97c \uc0ac\uc6a9\ud574 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uac80\uc0ac\ub97c \uc218\ud589\ud560 \uc218 \uc788\ub3c4\ub85d \ucf54\ub4dc\ub974 \uc0dd\uc131\ud55c\ub2e4. MSVC\uac00 \ud558\ub294 \uc77c\uc744 \ud655\uc778\ud558\uae30 \uc704\ud574 fibonacci \uc608\uc81c\ub85c \ub2e4\uc2dc \uac00\ubcf4\uc790. \uc774 \ucf54\ub4dc\ub294 \ud2c0\ub9b0 \ud615\ud0dc\uc77c \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc815\ud655\ud55c \uba54\ucee4\ub2c8\uc998\uc744 \ud655\uc778\ud558\uac8c \ub418\uba74 \uac31\uc2e0\ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // \ubcc4\uce6d : \ubc18\ud658\ud0c0\uc785 using return_type = generator < int > ; // \ubc18\ud658\ud0c0\uc785\uc774 Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294\uac00? using traits = coroutine_traite < return_type > ; // \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud55c\ub2e4\uba74 \uc774 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4. // fibonacci \ud568\uc218\ub97c \uc704\ud55c \uac00\uc0c1\uc758 \ud504\ub808\uc784. \uc704\uc640 \ub3d9\uc77c\ud558\ub2e4. struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // \ud504\ub808\uc784\uc744 \ub3d9\uc801\uc73c\ub85c \ud560\ub2f9\ud55c\ub2e4. context(ctx)\ub77c\uace0 \ud558\uaca0\ub2e4. // \ud2b9\uc815\ud55c Allocator\ub97c \uc0ac\uc6a9\ud574 \ucee4\uc2a4\ud130\ub9c8\uc774\uc988 \ud560 \uc218\ub3c4 \uc788\uc9c0\ub9cc \uc5ec\uae30\uc120 \ub2e8\uc21c\ud788 new\ub85c \uc124\uba85\ud55c\ub2e4. __frame * ctx = new __frame { std :: move ( n )}; // \ubc18\ud658 \uac1c\uccb4\ub97c \uc0dd\uc131\ud55c\ub2e4. return_type __return = ctx -> _promise . get_return_object (); // true\uc77c \uacbd\uc6b0 \uc911\ub2e8, false\uc77c \uacbd\uc6b0 \uc9c4\ud589\ud55c\ub2e4. if ( ctx -> _promise . initial_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __initial_suspend_point : } // \uc0ac\uc6a9\uc790 \ucf54\ub4dc\ub294 \ud504\ub808\uc784\uc744 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ubcc0\uacbd\ub41c\ub2e4. // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // promise\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // `ctx->_prefix`\uc758 Index\ub97c \uc870\uc815\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4. // co_await suspend_always{}; __suspend_resume_point_1 : // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uacc4\uc0b0\ud558\uace0 Shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __final_suspend_point : } // \uc815\ub9ac\uc791\uc5c5... } \uc0dd\uac01\ubcf4\ub2e4 \ucef4\ud30c\uc77c\ub7ec\uac00 \ub9ce\uc740 \uc791\uc5c5\uc744, \ud558\uc9c0\ub9cc \uae30\uc874\uc5d0 \uc2a4\ud0dd \ud504\ub808\uc784\uc5d0 \ub300\ud574\uc11c \ud558\ub358\uac83\uacfc \uc720\uc0ac\ud55c \uc791\uc5c5\uc744 \ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\uc5c8\ub2e4. ctx \uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ud799\uc601\uc5ed\uc5d0 \uc704\uce58\ud55c \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc740 this \ud3ec\uc778\ud130\uc758 \uc0ac\uc6a9\uacfc \ub2e4\ub974\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \uc774\ub7f0 \ud504\ub808\uc784 \uae30\ubc18 \uad6c\ud604\uc758 \ube44\uc6a9\uc740 \ucd94\uac00\uc801\uc778 co_await \uad00\ub828 \ube44\uc6a9\uc774\uc678\uc5d0\ub294 \ubb34\uc2dc\ud560 \uc218 \uc788\ub294 \uc218\uc900\uc77c \uac83\uc774\ub2e4. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend; \uc7a0\uae50 \uc815\ub9ac \u00b6 co_return \uacfc co_yield \uc5d0 \ub300\ud574\uc11c generator<T> \uc608\uc81c\ub97c \ud1b5\ud574 \uc0b4\ud3b4\ubd24\ub2e4. Generator\ub294 \ubc18\ubcf5\uc790\uc640 \uc7ac\uac1c\ud568\uc218\ub97c \ud569\uce5c \uac83\uc774\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 coroutine_handle \uc744 \uc0ac\uc6a9\ud558\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\uc640 \ucef4\ud30c\uc77c\ub7ec Intrinsic\uc744 \ud569\uccd0\ub193\uc740 \uac83\uc774\ub2e4. \ud504\ub808\uc784 \uae30\ubc18\uc758 \uad6c\ud604\uc740 this \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ubcc0\uc218\ub97c \uc870\uc791\ud558\ub294 \uac83\uacfc \uc720\uc0ac\ud558\ub2e4. \ucef4\ud30c\uc77c \uc2dc\uac04(\uc815\uc801) \uac80\uc0ac\ub97c \uc704\ud574 coroutine_traits<T> \uac00 \uc0ac\uc6a9\ub41c\ub2e4. \uc774\ub97c \ud1b5\ud574 promise_type \uc744 \uad6c\ud604\ud558\ub3c4\ub85d \uac15\uc81c\ud558\uba70, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement\ub97c \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4. std::future<T> \uc758 \uacbd\uc6b0 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654\uac00 \uae30\ubcf8\uc801\uc73c\ub85c \uc9c0\uc6d0\ub41c\ub2e4. \"\uae30\ub2e4\ub9b4 \uc218 \uc788\ub2e4\"\ub294 \uac1c\ub150\uc5d0 \ub300\ud574\uc11c \u00b6 operator co_await = Syntactic Sugar + Resumable Function \uc7ac\uac1c\ud568\uc218\uc758 \ub9c8\uc9c0\ub9c9 \ud575\uc2ec\uc740 \ub2e8\ud56d \uc5f0\uc0b0\uc790 co_await \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ubb38\ub9e5\uc0c1\uc73c\ub85c, await\ub294 suspend\uc640 \uac19\uc740\uc758\ubbf8\ub2e4 . \uadf8\ub9ac\uace0 \uc774 \uc911\ub2e8 \ub54c\ubb38\uc5d0, \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \uc790\uc5f0\uc2a4\ub7fd\uac8c \ube44\ub3d9\uae30 \uac00 \ub41c\ub2e4. \uba58\ud0c8 \ubaa8\ub378 \uc0c1\uc5d0\uc11c \uc774\ub7f0 \ud2b9\uc131\uc740 \uaf64 \uc911\uc694\ud55c \uc810\uc778\ub370, C# \uc5b8\uc5b4\uc758 async & await \uae30\ub2a5\uacfc \uc720\uc0ac\ud558\ub2e4\uace0 \ubcfc \uc218 \uc788\ub2e4. C++ \uc138\uc0c1\uc5d0\uc11c \ub2e4\ub978\uc810\uc740, \ud504\ub85c\uadf8\ub798\uba38\uc758 \ucf54\ub4dc\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc9c0\uc6d0\uc744 \uc0ac\uc6a9\ud574\uc11c \uc218\ub3d9\uc73c\ub85c \uad00\ub9ac\ud560 \uc218 \uc788\ub2e4\ub294 \uc810\uc774\ub2e4. Example \u00b6 MSVC \ube14\ub85c\uadf8\uc758 \uc608\uc81c\ub97c \uac00\uc838\uc654\ub2e4. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // \uc5f0\uc0b0\uc790 \uc624\ubc84\ub85c\ub4dc // co_await \ub294 \uae30\ubcf8 \ud0c0\uc785(primitive type) \uc778\uc790\ub294 \ubc1b\uc9c0 \uc54a\ub294\ub2e4. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc120 \ud568\uc218 3\uac1c\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback\uc744 \uc218\ud589\ud558\ub294 Thread\uc5d0\uc11c Resume\ud55c\ub2e4. coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // \uc900\ube44\uac00 \uc548\ub418\uc5c8\uc73c\uba74 (`false`), `await_suspend`\ub97c \ud638\ucd9c\ud55c\ub2e4. // \uac12\uc774 \uc900\ube44\ub418\uc5c8\uc73c\uba74 (`true`), `await_resume`\ub97c \ubc14\ub85c \ud638\ucd9c\ud55c\ub2e4. bool await_ready () const { return duration . count () <= 0 ; } // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \ubb34\uc2dc\ub420 \uc218 \uc788\ub2e4. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // \ud0c0\uc774\uba38\ub97c \uc138\ud305\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4.... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // \uc7ac\uac1c\ub41c \ud6c4\uc5d0\ub294 T \ud0c0\uc785 \uac12\uc744 \ubc18\ud658\ud55c\ub2e4. // `void`\ub3c4 \uac00\ub2a5\ud558\ub2e4. void await_resume () {} }; return awaiter { duration }; } // \ucf54\ub8e8\ud2f4(\uc7ac\uac1c\ud568\uc218) future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // 1 \ubc00\ub9ac\ucd08\ub97c \uae30\ub2e4\ub9b0\ub2e4... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // \ud3c9\ubc94\ud55c \uc11c\ube0c\ub8e8\ud2f4 void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } \uc774 \ucf54\ub4dc\ub294 \ub300\ub7b5 \uc774\ub7f0 \uc2dd\uc73c\ub85c \uc9c4\ud589\ub41c\ub2e4. \uae30\ub2e4\ub9ac\uae30 \uc704\ud55c \uc778\ud130\ud398\uc774\uc2a4 \u00b6 co_await \ub294 \ub3d9\uc791\ud558\uae30 \uc704\ud574\uc11c \ud2b9\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc694\uad6c\ud55c\ub2e4. \uc704\uc5d0\uc11c \ubcf8 \uac83 \ucc98\ub7fc, Awaitable Interface\ub294 3\uac00\uc9c0 \ud568\uc218\ub97c \uad6c\ud604\ud574\uc57c\ub9cc \ud55c\ub2e4. await_ready await_suspend await_resume \uc774\ub4e4\uc740 \uba64\ubc84\ud568\uc218\uc77c \uc218\ub3c4 \uc788\uace0, \uc77c\ubc18 \ud568\uc218\ub85c\ub3c4 \uac00\ub2a5\ud558\ub2e4. future<T> \uc5ed\uc2dc \uc774 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. \ub2ec\ub9ac\ub9d0\ud574, future<T> \uac00 co_await \uc758 \uc778\uc790\uac00 \ub420\uc218\ub3c4 \uc788\ub2e4\ub294 \uc758\ubbf8\ub2e4. \uc544\ub798 \ucf54\ub4dc\ucc98\ub7fc \ube44\ud6a8\uc728\uc801\uc77c \uc218\ub3c4 \uc788\uaca0\uc9c0\ub9cc, \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c \uac04\ub2e8\ud55c \uc624\ubc84\ub85c\ub4dc \ub9cc\uc73c\ub85c\ub3c4 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4\ub294 \uc7a5\uc810\uc774 \uc788\ub2e4. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // future\ub97c await\ud558\uba74 \uc2a4\ub808\ub4dc\ub97c \ub9cc\ub4e4\uc5b4\uc11c detach\uc2dc\ud0a8\ub2e4. // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std \ucef4\ud30c\uc77c\ub7ec \ucabd\uc740 \uc5b4\ub5a8\uae4c? \uc774 \ucf54\ub4dc\uac00 \uc5b4\ub5bb\uac8c \ubc14\ub014\uae4c? \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810 \u00b6 operator co_await = Syntactic Sugar + Resumable Function co_await \ub294 \ud45c\ud604\uc744 \ubc14\uafbc\ub2e4\ub294 \uc810\uc5d0\uc11c \uacb0\uad6d syntatic sugar\ub77c\uace0 \ud560\uc218 \uc788\ub2e4. \uc778\uc790\ud0c0\uc785\uc774 Awaitable Interface\ub97c \uc54c\ub9de\uac8c \uad6c\ud604\ud558\uae30\ub9cc \ud55c\ub2e4\uba74, \ucef4\ud30c\uc77c\ub7ec\ub294 \ucf54\ub4dc\ub97c \ubc14\uafd4\uc900\ub2e4. \uc880\uc804\uc758 \uc608\uc81c\ucf54\ub4dc\ub97c \uc880\ub354 \uc790\uc138\ud558\uac8c \uc0b4\ud3b4\ubcf4\uaca0\ub2e4. // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // `co_await`\ud0a4\uc6cc\ub4dc\uac00 \uc788\uc73c\ubbc0\ub85c \uc7ac\uac1c\ud568\uc218\uac00 \ub41c\ub2e4. future < void > test () { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4... __frame * context ; // ... // Awaitable interface\ub97c \uad6c\ud604\ud558\uc600\ub2e4. // \uc815\ud655\ud558\uac8c\ub294 \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc774 \ubcc0\uc218\uac00 \uc0dd\uc131\ub420 \uac83\uc774\ub2e4. awaiter aw = operator co_await ( 1 ms ); // \uac12\uc774 \uc900\ube44\ub418\uc5b4 \uc788\ub294\uac00? if ( aw . await_ready () == false ) // await_ready(aw); { // \uac12\uc774 \uc5c6\uc73c\ubbc0\ub85c \uae30\ub2e4\ub824\uc57c \ud55c\ub2e4. // \ud568\uc218 \ud504\ub808\uc784\uc744 `coroutine_handle` \ud0c0\uc785\uc73c\ub85c \uac10\uc2f8\uace0... coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); // suspend \ud568\uc218\ub97c \ud638\ucd9c\ud55c\ub2e4. aw . await_suspend ( resume_cb ); // \uc911\ub2e8 \uc9c1\uc804\uc5d0 \ud504\ub808\uc784\uc5d0 Index\ub97c \ubcc0\uacbd\ud558\uace0...... __suspend_resume_point_1 : // \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc774 \uc5ec\uae30\uc5d0 \uc788\uc73c\ubbc0\ub85c ready\uc5d0\uc11c true\ub97c \ubc18\ud658\ud558\uba74 // \ud568\uc218\ub294 \uba48\ucd94\uc9c0 \uc54a\uace0 \uc9c4\ud589\ud55c\ub2e4. } // await_resume\uc774 \ubc18\ud658\ud0c0\uc785\uc774 \uc788\ub2e4\uba74 value\uc5d0 \uac12\uc744 \uc800\uc7a5\ud55c\ub2e4. // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } \uc774\uc81c \uc778\ud130\ud398\uc774\uc2a4\uc758 \uac01 \ud568\uc218\ub4e4\uc5d0 \ub300\ud574\uc11c \uc9da\uc5b4\ubcfc \uc218 \uc788\uaca0\ub2e4. await_ready : \"\uc9c0\uae08 \uac12\uc774 \uc788\ub294\uac00?\" await_ready \uc740 \ubd84\uae30\uc810\uc774 \ub41c\ub2e4. \uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\uba74 await_resume \uc5d0\uc11c \ubc14\ub85c \uadf8 \uac12\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uaca0\uc9c0\ub9cc, \uadf8\ub807\uc9c0 \uc54a\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc73c\ub85c \ubd84\uae30\ud574 \ud568\uc218\ub97c \uc911\ub2e8\ud55c\ub2e4. await_ready \ud568\uc218\uac00 \uc5b8\uc81c\ub098 true \ub97c \ubc18\ud658\ud55c\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc740 Dead Code\uac00 \ub418\uace0, \ucef4\ud30c\uc77c\ub7ec\uc758 \ucd5c\uc801\ud654 \uacfc\uc815\uc5d0\uc11c \uc18c\uba78\ub420 \uac83\uc774\ub2e4. \uc774 \uacbd\uc6b0\ub294 \ud504\ub808\uc784\uae4c\uc9c0 \uc18c\uba78\ub418\uace0 \uc77c\ubc18 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \ucd5c\uc801\ud654\ub420 \uc218 \ub3c4 \uc788\ub2e4. \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8 \ubc94\uc704\ub85c \uc9c4\uc785\ud558\uba74, \ud568\uc218 \ud504\ub808\uc784\uc744 coroutine_handle<> \ub85c \uac10\uc2f8\uc11c \uc778\uc790\ub85c \ub118\uaca8\uc900\ub2e4. coroutine_handle<>::from_address \ud568\uc218\uac00 \uc774 \uc5ed\ud560\uc744 \ud574\uc900\ub2e4. await_suspend : \"\uace7 \ub8e8\ud2f4\uc774 \uba48\ucda5\ub2c8\ub2e4. \ud574\uc57c\ud560 \uc77c\uc774\ub77c\ub3c4?\" await_suspend \ub294 coroutine_handle<> \uc744 \uc778\uc790\ub85c \ubc1b\uace0, \uc911\ub2e8\ud558\uae30 \uc804\uc5d0 \ud574\uc57c\ud560 \ub0b4\uc6a9\uc744 \ucf54\ub4dc\ub85c \ub07c\uc6cc\ub123\uc744 \uc218 \uc788\uac8c \ub41c\ub2e4. // Windows Thread Pool Timer\ub97c \uc0ac\uc6a9\ud55c\ub2e4. // Timer Callback\uc5d0 \ud504\ub808\uc784\uc758 \uc8fc\uc18c\ub97c \ub118\uaca8\uc8fc\ub294 \ubc29\uc2dd\uc73c\ub85c \ucf54\ub8e8\ud2f4\uc744 \ub9c8\ubb34\ub9ac\ud55c\ub2e4. class awaiter { bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // \ud3ec\uc778\ud130\ub85c \ubcc0\ud658\ud55c\ub2e4. resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Windows Thread Pool\uc5d0 \uc788\ub294 \uc2a4\ub808\ub4dc\uac00 Callback\uc744 \ud638\ucd9c\ud558\uac8c \ub41c\ub2e4. // \uc790\uc5f0\uc2a4\ub7fd\uac8c Resumer Thread\uac00 \ub41c\ub2e4. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // \ud504\ub808\uc784 \ud3ec\uc778\ud130\ub97c \ud578\ub4e4\ub85c \ubcc0\ud658, \uadf8\ub9ac\uace0 \uc7ac\uac1c. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"\uc5ec\uae30 \uacb0\uacfc\uac12\uacfc \uc2e4\ud589 \ud750\ub984\uc774\uc694.\" \ud568\uc218\ub97c \uc7ac\uac1c\ud558\uba74 \uc911\ub2e8\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\uba70, \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8\ubc94\uc704\ub97c \ubc97\uc5b4\ub098 await_resume \uc744 \ud638\ucd9c\ud55c\ub2e4. \uc911\ub2e8\ud558\ub358 \uc2dc\uc810\uc5d0\ub294 \uacb0\uacfc\uac12\uc774 \uc5c6\uc5c8\uae30 \ub54c\ubb38\uc5d0, \ud568\uc218\uac00 \uc7ac\uac1c\ub418\uc5c8\ub2e4\ub294 \uac83\uc740 \uacb0\uacfc\uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\ub294 \uc758\ubbf8\uac00 \ub41c\ub2e4. \ub9cc\uc57d void\ub77c\uba74 co_await \uc544\ub798\uc5d0 \uc788\ub294 \ucf54\ub4dc\ub97c \uc2e4\ud589\ud574\uc57c \ud558\ub3c4\ub85d \uc2e4\ud589\ud750\ub984\uc744 \ub118\uaca8\uc900\ub2e4\ub294 \uc758\ubbf8\uc77c \uac83\uc774\ub2e4. co_await Tricks \u00b6 Kenny Kerr \uc640 James Mcnellis \ub294 \uc774\ub7f0 \uba54\ucee4\ub2c8\uc998\uc744 \uc0ac\uc6a9\ud55c \ud2b8\ub9ad\ub4e4\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\ub294\ub370, \uc2dc\uac04\uc801 \uc5ec\uc720\uac00 \uc788\ub2e4\uba74 \uaf2d \ubcf4\uae30\ub97c \uad8c\ud55c\ub2e4. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Async Generator \u00b6 \uac1c\ub150 \u00b6 Async Generator = Awaitable iterator + Resumable function Generator\uc640 \ub9e4\uc6b0 \uc720\uc0ac\ud558\uc9c0\ub9cc, \ub2e4\ub978\uc810\uc740 \ubc18\ubcf5\uc790\uac00 Awaitable\ud558\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub2ec\ub9ac \ub9d0\ud558\uba74, Awaitable iterator \uc5d0 \ub300\ud574\uc11c for co_await \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. Kirkshoop\uc758 \uc124\uba85 \uc774 \ub3c4\uc6c0\uc774 \ub420 \uac83\uc774\ub2e4. Example \u00b6 \uc774 \uae30\ub2a5\uc744 \uc81c\ub300\ub85c \uc0ac\uc6a9\ud574\ubcf4\uc9c0 \ubabb\ud574 \uc81c\ub300\ub85c \ub41c \uc608\uc81c\ub97c \uc801\uc9c0 \ubabb\ud588\ub2e4. \ud558\uc9c0\ub9cc \uc9c0\uae08\uae4c\uc9c0\uc758 \uc608\uc81c\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810\uc5d0 \ub300\ud55c \uc124\uba85\uc744 \uc77d\uc5c8\ub2e4\uba74 \uc774 \ucf54\ub4dc\uac00 \uc774\ud574\ub420 \uac83\uc774\ub77c \uc0dd\uac01\ud55c\ub2e4. // \ubb34\ud55c\ud55c \uc815\uc218 \uc218\uc5f4 async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await \uad6c\ubb38 for co_await ( int v : infinite ()) { // `v`\ub85c \ubb34\uc5b8\uac00 \ud55c\ub2e4... } } iterator \uac00 Awaitable\ud558\ub2e4\uace0 \ud588\ub294\ub370, \uc774\ub294 usecase \uac00 \ub2e4\uc74c\uacfc \uac19\ub2e4\ub294 \uc758\ubbf8\ub2e4. std :: future < void > usecase () { // \uae30\ub2e4\ub9b4 \uc218 \uc788\ub294 \ubc18\ubcf5\uc790 : awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `begin()` \uc5d0 // `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. iter != gen . end (); // `end()` \ub294 nullptr\uc640 \uac19\ub2e4. co_await ++ iter ) // `operator++()`\uc5d0 `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. { int v = * iter ; // ... } } generator<T> \uc608\uc81c\uc640 \ub2e4\ub978 \uc810\uc740 \ud568\uc218\uac00 2\uac1c \uc9c0\uc810\uc5d0\uc11c \ubc18\ubcf5\uc790\ub97c \uae30\ub2e4\ub9ac\uace0 \uc788\ub2e4\ub294 \uac83\uc774\ub2e4. \ub530\ub77c\uc11c begin() \uacfc operator++() \ub294 usecase \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8/\uc7ac\uac1c\uc9c0\uc810\uc774 \ub41c\ub2e4. \uc5ec\uae30\uc120 value_type \uc740 \uae30\ubcf8 \uc790\ub8cc\ud615 int \ub77c\uc11c \uc5b4\ub824\uc6b4 \ucf54\ub4dc\ub294 \uc5c6\ub2e4. Awaitable iterator \ucf54\ub4dc\ub294 \ub2e4\uc74c\ucc98\ub7fc \ub9cc\ub4e4 \uc218 \uc788\ub2e4. \uc0ac\uc2e4 std::experimental::generator<T> \uc758 \ucf54\ub4dc\ub97c \uac70\uc758 \uadf8\ub300\ub85c \uac00\uc838\uc628 \uac83\uc774\ub2e4. // generator\uac00 \uc544\ub2c8\ub77c iterator\uac00 \ube44\ub3d9\uae30\ub85c \ub3d9\uc791\ud55c\ub2e4.(awaitable). template < typename T > struct async_generator { struct promise_type ; // Awaitable interface\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // \uc9c0\uae08\uc740 \uc608\uc81c\uc774\ubbc0\ub85c, \uc5b8\uc81c\ub098 \uac12\uc774 \uc874\uc7ac\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\uc9c0\ub3c4 \uc54a\ub294\ub2e4. bool await_ready () const { return true ; } // \uc911\ub2e8\ud558\uc9c0 \uc54a\uc73c\ubbc0\ub85c \ub0b4\uc6a9\uc774 \uc5c6\ub2e4. void await_suspend ( coroutine_handle <> hcoro ) {} // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc774 `co_await`\uc5d0\uac8c \uc804\ub2ec\ub41c\ub2e4. iterator await_resume () const { return * this ; } }; // iterator }; // async_generator \uba64\ubc84\ud568\uc218 3\uac1c\ub97c iterator \uc5d0 \ucd94\uac00\ud568\uc73c\ub85c\uc368, awaitable \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uc600\uace0 for co_await \uad6c\ubb38\uc744 \uc4f8 \uc218 \uc788\uc5c8\ub2e4. \ud558\uc9c0\ub9cc Awaitable Interface \ub2e8\ub77d\uc5d0\uc11c \uc124\uba85\ud588\ub4ef \uad73\uc774 \uba64\ubc84\ud568\uc218\uc77c \ud544\uc694\ub294 \uc5c6\ub2e4. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } \uc774\ub807\uac8c \ubcf4\uc870 \ud568\uc218\ub97c \uc815\uc758\ud558\ub294 \uac83 \ub9cc\uc73c\ub85c\ub3c4 \uae30\uc874\uc5d0 \uc0ac\uc6a9\ud558\ub358 iterator \ud0c0\uc785\ub4e4\uc744 \uc7ac\ud65c\uc6a9\ud560 \uc218 \uc788\ub2e4. \ub05d! \ud6c4\uae30 \u00b6 MSVC \ucf54\ub8e8\ud2f4\uc758 \uac1c\ub150\uacfc \ucf54\ub4dc\ub97c \ud6d1\uc5b4\ubd24\ub2e4. \uadf8\uac8c \uc804\ubd80\ub2e4. \ubd80\ub514 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uae30\ub97c. \uc0ac\uc2e4 \uc774 Feature\uc758 \ub514\uc2a4\uc5b4\uc148\ube14\ub9ac \uacb0\uacfc\uc5d0 \ub300\ud574\uc11c\ub3c4 \uc4f0\uace0 \uc2f6\uc5c8\ub294\ub370, \uad00\ub828\ud574\uc11c\ub294 \uc544\uc9c1 \ucd08\ubcf4\uc790 \ub2e8\uacc4\ub77c \uc81c\ub300\ub85c \uc124\uba85\ud560 \uc218\uac00 \uc5c6\uc5c8\ub2e4. \uae30\ud68c\uac00 \ub41c\ub2e4\uba74 \ucc28\ud6c4\uc5d0 \ub2e4\uc2dc \uae00\uc744 \uc368\ubcf4\uace0 \uc2f6\ub2e4. \ub098\uc911\uc5d0 \ub354\uc6b1 \uac1c\uc120\ud560 \uae30\ud68c\uac00 \uc788\uae30\ub97c. :D","title":"MSVC Coroutine \uc54c\uc544\ubcf4\uae30"},{"location":"articles/exploring-msvc-coroutine-kor/#msvc-coroutine","text":"Written in 2017/03/02 English","title":"MSVC Coroutine \uc54c\uc544\ubcf4\uae30"},{"location":"articles/exploring-msvc-coroutine-kor/#_1","text":"","title":"\ucc38\uace0\uc790\ub8cc"},{"location":"articles/exploring-msvc-coroutine-kor/#_2","text":"N3858 N3977 N4134 N4402","title":"\uc81c\uc548\uc11c"},{"location":"articles/exploring-msvc-coroutine-kor/#visual-c-team-blog","text":"Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++","title":"Visual C++ Team Blog"},{"location":"articles/exploring-msvc-coroutine-kor/#_3","text":"CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\"","title":"\uc601\uc0c1"},{"location":"articles/exploring-msvc-coroutine-kor/#github","text":"kirkshoop/ await","title":"GitHub \uc800\uc7a5\uc18c"},{"location":"articles/exploring-msvc-coroutine-kor/#_4","text":"\uc6b0\uc120 MSVC\uc758 Coroutine\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 3\uac00\uc9c0\uac00 \ud544\uc694\ud558\ub2e4. Visual Studio 2015 Up3 \ud639\uc740 \uadf8 \uc774\uc0c1\uc758 \uac1c\ubc1c\ud658\uacbd /await : \ucef4\ud30c\uc77c \uc635\uc158 <experimental/*> : \uc18c\uc2a4 \ucf54\ub4dc\uc5d0 \ub123\uc744 \ud5e4\ub354\ud30c\uc77c","title":"\uc8fc\uc758\uc0ac\ud56d"},{"location":"articles/exploring-msvc-coroutine-kor/#_5","text":"\uadf8\ub798\uc11c, \ucf54\ub8e8\ud2f4\uc774 \ub300\uccb4 \ubb54\uac00\uc694?","title":"\uc815\uc758"},{"location":"articles/exploring-msvc-coroutine-kor/#_6","text":"\uae30\ubcf8\uc801\uc73c\ub85c, \ud504\ub85c\uc2dc\uc800\uc758 \ud638\ucd9c\uc740 goto \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uadf8\ub7f0\ub370 \uc5b4\ub514\ub85c goto \ud55c\ub2e4\ub294 \uac83\uc77c\uae4c? \ub2e4\uc74c\uc5d0 \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc77c \uac83\uc774\ub2e4. \uba85\ub839\uc5b4\ub294 \ub8e8\ud2f4\uacfc \ud504\ub85c\uadf8\ub7a8\uc758 \uc77c\ubd80\uc774\uae30\ub3c4 \ud55c\ub370, \uc7a0\uc2dc \uc5ec\uae30\uc11c \ud55c\ubc88 \uc9da\uc5b4\ubcf4\uaca0\ub2e4. [\ud504\ub85c\uadf8\ub7a8]\uc740 \uc77c\ub828\uc758 [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub4e4\ub85c \ubcfc \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc5ec\uae30\uc11c [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub780, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c \uac83\uc774\uc5b4\uc57c \ud558\uba70, \ud504\ub85c\uadf8\ub7a8\uc744 \uc218\ud589\ud558\ub294 \uae30\uacc4\uc758 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\uc758 \uac12\ub4e4\uc744 \ud569\uce5c \uac83(composition)\uc774\ub2e4. \ubcf4\ud1b5\uc740 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac \uac12\uc758 \uc870\ud569\uc774 \uc720\ud55c\ud558\ub3c4\ub85d \uc124\uacc4\ud55c\ub2e4. Program State = Environment X Memory (\ud568\uc218\uc801 \ud569\uc131 : Cartesian Product) \uc5ec\uae30\uc11c \uba85\ub839\uc5b4\ub4e4\uc740 \uc0c1\ud0dc\uac04\uc758 \uc804\uc774(transition)\ub77c\uace0 \uc815\uc758\ud560 \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc774\ub7ec\ud55c \uc804\uc774\ub4e4\uc744 \uc21c\uc11c\ub300\ub85c \ubb36\uc740 \uac83\uc744 \ub8e8\ud2f4(routine)\uc774\ub77c\uace0 \ud55c\ub2e4. Instruction : \uba85\ub839, \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\uc758 \uc804\uc774 Routine : \uc21c\uc11c\uac00 \uc788\ub294 \uba85\ub839 \ubb36\uc74c \uadf8\ub7ec\uba74 \uc774\uc81c \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc73c\ub85c \ub118\uc5b4\uac08 \ucc28\ub840\ub2e4.","title":"\uace0\uc2dd(\u53e4\u5f0f) : \uae30\uacc4\ub808\ubca8\uc5d0\uc11c \uc0dd\uac01\ud558\uae30"},{"location":"articles/exploring-msvc-coroutine-kor/#_7","text":"\ubaa8\ub4e0 \ud504\ub85c\uadf8\ub798\uba38\ub4e4\uc740 \ucf54\ub4dc\uc5d0 \ub300\ud574\uc11c \uc790\uc2e0\ub9cc\uc758 \uc2ec\uc0c1(Mental Model)\uc744 \uac16\uae30 \ub9c8\ub828\uc774\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc758 \uba58\ud0c8 \ubaa8\ub378 \ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uace0\uc790 \ud55c\ub2e4.","title":"\uad00\uacc4"},{"location":"articles/exploring-msvc-coroutine-kor/#caller-callee","text":"\uc11c\ube0c\ub8e8\ud2f4\uc758 \uad00\uacc4\ub294 \uc77c\ubc29\uc801\uc774\ub2e4. \ud638\ucd9c\uc790(Caller)\ub294 \uc774\ubbf8 \uc5b4\ub5a4 \uc0c1\ud0dc\uc5d0 \uc788\uace0(\uc774\uc804 \uc870\uac74), \uc5b4\ub5a4 \ub8e8\ud2f4\uc774 \ud544\uc694\ud55c\uc9c0, \ud639\uc740 \ud638\ucd9c\ud560\uc9c0 \uc54c\uace0\uc788\ub2e4. \ud53c\ud638\ucd9c\uc790(Callee)\ub294 \ud504\ub85c\uadf8\ub798\uba38\uc758 \uc758\ub3c4\ub300\ub85c \uc815\uc758\ub41c \ucf54\ub4dc\ub97c \uac00\uc9c0\uace0 \uc788\uace0, \ud638\ucd9c\uc790\uc640 \ubb34\uad00\ud558\uac8c \uba85\ub839\ub4e4\uc744 \uc218\ud589\ud55c\ub2e4. \uc5ec\uae30\uc11c \ubd80\uc218\ud6a8\uacfc(Side-effect)\uac00 \uc788\uc744 \uc218 \uc788\uc9c0\ub9cc, \uadf8\uac74 \uba85\ub839\uc758 \ub0b4\uc6a9\uc5d0 \ub300\ud55c \uac83\uc774\uace0 \uad00\uacc4\uc640\ub294 \ubb34\uad00\ud558\ub2e4.","title":"\uc11c\ube0c\ub8e8\ud2f4 : Caller-Callee"},{"location":"articles/exploring-msvc-coroutine-kor/#activator-activator","text":"\ubcf4\ud1b5 \ucf54\ub8e8\ud2f4\uc740 cooperative\ud55c routine\uc774\ub2e4. \uc774 \ub54c\ubb38\uc5d0 \ud611\ub825\ub8e8\ud2f4\uc774\ub77c\uace0 \ubc88\uc5ed\ub418\uae30\ub3c4 \ud558\ub294\ub370, \uc774\ub7f0 \uc774\ub984\uc740 \ucf54\ub8e8\ud2f4\uc774 \ubb35\uc2dc\uc801\uc73c\ub85c \ub2e4\ub978 \ub8e8\ud2f4\uacfc \ud568\uaed8 \ub3d9\uc791\ud558\ub3c4\ub85d \uc124\uacc4\ub41c \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ub098\uc628 \ub8e8\ud2f4\ub4e4\uc740 \uc11c\ub85c\ub97c \ud65c\uc131\ud654\ud55c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \ud638\ucd9c\uc790(Invoker)\uc640 \uc7ac\uac1c\ub8e8\ud2f4(Resuming routine)\uc5d0 \uc758\ud574\uc11c \ud65c\uc131\ud654 \ub41c\ub2e4. \uc5ed\uc73c\ub85c \uc911\ub2e8\ud558\uac70\ub098 \ubc18\ud658\ud568\uc73c\ub85c\uc368 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\ub978 \ub8e8\ud2f4\uc744 \uc7ac\uac1c\uc2dc\ud0a4\uac8c \ub41c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c\ub294 Suspend/Return\ub4f1\uc73c\ub85c \uad6c\ubd84\ud558\uc600\uc73c\ub098, \ud65c\uc131\ud654\ub77c\ub294 \uac83\uc740 \uc2e4\uc81c\ub85c\ub294 \ub8e8\ud2f4 \uc548\uc758 \uc784\uc758\uc758 \uc9c0\uc810(\uba85\ub839\uc5b4)\uc73c\ub85c \uc810\ud504( goto / jmp )\ud558\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\ub294 \uac83\uc774 \ub2e4\ub978 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uac83\uacfc \uac19\uc744 \uc218 \uc788\uc73c\uba70, \ud568\uc218\uc758 \uc885\ub8cc\uc640 \uc911\ub2e8\uc758 \ucc28\uc774 \ub610\ud55c \ud655\uc5f0\ud558\uc9c0 \uc54a\uc744 \uc218 \uc788\ub2e4. \uc810\ud504\uc758 \ubaa9\ud45c\uc8fc\uc18c\uac00 \ub8e8\ud2f4\uc758 \ub3c4\uc785\ubd80(\ud568\uc218\ub77c\uba74 prologue)\ub77c\uba74 \ud65c\uc131\ud654\ub294 Invocation ( call )\uc774 \ub41c\ub2e4. \ubaa9\ud45c\uc8fc\uc18c\uac00 \ud504\ub85c\uc2dc\uc800\uc758 \ud55c\uac00\uc6b4\ub370 \uc704\uce58\ud558\uba74, \uc774\ub294 Activation ( resume )\uc774 \ub41c\ub2e4. Invocation: \ud638\ucd9c. \ub8e8\ud2f4\uc758 \uc2dc\uc791\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Activation: \ud65c\uc131\ud654. \ub8e8\ud2f4\uc758 \uc784\uc758 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc, \ucf54\ub8e8\ud2f4\uc740 \uc774\uc804 \uc0c1\ud0dc(Pre-condition)\uc640 \uc774\ud6c4 \uc0c1\ud0dc(Post-condition)\uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. \uc774 \ub9d0\uc740, \ucf54\ub8e8\ud2f4 \ub610\ud55c \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\ub97c \uc5b4\ub5bb\uac8c \uc804\uc774\uc2dc\ud0ac\uc9c0 \uc815\uc758\ub418\uc5b4\uc57c \ud55c\ub2e4\ub294 \ub9d0\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc11c\ube0c\ub8e8\ud2f4\uacfc\ub294 \ub2e4\ub974\uac8c, \ucf54\ub8e8\ud2f4\uc740 \uc790\uc2e0\ub9cc\uc758 \uc0c1\ud0dc\ub97c \uc720\uc9c0\ud55c \ucc44\ub85c \ub2e4\ub978 \uc8fc\uc18c\ub85c goto \ud560 \uc218 \uc788\ub2e4. \uc774\ub97c Suspension ( yield )\uc774\ub77c \ud55c\ub2e4. \uacbd\uc6b0\uc5d0 \ub530\ub77c \uc774\ub294 \ud504\ub85c\uc2dc\uc800\uc758 \uc885\ub8cc, \ud639\uc740 \ud568\uc218\uc758 \ubc18\ud658( return )\uc774 \ub420\uc218 \uc788\uc73c\uba70, \uadf8\ub54c\ub294 \uc885\ub8cc(finalization)\ub97c \ud568\uaed8 \uc218\ud589\ud558\uac8c \ub41c\ub2e4. Suspension: \uc911\ub2e8. \uc885\ub8cc\uc791\uc5c5 \uc5c6\uc774 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Finalization: \uc885\ub8cc. \ub8e8\ud2f4\uacfc \uad00\ub828\ub41c \uc790\uc6d0\ub4e4\uc744 \uc815\ub9ac(\ud30c\uad34)\ud558\uace0 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83","title":"\ucf54\ub8e8\ud2f4 : Activator-Activator"},{"location":"articles/exploring-msvc-coroutine-kor/#_8","text":"\uc694\ucee8\ub300 \uac00\uc7a5 \ud070 \ucc28\uc774\uc810\uc740, \ucf54\ub8e8\ud2f4\uc740 \uc11c\ube0c\ub8e8\ud2f4\ubcf4\ub2e4 \ub354 \ub9ce\uc740 \ub3d9\uc791(Operation)\uc744 \uc9c0\uc6d0\ud55c\ub2e4\ub294 \uac83\uc774\ub2e4. \uc774\uac83\uc774 \ub3c4\ub110\ub4dc \ud06c\ub204\uc2a4\uac00 The Art of Computer Programming \uc5d0\uc11c \uc774\ub807\uac8c \uc11c\uc220\ud55c \uc774\uc720\ub2e4. \"Subroutines are special cases of ... coroutines\" - Donald Knuth \uc774\ub97c \ud45c\ub85c \uc815\ub9ac\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4. Operation Subroutine Coroutine Invoke o o \ud504\ub85c\uc2dc\uc800\ub97c \uc2dc\uc791\ud55c\ub2e4 Activate x o \ud2b9\uc815\ud55c \uc9c0\uc810\uc73c\ub85c \uc9c4\uc785\ud55c\ub2e4 Suspend x o Control Flow\ub97c \uba48\ucd98\ub2e4. Finalize o o \uc9c0\uc5ed\ubcc0\uc218, \ub9e4\uac1c\ubcc0\uc218\ub4e4\uc744 \uc815\ub9ac\ud558\uace0 return \ud55c\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc774 \uc81c\ud55c\ub418\uc5c8\uc9c0\ub9cc \uad00\uacc4\uc5d0 \ub300\ud55c \uace0\ub824\uac00 \ud544\uc694\uc5c6\uc5b4 \uac04\ub2e8\ud558\ub2e4. \ubc18\uba74\uc5d0 \ucf54\ub8e8\ud2f4\uc740 \ub354 \ub9ce\uc740 \ub3d9\uc791\uc774 \uac00\ub2a5\ud558\uc9c0\ub9cc, \uc911\ub2e8\uacfc \ud65c\uc131\ud654\uc5d0 \ub300\ud55c(\uadf8\ub9ac\uace0 \uac01\uac01\uc758 Pre/Post condition\uc5d0 \ub300\ud55c) \uc815\uc758\uac00 \ud544\uc694\ud558\ubbc0\ub85c \ub354 \ubcf5\uc7a1\ud558\ub2e4. Routine: \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub97c \ubcc0\ud654\uc2dc\ud0a4\ub294 \uba85\ub839\uc5b4 \ubb36\uc74c. \uadf8 \ub0b4\uc6a9\uc740 \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c\ub2e4. Subroutine: \ub3d9\uc791 2\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Finalize Coroutine: \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Activate Suspend Finalize","title":"\ucc28\uc774\uc810?"},{"location":"articles/exploring-msvc-coroutine-kor/#_9","text":"\ud06c\ub204\uc2a4\ub294 \uc774\ub7f0 \uac1c\ub150\uc774 \uc5b4\ub5bb\uac8c \ucf54\ub4dc\ub85c \ud45c\ud604\ub418\ub294\uc9c0 \uadf8\uc758 \ucc45\uc5d0\uc11c \uc124\uba85\ud558\uace0 \uc788\ub2e4. \ub2e4\uc74c \ucf54\ub4dc\ub294 The Art of Computer Programming\uc5d0 \uc788\ub294 MIX \uba85\ub839\uc5b4\ub4e4\uc744 \uadf8\ub300\ub85c \uc62e\uaca8\uc628 \uac83\uc73c\ub85c, \ubaa8\ub450 \uc774\ud574\ud560 \ud544\uc694\ub294 \uc5c6\ub2e4. \uc624\ub298\ub0a0\uc758 call / return \uad6c\uc870\uc640 \ub2ec\ub9ac, \ubaa8\ub4e0 \ub3d9\uc791\ub4e4\uc774 JMP \uba85\ub839\uc5b4\ub85c \uc218\ud589\ub418\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ud575\uc2ec\uc740 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\uc218\uc758 \uc9c4\uc785\uc810\uacfc \uc911\ub2e8\uc810\uc744 \uac00\uc9c4\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub354\ud574\uc11c, \ubb35\uc2dc\uc801\uc778 \uc0c1\ud0dc(\ub808\uc9c0\uc2a4\ud130 \ud639\uc740 \uba54\ubaa8\ub9ac)\ub97c \uac00\uc9c8 \uc218\ub3c4 \uc788\ub2e4. // MIX \uc608\uc81c, \uc8fc\uc11d\uc744 \ubcc0\uacbd\ud558\uc600\uc74c // \uc790\uc138\ud55c \ub0b4\uc6a9\uc740 The Art of Computer Programming 1.4.2 \uc5d0 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF .","title":"\uc608\uc81c"},{"location":"articles/exploring-msvc-coroutine-kor/#_10","text":"","title":"\ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378"},{"location":"articles/exploring-msvc-coroutine-kor/#_11","text":"\"\ud568\uc815\uc774\ub2e4!\" - \uc544\ud06c\ubc14 \uc81c\ub3c5 \uc624\ub298\ub0a0 \ub110\ub9ac \uc0ac\uc6a9\ub418\uace0 \uc788\ub294 High-level \uc5b8\uc5b4\ub4e4\uc740 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c\ub2e4. \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc740 \uc5b8\uc5b4\uc801\uc73c\ub85c \uba85\ud655\ud558\uac8c \uc815\uc758\ub418\uace0, \uc790\ub3d9\uc73c\ub85c \uad00\ub9ac\ub418\uba70, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uac1c\uc785\ud558\uc9c0 \uc54a\uc544\ub3c4 \ubb38\uc81c\uc5c6\uc774 \ub3d9\uc791\ud55c\ub2e4. \uad6c\uc870\uc801 \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc774\ub7f0 \uc2a4\ud0dd\uc911\uc2ec\uc758 \ubaa8\ub378\uacfc \uc870\ud654\ub97c \uc774\ub8e8\uc5b4\uc654\ub2e4. \uc774 \ubaa8\ub378\uc5d0\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uc218\ud559\uc801\uc73c\ub85c \ud45c\ud604\ud560 \uc218 \uc788\ub294 \uc218\uc2dd\ud2b8\ub9ac \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uacb0\uacfc\uc801\uc73c\ub85c main \ud568\uc218\ub294 \uc885\ub8cc\ud558\uba70, \uc801\ub2f9\ud55c \uacb0\uacfc\uac12\uc744 \ubc18\ud658\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ud45c\ud604\ud55c \uac83 \ucc98\ub7fc, \ud2b8\ub9ac\ud615 \ubaa8\ub378\uc5d0\uc11c \ud568\uc218\uc758 \ud750\ub984\uc740 \uc774 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uae4a\uc774-\uc6b0\uc120 \uc21c\uc11c\ub85c \uc21c\ud68c\ud558\uba70, \uc791\uc131\ud558\ub294 \uc2dc\uc810\ubd80\ud130 \uac01 \uad6c\ubb38(Statement)\ub4e4\uc758 \uc2e4\ud589 \uc21c\uc11c\uac00 \uc815\ud574\uc9c4\ub2e4. \uadf8\ub9bc\uc5d0\uc11c B \uad6c\ubb38\uc5d0 \ub3c4\ub2ec\ud558\uae30 \uc704\ud574\uc120, A \uad6c\ubb38\uc744 \ub9c8\uccd0\uc57c \ud55c\ub2e4. \uc774 \uc2dc\uc810\uc5d0 \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub294 \uad6c\ubb38 A\uc758 \uc601\ud5a5\uc744 \ubc1b\uc544 \ubcc0\ud558\uac8c \ub418\uba70, \ub808\uc9c0\uc2a4\ud130/\uba54\ubaa8\ub9ac\ub294 \uc801\ub2f9\ud55c \uac12\uc744 \uac00\uc9c0\uace0 \uc788\uc744 \uac83\uc774\ub2e4.","title":"\uc2a4\ud0dd\uc774\ub2e4!"},{"location":"articles/exploring-msvc-coroutine-kor/#blocking","text":"\uc5ec\uae30\uc11c \ubb38\uc81c\uac00 \ub418\ub294 \uac83\uc740 \uc758\uc874\uc131\uc774\ub2e4. \ud2b8\ub9ac \ubaa8\ub378\uc740 \uc218\ud559\uc744 \ud504\ub85c\uadf8\ub7a8\uc73c\ub85c \uc62e\uaca8\ub193\uc740 \uac83\uc774\ub2e4. \uc218\uc2dd\uc5d0 \ud544\uc694\ud55c \ubaa8\ub4e0 \uac12\uc774 \uba54\ubaa8\ub9ac\uc5d0 \uc788\ub2e4\uba74, \ucef4\ud4e8\ud130\ub294 \uacc4\uc0b0\uc744 \ub3c4\uc911\uc5d0 \uba48\ucd94\uc9c0 \uc54a\uace0\ub3c4 \uc218\ud589\ud560 \uc218 \uc788\ub2e4. \ub2e4\ub9cc \uc6b0\ub9ac\uc758 \uc790\uc6d0\uc740 \ubb34\ud55c\ud558\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \ud504\ub85c\uadf8\ub7a8 \ud750\ub984\uc774 \uc2dc\uc791\ub418\ub294 \uc2dc\uc810\uc5d0 \ubaa8\ub4e0 \uac12\ub4e4\uc744 \uc900\ube44\ud560 \uc218\ub294 \uc5c6\ub2e4. \ub2e4\ub978 \uc6d0\uc778\ub3c4 \uc788\ub2e4. \uac12\uc774 \ubb3c\ub9ac\uc801\uc73c\ub85c \uac81\ub098 \uba3c \uacf3\uc5d0 \uc788\uc5b4\uc11c \uc2e4\uc2dc\uac04 \ud1b5\uc2e0\uc744 \ud574\uc57c\ud560\uc218\ub3c4 \uc788\ub2e4. \uacb0\uad6d \uc6b0\ub9ac\ub294 \ud544\uc5f0\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc744 \ud574\uc57c\ud55c\ub2e4. \uc804\ud1b5\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc740 \ub290\ub9ac\uace0, \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uba48\ucdb0\uc57c \ud588\ub2e4. \ubc18\uc751\uc131(Responsiveness)\uc744 \uc704\ud574 \ud504\ub85c\uadf8\ub7a8\uc774 \uba48\ucd94\uae30\ub97c \uc6d0\ud558\uc9c0 \uc54a\ub294\ub2e4\uba74 \uc5b4\ub5a8\uae4c? Non-blocking\uacfc \ube44\ub3d9\uae30(Asynchronous) \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc5ec\uae30\uc11c \uc2dc\uc791\ud55c\ub2e4. \uc774\ub294 \uc694\uc57d\ud558\uc790\uba74 \uae30\uc874\uc758 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uc77c\ubc18\ud654 \ud574\uc11c, \ud558\ub098\uc758 \uadf8\ub798\ud504\ub97c \uc791\uc131\ud558\ub294 \uac83\uc774\ub2e4. \uc0c1\ud0dc\uae30\uacc4\uac00 \uadf8\ub798\ud504\ub85c \ud45c\ud604\ub41c\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud574\ubcf4\ub77c. \uc774 \uadf8\ub798\ud504 \ubaa8\ub378\uc5d0\uc120 \ud504\ub85c\uadf8\ub7a8\uc740 \uc0c1\ud0dc\ub4e4\ub85c \uc774\ub8e8\uc5b4\uc9c4 \uadf8\ub798\ud504 \uac00 \ub41c\ub2e4. \uadf8\ub9ac\uace0 \ud504\ub85c\uc138\uc11c\ub4e4\uc740 \uc774 \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\ub294 \uac83\uc774\ub2e4. \ud504\ub85c\uc138\uc11c\ub294 \uc6b4\uc601\uccb4\uc81c\uc758 \ud504\ub85c\uc138\uc2a4, \uc2a4\ub808\ub4dc\uc77c \uc218 \uc788\ub2e4. \ub610\ub294 \uc5b8\uc5b4\ub808\ubca8\uc5d0\uc11c \uc9c0\uc6d0\ud558\ub294 \ucd94\uc0c1\ud654, \uac00\ub839 Erlang\uc758 \ud504\ub85c\uc138\uc2a4\ub098 Go\uc5b8\uc5b4\uc758 Goroutine\uc77c \uc218 \uc788\ub2e4. \ub354 \uc774\uc0c1\uc758 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc0dd\ub7b5\ud55c\ub2e4.","title":"Blocking"},{"location":"articles/exploring-msvc-coroutine-kor/#_12","text":"\ud575\uc2ec\uc740, \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\uba74\uc11c \uc5b4\ub5bb\uac8c \uc815\uc810\uac04\uc758 \ubb38\ub9e5(context) \uad50\ud658\uc774 \uac00\ub2a5\ud560\uae4c \ud558\ub294 \uac83\uc774\ub2e4. \uc6b0\uc120 \uc11c\ube0c\ub8e8\ud2f4\uc740 return \uacfc \ub3d9\uc2dc\uc5d0 \ud30c\uad34\ub418\ubbc0\ub85c(\uc0ac\ub77c\uc9c0\ubbc0\ub85c) \uc774\uac83\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. \ub2ec\ub9ac \ub9d0\ud574 \uc11c\ube0c\ub8e8\ud2f4\uc740 \uc601\uc18d\uc131\uc774 \uc5c6\ub2e4. \uc774\ub294 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc774 \ub3d9\uc791\ud558\ub294 \ubc29\uc2dd\uc774\uc9c0\ub9cc, \ub3d9\uc2dc\uc5d0 \uc815\uc810(\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc)\uac04\uc758 \ubb38\ub9e5\uc804\ub2ec\uc744 \uc544\uc8fc \uc5b4\ub835\uac8c \ub9cc\ub4e4\uc5c8\ub2e4. \ucf5c\ubc31 \uc9c0\uc625 \ub3c4 \uacb0\uad6d\uc740 \ubb38\ub9e5\uc804\ub2ec\uc744 \ud558\uae30 \uc704\ud55c \uace0\uc721\uc9c0\ucc45\uc774\ub77c \ud560 \uc218 \uc788\ub2e4. \"\uc81c\uc784\uc2a4, \uc774 \ucf54\ub4dc\uc5d0\ub294 \ubc84\uadf8\uac00 \uc788\uc5b4\uc694. \uace0\uce60 \uc218 \uc788\uaca0\uc5b4\uc694?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); }","title":"\uc601\uc18d\uc131"},{"location":"articles/exploring-msvc-coroutine-kor/#_13","text":"\uc6b0\ub9ac\uc5d0\uac90 \uc601\uc18d\uc131 \uc788\ub294 \ud568\uc218\uac00 \ud544\uc694\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc(finalization)\ud558\uc9c0 \uc54a\uc73c\uba74\uc11c \uc911\ub2e8(suspend/yield)\uc774 \uac00\ub2a5\ud588\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud558\uba74, \ub2f5\uc740 \uba85\ud655\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc788\uc73c\uba74 \uc774 \ubb38\uc81c\ub97c \ud574\uacb0\ud560 \uc218 \uc788\uc744 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc5b4\ub85c \uad6c\ud604\ud558\ub358 \uac1c\ub150\uc744 \uc5b4\ub5bb\uac8c \uc2a4\ud0dd \uc138\uc0c1\uc73c\ub85c \uac00\uc838\uc62c \uc218 \uc788\uc744\uae4c? \uc9c8\ubb38\uc744 \ubc14\uafd4\ubcf4\uc790. \ubb34\uc5c7\uc774 \uc601\uc18d\uc131\uc744 \uac00\uc838\uc57c \ud558\ub294\uac00?: \ubb38\ub9e5 \ubb38\ub9e5\uc740 \ubb34\uc5c7\uc778\uac00?: \ub8e8\ud2f4\uc758 \uc0c1\ud0dc \uc0c1\ud0dc\ub294 \ubb34\uc5c7\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c0\ub294\uac00?: \ud658\uacbd & \uba54\ubaa8\ub9ac \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\ub294 \uc5b4\ub514\uc5d0 \uc704\uce58\ud558\ub294\uac00?: \ud568\uc218 \ud504\ub808\uc784(Function Frame) \uc815\ub9ac\ud558\uc790\uba74, \uc9c8\ubb38\uc740 \uc5b4\ub5bb\uac8c \ud568\uc218 \ud504\ub808\uc784\ub4e4\uc744 \uc601\uc18d\uc131\uc788\uac8c \ub9cc\ub4e4 \uac83\uc778\uac00 \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc124\uba85\uc740 \uc790\uc138\ud788 \uae30\uc220\ud558\uc9c0\ub294 \uc54a\uaca0\uc9c0\ub9cc, \uc790\uc138\ud55c \uc124\uba85\uc744 \uc6d0\ud55c\ub2e4\uba74 \uc774 \ud398\uc774\uc9c0 \ub97c \ucc38\uace0\ud558\ub77c.","title":"\uc811\uadfc\ubc95"},{"location":"articles/exploring-msvc-coroutine-kor/#_14","text":"\"\uc65c \uc740\ud589\uc744 \ud130\ub098\uc694?\" \"\ub3c8\uc774 \uac70\uae30\uc5d0 \uc788\uc796\uc544\uc694\" - \uc5b4\ub290 \uc740\ud589 \uac15\ub3c4","title":"\uc2a4\ud0dd \uc548? \ubc16!"},{"location":"articles/exploring-msvc-coroutine-kor/#stack-ful","text":"\uc5b8\uc5b4\ub9c8\ub2e4 \ub2e4\ub974\uaca0\uc9c0\ub9cc, C++\ub294 \ud568\uc218 \ud504\ub808\uc784\uc744 \uc2a4\ud0dd\uc5d0 \ubc30\uce58\ud55c\ub2e4. \uc774\ub7f0 \uc0c1\ud669\uc5d0\uc11c \ud504\ub808\uc784\uc744 \ubcf4\uc874\ud558\ub824\uba74, \ud504\ub808\uc784\uc744 \uadf8\ub300\ub85c \ubcf5\uc0ac\ud574\uc11c \uc5b4\ub518\uac00\uc5d0 \uc800\uc7a5\ud574\ub450\ub294 \uc218 \ubc16\uc5d0 \uc5c6\ub2e4. \ub2e4\ub978 \ubc29\ubc95\uc73c\ub85c\ub294 \uc801\ub2f9\ud55c \uacf5\uac04\uc744 \ub530\ub85c \uc608\uc57d\ud574\uc11c \ub300\uccb4 \uc2a4\ud0dd(side stack)\uc73c\ub85c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc774 \uc788\uc744 \uac83\uc774\ub2e4. \uc774 \ubd80\ubd84\uc740 \uc9c0\ub098\uce58\ub3c4\ub85d \ud558\uaca0\ub2e4. MSVC\ub294 \uc2a4\ud0dd \uc678 \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4.","title":"\uc2a4\ud0dd \ub0b4(Stack-ful) \ucf54\ub8e8\ud2f4 / \ubd84\ud560 \uc2a4\ud0dd"},{"location":"articles/exploring-msvc-coroutine-kor/#stack-less","text":"N3858 \uc81c\uc548\uc11c\uc5d0\ub294 \uc774\ub978\ubc14 '\ub2e4\uc2dc \uc2dc\uc791\ud558\ub294 \ud568\uc218'(Resumable Function, \uc774\ud558 \uc7ac\uac1c\ud568\uc218)\uc758 \uad6c\ud604\uac00\ub2a5\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uadf8 \ubc29\ubc95\ub860 \uc911 \ud558\ub098\ub294 \ud799(Heap)\uc5d0 \ud568\uc218\uc758 \ud65c\uc131 \ud504\ub808\uc784(Activation Frame)\uc744 \ud560\ub2f9\ud558\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud504\ub808\uc784\uc740 \ub2e8\uc21c\ud558\uac8c\ub294 \uad6c\uc870\uccb4\uc77c \ubfd0\uc774\ub2e4. \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791 4\uac1c\ub294 \uc5b4\ub5bb\uac8c \ub41c \uac83\uc77c\uae4c? \uc774\ub4e4\uc740 Compiler Intrinsic \ud615\ud0dc\ub85c MSVC\uac00 \uc790\uccb4\uc801\uc73c\ub85c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... \uadf8\ub7ec\ub2c8 \uc774 \ubd80\ubd84\uc5d0 \ub300\ud574\uc11c\ub294 \uc190\ub308 \uc218 \uc788\ub294 \ubd80\ubd84\uc774 \uc5c6\ub2e4. \ub354 \uc790\uc138\ud55c \uc124\uba85\uc774 \ud544\uc694\ud558\ub2e4\uba74 \ucc38\uace0\uc790\ub8cc\uc5d0\uc11c CppCon \ubc1c\ud45c\ub4e4\uc744 \uc2dc\uccad\ud558\uae30\ub97c \uad8c\ud55c\ub2e4. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block \uc774 intrinsic\ub4e4 \uc911 Frame\uacfc Block\ub4e4\uc758 \uc5ed\ud560\uc5d0 \ub300\ud574\uc11c \uba85\ud655\ud558\uc9c0 \uc54a\uc740 \ubd80\ubd84\uc774 \ub0a8\uc544\uc788\ub294 \uac83 \uac19\uc2b5\ub2c8\ub2e4. \uae30\ud68c\uac00 \ub418\uba74 \uc5c5\ub370\uc774\ud2b8 \ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.","title":"\uc2a4\ud0dd \uc678(Stack-less) \ucf54\ub8e8\ud2f4\uacfc \ud568\uc218 \ud504\ub808\uc784"},{"location":"articles/exploring-msvc-coroutine-kor/#the-c-coroutine-resumable-function","text":"\uc774 \uc2dc\uc810\uc5d0\uc11c \ub450 \uc6a9\uc5b4\ub97c \uc815\ub9ac\ud560 \ud544\uc694\uac00 \uc788\uc744 \uac83 \uac19\ub2e4. Coroutine : \uac1c\ub150 . \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Resumable Function : C++ \uc5b8\uc5b4\uc5d0\uc11c Coroutine\uc758 \uad6c\ud604 \ubc29\ubc95 \ucd94\uac00\ub85c \ub2e4\uc74c \ud45c\ub294 \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791\ub4e4\uc744 \uc5b4\ub5bb\uac8c \uc0ac\uc6a9\ud558\ub294\uc9c0 \uc815\ub9ac\ud55c \uac83\uc774\ub2e4. Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return","title":"The C++ Coroutine : Resumable Function"},{"location":"articles/exploring-msvc-coroutine-kor/#invoke","text":"\ud568\uc218 \ud638\ucd9c\uc5d0 \ub300\ud574\uc11c\ub294 \ubcc0\uacbd\uc0ac\ud56d\uc774 \uc5c6\ub2e4. \ud558\uc9c0\ub9cc \uc7ac\uac1c\ud568\uc218\ub294 std::future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4.","title":"\ud638\ucd9c(Invoke)"},{"location":"articles/exploring-msvc-coroutine-kor/#finalize","text":"\uc11c\ube0c\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ubc18\ud658\uc9c0\uc810\uc740 \uc775\ud788 \uc54c\ub824\uc9c4 return \ud0a4\uc6cc\ub4dc\ub97c \uc0ac\uc6a9\ud558\uba74 \ub41c\ub2e4. \ucf54\ub8e8\ud2f4\uc774\ub77c\uba74 co_return \ud0a4\uc6cc\ub4dc\uac00 \uc774 \uc5ed\ud560\uc744 \ub300\uc2e0\ud55c\ub2e4.","title":"\uc885\ub8cc(Finalize)"},{"location":"articles/exploring-msvc-coroutine-kor/#suspend","text":"\ud568\uc218\ub97c \uc911\ub2e8\ud558\uace0 Control Flow\ub97c \uc591\ubcf4\ud558\ub294 \ubc29\ubc95\uc740 co_yield expression\uacfc co_await \uc5f0\uc0b0\uc790\ub97c \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. \uc774 \ub458 \uc911 \ud558\ub098\ub77c\ub3c4 \uc0ac\uc6a9\ud558\uba74, \uadf8 \uc9c0\uc810\uc740 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc73c\ub85c \uc0ac\uc6a9\ub418\uba70 MSVC\ub294 \uadf8 \ud568\uc218\ub97c \uc7ac\uac1c\ud568\uc218\ub85c \ub9cc\ub4e4\uac8c \ub41c\ub2e4. (\ub354\ud574\uc11c co_return \uad6c\ubb38\ub3c4 \ud568\uc218 \ub0b4\uc5d0 \uc704\uce58\ud558\uba74 \uc7ac\uac1c\ud568\uc218\ub85c \uc778\uc2dd\ub41c\ub2e4.)","title":"\uc911\ub2e8(Suspend)"},{"location":"articles/exploring-msvc-coroutine-kor/#activate","text":"\uc911\ub2e8\ub41c \ud568\uc218\ub97c \ud65c\uc131\ud654 \ud560 \ub54c\ub294, coroutine_handle \uacfc \uba64\ubc84\ud568\uc218 .resume() \ub97c \uc0ac\uc6a9\ud55c\ub2e4. \uc774 \ud638\ucd9c\uc740 Compiler Intrinsic\uc778 _coro_resume \uc704\uc5d0 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc62c\ub9b0 \uac83\uc774\ub2e4.","title":"\ud65c\uc131\ud654(Activate)"},{"location":"articles/exploring-msvc-coroutine-kor/#code","text":"\uc608\uc81c \ucf54\ub4dc\uc640 \uad00\ub828\ud574 kirkshoop\uc758 \uc800\uc7a5\uc18c \uac00 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uc2b5\ub2c8\ub2e4. \ubbf8\ub9ac \uc694\uc57d\ud558\uc790\uba74, MSVC\uc758 \uc694\uad6c\uc0ac\ud56d\uc744 \ub530\ub974\uae30\ub9cc \ud55c\ub2e4\uba74 C++\uc5d0\uc11c\ub3c4 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. \uc81c\uc548\uc11c\uc758 \uc774\ub984\uc774 \uc7ac\uac1c (\ub530\ub77c\uc11c, \uc601\uc18d\uc131 \uc788\ub294) \ud568\uc218 \ub77c\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud558\ub77c. \uc7ac\uac1c\ud568\uc218\uc5d0\ub294 \uba87\uac00\uc9c0 \uc885\ub958\uac00 \uc788\ub294\ub370, \ud568\uc218\uc5d0 \uc5b4\ub5a4 \uc5ed\ud560\uc744 \ub9e1\uae30\uace0\uc790 \ud558\ub290\ub0d0\uc5d0 \ub530\ub77c \ub2ec\ub77c\uc9c4\ub2e4. \uadf8\ub7ec\uba74 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc694\uad6c\uc0ac\ud56d\uc774\ub780 \ubb34\uc5c7\uc77c\uae4c?","title":"Code"},{"location":"articles/exploring-msvc-coroutine-kor/#promise","text":"C++11\uc5d0 \ucd94\uac00\ub41c std::future<T> \uc640 std::promise<T> , \uadf8\ub9ac\uace0 \uc774 \ub450 \uc9dd\uad81\uc758 \uad00\uacc4\uc5d0 \ub300\ud574\uc11c \uc54c \uac83\uc774\ub77c \uc804\uc81c\ud558\uaca0\ub2e4. \uc77c\ubc18\uc801\uc73c\ub85c, future<T> \ub294 \" \ub098\uc911\uc5d0 \uac12\uc774\ub098 \uc608\uc678\ub97c \uc904\uac8c\"\ub77c\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. ( std::async \ub97c \ucc38\uace0\ud558\ub77c) \uadf8\ub9ac\uace0 \uac12/\uc608\uc678\ub294 promise<T> \ub97c \ud1b5\ud574\uc11c \uc804\ub2ec\ub41c\ub2e4. \uc774\ub294 \"\uacb0\uacfc\ub97c \uc900\ub2e4\ub294 \uc57d\uc18d \uc744 \uc9c0\ucf30\ub2e4.\"\ub77c\ub294 \uac83\uc774\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\uac00 future<T> \ub97c \ubc18\ud658\ud55c\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \ub9d0 \uadf8\ub300\ub85c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \uc2a4\uc2a4\ub85c \uc911\ub2e8\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0 \ud65c\uc131\ud654\ud55c \ub8e8\ud2f4 \uc785\uc7a5\uc5d0\uc11c\ub294 \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc\ud588\ub294\uc9c0 \uc54c \ubc29\ubc95\uc774 \uc5c6\ub2e4. \ubc18\ud658\uac12\uc774 \uc788\ub2e4\ub294 \uac83\uc744 \uc54c \uc218 \uc5c6\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud568\uc218\uc758 \uc2dc\uadf8\ub2c8\ucc98(Signature)\uc0c1\uc73c\ub85c\ub294, \ub098\uc911\uc5d0 \ub77c\ub294 \uc758\ubbf8\uac00 \ub2f4\uae34 \ud0c0\uc785 future \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud568\uc73c\ub85c\uc368 \uc77c\ubc18\uc801\uc778 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uace0 \uc788\ub2e4. \ub2e4\ub9cc \uae30\uc874\uacfc \ub2ec\ub9ac \uc5ec\uae30\uc11c\uc758 promise \ub294 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c\uac83\uc774\ub2e4. N4402 \ub294 \uc774 \ub0b4\uc6a9\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uc5b4\uc9f8\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uac8c \uc57d\uc18d\uc774 \ud544\uc694\ud55c \uac83\uc77c\uae4c? \uc774\ub294 \uc7ac\uac1c\ud568\uc218\uac00 \ucd94\uc0c1\ud654 \ud55c \uacb0\uacfc\ubb3c\uc774\uae30 \ub54c\ubb38\uc774\ub2e4. \uc2a4\ud0dd \uae30\ubc18\uc758 \ud658\uacbd\ub54c\ubb38\uc5d0, \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud558\uae30\ub294 \ud588\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc640 \uac19\uc774 1\ucc28\uc6d0\uc73c\ub85c \ubc30\uce58\ub41c(flat) \uad6c\ubb38\uad6c\uc870\ub294 \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 \uacb0\uad6d \ud799\uc5d0\uc11c \uc0b4\uc544\uc788\uc73c\uba70, \ud799 \uc601\uc5ed(\ud568\uc218 \ud504\ub808\uc784)\uc5d0\uc11c \uc2a4\ud0dd \uc601\uc5ed( future \ub610\ub294 awaitable)\uc73c\ub85c \uac12\uc744 \uc804\ub2ec\ud574\uc57c \ud558\uace0, \uc774 \uacfc\uc815\uc740 \uc77c\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4 \ub97c \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9c0\ub3c4\ub85d \ud55c \uac83\uc774\ub2e4. \ubb3c\ub860 \uc778\ud130\ud398\uc774\uc2a4\ub294 \ucef4\ud30c\uc77c\ub7ec\uc640 \ud504\ub85c\uadf8\ub798\uba38 \uc591\ucabd \ubaa8\ub450\ub97c \uc704\ud55c \uac83\uc774\ub2e4.","title":"Promise : \ucef4\ud30c\uc77c\ub7ec\uac00 \uc6d0\ud558\ub294 \uac83"},{"location":"articles/exploring-msvc-coroutine-kor/#resumable-promise-requirement","text":"\uc7ac\uac1c\ud568\uc218\uc758 Promise \uc694\uad6c\uc0ac\ud56d \uadf8 \uc778\ud130\ud398\uc774\uc2a4\uac00 \uc5b4\ub5bb\uac8c \uc4f0\uc774\ub294\uc9c0\ub294 \uc7a0\uc2dc \ud6c4 \uae30\uc220\ud558\uace0, \uadf8\uc5d0 \uc55e\uc11c N4402 \ubb38\uc11c\ub97c \uc0b4\ud3b4\ubcf4\uc790. \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub294 Promise \ud0c0\uc785\uc740 \uc544\ub798 \ud45c\uc5d0 \uc5f4\uac70\ub41c \uba64\ubc84\ud568\uc218\ub4e4\uc744 \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4. \uc81c\uc548\uc11c\ub97c \uc694\uc57d\ud55c \uac83\uc774\ubbc0\ub85c, \ubcf4\ub2e4 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc81c\uc548\uc11c\ub97c \ucc38\uace0\ud558\uae30 \ubc14\ub780\ub2e4. Expression Note P{} \uc774 \ud0c0\uc785\uc740 default constructible \ud574\uc57c\ud55c\ub2e4. p.get_return_object() \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc744 \uacb0\uc815\ud55c\ub2e4. future<T> \ud639\uc740 \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc774 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4. p.return_value(v) co_return \uad6c\ubb38. \uacb0\uacfc\uac12\uc73c\ub85c v \ub97c \uc804\ub2ec\ud558\uba70, \uadf8 \uac12\uc740 \ub098\uc911\uc5d0 \uc0ac\uc6a9(consume)\ub41c\ub2e4. p.return_value() co_return \uad6c\ubb38. void \ud0c0\uc785\uc5d0 \uc0ac\uc6a9\ub418\uba70, \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\uc744 \uc758\ubbf8\ud558\uae30\ub3c4 \ud55c\ub2e4. \uc7ac\uac1c\ud568\uc218\uac00 \uc885\ub8cc\ub420\ub54c \uc0ac\uc6a9\ub41c\ub2e4. \uc774 \ud568\uc218\uac00 \ud638\ucd9c\ub418\ub294 \uac83\uc740 \"\ub354\uc774\uc0c1 \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\"\uc744 \uc758\ubbf8\ud55c\ub2e4. p.set_exception(e) \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. Resumer \uce21\uc5d0\uc11c \uacb0\uacfc\uac12\uc744 \uc0ac\uc6a9\ud558\ub824\uace0 \ud560\ub54c throw \ub41c\ub2e4. p.yield_value(v) co_yield \ud45c\ud604\uc2dd. return_value(v) \uc640 \uc720\uc0ac\ud558\ub2e4. p.initial_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810(initial suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. p.final_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810(final suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. \uc5ec\uae30\uc11c \uc77c\ubd80 \ud568\uc218\ub4e4\uc740 coroutine_traits<T> \uc640 \uc5f0\uad00\ub418\uc5b4\uc788\ub294\ub370, \uc774\ud6c4\uc5d0 \uc774 \ud0c0\uc785\uc758 \uc720\ub3d9\uc131\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\uaca0\ub2e4. \uc774\uc81c C++ \ucf54\ub8e8\ud2f4\uc758 \uc0ac\uc6a9\ubc29\ubc95\uc73c\ub85c \ucd08\uc810\uc744 \uc62e\uaca8\ubcf4\uc790.","title":"Resumable Promise Requirement"},{"location":"articles/exploring-msvc-coroutine-kor/#generator","text":"","title":"Generator"},{"location":"articles/exploring-msvc-coroutine-kor/#_15","text":"Generator = Iterator + Resumable Function \ubc18\ubcf5\uc790\uac00 \ubcf4\uc774\ub294\uac00? generator<T> \ub294 \uac12\uc758 \uc218\uc5f4(sequence)\uc744 \ucd94\uc0c1\ud654 \ud55c \uac83\uc774\ub2e4. \uc774\ub54c \uac12\uc740 \uc7ac\uac1c\ud568\uc218\uc5d0 \uc758\ud574\uc11c \uc0dd\uc131\ub418\ub294\ub370, \uc7ac\uac1c\ud568\uc218\ub294 \uc0c8\ub85c \ud638\ucd9c\ub418\uba74 \ud568\uc218 \ud504\ub808\uc784\uc774 \ud799 \uc601\uc5ed\uc5d0 \uc720\uc9c0\ub418\ubbc0\ub85c, generator \ub9c8\ub2e4 \uace0\uc720\ud55c \ubb38\ub9e5\uc744 \uac00\uc9c0\uac8c \ub41c\ub2e4.","title":"\uac1c\ub150"},{"location":"articles/exploring-msvc-coroutine-kor/#example","text":"\ub2e4\uc74c \ucf54\ub4dc\ub294 N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator \ub97c \uc791\uc131\ud55c \uac83\uc774\ub2e4. #include <experimental/generator> // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc9c0\uc815(Set)\ud558\uace0 \uc911\ub2e8(Suspend)\ud55c\ub2e4. co_yield f1 ; // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uad6c\ud55c \ub4a4 Shift \ud55c\ub2e4. int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // \ub354\uc774\uc0c1 \uac12\uc744 \uc0dd\uc131\ud558\uc9c0 \uc54a\ub294\ub2e4. } void usecase () { // 10\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \ubc1b\ub294\ub2e4. for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc5b4\ub5bb\uac8c \uc774\uac8c \uac00\ub2a5\ud55c\uac78\uae4c? generator<T> \uc758 \uc815\uc758\ub97c \uc0b4\ud3b4\ubcf4\uc790.","title":"Example"},{"location":"articles/exploring-msvc-coroutine-kor/#detail","text":"\uac04\ub7b5\ud558\uac8c generator<T> \ub97c \uc62e\uaca8\uc654\ub2e4. iterator \uc640 promise_type \uc744 \uc9c0\uc6d0\ud558\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ub610\ud55c begin() / end() \ud568\uc218\ub85c Range-based for loop \ub97c \uc9c0\uc6d0\ud558\uace0 \uc788\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud578\ub4e4 coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc788\ub2e4\uba74 \uc7ac\uac1c\ud574\uc11c \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc788\ub2e4. if ( _Coro ) { _Coro . resume (); // \ud568\uc218\uac00 \ubc18\ud658\ub418\uc5c8\ub098? if ( _Coro . done ()) return { nullptr }; // return end(); } // \uc544\uc9c1 \ub05d\ub098\uc9c0 \uc54a\uc558\ub2e4. // \ub2e4\uc74c\uc5d0 \ub2e4\uc2dc resume\ud558\uc790... return { _Coro }; } iterator end () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc5c6\ub2e4\uba74, \uac12\uc744 \ub354 \uac00\uc838\uc62c \uc218 \uc5c6\ub2e4. return { nullptr }; } ~ generator () { // RAII : \ud568\uc218 \ud504\ub808\uc784\uc744 \ud30c\uad34\ud55c\ub2e4. if ( _Coro ) { _Coro . destroy (); } } }; \uc774\ub97c \ubc14\ud0d5\uc73c\ub85c \uc2e4\uc81c\ub85c\ub294 \uc774\ub7f0 \ucf54\ub4dc\uac00 \ub9cc\ub4e4\uc5b4\uc9c8 \uac83\uc774\ub2e4. void usecase () { // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int > gen = fibonacci ( 10 ); // `iter++`\ub294 delete\ub418\uc5c8\uc73c\ubbc0\ub85c \uc0ac\uc6a9\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc77c\ubc18\uc801\uc778 iterator-for \uad6c\ubb38\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. iterator \ub294 \uc5b4\ub5bb\uac8c \ub418\uc5b4\uc788\uc744\uae4c? template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // \ubc18\ubcf5\uc790 \uc778\ud130\ud398\uc774\uc2a4 struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // \ub2e4\uc74c\uc73c\ub85c \uc774\ub3d9\ud560\ub54c... iterator & operator ++ () { // \ud568\uc218\ub97c \uc7ac\uac1c\ud574\uc11c \uac12\uc744 yield\ud558\ub3c4\ub85d \ud55c\ub2e4. _Coro . resume (); // \ub9cc\uc57d \ud568\uc218\uac00 return\ud588\ub2e4\uba74, \uadf8 \ud578\ub4e4\uc740 generator\uac00 \uc18c\uba78\uc2dc\ud0ac \uac83\uc774\ub2e4. if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // MSVC\uc758 \ucf54\uba58\ud2b8\ub294, \uc694\uc57d\ud558\uc790\uba74, // \ud6c4\uc704\uc99d\uac00\uc2dd\uc740 iterator\ub97c \ub36e\uc5b4\uc4f8 \uc218 \uc788\uace0, // \uc774\ub85c\uc778\ud574 handle\uc774 nullptr\ub85c \ubc14\ub00c\uba74\uc11c // \ud568\uc218 \ud504\ub808\uc784 \ub0b4\uc5d0 \ub9c8\uc9c0\ub9c9 \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc5c6\ub2e4\ub294 \uac83\uc774\ub2e4. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // `promise`\uc5d0 \ud3ec\uc778\ud130\uac00 \uc788\ub2e4. \ud3ec\uc778\ud130\ub97c \ucc38\uc870\ud574 \ud504\ub808\uc784 \uc548\uc758 \uac12\uc744 \uac00\uc838\uc628\ub2e4. _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; \uc774 \ucf54\ub4dc\ub97c \ubcf4\uba74 \ubc18\ubcf5\uc790\uac00 \ud568\uc218\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc7ac\uac1c\ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 generator<T> \uc758 promise_type \uc744 \ud1b5\ud574\uc11c \uac12\uc744 \ud68d\ub4dd\ud55c\ub2e4. \uc774 \uacbd\uc6b0\ub294 usecase \ud568\uc218\uac00 generator \uc758 \ud638\ucd9c\uc790\uba74\uc11c \uc7ac\uac1c\uc790\uc778 \uac83\uc774\ub2e4.","title":"\uc2e4\uccb4(Detail)"},{"location":"articles/exploring-msvc-coroutine-kor/#_16","text":"\uc774\uc81c \ud575\uc2ec\uc774 \ub418\ub294 promise_type \uc744 \ubcfc \ucc28\ub840\ub2e4. \uae30\uc220\ub41c \uac83 \ubcf4\ub2e4 \ucf54\ub4dc\uac00 \uc880 \ub354 \uc788\uc9c0\ub9cc \ub2e8\uc21c\ud654 \ud558\uc600\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } \uc774 promise_type \uc740 \uc694\uad6c\uc0ac\ud56d \uc911\uc5d0\uc11c 4\uac1c\uc758 \uba64\ubc84\ud568\uc218\ub97c \ub9cc\uc871\ud55c\ub2e4. get_return_object , initial_suspend , final_suspend , \uadf8\ub9ac\uace0 yield_value \uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. co_yield \ub294 \"\uac12\uc744 \uc9c0\uc815\ud558\uace0 \uc911\ub2e8\ud558\ub77c\"\uc640 \uac19\uc740 \uc758\ubbf8\uc778\ub370, \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774\ub97c \uc774\ub807\uac8c \ubcc0\uacbd\ud55c\ub2e4. co_yield : co_await + p.yield_value(x) \ub530\ub77c\uc11c, co_yield \uc5d0 \uc778\uc790 \ud45c\ud604\uc2dd\uc774 \uc5c6\ub2e4\ub294 \uac83\uc740 \ubd88\uac00\ub2a5 \ud558\ub2e4. x \ub294 void \uac00 \ub420 \uc218 \uc5c6\uae30 \ub54c\ubb38\uc774\ub2e4. \uac19\uc740 \uc774\uc720\ub85c generator<void> \ub294 \ucef4\ud30c\uc77c \uc5d0\ub7ec\uac00 \ub418\uba70, \uc5f0\uc18d\ub41c \uac12\uc758 \ucd94\uc0c1\ud654\ub77c\ub294 \uc815\uc758\uc5d0\ub3c4 \uc704\ubc30\ub41c\ub2e4. \uc5c4\ubc00\ud788 \ub9d0\ud574 \uc5ec\uae30\uc11c co_await \ub294 suspend \ub97c \uc758\ubbf8\ud55c\ub2e4. \uc790\uc138\ud55c \uc124\uba85\uc740 \ud6c4\uc220\ud55c\ub2e4. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud45c\ud604\uc2dd\uc744 \uc544\ub798\uc640 \uac19\uc774 \ubc14\uafbc\ub2e4. // co_yield f1; p . yield_value ( f1 ); // \uac12\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc9c0\uc815\ud558\uace0 co_await suspend_always {}; // \uc911\ub2e8\ud55c\ub2e4. // ... } co_return ; // \ub354\uc774\uc0c1 \uac12\uc774 \uc5c6\ub2e4. } \uc774 \ucf54\ub4dc\uc5d0\ub294 promise_type p{} \uac19\uc740 \ubcc0\uc218 \uc120\uc5b8\uc774\ub098, \ub2e4\ub978 \ud568\uc218\ub4e4\uc758 \ud638\ucd9c\uc774 \uc5c6\ub2e4. \uadf8 \uc774\uc720\ub294 \ub2e4\uc74c \ub2e8\uc6d0\uc5d0\uc11c \ub2e4\ub8e8\uaca0\ub2e4.","title":"\ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810"},{"location":"articles/exploring-msvc-coroutine-kor/#resumable-function","text":"\uc7ac\uac1c \ud568\uc218 \uc774\ubc88\uc5d4 \uc880 \ub354 \uc0c1\ud5a5\uc2dd\uc73c\ub85c \uc54c\uc544\ubcf4\uc790. \uc608\uc81c\ucf54\ub4dc\ub294 Awaitable Concept\ub97c \uc774\ud574\ud55c \ub4a4\uc5d0 \ubd10\uc57c \ud55c\ub2e4.","title":"Resumable Function"},{"location":"articles/exploring-msvc-coroutine-kor/#_17","text":"Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> \ub294 \ub2e8\uc21c\ud55c \uc608\uc81c\uc600\ub2e4. generator \ub294 coroutine_handle \uc744 \uba64\ubc84\ubcc0\uc218\ub85c \uac00\uc9c0\uace0 \uc788\uc5c8\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ubb34\uc5c7\uc778\uc9c0 \uc0b4\ud3b4\ubd10\uc57c \ud55c\ub2e4. \uc0ac\uc2e4, coroutine_handle \uc758 \uc608\uc804 \uc774\ub984\uc740 resumable_handle \uc600\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 C++\uc0c1\uc5d0\uc11c \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud55c \uac83\uc774\ub77c\uace0 \uc124\uba85\ud588\ub294\ub370, coroutine_handle \ub294 \ub2ec\ub9ac \ub9d0\ud558\uba74 \uc7ac\uac1c\ud568\uc218\uc5d0 \ub300\ud55c \ud578\ub4e4(Resumable Function Handle)\uc774\ub2e4. Windows API\ub97c \uc0ac\uc6a9\ud574\ubcf8 \uacbd\ud5d8\uc774 \uc788\ub2e4\uba74 Handle \uc774 \uacb0\uad6d void* \ub77c\ub294 \uac83\uc744 \uc54c \uac83\uc774\ub2e4. \uc5ec\uae30\uc11c\ub3c4 \ub3d9\uc77c\ud558\ub2e4. \uc55e\uc11c \uc124\uba85\ud588\ub358 \uac83 \ucc98\ub7fc MSVC\ub294 \ud799 \uc601\uc5ed\uc5d0 \ud504\ub808\uc784\uc744 \ub3d9\uc801\ud560\ub2f9\ud558\uace0, \uac70\uae30\uc5d0 \uc57d\uac04\uc758 intrinsic\uc744 \ub354\ud558\ub294 \ud615\ud0dc\ub85c \uc2a4\ud0dd \uc678(stack-less) \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4. coroutine_handle \uc740 \uc774\ub4e4\uc744 \ud558\ub098\uc758 \ud0c0\uc785\uc73c\ub85c \ubb36\uc5b4\ub193\uc740 \uac83\uc774\ub2e4.","title":"\uac1c\ub150"},{"location":"articles/exploring-msvc-coroutine-kor/#_18","text":"\uadf8\ub7ec\uba74, Resumable Frame \uc740 \ub300\uccb4 \uc5b4\ub5bb\uac8c \uc0dd\uacbc\uc744\uae4c? \uc77c\ub2e8 \ud504\ub808\uc784\uc740 Head\uc640 Body\ub85c \ub098\ub25c\ub2e4. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Head // - Fn : \uc7ac\uac1c\ud560 \ub54c \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc758 \uc8fc\uc18c // - cdecl : \uc774 Convention\uc5d0\uc11c \ud568\uc218 \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 Caller \uac00 \ub2f4\ub2f9\ud55c\ub2e4. // - Index : Resumption point\uc758 \uc778\ub371\uc2a4 // 0\ubc88\uc740 \ud568\uc218\uac00 \uc885\ub8cc\ub41c(`done()`) \uacbd\uc6b0\uc5d0 \uc0ac\uc6a9\ud55c\ub2e4. // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Body \uc5d0\ub294... // - Promise \ud0c0\uc785 \uac1c\uccb4 // - \ud504\ub808\uc784\uc73c\ub85c \uc774\ub3d9\uc2dc\ud0a8 Arguments // - \ud568\uc218 Body // - \uc9c0\uc5ed/\uc784\uc2dc \ubcc0\uc218\ub4e4 // - Platform \uc804\uc6a9 // - \ub808\uc9c0\uc2a4\ud130 \ub4f1\ub4f1 // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : \uc774\ub984\ucc98\ub7fc _Resumable_frame_prefix \uac00 \ud568\uc218\ud504\ub808\uc784\uc758 \uc55e\ubd80\ubd84\uc774 \ub41c\ub2e4. MSVC \ub294 \uc774 \uacf5\uac04\uc5d0 sizeof(void *) * 2 (x64 \uc5d0\uc11c 16 \ubc14\uc774\ud2b8)\ub9cc\ud07c\uc758 \uace0\uc815\ub41c \ud06c\uae30\ub97c \uc0ac\uc6a9\ud55c\ub2e4. Fn : cdecl \ud638\ucd9c \uaddc\uc57d\uc73c\ub85c \uc120\uc5b8\ub418\uc5b4\uc788\ub2e4\ub294 \uc810\uc774 \ud2b9\uc774\ud55c\ub370, cdecl \uc5d0\uc11c \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 \ud638\ucd9c\uc790\uc758 \uc5ed\ud560\uc774\uba70, \ub530\ub77c\uc11c Fn \uc744 \ud638\ucd9c\ud558\ub294 \uac83\uc740 \uadf8 \uc2dc\uc810\uc758 \uc2a4\ud0dd\uacfc \ud568\uc218 \ud504\ub808\uc784\uc5d0 \uc601\ud5a5\uc744 \ubbf8\uce58\uc9c0 \uc54a\ub294\ub2e4. Index : \uc7ac\uac1c\ud568\uc218\ub294 \ub2e4\uc218\uc758 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\ub4e4\uc744 \uac00\uc9c0\uace0 \uc788\uace0, Index \ub294 \uac01 \uc9c0\uc810\ub4e4\ub85c switch \ud558\ub294\ub370 \uc0ac\uc6a9\ub41c\ub2e4. Flag : ??? \uc774\uac74 \ub300\uccb4 \ubb58\uae4c ??? Body : N4402\uc5d0 \ud568\uc218 \ud504\ub808\uc784\uc758 \uad6c\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. James McNellis\uc758 \ubc1c\ud45c\uc790\ub8cc\uc5d0 \uc758\ud558\uba74, \ucef4\ud30c\uc77c\ub7ec\uac00 \uc0dd\uc131\ud558\ub294 \ud504\ub808\uc784\uc740 \ub2e4\uc74c\uc744 \ud3ec\ud568\ud55c\ub2e4. \uc77c\ubc18\uc801\uc778 \uc2a4\ud0dd \ud504\ub808\uc784\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // `fibonacci` \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784(\uc608\uc2dc) struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci\ub294 `generator<int>`\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int >:: promise_type _p ; // \ud504\ub808\uc784\uc5d0 \uc778\uc790\ub97c \uc800\uc7a5\ud55c\ub2e4. int _n ; // fibonacci(n); int _f1 , _f2 ; // \uc9c0\uc5ed \ubcc0\uc218 int _i , _f3 ; // \uc784\uc2dc \ubcc0\uc218 // Platform \uc804\uc6a9 \uc800\uc7a5\uc18c // \ub808\uc9c0\uc2a4\ud130\ub098 \uc774\uac83\uc800\uac83... };","title":"\uc7ac\uac1c\ud568\uc218\uc758 \ud504\ub808\uc784"},{"location":"articles/exploring-msvc-coroutine-kor/#coroutine-traits","text":"p.get_return_object() \uc5d0 \ub300\ud574\uc11c \ub2e4\ub8e8\uc9c0 \uc54a\uc558\uc5c8\ub294\ub370, \uc5ec\uae30\uc11c \uac19\uc774 \ub2e4\ub8e8\uace0\uc790 \ud55c\ub2e4. \uba3c\uc800 coroutine_traits \ub97c \ub208\uc5ec\uaca8\ubd10\uc57c \ud55c\ub2e4. // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; \uad49\uc7a5\ud788 \ub2e8\uc21c\ud55c\ub370, coroutine_traits \uc774 \uc694\uad6c\ud558\ub294 \uac83\uc740 \uacb0\uad6d promise_type \ub97c \uad6c\ud604\ud558\ub77c\ub294 \uac83\uc774\ub2e4. \uc774\uc5d0 \ub300\ud55c \uac80\uc0ac\ub294 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uc774\ub8e8\uc5b4\uc9c0\uace0, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement \ub97c \ub9cc\uc871\uc2dc\ucf1c\uc57c \ud55c\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\ub294 future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \uc0ac\uc2e4 \uadf8\uac83\uc740 \ubd80\uc815\ud655\ud55c \uc124\uba85\uc774\uc5c8\ub2e4. coroutine_traits \ub97c \ub9cc\uc871\uc2dc\ud0a4\uae30\ub9cc \ud55c\ub2e4\uba74, \uadf8 \ud0c0\uc785\uc740 \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc774 \ub420 \uc218 \uc788\ub2e4. std::future<T> \ub97c \uc704\ud55c coroutine_traits \uc758 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 \ubc84\uc804\uc744 \uc62e\uaca8\uc654\ub2e4. generator<T> \uc758 \uacbd\uc6b0\ub294 \ub0b4\ubd80\uc5d0 promise_type \uc744 \uad6c\ud604\ud558\uace0 \uc788\uc5c8\ub294\ub370, \uc608\uc804\ubd80\ud130 \uc0ac\uc6a9\ud558\ub358 \ud0c0\uc785\ub4e4\uc774\ub098 \ucee4\uc2a4\ud140 \ud0c0\uc785\ub4e4\uc740 \uc774\ub7f0 \ud2b8\ub9ad\uc744 \uc0ac\uc6a9\ud574\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc720\uc5f0\ud558\uac8c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. // <future> \ud5e4\ub354 #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // `std::future<T>`\ub97c \uc704\ud55c \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // `future<_Ty>`\ub97c \ubc18\ud658\ud558\ub294 \uc7ac\uac1c\ud568\uc218\ub4e4\uc744 \uc704\ud55c \ud0c0\uc785\uc815\uc758 struct promise_type { // `std::promise<T>`\ub97c \uadf8\ub300\ub85c \uc0ac\uc6a9\ud55c\ub2e4. promise < _Ty > _MyPromise ; // \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc740 `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // `false`\uc77c \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool initial_suspend () const { return ( false ); } // `false`\uc77c \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool final_suspend () const { return ( false ); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif MSVC\ub294 co_await / co_yield / co_return \ud0a4\uc6cc\ub4dc \uc911 \ud558\ub098\ub97c \ud655\uc778\ud558\uba74, coroutine_traits \ub97c \uc0ac\uc6a9\ud574 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uac80\uc0ac\ub97c \uc218\ud589\ud560 \uc218 \uc788\ub3c4\ub85d \ucf54\ub4dc\ub974 \uc0dd\uc131\ud55c\ub2e4. MSVC\uac00 \ud558\ub294 \uc77c\uc744 \ud655\uc778\ud558\uae30 \uc704\ud574 fibonacci \uc608\uc81c\ub85c \ub2e4\uc2dc \uac00\ubcf4\uc790. \uc774 \ucf54\ub4dc\ub294 \ud2c0\ub9b0 \ud615\ud0dc\uc77c \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc815\ud655\ud55c \uba54\ucee4\ub2c8\uc998\uc744 \ud655\uc778\ud558\uac8c \ub418\uba74 \uac31\uc2e0\ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // \ubcc4\uce6d : \ubc18\ud658\ud0c0\uc785 using return_type = generator < int > ; // \ubc18\ud658\ud0c0\uc785\uc774 Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294\uac00? using traits = coroutine_traite < return_type > ; // \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud55c\ub2e4\uba74 \uc774 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4. // fibonacci \ud568\uc218\ub97c \uc704\ud55c \uac00\uc0c1\uc758 \ud504\ub808\uc784. \uc704\uc640 \ub3d9\uc77c\ud558\ub2e4. struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // \ud504\ub808\uc784\uc744 \ub3d9\uc801\uc73c\ub85c \ud560\ub2f9\ud55c\ub2e4. context(ctx)\ub77c\uace0 \ud558\uaca0\ub2e4. // \ud2b9\uc815\ud55c Allocator\ub97c \uc0ac\uc6a9\ud574 \ucee4\uc2a4\ud130\ub9c8\uc774\uc988 \ud560 \uc218\ub3c4 \uc788\uc9c0\ub9cc \uc5ec\uae30\uc120 \ub2e8\uc21c\ud788 new\ub85c \uc124\uba85\ud55c\ub2e4. __frame * ctx = new __frame { std :: move ( n )}; // \ubc18\ud658 \uac1c\uccb4\ub97c \uc0dd\uc131\ud55c\ub2e4. return_type __return = ctx -> _promise . get_return_object (); // true\uc77c \uacbd\uc6b0 \uc911\ub2e8, false\uc77c \uacbd\uc6b0 \uc9c4\ud589\ud55c\ub2e4. if ( ctx -> _promise . initial_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __initial_suspend_point : } // \uc0ac\uc6a9\uc790 \ucf54\ub4dc\ub294 \ud504\ub808\uc784\uc744 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ubcc0\uacbd\ub41c\ub2e4. // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // promise\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // `ctx->_prefix`\uc758 Index\ub97c \uc870\uc815\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4. // co_await suspend_always{}; __suspend_resume_point_1 : // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uacc4\uc0b0\ud558\uace0 Shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __final_suspend_point : } // \uc815\ub9ac\uc791\uc5c5... } \uc0dd\uac01\ubcf4\ub2e4 \ucef4\ud30c\uc77c\ub7ec\uac00 \ub9ce\uc740 \uc791\uc5c5\uc744, \ud558\uc9c0\ub9cc \uae30\uc874\uc5d0 \uc2a4\ud0dd \ud504\ub808\uc784\uc5d0 \ub300\ud574\uc11c \ud558\ub358\uac83\uacfc \uc720\uc0ac\ud55c \uc791\uc5c5\uc744 \ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\uc5c8\ub2e4. ctx \uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ud799\uc601\uc5ed\uc5d0 \uc704\uce58\ud55c \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc740 this \ud3ec\uc778\ud130\uc758 \uc0ac\uc6a9\uacfc \ub2e4\ub974\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \uc774\ub7f0 \ud504\ub808\uc784 \uae30\ubc18 \uad6c\ud604\uc758 \ube44\uc6a9\uc740 \ucd94\uac00\uc801\uc778 co_await \uad00\ub828 \ube44\uc6a9\uc774\uc678\uc5d0\ub294 \ubb34\uc2dc\ud560 \uc218 \uc788\ub294 \uc218\uc900\uc77c \uac83\uc774\ub2e4. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend;","title":"Coroutine Traits"},{"location":"articles/exploring-msvc-coroutine-kor/#_19","text":"co_return \uacfc co_yield \uc5d0 \ub300\ud574\uc11c generator<T> \uc608\uc81c\ub97c \ud1b5\ud574 \uc0b4\ud3b4\ubd24\ub2e4. Generator\ub294 \ubc18\ubcf5\uc790\uc640 \uc7ac\uac1c\ud568\uc218\ub97c \ud569\uce5c \uac83\uc774\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 coroutine_handle \uc744 \uc0ac\uc6a9\ud558\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\uc640 \ucef4\ud30c\uc77c\ub7ec Intrinsic\uc744 \ud569\uccd0\ub193\uc740 \uac83\uc774\ub2e4. \ud504\ub808\uc784 \uae30\ubc18\uc758 \uad6c\ud604\uc740 this \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ubcc0\uc218\ub97c \uc870\uc791\ud558\ub294 \uac83\uacfc \uc720\uc0ac\ud558\ub2e4. \ucef4\ud30c\uc77c \uc2dc\uac04(\uc815\uc801) \uac80\uc0ac\ub97c \uc704\ud574 coroutine_traits<T> \uac00 \uc0ac\uc6a9\ub41c\ub2e4. \uc774\ub97c \ud1b5\ud574 promise_type \uc744 \uad6c\ud604\ud558\ub3c4\ub85d \uac15\uc81c\ud558\uba70, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement\ub97c \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4. std::future<T> \uc758 \uacbd\uc6b0 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654\uac00 \uae30\ubcf8\uc801\uc73c\ub85c \uc9c0\uc6d0\ub41c\ub2e4.","title":"\uc7a0\uae50 \uc815\ub9ac"},{"location":"articles/exploring-msvc-coroutine-kor/#_20","text":"operator co_await = Syntactic Sugar + Resumable Function \uc7ac\uac1c\ud568\uc218\uc758 \ub9c8\uc9c0\ub9c9 \ud575\uc2ec\uc740 \ub2e8\ud56d \uc5f0\uc0b0\uc790 co_await \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ubb38\ub9e5\uc0c1\uc73c\ub85c, await\ub294 suspend\uc640 \uac19\uc740\uc758\ubbf8\ub2e4 . \uadf8\ub9ac\uace0 \uc774 \uc911\ub2e8 \ub54c\ubb38\uc5d0, \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \uc790\uc5f0\uc2a4\ub7fd\uac8c \ube44\ub3d9\uae30 \uac00 \ub41c\ub2e4. \uba58\ud0c8 \ubaa8\ub378 \uc0c1\uc5d0\uc11c \uc774\ub7f0 \ud2b9\uc131\uc740 \uaf64 \uc911\uc694\ud55c \uc810\uc778\ub370, C# \uc5b8\uc5b4\uc758 async & await \uae30\ub2a5\uacfc \uc720\uc0ac\ud558\ub2e4\uace0 \ubcfc \uc218 \uc788\ub2e4. C++ \uc138\uc0c1\uc5d0\uc11c \ub2e4\ub978\uc810\uc740, \ud504\ub85c\uadf8\ub798\uba38\uc758 \ucf54\ub4dc\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc9c0\uc6d0\uc744 \uc0ac\uc6a9\ud574\uc11c \uc218\ub3d9\uc73c\ub85c \uad00\ub9ac\ud560 \uc218 \uc788\ub2e4\ub294 \uc810\uc774\ub2e4.","title":"\"\uae30\ub2e4\ub9b4 \uc218 \uc788\ub2e4\"\ub294 \uac1c\ub150\uc5d0 \ub300\ud574\uc11c"},{"location":"articles/exploring-msvc-coroutine-kor/#example_1","text":"MSVC \ube14\ub85c\uadf8\uc758 \uc608\uc81c\ub97c \uac00\uc838\uc654\ub2e4. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // \uc5f0\uc0b0\uc790 \uc624\ubc84\ub85c\ub4dc // co_await \ub294 \uae30\ubcf8 \ud0c0\uc785(primitive type) \uc778\uc790\ub294 \ubc1b\uc9c0 \uc54a\ub294\ub2e4. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc120 \ud568\uc218 3\uac1c\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback\uc744 \uc218\ud589\ud558\ub294 Thread\uc5d0\uc11c Resume\ud55c\ub2e4. coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // \uc900\ube44\uac00 \uc548\ub418\uc5c8\uc73c\uba74 (`false`), `await_suspend`\ub97c \ud638\ucd9c\ud55c\ub2e4. // \uac12\uc774 \uc900\ube44\ub418\uc5c8\uc73c\uba74 (`true`), `await_resume`\ub97c \ubc14\ub85c \ud638\ucd9c\ud55c\ub2e4. bool await_ready () const { return duration . count () <= 0 ; } // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \ubb34\uc2dc\ub420 \uc218 \uc788\ub2e4. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // \ud0c0\uc774\uba38\ub97c \uc138\ud305\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4.... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // \uc7ac\uac1c\ub41c \ud6c4\uc5d0\ub294 T \ud0c0\uc785 \uac12\uc744 \ubc18\ud658\ud55c\ub2e4. // `void`\ub3c4 \uac00\ub2a5\ud558\ub2e4. void await_resume () {} }; return awaiter { duration }; } // \ucf54\ub8e8\ud2f4(\uc7ac\uac1c\ud568\uc218) future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // 1 \ubc00\ub9ac\ucd08\ub97c \uae30\ub2e4\ub9b0\ub2e4... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // \ud3c9\ubc94\ud55c \uc11c\ube0c\ub8e8\ud2f4 void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } \uc774 \ucf54\ub4dc\ub294 \ub300\ub7b5 \uc774\ub7f0 \uc2dd\uc73c\ub85c \uc9c4\ud589\ub41c\ub2e4.","title":"Example"},{"location":"articles/exploring-msvc-coroutine-kor/#_21","text":"co_await \ub294 \ub3d9\uc791\ud558\uae30 \uc704\ud574\uc11c \ud2b9\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc694\uad6c\ud55c\ub2e4. \uc704\uc5d0\uc11c \ubcf8 \uac83 \ucc98\ub7fc, Awaitable Interface\ub294 3\uac00\uc9c0 \ud568\uc218\ub97c \uad6c\ud604\ud574\uc57c\ub9cc \ud55c\ub2e4. await_ready await_suspend await_resume \uc774\ub4e4\uc740 \uba64\ubc84\ud568\uc218\uc77c \uc218\ub3c4 \uc788\uace0, \uc77c\ubc18 \ud568\uc218\ub85c\ub3c4 \uac00\ub2a5\ud558\ub2e4. future<T> \uc5ed\uc2dc \uc774 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. \ub2ec\ub9ac\ub9d0\ud574, future<T> \uac00 co_await \uc758 \uc778\uc790\uac00 \ub420\uc218\ub3c4 \uc788\ub2e4\ub294 \uc758\ubbf8\ub2e4. \uc544\ub798 \ucf54\ub4dc\ucc98\ub7fc \ube44\ud6a8\uc728\uc801\uc77c \uc218\ub3c4 \uc788\uaca0\uc9c0\ub9cc, \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c \uac04\ub2e8\ud55c \uc624\ubc84\ub85c\ub4dc \ub9cc\uc73c\ub85c\ub3c4 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4\ub294 \uc7a5\uc810\uc774 \uc788\ub2e4. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // future\ub97c await\ud558\uba74 \uc2a4\ub808\ub4dc\ub97c \ub9cc\ub4e4\uc5b4\uc11c detach\uc2dc\ud0a8\ub2e4. // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std \ucef4\ud30c\uc77c\ub7ec \ucabd\uc740 \uc5b4\ub5a8\uae4c? \uc774 \ucf54\ub4dc\uac00 \uc5b4\ub5bb\uac8c \ubc14\ub014\uae4c?","title":"\uae30\ub2e4\ub9ac\uae30 \uc704\ud55c \uc778\ud130\ud398\uc774\uc2a4"},{"location":"articles/exploring-msvc-coroutine-kor/#_22","text":"operator co_await = Syntactic Sugar + Resumable Function co_await \ub294 \ud45c\ud604\uc744 \ubc14\uafbc\ub2e4\ub294 \uc810\uc5d0\uc11c \uacb0\uad6d syntatic sugar\ub77c\uace0 \ud560\uc218 \uc788\ub2e4. \uc778\uc790\ud0c0\uc785\uc774 Awaitable Interface\ub97c \uc54c\ub9de\uac8c \uad6c\ud604\ud558\uae30\ub9cc \ud55c\ub2e4\uba74, \ucef4\ud30c\uc77c\ub7ec\ub294 \ucf54\ub4dc\ub97c \ubc14\uafd4\uc900\ub2e4. \uc880\uc804\uc758 \uc608\uc81c\ucf54\ub4dc\ub97c \uc880\ub354 \uc790\uc138\ud558\uac8c \uc0b4\ud3b4\ubcf4\uaca0\ub2e4. // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // `co_await`\ud0a4\uc6cc\ub4dc\uac00 \uc788\uc73c\ubbc0\ub85c \uc7ac\uac1c\ud568\uc218\uac00 \ub41c\ub2e4. future < void > test () { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4... __frame * context ; // ... // Awaitable interface\ub97c \uad6c\ud604\ud558\uc600\ub2e4. // \uc815\ud655\ud558\uac8c\ub294 \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc774 \ubcc0\uc218\uac00 \uc0dd\uc131\ub420 \uac83\uc774\ub2e4. awaiter aw = operator co_await ( 1 ms ); // \uac12\uc774 \uc900\ube44\ub418\uc5b4 \uc788\ub294\uac00? if ( aw . await_ready () == false ) // await_ready(aw); { // \uac12\uc774 \uc5c6\uc73c\ubbc0\ub85c \uae30\ub2e4\ub824\uc57c \ud55c\ub2e4. // \ud568\uc218 \ud504\ub808\uc784\uc744 `coroutine_handle` \ud0c0\uc785\uc73c\ub85c \uac10\uc2f8\uace0... coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); // suspend \ud568\uc218\ub97c \ud638\ucd9c\ud55c\ub2e4. aw . await_suspend ( resume_cb ); // \uc911\ub2e8 \uc9c1\uc804\uc5d0 \ud504\ub808\uc784\uc5d0 Index\ub97c \ubcc0\uacbd\ud558\uace0...... __suspend_resume_point_1 : // \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc774 \uc5ec\uae30\uc5d0 \uc788\uc73c\ubbc0\ub85c ready\uc5d0\uc11c true\ub97c \ubc18\ud658\ud558\uba74 // \ud568\uc218\ub294 \uba48\ucd94\uc9c0 \uc54a\uace0 \uc9c4\ud589\ud55c\ub2e4. } // await_resume\uc774 \ubc18\ud658\ud0c0\uc785\uc774 \uc788\ub2e4\uba74 value\uc5d0 \uac12\uc744 \uc800\uc7a5\ud55c\ub2e4. // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } \uc774\uc81c \uc778\ud130\ud398\uc774\uc2a4\uc758 \uac01 \ud568\uc218\ub4e4\uc5d0 \ub300\ud574\uc11c \uc9da\uc5b4\ubcfc \uc218 \uc788\uaca0\ub2e4. await_ready : \"\uc9c0\uae08 \uac12\uc774 \uc788\ub294\uac00?\" await_ready \uc740 \ubd84\uae30\uc810\uc774 \ub41c\ub2e4. \uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\uba74 await_resume \uc5d0\uc11c \ubc14\ub85c \uadf8 \uac12\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uaca0\uc9c0\ub9cc, \uadf8\ub807\uc9c0 \uc54a\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc73c\ub85c \ubd84\uae30\ud574 \ud568\uc218\ub97c \uc911\ub2e8\ud55c\ub2e4. await_ready \ud568\uc218\uac00 \uc5b8\uc81c\ub098 true \ub97c \ubc18\ud658\ud55c\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc740 Dead Code\uac00 \ub418\uace0, \ucef4\ud30c\uc77c\ub7ec\uc758 \ucd5c\uc801\ud654 \uacfc\uc815\uc5d0\uc11c \uc18c\uba78\ub420 \uac83\uc774\ub2e4. \uc774 \uacbd\uc6b0\ub294 \ud504\ub808\uc784\uae4c\uc9c0 \uc18c\uba78\ub418\uace0 \uc77c\ubc18 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \ucd5c\uc801\ud654\ub420 \uc218 \ub3c4 \uc788\ub2e4. \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8 \ubc94\uc704\ub85c \uc9c4\uc785\ud558\uba74, \ud568\uc218 \ud504\ub808\uc784\uc744 coroutine_handle<> \ub85c \uac10\uc2f8\uc11c \uc778\uc790\ub85c \ub118\uaca8\uc900\ub2e4. coroutine_handle<>::from_address \ud568\uc218\uac00 \uc774 \uc5ed\ud560\uc744 \ud574\uc900\ub2e4. await_suspend : \"\uace7 \ub8e8\ud2f4\uc774 \uba48\ucda5\ub2c8\ub2e4. \ud574\uc57c\ud560 \uc77c\uc774\ub77c\ub3c4?\" await_suspend \ub294 coroutine_handle<> \uc744 \uc778\uc790\ub85c \ubc1b\uace0, \uc911\ub2e8\ud558\uae30 \uc804\uc5d0 \ud574\uc57c\ud560 \ub0b4\uc6a9\uc744 \ucf54\ub4dc\ub85c \ub07c\uc6cc\ub123\uc744 \uc218 \uc788\uac8c \ub41c\ub2e4. // Windows Thread Pool Timer\ub97c \uc0ac\uc6a9\ud55c\ub2e4. // Timer Callback\uc5d0 \ud504\ub808\uc784\uc758 \uc8fc\uc18c\ub97c \ub118\uaca8\uc8fc\ub294 \ubc29\uc2dd\uc73c\ub85c \ucf54\ub8e8\ud2f4\uc744 \ub9c8\ubb34\ub9ac\ud55c\ub2e4. class awaiter { bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // \ud3ec\uc778\ud130\ub85c \ubcc0\ud658\ud55c\ub2e4. resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Windows Thread Pool\uc5d0 \uc788\ub294 \uc2a4\ub808\ub4dc\uac00 Callback\uc744 \ud638\ucd9c\ud558\uac8c \ub41c\ub2e4. // \uc790\uc5f0\uc2a4\ub7fd\uac8c Resumer Thread\uac00 \ub41c\ub2e4. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // \ud504\ub808\uc784 \ud3ec\uc778\ud130\ub97c \ud578\ub4e4\ub85c \ubcc0\ud658, \uadf8\ub9ac\uace0 \uc7ac\uac1c. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"\uc5ec\uae30 \uacb0\uacfc\uac12\uacfc \uc2e4\ud589 \ud750\ub984\uc774\uc694.\" \ud568\uc218\ub97c \uc7ac\uac1c\ud558\uba74 \uc911\ub2e8\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\uba70, \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8\ubc94\uc704\ub97c \ubc97\uc5b4\ub098 await_resume \uc744 \ud638\ucd9c\ud55c\ub2e4. \uc911\ub2e8\ud558\ub358 \uc2dc\uc810\uc5d0\ub294 \uacb0\uacfc\uac12\uc774 \uc5c6\uc5c8\uae30 \ub54c\ubb38\uc5d0, \ud568\uc218\uac00 \uc7ac\uac1c\ub418\uc5c8\ub2e4\ub294 \uac83\uc740 \uacb0\uacfc\uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\ub294 \uc758\ubbf8\uac00 \ub41c\ub2e4. \ub9cc\uc57d void\ub77c\uba74 co_await \uc544\ub798\uc5d0 \uc788\ub294 \ucf54\ub4dc\ub97c \uc2e4\ud589\ud574\uc57c \ud558\ub3c4\ub85d \uc2e4\ud589\ud750\ub984\uc744 \ub118\uaca8\uc900\ub2e4\ub294 \uc758\ubbf8\uc77c \uac83\uc774\ub2e4.","title":"\ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810"},{"location":"articles/exploring-msvc-coroutine-kor/#co_await-tricks","text":"Kenny Kerr \uc640 James Mcnellis \ub294 \uc774\ub7f0 \uba54\ucee4\ub2c8\uc998\uc744 \uc0ac\uc6a9\ud55c \ud2b8\ub9ad\ub4e4\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\ub294\ub370, \uc2dc\uac04\uc801 \uc5ec\uc720\uac00 \uc788\ub2e4\uba74 \uaf2d \ubcf4\uae30\ub97c \uad8c\ud55c\ub2e4. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"co_await Tricks"},{"location":"articles/exploring-msvc-coroutine-kor/#async-generator","text":"","title":"Async Generator"},{"location":"articles/exploring-msvc-coroutine-kor/#_23","text":"Async Generator = Awaitable iterator + Resumable function Generator\uc640 \ub9e4\uc6b0 \uc720\uc0ac\ud558\uc9c0\ub9cc, \ub2e4\ub978\uc810\uc740 \ubc18\ubcf5\uc790\uac00 Awaitable\ud558\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub2ec\ub9ac \ub9d0\ud558\uba74, Awaitable iterator \uc5d0 \ub300\ud574\uc11c for co_await \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. Kirkshoop\uc758 \uc124\uba85 \uc774 \ub3c4\uc6c0\uc774 \ub420 \uac83\uc774\ub2e4.","title":"\uac1c\ub150"},{"location":"articles/exploring-msvc-coroutine-kor/#example_2","text":"\uc774 \uae30\ub2a5\uc744 \uc81c\ub300\ub85c \uc0ac\uc6a9\ud574\ubcf4\uc9c0 \ubabb\ud574 \uc81c\ub300\ub85c \ub41c \uc608\uc81c\ub97c \uc801\uc9c0 \ubabb\ud588\ub2e4. \ud558\uc9c0\ub9cc \uc9c0\uae08\uae4c\uc9c0\uc758 \uc608\uc81c\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810\uc5d0 \ub300\ud55c \uc124\uba85\uc744 \uc77d\uc5c8\ub2e4\uba74 \uc774 \ucf54\ub4dc\uac00 \uc774\ud574\ub420 \uac83\uc774\ub77c \uc0dd\uac01\ud55c\ub2e4. // \ubb34\ud55c\ud55c \uc815\uc218 \uc218\uc5f4 async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await \uad6c\ubb38 for co_await ( int v : infinite ()) { // `v`\ub85c \ubb34\uc5b8\uac00 \ud55c\ub2e4... } } iterator \uac00 Awaitable\ud558\ub2e4\uace0 \ud588\ub294\ub370, \uc774\ub294 usecase \uac00 \ub2e4\uc74c\uacfc \uac19\ub2e4\ub294 \uc758\ubbf8\ub2e4. std :: future < void > usecase () { // \uae30\ub2e4\ub9b4 \uc218 \uc788\ub294 \ubc18\ubcf5\uc790 : awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `begin()` \uc5d0 // `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. iter != gen . end (); // `end()` \ub294 nullptr\uc640 \uac19\ub2e4. co_await ++ iter ) // `operator++()`\uc5d0 `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. { int v = * iter ; // ... } } generator<T> \uc608\uc81c\uc640 \ub2e4\ub978 \uc810\uc740 \ud568\uc218\uac00 2\uac1c \uc9c0\uc810\uc5d0\uc11c \ubc18\ubcf5\uc790\ub97c \uae30\ub2e4\ub9ac\uace0 \uc788\ub2e4\ub294 \uac83\uc774\ub2e4. \ub530\ub77c\uc11c begin() \uacfc operator++() \ub294 usecase \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8/\uc7ac\uac1c\uc9c0\uc810\uc774 \ub41c\ub2e4. \uc5ec\uae30\uc120 value_type \uc740 \uae30\ubcf8 \uc790\ub8cc\ud615 int \ub77c\uc11c \uc5b4\ub824\uc6b4 \ucf54\ub4dc\ub294 \uc5c6\ub2e4. Awaitable iterator \ucf54\ub4dc\ub294 \ub2e4\uc74c\ucc98\ub7fc \ub9cc\ub4e4 \uc218 \uc788\ub2e4. \uc0ac\uc2e4 std::experimental::generator<T> \uc758 \ucf54\ub4dc\ub97c \uac70\uc758 \uadf8\ub300\ub85c \uac00\uc838\uc628 \uac83\uc774\ub2e4. // generator\uac00 \uc544\ub2c8\ub77c iterator\uac00 \ube44\ub3d9\uae30\ub85c \ub3d9\uc791\ud55c\ub2e4.(awaitable). template < typename T > struct async_generator { struct promise_type ; // Awaitable interface\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // \uc9c0\uae08\uc740 \uc608\uc81c\uc774\ubbc0\ub85c, \uc5b8\uc81c\ub098 \uac12\uc774 \uc874\uc7ac\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\uc9c0\ub3c4 \uc54a\ub294\ub2e4. bool await_ready () const { return true ; } // \uc911\ub2e8\ud558\uc9c0 \uc54a\uc73c\ubbc0\ub85c \ub0b4\uc6a9\uc774 \uc5c6\ub2e4. void await_suspend ( coroutine_handle <> hcoro ) {} // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc774 `co_await`\uc5d0\uac8c \uc804\ub2ec\ub41c\ub2e4. iterator await_resume () const { return * this ; } }; // iterator }; // async_generator \uba64\ubc84\ud568\uc218 3\uac1c\ub97c iterator \uc5d0 \ucd94\uac00\ud568\uc73c\ub85c\uc368, awaitable \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uc600\uace0 for co_await \uad6c\ubb38\uc744 \uc4f8 \uc218 \uc788\uc5c8\ub2e4. \ud558\uc9c0\ub9cc Awaitable Interface \ub2e8\ub77d\uc5d0\uc11c \uc124\uba85\ud588\ub4ef \uad73\uc774 \uba64\ubc84\ud568\uc218\uc77c \ud544\uc694\ub294 \uc5c6\ub2e4. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } \uc774\ub807\uac8c \ubcf4\uc870 \ud568\uc218\ub97c \uc815\uc758\ud558\ub294 \uac83 \ub9cc\uc73c\ub85c\ub3c4 \uae30\uc874\uc5d0 \uc0ac\uc6a9\ud558\ub358 iterator \ud0c0\uc785\ub4e4\uc744 \uc7ac\ud65c\uc6a9\ud560 \uc218 \uc788\ub2e4.","title":"Example"},{"location":"articles/exploring-msvc-coroutine-kor/#_24","text":"MSVC \ucf54\ub8e8\ud2f4\uc758 \uac1c\ub150\uacfc \ucf54\ub4dc\ub97c \ud6d1\uc5b4\ubd24\ub2e4. \uadf8\uac8c \uc804\ubd80\ub2e4. \ubd80\ub514 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uae30\ub97c. \uc0ac\uc2e4 \uc774 Feature\uc758 \ub514\uc2a4\uc5b4\uc148\ube14\ub9ac \uacb0\uacfc\uc5d0 \ub300\ud574\uc11c\ub3c4 \uc4f0\uace0 \uc2f6\uc5c8\ub294\ub370, \uad00\ub828\ud574\uc11c\ub294 \uc544\uc9c1 \ucd08\ubcf4\uc790 \ub2e8\uacc4\ub77c \uc81c\ub300\ub85c \uc124\uba85\ud560 \uc218\uac00 \uc5c6\uc5c8\ub2e4. \uae30\ud68c\uac00 \ub41c\ub2e4\uba74 \ucc28\ud6c4\uc5d0 \ub2e4\uc2dc \uae00\uc744 \uc368\ubcf4\uace0 \uc2f6\ub2e4. \ub098\uc911\uc5d0 \ub354\uc6b1 \uac1c\uc120\ud560 \uae30\ud68c\uac00 \uc788\uae30\ub97c. :D","title":"\ub05d! \ud6c4\uae30"},{"location":"articles/exploring-msvc-coroutine/","text":"Exploring MSVC Coroutine \u00b6 Written in 2017/02/17 \ud55c\uad6d\uc5b4 Reference \u00b6 Proposal \u00b6 N3858 N3977 N4134 N4402 Visual C++ Team Blog \u00b6 Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++ Video \u00b6 CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\" GitHub \u00b6 kirkshoop/ await Caution \u00b6 To try this feature, you need 3 things. Visual Studio 2015 Up3 or later. /await Compiler option <experimental/*> header files to include. Definition \u00b6 So, what is coroutine? Old Fashion : The Machine Level \u00b6 For me, the story starts from The Art of Computer Programming , written by Donald Knuth. Basically, the procedure call is goto . But, goto where? As you know, program can be thought as a sequence of states. And program's state, which is defined by programmer, is composition of machine environment and memory. It can be finite, or infinite. Program State = Environment X Memory (Cartesian Product) Here, instructions are transition between states. And routine is a ordered group of instructions. Instruction : Transition between states Routine : Ordered group of instructions Now, let's go to subroutine & coroutine. Concept : Relation \u00b6 All programmers have their own mental model for codes. Lets start from the point. Mental model for subroutine and coroutine. Subroutine : Caller-Callee \u00b6 Caller expects some states (Pre-condition). And it knows which routine is required. Callee, with specified (in other words, well-defined) codes, do its work without consideration of its caller. It can be impure with side-effect. But it's about work, not the relation. Coroutine : Activator-Activator \u00b6 Coroutine is cooperative routine. In other worlds, it is aware of the other routines. Notice that both are activated and activating by each other. Coroutine is activated by Invoker and Resuming routine. And by suspending or returning, coroutine activates its peer. In real, these activations are equal to jump( goto / jmp ) instruction. So some suspension can be considered as invocation. Or there might not be significant difference between suspension and finalization. If the point is entry(prologue) of routine, it is invocation ( call ). If the flow goes to the middle of procedure, then it's activation ( resume ). Invocation: Jump to start the routine Activation: Jump into a point of the routine Like subroutine, coroutines has specification for its pre-condition and post-condition. Therefore it must be designed with consideration of modification on program state. But after its work, it preserves the state and goto another point. This is suspension ( yield ). Of course, this can be return. In that case, it just finalizes and then return to its caller. (Since they have activation records) Suspension: Jump to another point without finalization Finalization: Destroy(cleanup) all function resources Difference? \u00b6 So, the major difference of coroutine/subroutine is that coroutine supports more operations. This is why Knuth summarized in his book. \"Subroutines are special cases of ... coroutines\" - Donald Knuth Let's see that in table form. Operation Subroutine Coroutine Invoke o o General procedure start Activate x o goto a specific point of procedure Suspend x o Yield current control flow Finalize o o Cleanup and return Clearly, subroutine is limited but easy and simple in relationship. However, coroutine have more operations, but might be complex because it suspension and activation should be managed. Routine: Group of instructions that modify the program state to another with defined statements Subroutine: Routine that supports 2 operations Invoke Finalize Coroutine: Routine that supports 4 operations Invoke Activate Suspend Finalize Example \u00b6 Knuth wrote how this is expressed in code. You don't have to understand all MIX instructions. Unlike theseday's subroutine, operations are usually JMP without abstraction. What I want to explain is that there is a gap between High-level and Assembly languages. The key point is coroutine has multiple points for entry and exit . Also, they have some implicit states. // MIX example, modified // The Art of Computer Programming 1.4.2. // For detail, read the book. :D // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF . Motivation : Programming Model \u00b6 It's a stack! \u00b6 \"It's A Trap!\" - Admiral Ackbar These days, we are familiar with high-level languages with runtime stack. It's fancy, well-defined, and automated. Think of structured, stack-ful program's model. In the model, the program is basically a mathematical expression tree that flows in depth-first order. For instance, main function finished at some time point and then it returns a value. Like figure, functions in this model embeds a sequence of statements when it is written. To reach the statement B, we have to finish the traversal for statement A. Then, the program state is affected by statement A. Memory locations will containing result values. Environments like registers will be set as defined. Blocking \u00b6 But the dependency became a problem. Remind that tree model follows mathematics. If we have all values in the expression, the calculation can be processed without blocking. Since we don't have infinite resource, we can't prepare all values when the flow starts. So, we need some In/Out operations. which is extremely slow. Waiting its result blocks our control flow. We don't want to stop our program. We want responsiveness. That's why we started to use non-blocking operations and to apply some asynchronous programming models. We generalized the program tree to a graph form. Which is another notation for state machine. Now, the program is graph of states . And our processors traverse over it. Processor can be OS Process, OS Thread, or some language supported abstraction such as Goroutine and Erlang process. But, Let me skip them, we are thinking about coroutine now. Persistence \u00b6 The point is, we have to deliver some context between vertices of the graph. But subroutine can't do this. Because it always destroyes(finalizes) itself. Subroutine is lack of persistence. It returns to caller. That's how runtime stack works. But it disabled us to pass contexts between states. Think of callback hell to enable that context forwarding. \"James. This code has a bug. Can you fix it?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); } Approach \u00b6 We need some persistent function. Reminding coroutine suspend/yield its control without finalization, the answer is crystal clear. Coroutine can take the role. But how can we migrate that assembly concept into our stack world? Let's change the question. What should be persistent?: Context What is context?: The routine's state What makes the state?: Environment & Memory Where are they?: Function Frame Henceforce, our migration starts from how to make those frames persistent . If you can't get what it is, visit this page . Stackful? Stackless! \u00b6 \"Why do you rob banks?\" \"That's where the money is.\" - Bank robber Stackful or Segmented Stack \u00b6 It differes upon language, but C++ places function frames in runtime stack. To preserve some frame, we have to dump it and store it in some location. Or we can make a smaller chunk of space and use it as a side(alternantive) stack for function. But let's bypass them. Our focus, MSVC coroutine is stackless. Stackless - Function Frame \u00b6 N3858 wrote about resumable function's implementability. It suggested heap-allocated activation frames. But frame is just a structure. Remind that we need 4 operations for coroutine. Those are declared as compiler intrinsic. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... So there is nothing we can touch.(Unless you are in MSVC team... right?) But if you want more detail, follow the references above and watch CppCon talks. you may noticed there are 2 kinds of concept. Frame and Block. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block It is not clear for me now. Let me update this section later. In my opinion, the frame is activation record for the function (In the case, resumable function). And block is space for function code. Therefore, it will contain local/captured arguments, And it's size will depends on maximum stack size of the function. ... Probably. The C++ Coroutine : Resumable Function \u00b6 At this point, we have to define 2 terms. Coroutine : Concept . Routine that supports 4 operations Resumable Function : Implementation of coroutine concept in C++ world And the following table is about how to use its operations Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return Invoke \u00b6 For function call, there is no change. But the resumable function returns std::future<T> . Finalize \u00b6 Cleanup and return point can be specified the well-known keyword, return . For same purpose, in resumable function, co_return statement is used. Suspend \u00b6 When you wan to suspend funtion and yield its control, co_yield expression and co_await operator can do that. By adding 1 of them, the suspend/resume point is specified and MSVC will treat the function as coroutine. (Also, co_return statement can be used) Activate \u00b6 When we have to activate suspended function, we will use coroutine_handle and its memeber function, .resume() . This is an interface to compiler intrinsic _coro_resume above. Code \u00b6 Example codes are inspired by kirkshoop's repository . In short, if we follows MSVC's requirement, we can use C++ coroutine. But notice that the title of proposal is resumable (therefore, persistent) function. However, its category differs to which meaning you want to carry with. Before that, let's start with compiler's requirement. Promise : Compiler's Requirement \u00b6 You may already know about std::future<T> and std::promise<T> , and relation of the pair. Usually, future<T> is something like \"I will return value or exception later \" (See std::async() ). And the value/exception is transferred via promise<T> . It is, \"I kept the promise for the value\". And I already explained that resumable returns future<T> . Literally, This is not weird because coroutine can suspends itself and therefore its activator can't sure that it has returned. However, with the signature, programmer can still explicitly specify for return type just like conventional subroutine. But here, the promise is for resumable function. See N4402 . You may ask why this is necessary. The answer is that resumable function is abstraction . Because of stack, we had migrated the coroutine concept but not assembly-like flat code. Our resumable function lives in heap and to pass value from heap space(from function frame) to stack space(to future or awaitable), there must be some interface . For both compiler and programmer. Resumable Promise Requirement \u00b6 I will explain how this interface is used soon. According to N4402, the promise type for resumable function should support operations in the table below. I summarized note column. For detail, please read the document. Expression Note P{} Promise must be default constructible p.get_return_object() The return value of funtion. It can be future<T> , or some user-defined type. p.return_value(v) co_return statement. Pass the value v and the value will be consumed later. p.return_value() co_return statement. Pass void . Can be invoked when the coroutine returns. And calling this can be thought as \"No more value\". p.set_exception(e) Pass the exception. It will throw when the resumer activates the function with this context. p.yield_value(v) co_yield expression. Similar to return_value(v) . p.initial_suspend() If return true , suspends at initial suspend point. p.final_suspend() If return true , suspends at final suspend point. Some operations are related to coroutine_traits<T> . Later section will describe its flexibility. It is pretty abstract for now, but we are in progress. Lets move our focus to usecases of C++ coroutine. Generator \u00b6 Concept \u00b6 Generator = Iterator + Resumable Function See? There is an iterator. generator<T> is abstraction for sequence of values, which are generated by resumable function. The function is persistent, and contains some unique context in its frame. Example \u00b6 The following code is simple generator for fibonacci numbers. #include <experimental/generator> // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // Set the value and suspend co_yield f1 ; // Calculate next fibo and shift int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // No more value } void usecase () { // A sequence of 10 fibo numbers for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } How this can be possible? Well, lets see the definition of generator<T> . Detail \u00b6 Here is a skeleton of generator<T> . We can see that it supports iterator and promise_type . and begin() / end() function to support Range-based for loop template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // Handle for Resumable Funtion coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // If we have handle, we can resume it to get the value. if ( _Coro ) { _Coro . resume (); // The function returned? if ( _Coro . done ()) return { nullptr }; // return end(); } // The function is not finished. // Will be reused later... return { _Coro }; } iterator end () { // No handle, No more value. return { nullptr }; } ~ generator () { // RAII : Destroy function frame if ( _Coro ) { _Coro . destroy (); } } }; So, the actual usecase function will be like this. void usecase () { // A generator for 10 fibo numbers generator < int > gen = fibonacci ( 10 ); // We cannot use `iter++` because it is deleted. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } Pretty simple with the iterator! Let's hack the iterator then... template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Iterator interface struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // When we move next... iterator & operator ++ () { // Make the function yield next value _Coro . resume (); // If done, just release. // Generator will destroy it later... if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // This is MSVC comment.... // In short, post increment can overlap the handle in iterator. // And it can leak the last value in coroutine frame. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // We use `promise` to get the value. // It is pointing the value in function frame _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; At this point, we can understand that iterator is resuming the function repetitively. And acquiring value from generator<T> 's promise_type . So in this case, usecase function is both invoker and resumer for the generator . Compiler's View \u00b6 Now, the keystone promise_type is on the stage. It has more codes but I will skip them for simplicity. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } The promise_type supports 4 functions in requirement. get_return_object , initial_suspend , final_suspend , and yield_value . In short, co_yield is equal to \"Set the value and suspend\". Compiler will change the expression like following. co_yield : co_await + p.yield_value(x) Therefore, co_yield with empty expression is impossible . Because x can't be void . Since generator is abstraction of sequence, this is natural constraint. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // Compiler changes the expression to... // co_yield f1; p . yield_value ( f1 ); // Set the value pointer co_await suspend_always {}; // And suspend. // ... } co_return ; // No more value } Notice that there is no promise_type p{} or something else. Its secret will be covered in next section. Resumable Function \u00b6 This section starts from detail. The example code will be seen after explanation of awaitable concept. Concept \u00b6 Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> was simple example. And you may remember that it contains coroutine_handle . Let's cover the type. coroutine_handle was resumable_handle . Remembering that resumable function is C++ implementation of coroutine concept, it is alias of resumable function handle. If you have an experience of Windows API, you probably know what handle means. It is void * . We already talked about how stackless coroutine can be implemented. MSVC uses heap allocated function frame and supports several intrinsics. With the pointer to frame in heap, coroutine_handle adds some operation over it. Resumable Frame \u00b6 Then, how does the frame look like? As I commented above, the frame of resumable function. It has head and body. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // Head of function frame // - Fn : Instruction address for resume operation // - cdecl : Caller manages the frame. Callee won't touch it. // - Index : Index to resumption point. // 0 is special value for `done()` // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // Coroutine Frame will include... // - Promise // - Captured arguments // - Function body // - Local Variables and Temporaries // - Platform context // - Registers // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : Like its name, _Resumable_frame_prefix is head of coroutine frame. MSVC uses fixed size of sizeof(void *) * 2 (16 bytes in x64) for this struct. Fn : Note that this is declared as cdecl convention. Since cdecl specifies stack cleanup (in the case, frame destruction) is up to caller, the call of Fn won't destroy the frame. Index : Resumable function can have multiple resumption point. This is a index for the point. Flag : ??? Who are you ??? Body : N4402 describes what frame includes. Based on James McNellis's PPT, the compiler-generated frame body will be like the following code. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // Possible frame for fibonacci function struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _p ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; Coroutine Traits \u00b6 We didn't cover p.get_return_object() yet. This is the section for the topic. Let me explain coroutine_traits first... // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; It's pretty simple. coroutine_traits requires promise_type to be implemented at compile time. And it must follow Resumable Promise Requirement . I explaind that resumable function returns future<T> , but that was not correct. If there is a type that fulfills the coroutine_traits , it can be return type of Resumable function. Let't go to template specialization of coroutine_traits for std::future<T> . Previous example, generator<T> implemented promise type in itself, but with the specialization trick, we can reuse some old types or try some custom type. // <future> #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // Template Specialization for `std::future<T>` template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // defines resumable traits for functions returning future<_Ty> struct promise_type { // `std::promise<T>` promise < _Ty > _MyPromise ; // Resumable function can return `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // if `false`, we skip the initial suspend point. bool initial_suspend () const { return ( false ); } // if `false`, we skip the final suspend point. bool final_suspend () const { return ( false ); } // Pass the value through `std::promise<T>` template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // Pass the exception through `std::promise<T>` void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif When MSVC meets co_await / co_yield / co_return , it applies coroutine_traits to enable compile-time check. Let's see the fibonacci example again. It will show what MSVC does. The code might be wrong. I will update it as I find correct mechanism. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { using return_type = generator < int > ; // At this point, compiler will generate code // and check `return_type` fulfills promise requirement. using traits = coroutine_traite < return_type > ; // Requirement : OK. // We can generate unique frame type for this function. // Possible frame for fibonacci function struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // We are forwarding arguments to frame! // Let's call it context(ctx) __frame * ctx = new __frame { std :: move ( n )}; // Generate return objet // In this case, `generator<int>` return_type __return = ctx -> _promise . get_return_object (); // if true, suspend. // if false, keep move... if ( ctx -> _promise . initial_suspend () ){ // always true // suspend... __initial_suspend_point : } // User code : use variables in frame(ctx)... // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // Pass value through promise // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // instructions for suspension with `ctx->_prefix`... // co_await suspend_always{}; __suspend_resume_point_1 : // Calculate next fibo and shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // always true // suspend... __final_suspend_point : } // Instructions for clean up... } So we could find out that compiler do a lot of job instead of us. And using frame pointer ctx is not that different from this pointer for memeber functions. Therefore, the cost for frame-based code will be negligible. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend; Section Summary \u00b6 We covered co_return and co_yield with generator<T> example. Generator was a combination of iterator and resumable function. Resumable functions use coroutine_handle , which is basically raw pointer to function frame and some operations that rely on compiler intrinsics. The mechanism for frame-based approach was pretty similar to this pointer approach. For compile-time(static) assertion, coroutine_traits<T> is used. It enforce the return type to support promise_type that fulfills resumable promise requirement. And there was a specialization especially for std::future<T> . The Awaitable Concept \u00b6 operator co_await = Syntactic Sugar + Resumable Function The last core of resumable function is co_await . It is unary operator. In this semantics, await is synonym of suspend . And because of suspension, its return value becomes asynchronous . This is the important point for our mental model. You may thought async & await of C# language, The difference in C++ world is that we can manage them manually , with our code and compiler support. Example \u00b6 The code is sample from MSVC blog. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // operator overload. // co_await can't use primitive type parameter. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // Awaitable must implements 3 function. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback Thread will resume the function coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // If not ready (`false`), invoke `await_suspend` // If ready (`true`), go to `await_resume` directly. bool await_ready () const { return duration . count () <= 0 ; } // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // Set the timer and then suspend... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Return T type's value after resumed. // T can be `void`. void await_resume () {} }; return awaiter { duration }; } // Resumable Function future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // await for 1 millisecond... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // This is normal subroutine void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } It's flow is like the figure. Awaitable Interface \u00b6 co_await requires some interface for its operation. As we can see in code above, Awaitable interface should implement at least 3 functions. await_ready await_suspend await_resume It can be both member and normal function. future<T> also implements this interface. so future can be an argument for co_await . But just like the code await_suspend , it can be inefficient. For user-defined type, simple overload is enough. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std How about compiler's view? How does it change our code? Compiler's View \u00b6 operator co_await = Syntactic Sugar + Resumable Function I explained that co_await is syntatic sugar. If operator's argument type implements awaitable concept appropriately, the code will be modified by compiler. Revisiting previous example, test function which awaits for 1 millisecond, let's see how it works... // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // With `co_await` keyword in function body, // compiler will make this function to resumable. future < void > test () { // Compiler-generated coroutine frame... __frame * context ; // ... // Awaitable type implements awaitable interface. // Precisely, this will be temporary variable in frame. awaiter aw = operator co_await ( 1 ms ); // Do we have expected value now? // If not, suspend. // If ready, skip the suspend and resume directly. if ( aw . await_ready () == false ) // await_ready(aw); { // Wrap the function frame to `coroutine_handle` type coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); aw . await_suspend ( resume_cb ); // some instructions.... __suspend_resume_point_1 : // Since resume point is in this scope, // there won't be suspension if ready()==true. } // If await_resume has return type... // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } So there are some points for each of interface functions. await_ready : \"Do we have return value now?\" await_ready makes the branch. It asks value for await_resume is ready. If not, the control flows into the scope of if statement. If it's ready, await_ready returns true and await_resume will be invoked directly. Compiler can optimize the code if it returns false always. In the case, we don't need suspension and therefore frame wrapping becomes unnecessary. The coroutine will become normal subroutine after optimization steps. In suspension scope, we must ready for suspension. Since coroutine_handle<> is just a raw pointer to frame, we can wrap it easily with static function coroutine_handle<>::from_address . await_suspend : \"The routine will suspend soon. Do what you have to do!\" await_suspend receives coroutine_handle<> for its argument. With this function, we can interleave our code for suspension handling. // The example code set the Windows Thread Pool Timer // and forward frame's address as callback argument. class awaiter { // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // Unwrap the handle resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // A thread in Windows Thread Pool will invoke this callback. // And it will be resumer for the function. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Wrap the frame to handle again. And resume. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"Now, here is the return value and control flow\" Suspend/resume point is created for resume operation. When the coroutine handle's .resume() is invoked, the function will set the context(frame pointer) and jump to it. The flow then exits the scope and call await_resume . Notice that we did suspend because the value wasn't ready( await_ready ). When the function is resumed, there should be return value. If await_resume 's return type is void, it means control flow is back. co_await Tricks \u00b6 Kenny Kerr and James Mcnellis introduced several tricks with this mechanism. I strongly recommend you to watch the video. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Async Generator \u00b6 Concept \u00b6 Async Generator = Awaitable iterator + Resumable function This is similar to Generator's concept, but it has awaitable iterator . In other words, we can use for co_await statement for it. Kirkshoop will give you clear explanation for this. Example \u00b6 I won't write hard example since I hadn't try this feature. But previous examples and explanations will help your understanding. // Infinite sequence of interger. async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await statement for co_await ( int v : infinite ()) { // do something with `v`... } } I sad iterator is awaitable. So real code of usecase will be like following. std :: future < void > usecase () { // generator with awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `co_await` + `begin()` iter != gen . end (); // `end()` has nullptr co_await ++ iter ) // `co_await` + `operator++()` { int v = * iter ; // ... } } The only difference form generator<T> example is that the function is awaiting iterator at 2 points. begin() and operator++() . These are points for resume operation. Here, value type is primitive type int . So there won't be complex code here. The following code shows how to make awaitable iterator. The other code for generator body and promise_type is exactly same with std::experimental::generator<T> // Actually, generator is not async. Its iterator is async(awaitable). template < typename T > struct async_generator { struct promise_type ; // Same with experimental generator // We will implement awaitable interface... struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // Since this is syntactic example, there is no suspension. bool await_ready () const { return true ; } // With no suspension, there is nothing to do with handle. void await_suspend ( coroutine_handle <> hcoro ) {} // Return awaitable iterator at resume point iterator await_resume () const { return * this ; } }; // iterator }; // async_generator By adding 3 member functions for iterator , we could make it awaitable and became available to use for co_await statement. But as I mentioned at Awaitable Interface section, you don't have to add member function. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } Adding these helper functions for old types will work fine. Conclusion \u00b6 So, we have traveled MSVC coroutine from concept to code. That's all. I wish I made helpful description. I'd like to add disassembly experience about this feature, but I can't make it because I'm a beginner for that ability. I will try that topic later. I couldn't make this article in more detail. Maybe there could be a chance to update this...! :D","title":"Exploring MSVC Coroutine"},{"location":"articles/exploring-msvc-coroutine/#exploring-msvc-coroutine","text":"Written in 2017/02/17 \ud55c\uad6d\uc5b4","title":"Exploring MSVC Coroutine"},{"location":"articles/exploring-msvc-coroutine/#reference","text":"","title":"Reference"},{"location":"articles/exploring-msvc-coroutine/#proposal","text":"N3858 N3977 N4134 N4402","title":"Proposal"},{"location":"articles/exploring-msvc-coroutine/#visual-c-team-blog","text":"Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++","title":"Visual C++ Team Blog"},{"location":"articles/exploring-msvc-coroutine/#video","text":"CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\"","title":"Video"},{"location":"articles/exploring-msvc-coroutine/#github","text":"kirkshoop/ await","title":"GitHub"},{"location":"articles/exploring-msvc-coroutine/#caution","text":"To try this feature, you need 3 things. Visual Studio 2015 Up3 or later. /await Compiler option <experimental/*> header files to include.","title":"Caution"},{"location":"articles/exploring-msvc-coroutine/#definition","text":"So, what is coroutine?","title":"Definition"},{"location":"articles/exploring-msvc-coroutine/#old-fashion-the-machine-level","text":"For me, the story starts from The Art of Computer Programming , written by Donald Knuth. Basically, the procedure call is goto . But, goto where? As you know, program can be thought as a sequence of states. And program's state, which is defined by programmer, is composition of machine environment and memory. It can be finite, or infinite. Program State = Environment X Memory (Cartesian Product) Here, instructions are transition between states. And routine is a ordered group of instructions. Instruction : Transition between states Routine : Ordered group of instructions Now, let's go to subroutine & coroutine.","title":"Old Fashion : The Machine Level"},{"location":"articles/exploring-msvc-coroutine/#concept-relation","text":"All programmers have their own mental model for codes. Lets start from the point. Mental model for subroutine and coroutine.","title":"Concept : Relation"},{"location":"articles/exploring-msvc-coroutine/#subroutine-caller-callee","text":"Caller expects some states (Pre-condition). And it knows which routine is required. Callee, with specified (in other words, well-defined) codes, do its work without consideration of its caller. It can be impure with side-effect. But it's about work, not the relation.","title":"Subroutine : Caller-Callee"},{"location":"articles/exploring-msvc-coroutine/#coroutine-activator-activator","text":"Coroutine is cooperative routine. In other worlds, it is aware of the other routines. Notice that both are activated and activating by each other. Coroutine is activated by Invoker and Resuming routine. And by suspending or returning, coroutine activates its peer. In real, these activations are equal to jump( goto / jmp ) instruction. So some suspension can be considered as invocation. Or there might not be significant difference between suspension and finalization. If the point is entry(prologue) of routine, it is invocation ( call ). If the flow goes to the middle of procedure, then it's activation ( resume ). Invocation: Jump to start the routine Activation: Jump into a point of the routine Like subroutine, coroutines has specification for its pre-condition and post-condition. Therefore it must be designed with consideration of modification on program state. But after its work, it preserves the state and goto another point. This is suspension ( yield ). Of course, this can be return. In that case, it just finalizes and then return to its caller. (Since they have activation records) Suspension: Jump to another point without finalization Finalization: Destroy(cleanup) all function resources","title":"Coroutine : Activator-Activator"},{"location":"articles/exploring-msvc-coroutine/#difference","text":"So, the major difference of coroutine/subroutine is that coroutine supports more operations. This is why Knuth summarized in his book. \"Subroutines are special cases of ... coroutines\" - Donald Knuth Let's see that in table form. Operation Subroutine Coroutine Invoke o o General procedure start Activate x o goto a specific point of procedure Suspend x o Yield current control flow Finalize o o Cleanup and return Clearly, subroutine is limited but easy and simple in relationship. However, coroutine have more operations, but might be complex because it suspension and activation should be managed. Routine: Group of instructions that modify the program state to another with defined statements Subroutine: Routine that supports 2 operations Invoke Finalize Coroutine: Routine that supports 4 operations Invoke Activate Suspend Finalize","title":"Difference?"},{"location":"articles/exploring-msvc-coroutine/#example","text":"Knuth wrote how this is expressed in code. You don't have to understand all MIX instructions. Unlike theseday's subroutine, operations are usually JMP without abstraction. What I want to explain is that there is a gap between High-level and Assembly languages. The key point is coroutine has multiple points for entry and exit . Also, they have some implicit states. // MIX example, modified // The Art of Computer Programming 1.4.2. // For detail, read the book. :D // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF .","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#motivation-programming-model","text":"","title":"Motivation : Programming Model"},{"location":"articles/exploring-msvc-coroutine/#its-a-stack","text":"\"It's A Trap!\" - Admiral Ackbar These days, we are familiar with high-level languages with runtime stack. It's fancy, well-defined, and automated. Think of structured, stack-ful program's model. In the model, the program is basically a mathematical expression tree that flows in depth-first order. For instance, main function finished at some time point and then it returns a value. Like figure, functions in this model embeds a sequence of statements when it is written. To reach the statement B, we have to finish the traversal for statement A. Then, the program state is affected by statement A. Memory locations will containing result values. Environments like registers will be set as defined.","title":"It's a stack!"},{"location":"articles/exploring-msvc-coroutine/#blocking","text":"But the dependency became a problem. Remind that tree model follows mathematics. If we have all values in the expression, the calculation can be processed without blocking. Since we don't have infinite resource, we can't prepare all values when the flow starts. So, we need some In/Out operations. which is extremely slow. Waiting its result blocks our control flow. We don't want to stop our program. We want responsiveness. That's why we started to use non-blocking operations and to apply some asynchronous programming models. We generalized the program tree to a graph form. Which is another notation for state machine. Now, the program is graph of states . And our processors traverse over it. Processor can be OS Process, OS Thread, or some language supported abstraction such as Goroutine and Erlang process. But, Let me skip them, we are thinking about coroutine now.","title":"Blocking"},{"location":"articles/exploring-msvc-coroutine/#persistence","text":"The point is, we have to deliver some context between vertices of the graph. But subroutine can't do this. Because it always destroyes(finalizes) itself. Subroutine is lack of persistence. It returns to caller. That's how runtime stack works. But it disabled us to pass contexts between states. Think of callback hell to enable that context forwarding. \"James. This code has a bug. Can you fix it?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); }","title":"Persistence"},{"location":"articles/exploring-msvc-coroutine/#approach","text":"We need some persistent function. Reminding coroutine suspend/yield its control without finalization, the answer is crystal clear. Coroutine can take the role. But how can we migrate that assembly concept into our stack world? Let's change the question. What should be persistent?: Context What is context?: The routine's state What makes the state?: Environment & Memory Where are they?: Function Frame Henceforce, our migration starts from how to make those frames persistent . If you can't get what it is, visit this page .","title":"Approach"},{"location":"articles/exploring-msvc-coroutine/#stackful-stackless","text":"\"Why do you rob banks?\" \"That's where the money is.\" - Bank robber","title":"Stackful? Stackless!"},{"location":"articles/exploring-msvc-coroutine/#stackful-or-segmented-stack","text":"It differes upon language, but C++ places function frames in runtime stack. To preserve some frame, we have to dump it and store it in some location. Or we can make a smaller chunk of space and use it as a side(alternantive) stack for function. But let's bypass them. Our focus, MSVC coroutine is stackless.","title":"Stackful or Segmented Stack"},{"location":"articles/exploring-msvc-coroutine/#stackless-function-frame","text":"N3858 wrote about resumable function's implementability. It suggested heap-allocated activation frames. But frame is just a structure. Remind that we need 4 operations for coroutine. Those are declared as compiler intrinsic. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... So there is nothing we can touch.(Unless you are in MSVC team... right?) But if you want more detail, follow the references above and watch CppCon talks. you may noticed there are 2 kinds of concept. Frame and Block. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block It is not clear for me now. Let me update this section later. In my opinion, the frame is activation record for the function (In the case, resumable function). And block is space for function code. Therefore, it will contain local/captured arguments, And it's size will depends on maximum stack size of the function. ... Probably.","title":"Stackless - Function Frame"},{"location":"articles/exploring-msvc-coroutine/#the-c-coroutine-resumable-function","text":"At this point, we have to define 2 terms. Coroutine : Concept . Routine that supports 4 operations Resumable Function : Implementation of coroutine concept in C++ world And the following table is about how to use its operations Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return","title":"The C++ Coroutine : Resumable Function"},{"location":"articles/exploring-msvc-coroutine/#invoke","text":"For function call, there is no change. But the resumable function returns std::future<T> .","title":"Invoke"},{"location":"articles/exploring-msvc-coroutine/#finalize","text":"Cleanup and return point can be specified the well-known keyword, return . For same purpose, in resumable function, co_return statement is used.","title":"Finalize"},{"location":"articles/exploring-msvc-coroutine/#suspend","text":"When you wan to suspend funtion and yield its control, co_yield expression and co_await operator can do that. By adding 1 of them, the suspend/resume point is specified and MSVC will treat the function as coroutine. (Also, co_return statement can be used)","title":"Suspend"},{"location":"articles/exploring-msvc-coroutine/#activate","text":"When we have to activate suspended function, we will use coroutine_handle and its memeber function, .resume() . This is an interface to compiler intrinsic _coro_resume above.","title":"Activate"},{"location":"articles/exploring-msvc-coroutine/#code","text":"Example codes are inspired by kirkshoop's repository . In short, if we follows MSVC's requirement, we can use C++ coroutine. But notice that the title of proposal is resumable (therefore, persistent) function. However, its category differs to which meaning you want to carry with. Before that, let's start with compiler's requirement.","title":"Code"},{"location":"articles/exploring-msvc-coroutine/#promise-compilers-requirement","text":"You may already know about std::future<T> and std::promise<T> , and relation of the pair. Usually, future<T> is something like \"I will return value or exception later \" (See std::async() ). And the value/exception is transferred via promise<T> . It is, \"I kept the promise for the value\". And I already explained that resumable returns future<T> . Literally, This is not weird because coroutine can suspends itself and therefore its activator can't sure that it has returned. However, with the signature, programmer can still explicitly specify for return type just like conventional subroutine. But here, the promise is for resumable function. See N4402 . You may ask why this is necessary. The answer is that resumable function is abstraction . Because of stack, we had migrated the coroutine concept but not assembly-like flat code. Our resumable function lives in heap and to pass value from heap space(from function frame) to stack space(to future or awaitable), there must be some interface . For both compiler and programmer.","title":"Promise : Compiler's Requirement"},{"location":"articles/exploring-msvc-coroutine/#resumable-promise-requirement","text":"I will explain how this interface is used soon. According to N4402, the promise type for resumable function should support operations in the table below. I summarized note column. For detail, please read the document. Expression Note P{} Promise must be default constructible p.get_return_object() The return value of funtion. It can be future<T> , or some user-defined type. p.return_value(v) co_return statement. Pass the value v and the value will be consumed later. p.return_value() co_return statement. Pass void . Can be invoked when the coroutine returns. And calling this can be thought as \"No more value\". p.set_exception(e) Pass the exception. It will throw when the resumer activates the function with this context. p.yield_value(v) co_yield expression. Similar to return_value(v) . p.initial_suspend() If return true , suspends at initial suspend point. p.final_suspend() If return true , suspends at final suspend point. Some operations are related to coroutine_traits<T> . Later section will describe its flexibility. It is pretty abstract for now, but we are in progress. Lets move our focus to usecases of C++ coroutine.","title":"Resumable Promise Requirement"},{"location":"articles/exploring-msvc-coroutine/#generator","text":"","title":"Generator"},{"location":"articles/exploring-msvc-coroutine/#concept","text":"Generator = Iterator + Resumable Function See? There is an iterator. generator<T> is abstraction for sequence of values, which are generated by resumable function. The function is persistent, and contains some unique context in its frame.","title":"Concept"},{"location":"articles/exploring-msvc-coroutine/#example_1","text":"The following code is simple generator for fibonacci numbers. #include <experimental/generator> // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // Set the value and suspend co_yield f1 ; // Calculate next fibo and shift int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // No more value } void usecase () { // A sequence of 10 fibo numbers for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } How this can be possible? Well, lets see the definition of generator<T> .","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#detail","text":"Here is a skeleton of generator<T> . We can see that it supports iterator and promise_type . and begin() / end() function to support Range-based for loop template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // Handle for Resumable Funtion coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // If we have handle, we can resume it to get the value. if ( _Coro ) { _Coro . resume (); // The function returned? if ( _Coro . done ()) return { nullptr }; // return end(); } // The function is not finished. // Will be reused later... return { _Coro }; } iterator end () { // No handle, No more value. return { nullptr }; } ~ generator () { // RAII : Destroy function frame if ( _Coro ) { _Coro . destroy (); } } }; So, the actual usecase function will be like this. void usecase () { // A generator for 10 fibo numbers generator < int > gen = fibonacci ( 10 ); // We cannot use `iter++` because it is deleted. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } Pretty simple with the iterator! Let's hack the iterator then... template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Iterator interface struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // When we move next... iterator & operator ++ () { // Make the function yield next value _Coro . resume (); // If done, just release. // Generator will destroy it later... if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // This is MSVC comment.... // In short, post increment can overlap the handle in iterator. // And it can leak the last value in coroutine frame. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // We use `promise` to get the value. // It is pointing the value in function frame _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; At this point, we can understand that iterator is resuming the function repetitively. And acquiring value from generator<T> 's promise_type . So in this case, usecase function is both invoker and resumer for the generator .","title":"Detail"},{"location":"articles/exploring-msvc-coroutine/#compilers-view","text":"Now, the keystone promise_type is on the stage. It has more codes but I will skip them for simplicity. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } The promise_type supports 4 functions in requirement. get_return_object , initial_suspend , final_suspend , and yield_value . In short, co_yield is equal to \"Set the value and suspend\". Compiler will change the expression like following. co_yield : co_await + p.yield_value(x) Therefore, co_yield with empty expression is impossible . Because x can't be void . Since generator is abstraction of sequence, this is natural constraint. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // Compiler changes the expression to... // co_yield f1; p . yield_value ( f1 ); // Set the value pointer co_await suspend_always {}; // And suspend. // ... } co_return ; // No more value } Notice that there is no promise_type p{} or something else. Its secret will be covered in next section.","title":"Compiler's View"},{"location":"articles/exploring-msvc-coroutine/#resumable-function","text":"This section starts from detail. The example code will be seen after explanation of awaitable concept.","title":"Resumable Function"},{"location":"articles/exploring-msvc-coroutine/#concept_1","text":"Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> was simple example. And you may remember that it contains coroutine_handle . Let's cover the type. coroutine_handle was resumable_handle . Remembering that resumable function is C++ implementation of coroutine concept, it is alias of resumable function handle. If you have an experience of Windows API, you probably know what handle means. It is void * . We already talked about how stackless coroutine can be implemented. MSVC uses heap allocated function frame and supports several intrinsics. With the pointer to frame in heap, coroutine_handle adds some operation over it.","title":"Concept"},{"location":"articles/exploring-msvc-coroutine/#resumable-frame","text":"Then, how does the frame look like? As I commented above, the frame of resumable function. It has head and body. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // Head of function frame // - Fn : Instruction address for resume operation // - cdecl : Caller manages the frame. Callee won't touch it. // - Index : Index to resumption point. // 0 is special value for `done()` // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // Coroutine Frame will include... // - Promise // - Captured arguments // - Function body // - Local Variables and Temporaries // - Platform context // - Registers // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : Like its name, _Resumable_frame_prefix is head of coroutine frame. MSVC uses fixed size of sizeof(void *) * 2 (16 bytes in x64) for this struct. Fn : Note that this is declared as cdecl convention. Since cdecl specifies stack cleanup (in the case, frame destruction) is up to caller, the call of Fn won't destroy the frame. Index : Resumable function can have multiple resumption point. This is a index for the point. Flag : ??? Who are you ??? Body : N4402 describes what frame includes. Based on James McNellis's PPT, the compiler-generated frame body will be like the following code. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // Possible frame for fibonacci function struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _p ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. };","title":"Resumable Frame"},{"location":"articles/exploring-msvc-coroutine/#coroutine-traits","text":"We didn't cover p.get_return_object() yet. This is the section for the topic. Let me explain coroutine_traits first... // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; It's pretty simple. coroutine_traits requires promise_type to be implemented at compile time. And it must follow Resumable Promise Requirement . I explaind that resumable function returns future<T> , but that was not correct. If there is a type that fulfills the coroutine_traits , it can be return type of Resumable function. Let't go to template specialization of coroutine_traits for std::future<T> . Previous example, generator<T> implemented promise type in itself, but with the specialization trick, we can reuse some old types or try some custom type. // <future> #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // Template Specialization for `std::future<T>` template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // defines resumable traits for functions returning future<_Ty> struct promise_type { // `std::promise<T>` promise < _Ty > _MyPromise ; // Resumable function can return `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // if `false`, we skip the initial suspend point. bool initial_suspend () const { return ( false ); } // if `false`, we skip the final suspend point. bool final_suspend () const { return ( false ); } // Pass the value through `std::promise<T>` template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // Pass the exception through `std::promise<T>` void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif When MSVC meets co_await / co_yield / co_return , it applies coroutine_traits to enable compile-time check. Let's see the fibonacci example again. It will show what MSVC does. The code might be wrong. I will update it as I find correct mechanism. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { using return_type = generator < int > ; // At this point, compiler will generate code // and check `return_type` fulfills promise requirement. using traits = coroutine_traite < return_type > ; // Requirement : OK. // We can generate unique frame type for this function. // Possible frame for fibonacci function struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // We are forwarding arguments to frame! // Let's call it context(ctx) __frame * ctx = new __frame { std :: move ( n )}; // Generate return objet // In this case, `generator<int>` return_type __return = ctx -> _promise . get_return_object (); // if true, suspend. // if false, keep move... if ( ctx -> _promise . initial_suspend () ){ // always true // suspend... __initial_suspend_point : } // User code : use variables in frame(ctx)... // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // Pass value through promise // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // instructions for suspension with `ctx->_prefix`... // co_await suspend_always{}; __suspend_resume_point_1 : // Calculate next fibo and shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // always true // suspend... __final_suspend_point : } // Instructions for clean up... } So we could find out that compiler do a lot of job instead of us. And using frame pointer ctx is not that different from this pointer for memeber functions. Therefore, the cost for frame-based code will be negligible. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend;","title":"Coroutine Traits"},{"location":"articles/exploring-msvc-coroutine/#section-summary","text":"We covered co_return and co_yield with generator<T> example. Generator was a combination of iterator and resumable function. Resumable functions use coroutine_handle , which is basically raw pointer to function frame and some operations that rely on compiler intrinsics. The mechanism for frame-based approach was pretty similar to this pointer approach. For compile-time(static) assertion, coroutine_traits<T> is used. It enforce the return type to support promise_type that fulfills resumable promise requirement. And there was a specialization especially for std::future<T> .","title":"Section Summary"},{"location":"articles/exploring-msvc-coroutine/#the-awaitable-concept","text":"operator co_await = Syntactic Sugar + Resumable Function The last core of resumable function is co_await . It is unary operator. In this semantics, await is synonym of suspend . And because of suspension, its return value becomes asynchronous . This is the important point for our mental model. You may thought async & await of C# language, The difference in C++ world is that we can manage them manually , with our code and compiler support.","title":"The Awaitable Concept"},{"location":"articles/exploring-msvc-coroutine/#example_2","text":"The code is sample from MSVC blog. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // operator overload. // co_await can't use primitive type parameter. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // Awaitable must implements 3 function. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback Thread will resume the function coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // If not ready (`false`), invoke `await_suspend` // If ready (`true`), go to `await_resume` directly. bool await_ready () const { return duration . count () <= 0 ; } // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // Set the timer and then suspend... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Return T type's value after resumed. // T can be `void`. void await_resume () {} }; return awaiter { duration }; } // Resumable Function future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // await for 1 millisecond... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // This is normal subroutine void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } It's flow is like the figure.","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#awaitable-interface","text":"co_await requires some interface for its operation. As we can see in code above, Awaitable interface should implement at least 3 functions. await_ready await_suspend await_resume It can be both member and normal function. future<T> also implements this interface. so future can be an argument for co_await . But just like the code await_suspend , it can be inefficient. For user-defined type, simple overload is enough. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std How about compiler's view? How does it change our code?","title":"Awaitable Interface"},{"location":"articles/exploring-msvc-coroutine/#compilers-view_1","text":"operator co_await = Syntactic Sugar + Resumable Function I explained that co_await is syntatic sugar. If operator's argument type implements awaitable concept appropriately, the code will be modified by compiler. Revisiting previous example, test function which awaits for 1 millisecond, let's see how it works... // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // With `co_await` keyword in function body, // compiler will make this function to resumable. future < void > test () { // Compiler-generated coroutine frame... __frame * context ; // ... // Awaitable type implements awaitable interface. // Precisely, this will be temporary variable in frame. awaiter aw = operator co_await ( 1 ms ); // Do we have expected value now? // If not, suspend. // If ready, skip the suspend and resume directly. if ( aw . await_ready () == false ) // await_ready(aw); { // Wrap the function frame to `coroutine_handle` type coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); aw . await_suspend ( resume_cb ); // some instructions.... __suspend_resume_point_1 : // Since resume point is in this scope, // there won't be suspension if ready()==true. } // If await_resume has return type... // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } So there are some points for each of interface functions. await_ready : \"Do we have return value now?\" await_ready makes the branch. It asks value for await_resume is ready. If not, the control flows into the scope of if statement. If it's ready, await_ready returns true and await_resume will be invoked directly. Compiler can optimize the code if it returns false always. In the case, we don't need suspension and therefore frame wrapping becomes unnecessary. The coroutine will become normal subroutine after optimization steps. In suspension scope, we must ready for suspension. Since coroutine_handle<> is just a raw pointer to frame, we can wrap it easily with static function coroutine_handle<>::from_address . await_suspend : \"The routine will suspend soon. Do what you have to do!\" await_suspend receives coroutine_handle<> for its argument. With this function, we can interleave our code for suspension handling. // The example code set the Windows Thread Pool Timer // and forward frame's address as callback argument. class awaiter { // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // Unwrap the handle resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // A thread in Windows Thread Pool will invoke this callback. // And it will be resumer for the function. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Wrap the frame to handle again. And resume. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"Now, here is the return value and control flow\" Suspend/resume point is created for resume operation. When the coroutine handle's .resume() is invoked, the function will set the context(frame pointer) and jump to it. The flow then exits the scope and call await_resume . Notice that we did suspend because the value wasn't ready( await_ready ). When the function is resumed, there should be return value. If await_resume 's return type is void, it means control flow is back.","title":"Compiler's View"},{"location":"articles/exploring-msvc-coroutine/#co_await-tricks","text":"Kenny Kerr and James Mcnellis introduced several tricks with this mechanism. I strongly recommend you to watch the video. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"co_await Tricks"},{"location":"articles/exploring-msvc-coroutine/#async-generator","text":"","title":"Async Generator"},{"location":"articles/exploring-msvc-coroutine/#concept_2","text":"Async Generator = Awaitable iterator + Resumable function This is similar to Generator's concept, but it has awaitable iterator . In other words, we can use for co_await statement for it. Kirkshoop will give you clear explanation for this.","title":"Concept"},{"location":"articles/exploring-msvc-coroutine/#example_3","text":"I won't write hard example since I hadn't try this feature. But previous examples and explanations will help your understanding. // Infinite sequence of interger. async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await statement for co_await ( int v : infinite ()) { // do something with `v`... } } I sad iterator is awaitable. So real code of usecase will be like following. std :: future < void > usecase () { // generator with awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `co_await` + `begin()` iter != gen . end (); // `end()` has nullptr co_await ++ iter ) // `co_await` + `operator++()` { int v = * iter ; // ... } } The only difference form generator<T> example is that the function is awaiting iterator at 2 points. begin() and operator++() . These are points for resume operation. Here, value type is primitive type int . So there won't be complex code here. The following code shows how to make awaitable iterator. The other code for generator body and promise_type is exactly same with std::experimental::generator<T> // Actually, generator is not async. Its iterator is async(awaitable). template < typename T > struct async_generator { struct promise_type ; // Same with experimental generator // We will implement awaitable interface... struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // Since this is syntactic example, there is no suspension. bool await_ready () const { return true ; } // With no suspension, there is nothing to do with handle. void await_suspend ( coroutine_handle <> hcoro ) {} // Return awaitable iterator at resume point iterator await_resume () const { return * this ; } }; // iterator }; // async_generator By adding 3 member functions for iterator , we could make it awaitable and became available to use for co_await statement. But as I mentioned at Awaitable Interface section, you don't have to add member function. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } Adding these helper functions for old types will work fine.","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#conclusion","text":"So, we have traveled MSVC coroutine from concept to code. That's all. I wish I made helpful description. I'd like to add disassembly experience about this feature, but I can't make it because I'm a beginner for that ability. I will try that topic later. I couldn't make this article in more detail. Maybe there could be a chance to update this...! :D","title":"Conclusion"},{"location":"articles/russian-roulette-kor/","text":"Russian Roulette and C++ Coroutines \u00b6 English \uc774\ubc88\uc5d0\ub294 \uc5ec\ub7ec \ucf54\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc5d0 \uc9d1\uc911\ud558\uace0 \uc774\ub4e4\uc758 \uc9c4\ud589\uc744 \ud558\ub098\uc758 \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uc218\ud589\ud558\ub294 \ucf54\ub4dc\ub97c \ud558\ub098 \uc791\uc131\ud574\ubcf4\uace0\uc790 \ud569\ub2c8\ub2e4. \uc608\uc2dc\ub85c\ub294 \uad49\uc7a5\ud788 \uc720\uba85\ud55c \uaddc\uce59\uc744 \uac00\uc9c4 \ub7ec\uc2dc\uc548 \ub8f0\ub81b\uacfc \uadf8 \uac8c\uc784\uc758 \ucc38\uac00\uc790\ub4e4\uc744 \uc0ac\uc6a9\ud574 \ubd24\uc2b5\ub2c8\ub2e4. \ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 1: \uc57d\uc2e4/\ubc29\uc544\uc1e0 \u00b6 \uc6b0\uc120 \ub9ac\ubcfc\ubc84\ub97c \ub9cc\ub4dc\ub294 \uac83\ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \ucc38\uac00 \uc778\uc6d0\uc774 \uc5bc\ub9c8\ub098 \uc788\uc744\uc9c0 \ubaa8\ub974\uae30 \ub54c\ubb38\uc5d0, uint32_t \ub97c \uc0ac\uc6a9\ud574 \ucda9\ubd84\ud788 \ub9ce\uc740 \uc57d\uc2e4(chamber)\uc744 \uc900\ube44\ud560 \uac81\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \uc784\uc758\uc758 \uc57d\uc2e4\uc744 \uc120\ud0dd\ud558\ub294 select_chamber \ub97c \uc544\ub798\uc640 \uac19\uc774 \uc815\uc758\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } \uacbd\uc6b0\uc5d0 \ub530\ub77c\uc11c\ub294 \uc778\uc790\ub97c \ubc1b\uc544 \uc0c1\ud669\uc5d0 \ub530\ub77c \uc57d\uc2e4\uc744 \uc120\ud0dd\ud560\uc9c0 \ubaa8\ub974\uc9c0\ub9cc, \uc774 \uc608\uc2dc\uc5d0\uc11c\ub294 \uac00\uc7a5 \ub2e8\uc21c\ud55c \ubc29\ubc95(\ubb34\uc791\uc704)\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc57d\uc2e4\uc774 \uc788\uc73c\ub2c8 \uc774\uc81c \ubc29\uc544\uc1e0(trigger)\ub97c \uc900\ube44\ud574\uc57c\uaca0\uad70\uc694. \ubc29\uc544\uc1e0\ub294 \ub2f9\uae38( pull ) \uc218 \uc788\uc73c\uba70, \ud604\uc7ac \uacf5\uc774\uac00 \ub9de\ubb3c\ub9b0 \uc57d\uc2e4( current )\uacfc \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud574\uc11c \uc54c\uace0 \uc788\uc2b5\ub2c8\ub2e4. \ud55c\ubc88 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uba74 \uc57d\uc2e4\uc774 \ud68c\uc804\ud560\ud14c\ub2c8, \uc5ec\uae30\uc11c\ub294 \uac04\ub2e8\ud788 chamber_t \uc758 \uac12\uc744 1 \uac10\uc18c \uc2dc\ud0a4\ub294 \uac83\uc73c\ub85c \uc57d\uc2e4\uc744 \ud68c\uc804\uc2dc\ud0a4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... }; \ucc38\uac00\uc790 \ud589\ub3d9 \uc815\uc758\ud558\uae30 \u00b6 \uc5ec\uae30\uc11c \ubc29\uc544\uc1e0\ub294 Awaitable \ud0c0\uc785\uc73c\ub85c \uc815\uc758\ud574\uc11c, \uac8c\uc784 \ucc38\uac00\uc790\ub4e4\uc774 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae34 \ud6c4 \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\ub3c4\ub85d \ub9cc\ub4e4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; \uc774\ub807\uac8c \uc815\uc758\ud55c \uc774\uc720\ub294 \ucc38\uac00\uc790(player)\ub4e4\uc774 3\uac00\uc9c0 \uc0c1\ud0dc\ub97c \uac00\uc9c0\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4. \ubc29\uc544\uc1e0\ub97c \ub2f9\uacbc\uc9c0\ub9cc, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc9c0 \uc54a\uc558\ub2e4 (\uc0b4\uc558\ub2e4!) \ubc29\uc544\uc1e0\ub97c \ub2f9\uaca8\uc11c, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc5c8\ub2e4 (X\ub97c \ub20c\ub7ec \uc870\uc758\ub97c \ud45c\ud558\uc2ed\uc2dc\uc624.) \ucc28\ub840\ub97c \uae30\ub2e4\ub9ac\ub358 \uc911 \ub2e4\ub978 \uc0ac\ub78c\uc774 \uc774\ubbf8 \ucd1d\uc54c\uc744 \ubc1b\uc558\ub2e4 \ucf54\ub4dc\ub85c \ud45c\ud604\ud558\uc790\uba74 \uc544\ub798\uc640 \uac19\uc2b5\ub2c8\ub2e4. index \ub97c \uc0ac\uc6a9\ud574 \uac01 player \ub4e4\uc744 \uad6c\ubd84\ud558\uace0, \ucf54\ub8e8\ud2f4 \uc678\ubd80\uc5d0 \uc704\uce58\ud55c fired (\ubd88\uc774\uc57c!)\uc758 \uac12\uc744 \ubcc0\uacbd\ud558\ub294 \ubc29\ubc95\uc73c\ub85c \ucd1d\uc54c\uc774 \ubc1c\uc0ac\ub418\uc5c8\uc744 \ub54c \ub2e4\ub978 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \uc774\ub97c \ud655\uc778\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. \ubaa8\ub450\uac00 \uac19\uc740 \ub9ac\ubcfc\ubc84\uc758 \ubc29\uc544\uc1e0\ub97c \uc0ac\uc6a9\ud558\ubbc0\ub85c, trigger \ub294 \ucc38\uc870\ub97c \uc0ac\uc6a9\ud558\uc600\uc2b5\ub2c8\ub2e4. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } \uc774\ub807\uac8c \ud558\uba74 \uc2e4\uc81c\ub85c\ub294 \ubaa8\ub4e0 \ucc38\uac00\uc790 \ucf54\ub8e8\ud2f4\ub4e4\uc740 \ubc29\uc544\uc1e0\ub97c \ubbf8\ub9ac \ub2f9\uaca8\ub193\uace0 \uae30\ub2e4\ub9ac\uac8c(suspend) \ub429\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \ubc29\uc544\uc1e0\ub97c \ud55c\ubc88\uc529 \ub2f9\uae30\uba74\uc11c \ucc28\ub840\ub300\ub85c \uae68\uc6cc\ubcf4\ub294(resume) \uac83\uc774\uc8e0. \ucc28\ub840\uac00 \ub418\uba74(resumed) trigger_t \uc740 await_resume \uc758 \ubc18\ud658\uac12\uc744 \ud1b5\ud574 \uacb0\uacfc( fired )\ub97c \uc804\ub2ec\ud560 \uac83\uc774\uace0 \uadf8 \uac12\uc5d0 \ub530\ub77c\uc11c player \uc758 \ub3d9\uc791\uc774 \ub2ec\ub77c\uc9c0\uac8c \ub429\ub2c8\ub2e4. \ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 2 \u00b6 \uc774\uc81c \ub9ac\ubcfc\ubc84\ub97c \ub9c8\uc800 \uc644\uc131\ud558\uace0, user_behavior_t \uc5d0 \ub300\ud574 \uc124\uba85\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc774\ubbf8 \uc704\uc5d0\uc11c trigger_t \ub97c \uc815\uc758 \ud588\uc73c\ubbc0\ub85c, revolver_t \ub294 1\uac1c\uc758 \ubc29\uc544\uc1e0\uc640 \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud55c \uc815\ubcf4\ub97c \uac00\uc9c0\uace0 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; \ubb3c\ub860 \ub204\uad70\uac00\ub294 \ub2f9\ucca8 \ub418\uc5b4\uc57c \ud558\uae30 \ub54c\ubb38\uc5d0, \ubaa8\ub4c8\ub85c \uc5f0\uc0b0\uc744 \ud558\ub294 \uac83\ub3c4 \uc78a\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4. \uac8c\uc784 \uc9c4\ud589\uacfc\uc815 \u00b6 \uc774\uc81c \ucc38\uac00\uc790\uc640 \ub3c4\uad6c(\ub9ac\ubcfc\ubc84)\uac00 \ubaa8\ub450 \uc815\uc758\ub418\uc5c8\uc73c\ub2c8, \uac8c\uc784 \uc9c4\ud589\uacfc\uc815\uc744 \ud45c\ud604\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \uc774 \uac8c\uc784\uc5d0\uc11c\ub294 \ucd1d 6\uba85\uc758 \ucc38\uac00\uc790\uac00 \uc788\ub2e4\uace0 \uac00\uc815\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } \ucc38\uac00\uc790\uc640 \ub3c4\uad6c\uac00 \uc900\ube44\ub418\uba74, russian_roulette \uc744 \ud638\ucd9c\ud558\uc5ec \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. GSL(C++ \ud575\uc2ec \uac00\uc774\ub4dc\ub77c\uc778 \uc9c0\uc6d0 \ub77c\uc774\ube0c\ub7ec\ub9ac)\uc5d0 \uc775\uc219\ud558\uc9c0 \uc54a\uc73c\uc2dc\ub354\ub77c\ub3c4 \uc77d\ub294\ub370 \ubb38\uc81c\ub294 \uc5c6\uc744 \uac83\uc785\ub2c8\ub2e4. \ubaa8\ub974\ub294 \ubd84\ub4e4\uc744 \uc704\ud574 \uc124\uba85\ud558\uc790\uba74, gsl::span \uc740 \ubc94\uc704\ub97c \ud45c\ud604\ud558\uc5ec range- for \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\uace0, gsl::finally \ub294 \uac1c\uccb4\uac00 \uc18c\uba78\ud558\ub294 \uc2dc\uc810\uc5d0 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uae30\ub2a5\uc744 \ud569\ub2c8\ub2e4. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } \ubaa8\ub4e0 player \ub4e4\uc774 fired \uc640 revolver \ub97c \uacf5\uc720\ud558\uba70 \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. \uc774\ub4e4\uc758 \ud589\ub3d9\uc740 \ucf54\ub8e8\ud2f4\uc73c\ub85c \uc815\uc758\ud558\uc600\uc2b5\ub2c8\ub2e4. \ucc38\uac00\uc790\ub4e4\uc758 \uc218\uc640 \ubb34\uad00\ud558\uac8c, russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc740 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uac00 \ub418\uc5b4 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \ucc28\ub840\ub300\ub85c \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uac8c \ub9cc\ub4e4\uac83\uc785\ub2c8\ub2e4. \uc774\ub294 task.resume() \uc744 \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9d1\ub2c8\ub2e4. \uac8c\uc784\uc740 fired \uac00 true \uac00 \ub420 \ub54c\uae4c\uc9c0 \uacc4\uc18d\ub429\ub2c8\ub2e4. \uac8c\uc784\uc774 \ub05d\ub098\uba74 on_finish \uac1c\uccb4\uac00 \ubaa8\ub4e0 \ucc38\uac00\uc790\ub4e4\uc774 \uc0ac\uc6a9\ud55c \uba54\ubaa8\ub9ac(\ucf54\ub8e8\ud2f4 \ud504\ub808\uc784)\ub97c \ud68c\uc218\ud560 \uac83\uc785\ub2c8\ub2e4. \uac04\ub2e8\ud788 frame.destroy() \ud558\ub294 \uac83\uc73c\ub85c \uc774\ub97c \ucc98\ub9ac\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. Player \ucf54\ub8e8\ud2f4\uc744 \uc704\ud55c \ubc18\ud658 \ud0c0\uc785 \u00b6 C++ 20 Coroutines\uc5d0\uc11c \ucf54\ub8e8\ud2f4\uc744 \uc815\uc758\ud558\ub824\uba74, Coroutine Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294 \ubc18\ud658 \ud0c0\uc785\uc744 \uac00\uc838\uc57c \ud569\ub2c8\ub2e4. \uc774 \uc870\uac74\uc5d0 \ub9de\ucdb0\uc11c user_behavior_t \ub97c \uc815\uc758\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. Promise\uc5d0 \ub300\ud55c \uc0c1\uc138\ud55c \uc124\uba85\uc740 Lewiss Baker\uac00 \ub2e4\ub8ec \ubc14 \uc788\uc2b5\ub2c8\ub2e4 . \ud55c\uae00 \uc790\ub8cc\ub294 C++ Korea 5\ud68c \uc138\ubbf8\ub098\uc758 \ubc1c\ud45c\uc790\ub8cc \ub97c \ucc38\uace0\ud574\uc8fc\uc2dc\uae38 \ubc14\ub78d\ub2c8\ub2e4. \uc6b0\uc120 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc744 \uad00\ub9ac\ud558\ub294 user_behavior_t::promise_type \uc744 \uc815\uc758\ud574\uc57c \ud569\ub2c8\ub2e4. \uc5c4\ubc00\ud558\uac8c\ub294 coroutine_traits<user_behavior_t, ...>::promise_type \uc774\uc9c0\ub9cc, \uc5ec\uae30\uc11c\ub294 \uac00\uc7a5 \uac04\ub2e8\ud55c \ubc29\ubc95\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; \uac01 \ud568\uc218\ub4e4\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4. initial_suspend : \ucf54\ub8e8\ud2f4\uc774 \ud638\ucd9c(invoke)\ub418\uc5b4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc774 \uc0dd\uc131\ub41c \uc9c1\ud6c4 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 final_suspend : \ucf54\ub8e8\ud2f4\uc774 \ubc18\ud658( co_return )\ub41c \uc774\ud6c4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 unhandled_exception : \ucf54\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ucc98\ub9ac\ub418\uc9c0 \ubabb\ud55c Exception\uc774 \ubc1c\uc0dd\ud560\ub54c \ud638\ucd9c suspend_always \ud0c0\uc785 \uac1c\uccb4\ub97c \ubc18\ud658\ud558\ub294 \ud589\uc704\ub294 \ub2e8\uc21c\ud788 \ud604\uc7ac \ucf54\ub8e8\ud2f4\uc744 \uc911\ub2e8\ud558\uaca0\ub2e4\ub294 \uc758\ubbf8\uc785\ub2c8\ub2e4. \ub9cc\uc57d \uc911\ub2e8\ud558\uc9c0 \uc54a\uace0 \ubc14\ub85c \uc9c4\ud589\ud55c\ub2e4\uba74 suspend_never \ub97c \ubc18\ud658\ud558\uba74 \ub429\ub2c8\ub2e4. \uc704\uc5d0\uc11c \uc791\uc131\ud55c \uc608\uc2dc\uc5d0\uc11c player \ucf54\ub8e8\ud2f4\ub4e4\uc758 \uc9c4\ud589(suspend, resume) \uc5ec\ubd80\ub294 \ubaa8\ub450 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uc778 russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uad00\ub9ac\ud558\ubbc0\ub85c \ub450 \uacbd\uc6b0 \ubaa8\ub450 suspend_always \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. Player \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc811\uadfc \u00b6 user_behavior_t::promise_type \ub294 promise_manual_control \ub97c \uc0c1\uc18d\ubc1b\uc73c\uba74\uc11c, 2\uac00\uc9c0 \uba64\ubc84 \ud568\uc218\ub97c \uc815\uc758\ud569\ub2c8\ub2e4. return_void : co_return \uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4 get_return_object : \ucf54\ub8e8\ud2f4\uc758 \ubc18\ud658\ud0c0\uc785\uc744 \uc0dd\uc131\ud560 \uc218 \uc788\ub3c4\ub85d \uc784\uc758\uc758 \uac1c\uccb4\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4. \uc774 \uacbd\uc6b0\ub294 user_behavior_t \ub97c \ubc14\ub85c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; user_behavior_t \ub294 coroutine_handle<void> \ub97c \uc0c1\uc18d \ubc1b\uc544 resume , done , destroy \uc640 \uac19\uc774 \ucf54\ub8e8\ud2f4\uc744 \uc81c\uc5b4\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. \uc774\ub97c \uc704\ud574\uc11c\ub294 promise_type \uc73c\ub85c\ubd80\ud130 coroutine_handle<void> \ub97c \uc5bb\uc744 \ubc29\ubc95\uc774 \ud544\uc694\ud55c\ub370, \uc774\ub294 coroutine_handle<promise_type> \uc744 \uc0ac\uc6a9\ud558\uc5ec \ud574\uacb0\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc81c\uc5b4\ub294 russian_roulette \uc5d0\uc11c \uc9c1\uc811 \uc774\ub8e8\uc5b4\uc9c0\ubbc0\ub85c \uc9c0\uae08\uacfc \uac19\uc740 \ucf54\ub4dc\ub85c\ub3c4 \ubb38\uc81c\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. \ud558\uc9c0\ub9cc coroutine_handle<void> \ub294 \ub9c8\uce58 void* \ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0, \ubd80\uc8fc\uc758\ud55c \uc2e4\uc218\ub97c \uc608\ubc29\ud558\ub824\uba74 \ubcf5\uc0ac/\uc774\ub3d9 \uc0dd\uc131\uc790, \ubcf5\uc0ac/\uc774\ub3d9 \ub300\uc785 \uc5f0\uc0b0\uc790, \uc18c\uba78\uc790\ub97c \ucd94\uac00\ub85c \uc815\uc758\ud574\uc57c \ud560 \uac83\uc785\ub2c8\ub2e4. \uacb0\ub860 \u00b6 All-in-one \ucf54\ub4dc\ub294 Compiler Explorer\uc5d0\uc11c \uc2e4\ud589\ud574\ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4. https://github.com/Naios/continuable \ucc98\ub7fc future<T> \ub97c \ub354 \ud3b8\ub9ac\ud558\uac8c \uc0ac\uc6a9\ud558\uae30 \uc704\ud574 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560\uc218\ub3c4 \uc788\uc9c0\ub9cc, \uc774\ub294 \ud55c\uac00\uc9c0 \ubc29\ubc95\uc77c \ubfd0\uc785\ub2c8\ub2e4. \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc911\ub2e8 \uc9c0\uc810\uc5d0 \ub300\ud55c \uc815\ubcf4(index)\uac00 \uc788\uae30 \ub54c\ubb38\uc5d0 \uad6c\ud604\ub808\ubca8\uc5d0\uc11c\ub294 \uc0c1\ud0dc \ud328\ud134\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ub2e4\ub9cc \ucc28\uc774\uc810\uc774 \uc788\ub2e4\uba74 \uc0c1\ud0dc \ud328\ud134\uc774 \ucd94\uac00\uc801\uc778 \ud0c0\uc785\uc744 \uc791\uc131\ud574\uc57c \ud558\uc9c0\ub9cc, \ucf54\ub8e8\ud2f4\uc5d0\uc11c\ub294 \uc911\ub2e8(suspend)\uacfc \uc7ac\uac1c(resume)\ub97c \uc790\uc5f0\uc2a4\ub7fd\uac8c \uae30\uc220\ud558\ub294\ub370 \uc880 \ub354 \ucd08\uc810\uc744 \ub458 \uc218 \uc788\uc8e0. \uc774\ub294 \uc911\ub2e8\uacfc \uc7ac\uac1c\ud558\ub294 \uacfc\uc815\uc774 \ucf54\ub4dc\uc758 \uad6c\uc870\uc5d0 \uc601\ud5a5\uc744 \uc8fc\ub294 \uc77c\uc774 \uc904\uc5b4\ub4e0\ub2e4\uace0 \uc694\uc57d\ud560 \uc218 \uc788\uaca0\uc2b5\ub2c8\ub2e4.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette-kor/#russian-roulette-and-c-coroutines","text":"English \uc774\ubc88\uc5d0\ub294 \uc5ec\ub7ec \ucf54\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc5d0 \uc9d1\uc911\ud558\uace0 \uc774\ub4e4\uc758 \uc9c4\ud589\uc744 \ud558\ub098\uc758 \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uc218\ud589\ud558\ub294 \ucf54\ub4dc\ub97c \ud558\ub098 \uc791\uc131\ud574\ubcf4\uace0\uc790 \ud569\ub2c8\ub2e4. \uc608\uc2dc\ub85c\ub294 \uad49\uc7a5\ud788 \uc720\uba85\ud55c \uaddc\uce59\uc744 \uac00\uc9c4 \ub7ec\uc2dc\uc548 \ub8f0\ub81b\uacfc \uadf8 \uac8c\uc784\uc758 \ucc38\uac00\uc790\ub4e4\uc744 \uc0ac\uc6a9\ud574 \ubd24\uc2b5\ub2c8\ub2e4.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette-kor/#1","text":"\uc6b0\uc120 \ub9ac\ubcfc\ubc84\ub97c \ub9cc\ub4dc\ub294 \uac83\ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \ucc38\uac00 \uc778\uc6d0\uc774 \uc5bc\ub9c8\ub098 \uc788\uc744\uc9c0 \ubaa8\ub974\uae30 \ub54c\ubb38\uc5d0, uint32_t \ub97c \uc0ac\uc6a9\ud574 \ucda9\ubd84\ud788 \ub9ce\uc740 \uc57d\uc2e4(chamber)\uc744 \uc900\ube44\ud560 \uac81\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \uc784\uc758\uc758 \uc57d\uc2e4\uc744 \uc120\ud0dd\ud558\ub294 select_chamber \ub97c \uc544\ub798\uc640 \uac19\uc774 \uc815\uc758\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } \uacbd\uc6b0\uc5d0 \ub530\ub77c\uc11c\ub294 \uc778\uc790\ub97c \ubc1b\uc544 \uc0c1\ud669\uc5d0 \ub530\ub77c \uc57d\uc2e4\uc744 \uc120\ud0dd\ud560\uc9c0 \ubaa8\ub974\uc9c0\ub9cc, \uc774 \uc608\uc2dc\uc5d0\uc11c\ub294 \uac00\uc7a5 \ub2e8\uc21c\ud55c \ubc29\ubc95(\ubb34\uc791\uc704)\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc57d\uc2e4\uc774 \uc788\uc73c\ub2c8 \uc774\uc81c \ubc29\uc544\uc1e0(trigger)\ub97c \uc900\ube44\ud574\uc57c\uaca0\uad70\uc694. \ubc29\uc544\uc1e0\ub294 \ub2f9\uae38( pull ) \uc218 \uc788\uc73c\uba70, \ud604\uc7ac \uacf5\uc774\uac00 \ub9de\ubb3c\ub9b0 \uc57d\uc2e4( current )\uacfc \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud574\uc11c \uc54c\uace0 \uc788\uc2b5\ub2c8\ub2e4. \ud55c\ubc88 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uba74 \uc57d\uc2e4\uc774 \ud68c\uc804\ud560\ud14c\ub2c8, \uc5ec\uae30\uc11c\ub294 \uac04\ub2e8\ud788 chamber_t \uc758 \uac12\uc744 1 \uac10\uc18c \uc2dc\ud0a4\ub294 \uac83\uc73c\ub85c \uc57d\uc2e4\uc744 \ud68c\uc804\uc2dc\ud0a4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... };","title":"\ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 1: \uc57d\uc2e4/\ubc29\uc544\uc1e0"},{"location":"articles/russian-roulette-kor/#_1","text":"\uc5ec\uae30\uc11c \ubc29\uc544\uc1e0\ub294 Awaitable \ud0c0\uc785\uc73c\ub85c \uc815\uc758\ud574\uc11c, \uac8c\uc784 \ucc38\uac00\uc790\ub4e4\uc774 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae34 \ud6c4 \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\ub3c4\ub85d \ub9cc\ub4e4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; \uc774\ub807\uac8c \uc815\uc758\ud55c \uc774\uc720\ub294 \ucc38\uac00\uc790(player)\ub4e4\uc774 3\uac00\uc9c0 \uc0c1\ud0dc\ub97c \uac00\uc9c0\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4. \ubc29\uc544\uc1e0\ub97c \ub2f9\uacbc\uc9c0\ub9cc, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc9c0 \uc54a\uc558\ub2e4 (\uc0b4\uc558\ub2e4!) \ubc29\uc544\uc1e0\ub97c \ub2f9\uaca8\uc11c, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc5c8\ub2e4 (X\ub97c \ub20c\ub7ec \uc870\uc758\ub97c \ud45c\ud558\uc2ed\uc2dc\uc624.) \ucc28\ub840\ub97c \uae30\ub2e4\ub9ac\ub358 \uc911 \ub2e4\ub978 \uc0ac\ub78c\uc774 \uc774\ubbf8 \ucd1d\uc54c\uc744 \ubc1b\uc558\ub2e4 \ucf54\ub4dc\ub85c \ud45c\ud604\ud558\uc790\uba74 \uc544\ub798\uc640 \uac19\uc2b5\ub2c8\ub2e4. index \ub97c \uc0ac\uc6a9\ud574 \uac01 player \ub4e4\uc744 \uad6c\ubd84\ud558\uace0, \ucf54\ub8e8\ud2f4 \uc678\ubd80\uc5d0 \uc704\uce58\ud55c fired (\ubd88\uc774\uc57c!)\uc758 \uac12\uc744 \ubcc0\uacbd\ud558\ub294 \ubc29\ubc95\uc73c\ub85c \ucd1d\uc54c\uc774 \ubc1c\uc0ac\ub418\uc5c8\uc744 \ub54c \ub2e4\ub978 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \uc774\ub97c \ud655\uc778\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. \ubaa8\ub450\uac00 \uac19\uc740 \ub9ac\ubcfc\ubc84\uc758 \ubc29\uc544\uc1e0\ub97c \uc0ac\uc6a9\ud558\ubbc0\ub85c, trigger \ub294 \ucc38\uc870\ub97c \uc0ac\uc6a9\ud558\uc600\uc2b5\ub2c8\ub2e4. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } \uc774\ub807\uac8c \ud558\uba74 \uc2e4\uc81c\ub85c\ub294 \ubaa8\ub4e0 \ucc38\uac00\uc790 \ucf54\ub8e8\ud2f4\ub4e4\uc740 \ubc29\uc544\uc1e0\ub97c \ubbf8\ub9ac \ub2f9\uaca8\ub193\uace0 \uae30\ub2e4\ub9ac\uac8c(suspend) \ub429\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \ubc29\uc544\uc1e0\ub97c \ud55c\ubc88\uc529 \ub2f9\uae30\uba74\uc11c \ucc28\ub840\ub300\ub85c \uae68\uc6cc\ubcf4\ub294(resume) \uac83\uc774\uc8e0. \ucc28\ub840\uac00 \ub418\uba74(resumed) trigger_t \uc740 await_resume \uc758 \ubc18\ud658\uac12\uc744 \ud1b5\ud574 \uacb0\uacfc( fired )\ub97c \uc804\ub2ec\ud560 \uac83\uc774\uace0 \uadf8 \uac12\uc5d0 \ub530\ub77c\uc11c player \uc758 \ub3d9\uc791\uc774 \ub2ec\ub77c\uc9c0\uac8c \ub429\ub2c8\ub2e4.","title":"\ucc38\uac00\uc790 \ud589\ub3d9 \uc815\uc758\ud558\uae30"},{"location":"articles/russian-roulette-kor/#2","text":"\uc774\uc81c \ub9ac\ubcfc\ubc84\ub97c \ub9c8\uc800 \uc644\uc131\ud558\uace0, user_behavior_t \uc5d0 \ub300\ud574 \uc124\uba85\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc774\ubbf8 \uc704\uc5d0\uc11c trigger_t \ub97c \uc815\uc758 \ud588\uc73c\ubbc0\ub85c, revolver_t \ub294 1\uac1c\uc758 \ubc29\uc544\uc1e0\uc640 \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud55c \uc815\ubcf4\ub97c \uac00\uc9c0\uace0 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; \ubb3c\ub860 \ub204\uad70\uac00\ub294 \ub2f9\ucca8 \ub418\uc5b4\uc57c \ud558\uae30 \ub54c\ubb38\uc5d0, \ubaa8\ub4c8\ub85c \uc5f0\uc0b0\uc744 \ud558\ub294 \uac83\ub3c4 \uc78a\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4.","title":"\ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 2"},{"location":"articles/russian-roulette-kor/#_2","text":"\uc774\uc81c \ucc38\uac00\uc790\uc640 \ub3c4\uad6c(\ub9ac\ubcfc\ubc84)\uac00 \ubaa8\ub450 \uc815\uc758\ub418\uc5c8\uc73c\ub2c8, \uac8c\uc784 \uc9c4\ud589\uacfc\uc815\uc744 \ud45c\ud604\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \uc774 \uac8c\uc784\uc5d0\uc11c\ub294 \ucd1d 6\uba85\uc758 \ucc38\uac00\uc790\uac00 \uc788\ub2e4\uace0 \uac00\uc815\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } \ucc38\uac00\uc790\uc640 \ub3c4\uad6c\uac00 \uc900\ube44\ub418\uba74, russian_roulette \uc744 \ud638\ucd9c\ud558\uc5ec \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. GSL(C++ \ud575\uc2ec \uac00\uc774\ub4dc\ub77c\uc778 \uc9c0\uc6d0 \ub77c\uc774\ube0c\ub7ec\ub9ac)\uc5d0 \uc775\uc219\ud558\uc9c0 \uc54a\uc73c\uc2dc\ub354\ub77c\ub3c4 \uc77d\ub294\ub370 \ubb38\uc81c\ub294 \uc5c6\uc744 \uac83\uc785\ub2c8\ub2e4. \ubaa8\ub974\ub294 \ubd84\ub4e4\uc744 \uc704\ud574 \uc124\uba85\ud558\uc790\uba74, gsl::span \uc740 \ubc94\uc704\ub97c \ud45c\ud604\ud558\uc5ec range- for \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\uace0, gsl::finally \ub294 \uac1c\uccb4\uac00 \uc18c\uba78\ud558\ub294 \uc2dc\uc810\uc5d0 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uae30\ub2a5\uc744 \ud569\ub2c8\ub2e4. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } \ubaa8\ub4e0 player \ub4e4\uc774 fired \uc640 revolver \ub97c \uacf5\uc720\ud558\uba70 \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. \uc774\ub4e4\uc758 \ud589\ub3d9\uc740 \ucf54\ub8e8\ud2f4\uc73c\ub85c \uc815\uc758\ud558\uc600\uc2b5\ub2c8\ub2e4. \ucc38\uac00\uc790\ub4e4\uc758 \uc218\uc640 \ubb34\uad00\ud558\uac8c, russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc740 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uac00 \ub418\uc5b4 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \ucc28\ub840\ub300\ub85c \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uac8c \ub9cc\ub4e4\uac83\uc785\ub2c8\ub2e4. \uc774\ub294 task.resume() \uc744 \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9d1\ub2c8\ub2e4. \uac8c\uc784\uc740 fired \uac00 true \uac00 \ub420 \ub54c\uae4c\uc9c0 \uacc4\uc18d\ub429\ub2c8\ub2e4. \uac8c\uc784\uc774 \ub05d\ub098\uba74 on_finish \uac1c\uccb4\uac00 \ubaa8\ub4e0 \ucc38\uac00\uc790\ub4e4\uc774 \uc0ac\uc6a9\ud55c \uba54\ubaa8\ub9ac(\ucf54\ub8e8\ud2f4 \ud504\ub808\uc784)\ub97c \ud68c\uc218\ud560 \uac83\uc785\ub2c8\ub2e4. \uac04\ub2e8\ud788 frame.destroy() \ud558\ub294 \uac83\uc73c\ub85c \uc774\ub97c \ucc98\ub9ac\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.","title":"\uac8c\uc784 \uc9c4\ud589\uacfc\uc815"},{"location":"articles/russian-roulette-kor/#player","text":"C++ 20 Coroutines\uc5d0\uc11c \ucf54\ub8e8\ud2f4\uc744 \uc815\uc758\ud558\ub824\uba74, Coroutine Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294 \ubc18\ud658 \ud0c0\uc785\uc744 \uac00\uc838\uc57c \ud569\ub2c8\ub2e4. \uc774 \uc870\uac74\uc5d0 \ub9de\ucdb0\uc11c user_behavior_t \ub97c \uc815\uc758\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. Promise\uc5d0 \ub300\ud55c \uc0c1\uc138\ud55c \uc124\uba85\uc740 Lewiss Baker\uac00 \ub2e4\ub8ec \ubc14 \uc788\uc2b5\ub2c8\ub2e4 . \ud55c\uae00 \uc790\ub8cc\ub294 C++ Korea 5\ud68c \uc138\ubbf8\ub098\uc758 \ubc1c\ud45c\uc790\ub8cc \ub97c \ucc38\uace0\ud574\uc8fc\uc2dc\uae38 \ubc14\ub78d\ub2c8\ub2e4. \uc6b0\uc120 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc744 \uad00\ub9ac\ud558\ub294 user_behavior_t::promise_type \uc744 \uc815\uc758\ud574\uc57c \ud569\ub2c8\ub2e4. \uc5c4\ubc00\ud558\uac8c\ub294 coroutine_traits<user_behavior_t, ...>::promise_type \uc774\uc9c0\ub9cc, \uc5ec\uae30\uc11c\ub294 \uac00\uc7a5 \uac04\ub2e8\ud55c \ubc29\ubc95\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; \uac01 \ud568\uc218\ub4e4\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4. initial_suspend : \ucf54\ub8e8\ud2f4\uc774 \ud638\ucd9c(invoke)\ub418\uc5b4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc774 \uc0dd\uc131\ub41c \uc9c1\ud6c4 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 final_suspend : \ucf54\ub8e8\ud2f4\uc774 \ubc18\ud658( co_return )\ub41c \uc774\ud6c4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 unhandled_exception : \ucf54\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ucc98\ub9ac\ub418\uc9c0 \ubabb\ud55c Exception\uc774 \ubc1c\uc0dd\ud560\ub54c \ud638\ucd9c suspend_always \ud0c0\uc785 \uac1c\uccb4\ub97c \ubc18\ud658\ud558\ub294 \ud589\uc704\ub294 \ub2e8\uc21c\ud788 \ud604\uc7ac \ucf54\ub8e8\ud2f4\uc744 \uc911\ub2e8\ud558\uaca0\ub2e4\ub294 \uc758\ubbf8\uc785\ub2c8\ub2e4. \ub9cc\uc57d \uc911\ub2e8\ud558\uc9c0 \uc54a\uace0 \ubc14\ub85c \uc9c4\ud589\ud55c\ub2e4\uba74 suspend_never \ub97c \ubc18\ud658\ud558\uba74 \ub429\ub2c8\ub2e4. \uc704\uc5d0\uc11c \uc791\uc131\ud55c \uc608\uc2dc\uc5d0\uc11c player \ucf54\ub8e8\ud2f4\ub4e4\uc758 \uc9c4\ud589(suspend, resume) \uc5ec\ubd80\ub294 \ubaa8\ub450 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uc778 russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uad00\ub9ac\ud558\ubbc0\ub85c \ub450 \uacbd\uc6b0 \ubaa8\ub450 suspend_always \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4.","title":"Player \ucf54\ub8e8\ud2f4\uc744 \uc704\ud55c \ubc18\ud658 \ud0c0\uc785"},{"location":"articles/russian-roulette-kor/#player_1","text":"user_behavior_t::promise_type \ub294 promise_manual_control \ub97c \uc0c1\uc18d\ubc1b\uc73c\uba74\uc11c, 2\uac00\uc9c0 \uba64\ubc84 \ud568\uc218\ub97c \uc815\uc758\ud569\ub2c8\ub2e4. return_void : co_return \uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4 get_return_object : \ucf54\ub8e8\ud2f4\uc758 \ubc18\ud658\ud0c0\uc785\uc744 \uc0dd\uc131\ud560 \uc218 \uc788\ub3c4\ub85d \uc784\uc758\uc758 \uac1c\uccb4\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4. \uc774 \uacbd\uc6b0\ub294 user_behavior_t \ub97c \ubc14\ub85c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; user_behavior_t \ub294 coroutine_handle<void> \ub97c \uc0c1\uc18d \ubc1b\uc544 resume , done , destroy \uc640 \uac19\uc774 \ucf54\ub8e8\ud2f4\uc744 \uc81c\uc5b4\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. \uc774\ub97c \uc704\ud574\uc11c\ub294 promise_type \uc73c\ub85c\ubd80\ud130 coroutine_handle<void> \ub97c \uc5bb\uc744 \ubc29\ubc95\uc774 \ud544\uc694\ud55c\ub370, \uc774\ub294 coroutine_handle<promise_type> \uc744 \uc0ac\uc6a9\ud558\uc5ec \ud574\uacb0\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc81c\uc5b4\ub294 russian_roulette \uc5d0\uc11c \uc9c1\uc811 \uc774\ub8e8\uc5b4\uc9c0\ubbc0\ub85c \uc9c0\uae08\uacfc \uac19\uc740 \ucf54\ub4dc\ub85c\ub3c4 \ubb38\uc81c\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. \ud558\uc9c0\ub9cc coroutine_handle<void> \ub294 \ub9c8\uce58 void* \ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0, \ubd80\uc8fc\uc758\ud55c \uc2e4\uc218\ub97c \uc608\ubc29\ud558\ub824\uba74 \ubcf5\uc0ac/\uc774\ub3d9 \uc0dd\uc131\uc790, \ubcf5\uc0ac/\uc774\ub3d9 \ub300\uc785 \uc5f0\uc0b0\uc790, \uc18c\uba78\uc790\ub97c \ucd94\uac00\ub85c \uc815\uc758\ud574\uc57c \ud560 \uac83\uc785\ub2c8\ub2e4.","title":"Player \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc811\uadfc"},{"location":"articles/russian-roulette-kor/#_3","text":"All-in-one \ucf54\ub4dc\ub294 Compiler Explorer\uc5d0\uc11c \uc2e4\ud589\ud574\ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4. https://github.com/Naios/continuable \ucc98\ub7fc future<T> \ub97c \ub354 \ud3b8\ub9ac\ud558\uac8c \uc0ac\uc6a9\ud558\uae30 \uc704\ud574 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560\uc218\ub3c4 \uc788\uc9c0\ub9cc, \uc774\ub294 \ud55c\uac00\uc9c0 \ubc29\ubc95\uc77c \ubfd0\uc785\ub2c8\ub2e4. \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc911\ub2e8 \uc9c0\uc810\uc5d0 \ub300\ud55c \uc815\ubcf4(index)\uac00 \uc788\uae30 \ub54c\ubb38\uc5d0 \uad6c\ud604\ub808\ubca8\uc5d0\uc11c\ub294 \uc0c1\ud0dc \ud328\ud134\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ub2e4\ub9cc \ucc28\uc774\uc810\uc774 \uc788\ub2e4\uba74 \uc0c1\ud0dc \ud328\ud134\uc774 \ucd94\uac00\uc801\uc778 \ud0c0\uc785\uc744 \uc791\uc131\ud574\uc57c \ud558\uc9c0\ub9cc, \ucf54\ub8e8\ud2f4\uc5d0\uc11c\ub294 \uc911\ub2e8(suspend)\uacfc \uc7ac\uac1c(resume)\ub97c \uc790\uc5f0\uc2a4\ub7fd\uac8c \uae30\uc220\ud558\ub294\ub370 \uc880 \ub354 \ucd08\uc810\uc744 \ub458 \uc218 \uc788\uc8e0. \uc774\ub294 \uc911\ub2e8\uacfc \uc7ac\uac1c\ud558\ub294 \uacfc\uc815\uc774 \ucf54\ub4dc\uc758 \uad6c\uc870\uc5d0 \uc601\ud5a5\uc744 \uc8fc\ub294 \uc77c\uc774 \uc904\uc5b4\ub4e0\ub2e4\uace0 \uc694\uc57d\ud560 \uc218 \uc788\uaca0\uc2b5\ub2c8\ub2e4.","title":"\uacb0\ub860"},{"location":"articles/russian-roulette/","text":"Russian Roulette and C++ Coroutines \u00b6 \ud55c\uad6d\uc5b4 In this post, I'd like to show an example which separates definition of a behavior and its execution. For the example, the Russian Roulette is used. Following its famous rule, the players' behavior are defined using the coroutine and a game with those players will written be written in an ordinary subroutine. Making a revolver 1: Chamber/Trigger \u00b6 Let's start with makeing a revolver. Since we don't know how many players are going to join, uint32_t will be used to define the value space for the chamber. And we need an additional function, select_chamber , to select one chamber value. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } This is indeed the most simple implementation. It might be more complex for the real case, but let's use it anyway. We need a trigger now. Of course it can be pull ed, and it knows which chamber is loaded and which chamber is going to be fired for the moment( current ). After pull operation, simply decreasing 1 from the chamber_t 's value. Remind that we are going to use a revolver! // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... }; Defining the players' behavior \u00b6 In addition to that, let's make the trigger to an awaitable type. So all players can wait for the bullet after pulling it. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; By doing so, each player will be in one of the 3 state. Pulled the trigger, and not fired. (Alive!) Pulled the trigger, and fired. (Hold X to pay respect) Waiting for its turn, and another player received the bullet. In the 'code' form, it will be like the following. index is for distinguishing each player instance. fired should be non-local since the other player will monitor its value. Also trigger is passed by reference because all players share 1 revolver. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } What a short function! Remind that trigger_t is an awaitable type. So each player will suspend immediately after pulling the trigger. After all players become suspended, then we will resume them one by one. When a player is resumed, it will check the return value of the await_resume and notify the resule( fired ) by storing the result. Of course the player behavior branches with it. Making a revolver 2 \u00b6 Let me explain about the user_behavior_t after finishing the definition of the revolver and the game. 1 revolver owns 1 trigger. The point will be expressed through the implementation inheritance. In addition to that, revolver_t must be aware of the loaded chamber. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; Because someone must win the prize, we didn't forget to apply modular arithmetic. Progress of the game \u00b6 Now it's time to define a execution of the game. I already told you it's an ordinay subroutine. Assume that we have 6 players for 1 game. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } The game, russian_roulette is invoked with the resources. You may not aware of the the GSL(C++ Core G uideline S upport L ibrary), but don't take it so hard. gsl::span is a pair of the pointer and length to support range- for statement, gsl::finally invokes a given funcion object in its destuction phase. Here, by using it we can guarantee clean up of the coroutine frame. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } Like I said all player s share fired variable and revolver instance. Their behavior is defined using the coroutine. russian_roulette subroutine becomes the moderator of the game with the control flow. It's task is to continue this turn-based game by resuming each player coroutine. When they are resumed through task.resume() first time, they will pull the trigger and suspend again. The game continues (by resume) until fired becomes true . When there is a victim, the subroutine will return and on_finish object will destroy all players' coroutine frame. Simply using frame.destroy() will do the work. Return type for the player coroutine \u00b6 In C++ 20 Coroutines, the return type of the coroutine must fulfill the Coroutine Promise Requirement. user_behavior_t is such kind of the type. You can see the Lewiss Baker's post about it The first thing we have to do is to define user_behavior_t::promise_type which manages the coroutine frame. We can use coroutine_traits<user_behavior_t, ...>::promise_type to do the work, but let's go through the easy way :) #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; Each function's role is like the following. initial_suspend : Decide whether to suspend after the coroutine functions is invoked. At this moment the coroutine's frame is allocated. final_suspend : Decide whether to suspend after the coroutine function is returned( co_return ). unhandled_exception : Invoked when an exception is thrown in the coroutine function's body Returning suspend_always type means that the coroutine is willing to suspend for the defined moment. If you don't want to suspend and continue the flow, you should return suspend_never . For this example, player coroutine's creation, progress(suspend/resume), destruction is fully managed by the subroutine russian_roulette . So we will return suspend_always type and forget about the other concerns. Exposing the player coroutine's frame \u00b6 user_behavior_t::promise_type inherits promise_manual_control and add 2 funtion to meet the requirement. return_void : invoked just after co_return get_return_object : the function's return becomes the return type of the coroutine function. Here, we will return user_behavior_t directly. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; The inheritance is public . So it exposes those member functions which controls the coroutine. ( resume , done , and destroy ) After its base class construction, coroutine_handle<void> is in the empty state. Here, I used the simplest way to translate promise_type to its matching coroutine_handle<void> . You can see that from_promise of the coroutine_handle<promise_type> is doing the work. Unless we trust the execution manager, russian_roulette , such exposure won't matter. Remind that coroutine_handle<void> follows the semantics of void* . So if you want to prevent some mistakes for future extenstion, you had better define or delete copy/move functions and its destructor. Conclusion \u00b6 You can run the all-in-one code with the Compiler Explorer. Like https://github.com/Naios/continuable, C++ Coroutines can be used like a sugar for the future<T> . But that's the not only usage. Since the coroutine frame contains an index to distinguish its suspension points, we can't tell it is totaly different from the state pattern. We need to define awaitable type and the return types for our logic, but by doing so the point of suspension and continuation can be written more naturally. For my perspective this gives more resilience to the code.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette/#russian-roulette-and-c-coroutines","text":"\ud55c\uad6d\uc5b4 In this post, I'd like to show an example which separates definition of a behavior and its execution. For the example, the Russian Roulette is used. Following its famous rule, the players' behavior are defined using the coroutine and a game with those players will written be written in an ordinary subroutine.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette/#making-a-revolver-1-chambertrigger","text":"Let's start with makeing a revolver. Since we don't know how many players are going to join, uint32_t will be used to define the value space for the chamber. And we need an additional function, select_chamber , to select one chamber value. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } This is indeed the most simple implementation. It might be more complex for the real case, but let's use it anyway. We need a trigger now. Of course it can be pull ed, and it knows which chamber is loaded and which chamber is going to be fired for the moment( current ). After pull operation, simply decreasing 1 from the chamber_t 's value. Remind that we are going to use a revolver! // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... };","title":"Making a revolver 1: Chamber/Trigger"},{"location":"articles/russian-roulette/#defining-the-players-behavior","text":"In addition to that, let's make the trigger to an awaitable type. So all players can wait for the bullet after pulling it. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; By doing so, each player will be in one of the 3 state. Pulled the trigger, and not fired. (Alive!) Pulled the trigger, and fired. (Hold X to pay respect) Waiting for its turn, and another player received the bullet. In the 'code' form, it will be like the following. index is for distinguishing each player instance. fired should be non-local since the other player will monitor its value. Also trigger is passed by reference because all players share 1 revolver. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } What a short function! Remind that trigger_t is an awaitable type. So each player will suspend immediately after pulling the trigger. After all players become suspended, then we will resume them one by one. When a player is resumed, it will check the return value of the await_resume and notify the resule( fired ) by storing the result. Of course the player behavior branches with it.","title":"Defining the players' behavior"},{"location":"articles/russian-roulette/#making-a-revolver-2","text":"Let me explain about the user_behavior_t after finishing the definition of the revolver and the game. 1 revolver owns 1 trigger. The point will be expressed through the implementation inheritance. In addition to that, revolver_t must be aware of the loaded chamber. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; Because someone must win the prize, we didn't forget to apply modular arithmetic.","title":"Making a revolver 2"},{"location":"articles/russian-roulette/#progress-of-the-game","text":"Now it's time to define a execution of the game. I already told you it's an ordinay subroutine. Assume that we have 6 players for 1 game. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } The game, russian_roulette is invoked with the resources. You may not aware of the the GSL(C++ Core G uideline S upport L ibrary), but don't take it so hard. gsl::span is a pair of the pointer and length to support range- for statement, gsl::finally invokes a given funcion object in its destuction phase. Here, by using it we can guarantee clean up of the coroutine frame. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } Like I said all player s share fired variable and revolver instance. Their behavior is defined using the coroutine. russian_roulette subroutine becomes the moderator of the game with the control flow. It's task is to continue this turn-based game by resuming each player coroutine. When they are resumed through task.resume() first time, they will pull the trigger and suspend again. The game continues (by resume) until fired becomes true . When there is a victim, the subroutine will return and on_finish object will destroy all players' coroutine frame. Simply using frame.destroy() will do the work.","title":"Progress of the game"},{"location":"articles/russian-roulette/#return-type-for-the-player-coroutine","text":"In C++ 20 Coroutines, the return type of the coroutine must fulfill the Coroutine Promise Requirement. user_behavior_t is such kind of the type. You can see the Lewiss Baker's post about it The first thing we have to do is to define user_behavior_t::promise_type which manages the coroutine frame. We can use coroutine_traits<user_behavior_t, ...>::promise_type to do the work, but let's go through the easy way :) #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; Each function's role is like the following. initial_suspend : Decide whether to suspend after the coroutine functions is invoked. At this moment the coroutine's frame is allocated. final_suspend : Decide whether to suspend after the coroutine function is returned( co_return ). unhandled_exception : Invoked when an exception is thrown in the coroutine function's body Returning suspend_always type means that the coroutine is willing to suspend for the defined moment. If you don't want to suspend and continue the flow, you should return suspend_never . For this example, player coroutine's creation, progress(suspend/resume), destruction is fully managed by the subroutine russian_roulette . So we will return suspend_always type and forget about the other concerns.","title":"Return type for the player coroutine"},{"location":"articles/russian-roulette/#exposing-the-player-coroutines-frame","text":"user_behavior_t::promise_type inherits promise_manual_control and add 2 funtion to meet the requirement. return_void : invoked just after co_return get_return_object : the function's return becomes the return type of the coroutine function. Here, we will return user_behavior_t directly. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; The inheritance is public . So it exposes those member functions which controls the coroutine. ( resume , done , and destroy ) After its base class construction, coroutine_handle<void> is in the empty state. Here, I used the simplest way to translate promise_type to its matching coroutine_handle<void> . You can see that from_promise of the coroutine_handle<promise_type> is doing the work. Unless we trust the execution manager, russian_roulette , such exposure won't matter. Remind that coroutine_handle<void> follows the semantics of void* . So if you want to prevent some mistakes for future extenstion, you had better define or delete copy/move functions and its destructor.","title":"Exposing the player coroutine's frame"},{"location":"articles/russian-roulette/#conclusion","text":"You can run the all-in-one code with the Compiler Explorer. Like https://github.com/Naios/continuable, C++ Coroutines can be used like a sugar for the future<T> . But that's the not only usage. Since the coroutine frame contains an index to distinguish its suspension points, we can't tell it is totaly different from the state pattern. We need to define awaitable type and the return types for our logic, but by doing so the point of suspension and continuation can be written more naturally. For my perspective this gives more resilience to the code.","title":"Conclusion"},{"location":"articles/windll-linking-issues/","text":"Work In Progress ... :o","title":"Windll linking issues"},{"location":"features/channel-overview/","text":"Overview: Coroutine based channel \u00b6 This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutines libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible. See Also \u00b6 Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way. Example \u00b6 test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp Channel with a Lockable \u00b6 When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader . Template Parameters \u00b6 T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type Default Operations \u00b6 As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception. Member Variables \u00b6 Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; Functions \u00b6 Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Overview: Coroutine based channel"},{"location":"features/channel-overview/#overview-coroutine-based-channel","text":"This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutines libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible.","title":"Overview: Coroutine based channel"},{"location":"features/channel-overview/#see-also","text":"Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way.","title":"See Also"},{"location":"features/channel-overview/#example","text":"test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp","title":"Example"},{"location":"features/channel-overview/#channel-with-a-lockable","text":"When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader .","title":"Channel with a Lockable"},{"location":"features/channel-overview/#template-parameters","text":"T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type","title":"Template Parameters"},{"location":"features/channel-overview/#default-operations","text":"As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception.","title":"Default Operations"},{"location":"features/channel-overview/#member-variables","text":"Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Member Variables"},{"location":"features/channel-overview/#functions","text":"Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Functions"},{"location":"features/channel-read_write/","text":"Current version uses helper types to use channel in a designed manner. The types implements awaitable interface that is required by co_await operator. namespace coro { template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro See Also \u00b6 Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" Example \u00b6 test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp Awaitable Channel Read \u00b6 Short Example \u00b6 using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Type: reader<T, M> \u00b6 The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed). Awaitable Channel Write \u00b6 Short Example \u00b6 using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Type: writer<T, M> \u00b6 The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"Channel read write"},{"location":"features/channel-read_write/#see-also","text":"Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\"","title":"See Also"},{"location":"features/channel-read_write/#example","text":"test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp","title":"Example"},{"location":"features/channel-read_write/#awaitable-channel-read","text":"","title":"Awaitable Channel Read"},{"location":"features/channel-read_write/#short-example","text":"using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"features/channel-read_write/#type-readerltt-mgt","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed).","title":"Type: reader&lt;T, M&gt;"},{"location":"features/channel-read_write/#awaitable-channel-write","text":"","title":"Awaitable Channel Write"},{"location":"features/channel-read_write/#short-example_1","text":"using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"features/channel-read_write/#type-writerltt-mgt","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"Type: writer&lt;T, M&gt;"},{"location":"features/channel-select/","text":"Current version uses helper types to use channel in a designed manner. namespace coro { template < typename T , typename M > class channel ; template < typename T , typename M > class peeker ; } // namespace coro See Also \u00b6 Channel Concept Channel Read/Write Example \u00b6 test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp Channel Non-blocking Select \u00b6 Short Example \u00b6 using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); } Selecting a pair from arguments \u00b6 To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro Channel Peek Operation \u00b6 peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"Channel select"},{"location":"features/channel-select/#see-also","text":"Channel Concept Channel Read/Write","title":"See Also"},{"location":"features/channel-select/#example","text":"test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp","title":"Example"},{"location":"features/channel-select/#channel-non-blocking-select","text":"","title":"Channel Non-blocking Select"},{"location":"features/channel-select/#short-example","text":"using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); }","title":"Short Example"},{"location":"features/channel-select/#selecting-a-pair-from-arguments","text":"To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro","title":"Selecting a pair from arguments"},{"location":"features/channel-select/#channel-peek-operation","text":"peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"Channel Peek Operation"},{"location":"features/concrt-latch/","text":"See Also \u00b6 Go Language: sync.WaitGroup C++ Concurrency TS: Latch latch \u00b6 The type is used for synchronization in fork-join scenario. It will be removed when it C++ Concurrency TS becomes available. Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of the concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt Definition (Windows) \u00b6 The implementation uses Win32 Event object and a counter using <atomic> . The win32_event here doesn't support co_await expression. namespace concrt { class latch { atomic_uint64_t ref {}; mutable win32_event ev {}; // ... }; } // namespace concrt Definiton (POSIX) \u00b6 The implementation uses pthread_cond_t and pthread_mutex_t . It checks spurious wake-up so it can wait without timeout like the concurrency TS. namespace concrt { class latch { atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; // ... }; } // namespace concrt Example \u00b6 Wait for multiple times Throws exception when counter becomes negative test/channel_race_no_leak.cpp test/net_echo_tcp.cpp","title":"Concrt latch"},{"location":"features/concrt-latch/#see-also","text":"Go Language: sync.WaitGroup C++ Concurrency TS: Latch","title":"See Also"},{"location":"features/concrt-latch/#latch","text":"The type is used for synchronization in fork-join scenario. It will be removed when it C++ Concurrency TS becomes available. Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of the concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt","title":"latch"},{"location":"features/concrt-latch/#definition-windows","text":"The implementation uses Win32 Event object and a counter using <atomic> . The win32_event here doesn't support co_await expression. namespace concrt { class latch { atomic_uint64_t ref {}; mutable win32_event ev {}; // ... }; } // namespace concrt","title":"Definition (Windows)"},{"location":"features/concrt-latch/#definiton-posix","text":"The implementation uses pthread_cond_t and pthread_mutex_t . It checks spurious wake-up so it can wait without timeout like the concurrency TS. namespace concrt { class latch { atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; // ... }; } // namespace concrt","title":"Definiton (POSIX)"},{"location":"features/concrt-latch/#example","text":"Wait for multiple times Throws exception when counter becomes negative test/channel_race_no_leak.cpp test/net_echo_tcp.cpp","title":"Example"},{"location":"features/concrt-overview/","text":"#include <coroutine/concrt.h> using namespace concrt ; References \u00b6 C++ Reference: Extensions for concurrency Background \u00b6 When I requested for the explanation about the coroutine concept, I mostly start with notifing that the coroutine is irrelevent with the thread (see page 6) . What I explain is, in short: The coroutine is about the routine's design The thread is about the processor abstraction (CPU in general) Therefore, all program with the coroutine must be able to run on (only) 1 thread. Just notice that using a thread is an issue of the implementation, and using a C++ 20 coroutine is an issue of the design. Indeed you can use both together and they can work in harmony. What I want you to know here is that they have a different domain. Contents \u00b6 #include <coroutine/concrt.h> using namespace concrt ; There are 2 family. For Windows and for non-Windows. Shared \u00b6 section latch Windows \u00b6 ptp_work ptp_event Linux + Darwin (POSIX + System API) \u00b6 event and signaled_event_tasks TBA: implementation note for the Darwin","title":"Concrt overview"},{"location":"features/concrt-overview/#references","text":"C++ Reference: Extensions for concurrency","title":"References"},{"location":"features/concrt-overview/#background","text":"When I requested for the explanation about the coroutine concept, I mostly start with notifing that the coroutine is irrelevent with the thread (see page 6) . What I explain is, in short: The coroutine is about the routine's design The thread is about the processor abstraction (CPU in general) Therefore, all program with the coroutine must be able to run on (only) 1 thread. Just notice that using a thread is an issue of the implementation, and using a C++ 20 coroutine is an issue of the design. Indeed you can use both together and they can work in harmony. What I want you to know here is that they have a different domain.","title":"Background"},{"location":"features/concrt-overview/#contents","text":"#include <coroutine/concrt.h> using namespace concrt ; There are 2 family. For Windows and for non-Windows.","title":"Contents"},{"location":"features/concrt-overview/#shared","text":"section latch","title":"Shared"},{"location":"features/concrt-overview/#windows","text":"ptp_work ptp_event","title":"Windows"},{"location":"features/concrt-overview/#linux-darwin-posix-system-api","text":"event and signaled_event_tasks TBA: implementation note for the Darwin","title":"Linux + Darwin (POSIX + System API)"},{"location":"features/concrt-posix_event/","text":"","title":"Concrt posix event"},{"location":"features/concrt-ptp_event/","text":"Win32 Event Object + Coroutine \u00b6 See Also \u00b6 MSDN: Using Event Objects ptp_event \u00b6 Awaitable event with the Windows Thread Pool API. Allows mutliple usage with 1 instance. But only 1 co_await is possible each time. Example \u00b6 Wait until signal Cancel #include <coroutine/concrt.h> #include <coroutine/return.h> using namespace concrt ; using namespace coro ; auto wait_an_event ( ptp_event & wo , atomic_flag & flag ) -> no_return { // wait for set or cancel // `co_await` will forward `GetLastError` if canceled. if ( DWORD ec = co_await wo ) { FAIL_WITH_MESSAGE ( system_category (). message ( ec )); co_return ; } flag . test_and_set (); } auto ptp_event_set_test () { // Notice that the Event Object is managed separately. HANDLE ev = CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , // EVENT_ALL_ACCESS ); auto on_return = gsl :: finally ([ ev ]() { CloseHandle ( ev ); }); ptp_event waitable { ev }; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_an_event ( waitable , flag ); SetEvent ( ev ); SleepEx ( 3 , true ); // give time to the waiting threas set the `flag` REQUIRE ( flag . test_and_set ()); } Definition \u00b6 modules/windows/concrt.cpp class ptp_event final : no_copy_move { HANDLE wo {}; private : // WAITORTIMERCALLBACK static void __stdcall wait_on_thread_pool ( PVOID , BOOLEAN ); public : explicit ptp_event ( HANDLE target ) noexcept ( false ); ~ ptp_event () noexcept ; void cancel () noexcept ; bool await_ready () noexcept ; void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ); uint32_t await_resume () noexcept ; }; Since it uses INFINITE wait, user must make sure one of SetEvent or cancel will happen on the object. Default Operations \u00b6 The type is not copyable and movable. Functions \u00b6 Function Description cancel Cancel the waiting ptp_event . The waiting coroutine will be resumed automatically by the Win32 thread. await_ready Always returns false ( suspend_always ) await_suspend Attach a background thread work to wait the SetEvent await_resume Unregister the wait operation so it can be used again.","title":"Win32 Event Object + Coroutine"},{"location":"features/concrt-ptp_event/#win32-event-object-coroutine","text":"","title":"Win32 Event Object + Coroutine"},{"location":"features/concrt-ptp_event/#see-also","text":"MSDN: Using Event Objects","title":"See Also"},{"location":"features/concrt-ptp_event/#ptp_event","text":"Awaitable event with the Windows Thread Pool API. Allows mutliple usage with 1 instance. But only 1 co_await is possible each time.","title":"ptp_event"},{"location":"features/concrt-ptp_event/#example","text":"Wait until signal Cancel #include <coroutine/concrt.h> #include <coroutine/return.h> using namespace concrt ; using namespace coro ; auto wait_an_event ( ptp_event & wo , atomic_flag & flag ) -> no_return { // wait for set or cancel // `co_await` will forward `GetLastError` if canceled. if ( DWORD ec = co_await wo ) { FAIL_WITH_MESSAGE ( system_category (). message ( ec )); co_return ; } flag . test_and_set (); } auto ptp_event_set_test () { // Notice that the Event Object is managed separately. HANDLE ev = CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , // EVENT_ALL_ACCESS ); auto on_return = gsl :: finally ([ ev ]() { CloseHandle ( ev ); }); ptp_event waitable { ev }; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_an_event ( waitable , flag ); SetEvent ( ev ); SleepEx ( 3 , true ); // give time to the waiting threas set the `flag` REQUIRE ( flag . test_and_set ()); }","title":"Example"},{"location":"features/concrt-ptp_event/#definition","text":"modules/windows/concrt.cpp class ptp_event final : no_copy_move { HANDLE wo {}; private : // WAITORTIMERCALLBACK static void __stdcall wait_on_thread_pool ( PVOID , BOOLEAN ); public : explicit ptp_event ( HANDLE target ) noexcept ( false ); ~ ptp_event () noexcept ; void cancel () noexcept ; bool await_ready () noexcept ; void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ); uint32_t await_resume () noexcept ; }; Since it uses INFINITE wait, user must make sure one of SetEvent or cancel will happen on the object.","title":"Definition"},{"location":"features/concrt-ptp_event/#default-operations","text":"The type is not copyable and movable.","title":"Default Operations"},{"location":"features/concrt-ptp_event/#functions","text":"Function Description cancel Cancel the waiting ptp_event . The waiting coroutine will be resumed automatically by the Win32 thread. await_ready Always returns false ( suspend_always ) await_suspend Attach a background thread work to wait the SetEvent await_resume Unregister the wait operation so it can be used again.","title":"Functions"},{"location":"features/concrt-ptp_work/","text":"Win32 Thread Pool Work + Coroutine \u00b6 See Also \u00b6 CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions MSDN: CreateThreadpoolWork WandBox example: A function that selects its thread ptp_work \u00b6 Change current coroutine's execution thread to background thread in the windows thread pool. Example \u00b6 #include <coroutine/return.h> // for `no_return` #include <coroutine/concrt.h> using namespace coro ; // for `no_return` using namespace concrt ; // the example might fail because of the constant folding auto switch_to_background () -> no_return { auto before = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread in the pool auto after = GetCurrentThreadId (); Assert :: IsTrue ( before != after ); } Like the example, it is recommended to use it as a temporary object. Definition \u00b6 modules/windows/concrt.cpp namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt Default Operations \u00b6 The type doesn't require memory (0-byte size). And it is a regular type. Functions \u00b6 Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"Win32 Thread Pool Work + Coroutine"},{"location":"features/concrt-ptp_work/#win32-thread-pool-work-coroutine","text":"","title":"Win32 Thread Pool Work + Coroutine"},{"location":"features/concrt-ptp_work/#see-also","text":"CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions MSDN: CreateThreadpoolWork WandBox example: A function that selects its thread","title":"See Also"},{"location":"features/concrt-ptp_work/#ptp_work","text":"Change current coroutine's execution thread to background thread in the windows thread pool.","title":"ptp_work"},{"location":"features/concrt-ptp_work/#example","text":"#include <coroutine/return.h> // for `no_return` #include <coroutine/concrt.h> using namespace coro ; // for `no_return` using namespace concrt ; // the example might fail because of the constant folding auto switch_to_background () -> no_return { auto before = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread in the pool auto after = GetCurrentThreadId (); Assert :: IsTrue ( before != after ); } Like the example, it is recommended to use it as a temporary object.","title":"Example"},{"location":"features/concrt-ptp_work/#definition","text":"modules/windows/concrt.cpp namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt","title":"Definition"},{"location":"features/concrt-ptp_work/#default-operations","text":"The type doesn't require memory (0-byte size). And it is a regular type.","title":"Default Operations"},{"location":"features/concrt-ptp_work/#functions","text":"Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"Functions"},{"location":"features/concrt-section/","text":"See Also \u00b6 Concept: BasicLockable section : Critical Section \u00b6 A basic lockable type with System API. The type is not copyable and movable. The purpose of this type is to provide a thin wrapper to use a lockable type in this library's test codes . namespace concrt { class section final : no_copy_move { // ... public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt Definition (Windows) \u00b6 With Win32 API, It uses CRITICAL_SECTION instead of SRWLock . Even though SRWLock doesn't require deallocation and possibly good for performance reason, CRITICAL_SECTION is used since the type is for test code. namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { // ... }; } // namepace concrt Definition (POSIX) \u00b6 With POSIX API, it uses pthread_rwlock_t . The type's existance is only for platform compatibility of test codes. The type was written with pthread_mutex_t to replace std::mutex in test code. The reason was that some test codes required different setting like PTHREAD_PRIO_NONE . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; // ... }; } // namepace concrt Example \u00b6 #include <coroutine/concrt.h> using namespace concrt ; void perform_with_lock ( section & m ){ std :: lock_guard lck { m }; // do some work... } In this library: test/channel_race_no_leak.cpp","title":"Concrt section"},{"location":"features/concrt-section/#see-also","text":"Concept: BasicLockable","title":"See Also"},{"location":"features/concrt-section/#section-critical-section","text":"A basic lockable type with System API. The type is not copyable and movable. The purpose of this type is to provide a thin wrapper to use a lockable type in this library's test codes . namespace concrt { class section final : no_copy_move { // ... public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt","title":"section: Critical Section"},{"location":"features/concrt-section/#definition-windows","text":"With Win32 API, It uses CRITICAL_SECTION instead of SRWLock . Even though SRWLock doesn't require deallocation and possibly good for performance reason, CRITICAL_SECTION is used since the type is for test code. namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { // ... }; } // namepace concrt","title":"Definition (Windows)"},{"location":"features/concrt-section/#definition-posix","text":"With POSIX API, it uses pthread_rwlock_t . The type's existance is only for platform compatibility of test codes. The type was written with pthread_mutex_t to replace std::mutex in test code. The reason was that some test codes required different setting like PTHREAD_PRIO_NONE . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; // ... }; } // namepace concrt","title":"Definition (POSIX)"},{"location":"features/concrt-section/#example","text":"#include <coroutine/concrt.h> using namespace concrt ; void perform_with_lock ( section & m ){ std :: lock_guard lck { m }; // do some work... } In this library: test/channel_race_no_leak.cpp","title":"Example"},{"location":"features/frame-compiler_specific/","text":"This document covers compiler specific issues. See Also \u00b6 <coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo Compiler Awareness \u00b6 The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ... Compiler Intrinsic \u00b6 For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); Coroutine Frame Prefix \u00b6 The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Frame compiler specific"},{"location":"features/frame-compiler_specific/#see-also","text":"<coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo","title":"See Also"},{"location":"features/frame-compiler_specific/#compiler-awareness","text":"The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ...","title":"Compiler Awareness"},{"location":"features/frame-compiler_specific/#compiler-intrinsic","text":"For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * );","title":"Compiler Intrinsic"},{"location":"features/frame-compiler_specific/#coroutine-frame-prefix","text":"The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Coroutine Frame Prefix"},{"location":"features/frame-coroutine_handle/","text":"See Also \u00b6 n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later Library Issues \u00b6 https://github.com/luncliff/coroutine/issues/23 Coroutine Handle (Standard) \u00b6 ToDo: Summarize the standard docs Coroutine Handle (Custom) \u00b6 Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; } Template Parameters \u00b6 PromiseType must fulfills the Coroutine Promise Requirement. Default Operations \u00b6 The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... } With Void \u00b6 Mostly the type will be used with void as its promise type( coroutine_handle<void> ). In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; } With Promise \u00b6 When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; } Non-Member Functions \u00b6 Compare Operators \u00b6 namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"Frame coroutine handle"},{"location":"features/frame-coroutine_handle/#see-also","text":"n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later","title":"See Also"},{"location":"features/frame-coroutine_handle/#library-issues","text":"https://github.com/luncliff/coroutine/issues/23","title":"Library Issues"},{"location":"features/frame-coroutine_handle/#coroutine-handle-standard","text":"ToDo: Summarize the standard docs","title":"Coroutine Handle (Standard)"},{"location":"features/frame-coroutine_handle/#coroutine-handle-custom","text":"Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; }","title":"Coroutine Handle (Custom)"},{"location":"features/frame-coroutine_handle/#template-parameters","text":"PromiseType must fulfills the Coroutine Promise Requirement.","title":"Template Parameters"},{"location":"features/frame-coroutine_handle/#default-operations","text":"The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... }","title":"Default Operations"},{"location":"features/frame-coroutine_handle/#with-void","text":"Mostly the type will be used with void as its promise type( coroutine_handle<void> ). In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; }","title":"With Void"},{"location":"features/frame-coroutine_handle/#with-promise","text":"When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; }","title":"With Promise"},{"location":"features/frame-coroutine_handle/#non-member-functions","text":"","title":"Non-Member Functions"},{"location":"features/frame-coroutine_handle/#compare-operators","text":"namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"Compare Operators"},{"location":"features/frame-coroutine_traits/","text":"This document covers coroutine_traits<R, P...> . Coroutine Traits (Standard) \u00b6 TBA Coroutine Traits (Custom) \u00b6 Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"Frame coroutine traits"},{"location":"features/frame-coroutine_traits/#coroutine-traits-standard","text":"TBA","title":"Coroutine Traits (Standard)"},{"location":"features/frame-coroutine_traits/#coroutine-traits-custom","text":"Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"Coroutine Traits (Custom)"},{"location":"features/frame-overview/","text":"#include <coroutine/frame.h> using namespace std :: experimental ; References \u00b6 http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0664r0.html ToDo organize list in this issue add list for the latest ones Background \u00b6 C++ Coroutines is so compiler specific that we can't compile VC++'s <experimental/coroutine> with Clang compiler, and vice versa. Because this is an example project, I believe I have a duty to show people how to configure projects under those envionments. The start was clang-cl on Windows, and I solved some problems related to the difference between 2 compilers. For that, there was no way but to add a wrapper header file. <coroutine/frame.h> file is an adapter to handle coroutine frame's difference between compilers. (For now, they are MSVC and Clang ). Notice that the file imports <experimental/coroutine> . Just like below, <coroutine/frame.h> activates custom implementation only for specific environments. // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) // C++ 20 # include <coroutine> # elif __has_include(<experimental/coroutine>) // C++ 17 # include <experimental/coroutine> # endif #endif // ... So in general you don't have to care. Think of <coroutine/frame.h> as <coroutine> in the future. #if __has_include(<coroutine>) # include <coroutine> #else # include <coroutine/frame.h> #endif If you're really curious, read the file and please review my approach. :) Contents \u00b6 I'm going to cover both the standard and my implementation in this section. You can think these items are the supplement of https://en.cppreference.com/w/cpp . #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> coroutine_traits<R, P...> suspend_never and suspend_always Note: Compiler Specific Issues","title":"Frame overview"},{"location":"features/frame-overview/#references","text":"http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0664r0.html ToDo organize list in this issue add list for the latest ones","title":"References"},{"location":"features/frame-overview/#background","text":"C++ Coroutines is so compiler specific that we can't compile VC++'s <experimental/coroutine> with Clang compiler, and vice versa. Because this is an example project, I believe I have a duty to show people how to configure projects under those envionments. The start was clang-cl on Windows, and I solved some problems related to the difference between 2 compilers. For that, there was no way but to add a wrapper header file. <coroutine/frame.h> file is an adapter to handle coroutine frame's difference between compilers. (For now, they are MSVC and Clang ). Notice that the file imports <experimental/coroutine> . Just like below, <coroutine/frame.h> activates custom implementation only for specific environments. // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) // C++ 20 # include <coroutine> # elif __has_include(<experimental/coroutine>) // C++ 17 # include <experimental/coroutine> # endif #endif // ... So in general you don't have to care. Think of <coroutine/frame.h> as <coroutine> in the future. #if __has_include(<coroutine>) # include <coroutine> #else # include <coroutine/frame.h> #endif If you're really curious, read the file and please review my approach. :)","title":"Background"},{"location":"features/frame-overview/#contents","text":"I'm going to cover both the standard and my implementation in this section. You can think these items are the supplement of https://en.cppreference.com/w/cpp . #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> coroutine_traits<R, P...> suspend_never and suspend_always Note: Compiler Specific Issues","title":"Contents"},{"location":"features/frame-suspend_types/","text":"Coroutine Promise Requirement requires some awaitable type for the initial_suspend and final_suspend member functions for promise_type . suspend_never \u00b6 Awaitable type that never suspend. The control flows through ready - resume . Definition Example \u00b6 namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // Since the class won't suspend, this function won't be invoked } }; } // namespace std::experimental Known Usages \u00b6 In this library: Type enumerable<T> Type no_return TBA: external references suspend_always \u00b6 Awaitable type that always suspend. The control flows through ready - suspend - resume . Definition Example \u00b6 namespace std :: experimental { class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // The routine will suspend but the class ignores the given handle } }; } // namespace std::experimental Known Usages \u00b6 In this library: Type frame TBA: external references","title":"Frame suspend types"},{"location":"features/frame-suspend_types/#suspend_never","text":"Awaitable type that never suspend. The control flows through ready - resume .","title":"suspend_never"},{"location":"features/frame-suspend_types/#definition-example","text":"namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // Since the class won't suspend, this function won't be invoked } }; } // namespace std::experimental","title":"Definition Example"},{"location":"features/frame-suspend_types/#known-usages","text":"In this library: Type enumerable<T> Type no_return TBA: external references","title":"Known Usages"},{"location":"features/frame-suspend_types/#suspend_always","text":"Awaitable type that always suspend. The control flows through ready - suspend - resume .","title":"suspend_always"},{"location":"features/frame-suspend_types/#definition-example_1","text":"namespace std :: experimental { class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // The routine will suspend but the class ignores the given handle } }; } // namespace std::experimental","title":"Definition Example"},{"location":"features/frame-suspend_types/#known-usages_1","text":"In this library: Type frame TBA: external references","title":"Known Usages"},{"location":"features/net-implementation-epoll/","text":"This document is under progress ... Epoll \u00b6 For Linux platform, it uses epoll . modules/linux/net.cpp Expect & Ensures \u00b6 Socket \u00b6 Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); } Control Flow and Data \u00b6 The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close Concurrent I/O control \u00b6 I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request \u00b6 This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } Progress Check \u00b6 fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; } Suspend \u00b6 coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails } Polling and Resume \u00b6 Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; } Limitations \u00b6 Current version doesn't provide interface for I/O cancel.","title":"Net implementation epoll"},{"location":"features/net-implementation-epoll/#epoll","text":"For Linux platform, it uses epoll . modules/linux/net.cpp","title":"Epoll"},{"location":"features/net-implementation-epoll/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"features/net-implementation-epoll/#socket","text":"Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); }","title":"Socket"},{"location":"features/net-implementation-epoll/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close","title":"Control Flow and Data"},{"location":"features/net-implementation-epoll/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"features/net-implementation-epoll/#request","text":"This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); }","title":"Request"},{"location":"features/net-implementation-epoll/#progress-check","text":"fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; }","title":"Progress Check"},{"location":"features/net-implementation-epoll/#suspend","text":"coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails }","title":"Suspend"},{"location":"features/net-implementation-epoll/#polling-and-resume","text":"Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; }","title":"Polling and Resume"},{"location":"features/net-implementation-epoll/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"features/net-implementation-kqueue/","text":"This document is under progress ... KQueue \u00b6 For Mac OS(Darwin) platform, it uses kqueue . modules/darwin/net.cpp Expect & Ensures \u00b6 Socket \u00b6 All expectations for socket object are same with epoll based implementation . Control Flow and Data \u00b6 The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close Concurrent I/O control \u00b6 I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request \u00b6 It performs argument copy(packing) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } Progress Check \u00b6 The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; } Suspend \u00b6 Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } Polling and Resume \u00b6 wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; } Limitations \u00b6 Current version doesn't provide interface for I/O cancel.","title":"Net implementation kqueue"},{"location":"features/net-implementation-kqueue/#kqueue","text":"For Mac OS(Darwin) platform, it uses kqueue . modules/darwin/net.cpp","title":"KQueue"},{"location":"features/net-implementation-kqueue/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"features/net-implementation-kqueue/#socket","text":"All expectations for socket object are same with epoll based implementation .","title":"Socket"},{"location":"features/net-implementation-kqueue/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close","title":"Control Flow and Data"},{"location":"features/net-implementation-kqueue/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"features/net-implementation-kqueue/#request","text":"It performs argument copy(packing) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); }","title":"Request"},{"location":"features/net-implementation-kqueue/#progress-check","text":"The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; }","title":"Progress Check"},{"location":"features/net-implementation-kqueue/#suspend","text":"Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; }","title":"Suspend"},{"location":"features/net-implementation-kqueue/#polling-and-resume","text":"wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; }","title":"Polling and Resume"},{"location":"features/net-implementation-kqueue/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"features/net-implementation-winsock2/","text":"This document is under progress ... Coroutine + Socket Overlapped I/O + Completion Routine See Also \u00b6 CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Winsock Overlapped I/O \u00b6 modules/windows/net.cpp Remarks \u00b6 The library never invoke WSAStartup and WSACleanup . User must do it. Socket \u00b6 socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); } Control Flow and Data \u00b6 The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; io_buffer_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ; Concurrent I/O control \u00b6 I/O Request I/O Progress Check I/O Suspend I/O Resume Request \u00b6 The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); } Progress Check \u00b6 Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` } Suspend \u00b6 Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); } Resume (by Completion Routine) \u00b6 Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it. Limitations \u00b6 Current version doesn't provide interface for I/O cancel.","title":"Net implementation winsock2"},{"location":"features/net-implementation-winsock2/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"See Also"},{"location":"features/net-implementation-winsock2/#winsock-overlapped-io","text":"modules/windows/net.cpp","title":"Winsock Overlapped I/O"},{"location":"features/net-implementation-winsock2/#remarks","text":"The library never invoke WSAStartup and WSACleanup . User must do it.","title":"Remarks"},{"location":"features/net-implementation-winsock2/#socket","text":"socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); }","title":"Socket"},{"location":"features/net-implementation-winsock2/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; io_buffer_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ;","title":"Control Flow and Data"},{"location":"features/net-implementation-winsock2/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Resume","title":"Concurrent I/O control"},{"location":"features/net-implementation-winsock2/#request","text":"The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); }","title":"Request"},{"location":"features/net-implementation-winsock2/#progress-check","text":"Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` }","title":"Progress Check"},{"location":"features/net-implementation-winsock2/#suspend","text":"Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); }","title":"Suspend"},{"location":"features/net-implementation-winsock2/#resume-by-completion-routine","text":"Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it.","title":"Resume (by Completion Routine)"},{"location":"features/net-implementation-winsock2/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"features/net-overview/","text":"The interface contains socket I/O functions with coroutine. See Also \u00b6 CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" Dependency \u00b6 The interface uses GSL(Guideline Support Library) and some of this library's features. For GSL itself, please see the GSL section in the C++ Core Guidelines . #include <coroutine/yield.hpp> #include <gsl/gsl> Variables \u00b6 constexpr \u00b6 The header defines 2 constexpr variable. static constexpr bool is_winsock = /* true or false */ ; static constexpr bool is_netinet = /* true or false */ ; Types \u00b6 io_control_block \u00b6 This is an alias of OVERLAPPED struct. For netinet, it's struct follows the OVERLAPPED . // follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc; int32_t flag; uint64_t internal_high ; union { struct { int32_t offset ; // socklen_t addrlen; int32_t offset_high ; }; void * ptr ; }; int64_t handle ; // int64_t sd; }; endpoint_t \u00b6 Helper type for socket address usage. Notice that the type contains sockaddr_storage . union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; }; io_task_t \u00b6 This is an alias of coroutine_handle<void> . The coroutine frame becomes an user data in the underlying system's API // 1 task item == 1 resumable function using io_task_t = std :: experimental :: coroutine_handle < void > ; io_buffer_t \u00b6 The type is a view to the bytes(storage for read/write operation). Be aware that it doesn't have ownership. See gsl::span<T> for its usage. using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); io_work_t \u00b6 It is a struct to describe 1 I/O request to the underlying system's API class io_work_t : public io_control_block { io_task_t task {}; io_buffer_t buffer {}; endpoint_t * ep {}; public : bool ready () const noexcept ; uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 64 ); After co_await , error() returns the stored error from I/O operation. For its usage, see the examples in I/O operation functions. Operations \u00b6 Remarks \u00b6 The library doesn't use cancel/scatter/gather operations. The library doesn't provide create/destroy/option for the socket. Such an abstraction is tedious and distracts to understand both interface design and internal codes. It just expects that the given socket is non-block and async one, and it works as designed only for the case. Test helper codes below contain socket functions. You can copy-and-paste them :) test/test_network.h test/test_network.cpp wait_io_tasks \u00b6 Acquires currently resumable I/O coroutines. This function is for non-windows platform. Over Windows API, the implementation resumes I/O coroutines automatically. So it always yields nothing . Also, the library does not guarantee that all coroutines(I/O tasks) will be fetched at once. Therefore it is strongly recommended for user to have another method to detect that watching I/O coroutines are returned. User must repeat the resuming loop without break so that there is no leak of event. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > ; Example \u00b6 Use it with the constexpr variables . void io_polling_example () { if constexpr ( is_winsock == false ) { // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } } send_to \u00b6 Request to internal API to send a buffer to specific endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_send_to final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in6 & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; Params \u00b6 sd : a bound socket descriptor remote : remote address to send buf buf : data(span of std::byte ) to send work : I/O request holder. Down-casted to io_send_to Return \u00b6 send_to : lvalue reference to an awaitable type( io_send_to ) await_resume : success: the length of sent bytes in int64_t failure: the error code will be stored to given work Example \u00b6 The following code shows how send_to can be used. auto example ( uint64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz == storage . size ()); } recv_from \u00b6 Request to internal API to receive through a socket from the unspecified endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_recv_from final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; Params \u00b6 sd : a bound socket descriptor remote : memory to store sender's address buf : data(span of std::byte ) to receive work : I/O request holder. Down-casted to io_recv_from Return \u00b6 recv_from : lvalue reference to an awaitable type( io_recv_from ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example \u00b6 The following code shows how recv_from can be used. auto example ( uint64_t sd , sockaddr_in & remote , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); } send_stream \u00b6 Request to internal API to send to the connected peer and return a refernce of concrete io_work_t that can be used for co_await . class io_send final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ; Params \u00b6 sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_send Return \u00b6 send_stream : lvalue reference to an awaitable type( io_send ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example \u00b6 The following code shows how send_stream can be used. auto example ( int64_t sd , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz > 0 ); } recv_stream \u00b6 Request to internal API to receive through the connected socket and return a refernce of concrete io_work_t that can be used for co_await . class io_recv final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ; Params \u00b6 sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_recv Return \u00b6 recv_stream : lvalue reference to an awaitable type( io_recv ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example \u00b6 The following code shows how recv_stream can be used. auto example ( int64_t sd , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); } Usage Pattern \u00b6 User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine 1 I/O Reqeust == 1 Coroutine \u00b6 Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( uint64_t socket ) -> some_return_type { io_work_t work {}; // control block object io_buffer_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // ec is updated after the request auto ec = work . error (); // ... } // ... } The request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer Continuation of I/O Coroutines \u00b6 User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... } Examples \u00b6 resolve IPv6 Multicast TCPv6 Connect UDPv6 v4 mapped send_stream / recv_stream ( wait_io_tasks ) send_to / recv_from ( wait_io_tasks )","title":"Net overview"},{"location":"features/net-overview/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\"","title":"See Also"},{"location":"features/net-overview/#dependency","text":"The interface uses GSL(Guideline Support Library) and some of this library's features. For GSL itself, please see the GSL section in the C++ Core Guidelines . #include <coroutine/yield.hpp> #include <gsl/gsl>","title":"Dependency"},{"location":"features/net-overview/#variables","text":"","title":"Variables"},{"location":"features/net-overview/#constexpr","text":"The header defines 2 constexpr variable. static constexpr bool is_winsock = /* true or false */ ; static constexpr bool is_netinet = /* true or false */ ;","title":"constexpr"},{"location":"features/net-overview/#types","text":"","title":"Types"},{"location":"features/net-overview/#io_control_block","text":"This is an alias of OVERLAPPED struct. For netinet, it's struct follows the OVERLAPPED . // follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc; int32_t flag; uint64_t internal_high ; union { struct { int32_t offset ; // socklen_t addrlen; int32_t offset_high ; }; void * ptr ; }; int64_t handle ; // int64_t sd; };","title":"io_control_block"},{"location":"features/net-overview/#endpoint_t","text":"Helper type for socket address usage. Notice that the type contains sockaddr_storage . union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; };","title":"endpoint_t"},{"location":"features/net-overview/#io_task_t","text":"This is an alias of coroutine_handle<void> . The coroutine frame becomes an user data in the underlying system's API // 1 task item == 1 resumable function using io_task_t = std :: experimental :: coroutine_handle < void > ;","title":"io_task_t"},{"location":"features/net-overview/#io_buffer_t","text":"The type is a view to the bytes(storage for read/write operation). Be aware that it doesn't have ownership. See gsl::span<T> for its usage. using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 );","title":"io_buffer_t"},{"location":"features/net-overview/#io_work_t","text":"It is a struct to describe 1 I/O request to the underlying system's API class io_work_t : public io_control_block { io_task_t task {}; io_buffer_t buffer {}; endpoint_t * ep {}; public : bool ready () const noexcept ; uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 64 ); After co_await , error() returns the stored error from I/O operation. For its usage, see the examples in I/O operation functions.","title":"io_work_t"},{"location":"features/net-overview/#operations","text":"","title":"Operations"},{"location":"features/net-overview/#remarks","text":"The library doesn't use cancel/scatter/gather operations. The library doesn't provide create/destroy/option for the socket. Such an abstraction is tedious and distracts to understand both interface design and internal codes. It just expects that the given socket is non-block and async one, and it works as designed only for the case. Test helper codes below contain socket functions. You can copy-and-paste them :) test/test_network.h test/test_network.cpp","title":"Remarks"},{"location":"features/net-overview/#wait_io_tasks","text":"Acquires currently resumable I/O coroutines. This function is for non-windows platform. Over Windows API, the implementation resumes I/O coroutines automatically. So it always yields nothing . Also, the library does not guarantee that all coroutines(I/O tasks) will be fetched at once. Therefore it is strongly recommended for user to have another method to detect that watching I/O coroutines are returned. User must repeat the resuming loop without break so that there is no leak of event. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > ;","title":"wait_io_tasks"},{"location":"features/net-overview/#example","text":"Use it with the constexpr variables . void io_polling_example () { if constexpr ( is_winsock == false ) { // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } }","title":"Example"},{"location":"features/net-overview/#send_to","text":"Request to internal API to send a buffer to specific endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_send_to final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in6 & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ;","title":"send_to"},{"location":"features/net-overview/#params","text":"sd : a bound socket descriptor remote : remote address to send buf buf : data(span of std::byte ) to send work : I/O request holder. Down-casted to io_send_to","title":"Params"},{"location":"features/net-overview/#return","text":"send_to : lvalue reference to an awaitable type( io_send_to ) await_resume : success: the length of sent bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_1","text":"The following code shows how send_to can be used. auto example ( uint64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz == storage . size ()); }","title":"Example"},{"location":"features/net-overview/#recv_from","text":"Request to internal API to receive through a socket from the unspecified endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_recv_from final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ;","title":"recv_from"},{"location":"features/net-overview/#params_1","text":"sd : a bound socket descriptor remote : memory to store sender's address buf : data(span of std::byte ) to receive work : I/O request holder. Down-casted to io_recv_from","title":"Params"},{"location":"features/net-overview/#return_1","text":"recv_from : lvalue reference to an awaitable type( io_recv_from ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_2","text":"The following code shows how recv_from can be used. auto example ( uint64_t sd , sockaddr_in & remote , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); }","title":"Example"},{"location":"features/net-overview/#send_stream","text":"Request to internal API to send to the connected peer and return a refernce of concrete io_work_t that can be used for co_await . class io_send final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ;","title":"send_stream"},{"location":"features/net-overview/#params_2","text":"sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_send","title":"Params"},{"location":"features/net-overview/#return_2","text":"send_stream : lvalue reference to an awaitable type( io_send ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_3","text":"The following code shows how send_stream can be used. auto example ( int64_t sd , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz > 0 ); }","title":"Example"},{"location":"features/net-overview/#recv_stream","text":"Request to internal API to receive through the connected socket and return a refernce of concrete io_work_t that can be used for co_await . class io_recv final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ;","title":"recv_stream"},{"location":"features/net-overview/#params_3","text":"sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_recv","title":"Params"},{"location":"features/net-overview/#return_3","text":"recv_stream : lvalue reference to an awaitable type( io_recv ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_4","text":"The following code shows how recv_stream can be used. auto example ( int64_t sd , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); }","title":"Example"},{"location":"features/net-overview/#usage-pattern","text":"User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine","title":"Usage Pattern"},{"location":"features/net-overview/#1-io-reqeust-1-coroutine","text":"Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( uint64_t socket ) -> some_return_type { io_work_t work {}; // control block object io_buffer_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // ec is updated after the request auto ec = work . error (); // ... } // ... } The request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer","title":"1 I/O Reqeust == 1 Coroutine"},{"location":"features/net-overview/#continuation-of-io-coroutines","text":"User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... }","title":"Continuation of I/O Coroutines"},{"location":"features/net-overview/#examples","text":"resolve IPv6 Multicast TCPv6 Connect UDPv6 v4 mapped send_stream / recv_stream ( wait_io_tasks ) send_to / recv_from ( wait_io_tasks )","title":"Examples"},{"location":"features/return-frame/","text":"See Also \u00b6 C++ Coroutines: Understanding the promise type Exploring The C++ Coroutine Coroutine Promise Requirements (N4736) frame as a ReturnType \u00b6 When user wants to (or have to) manage the destruction of coroutine frame, frame opens a way to acquire the coroutine_handle<void> . Basically, this type is a shallow extension of coroutine_handle<void> . Example \u00b6 The type can be empty. In the case, using done() member function will access to nullptr . #include <coroutine/return.h> using namespace coro ; auto coro_frame_empty_test () -> void { frame fh {}; auto coro = static_cast < coroutine_handle < void >> ( fh ); REQUIRE ( coro . address () == nullptr ); } When the coroutine frame's destuction need to be controlled manually, just suspend( co_await ) or return( co_return , the final suspend) in the function. #include <coroutine/return.h> using namespace coro ; auto invoke_and_suspend () -> frame { co_await suspend_always {}; co_return ; }; auto coro_frame_first_suspend_test () -> void { auto frame = invoke_and_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done () == false ); // it is susepended, but not return. frame . destroy (); } Remarks \u00b6 The coroutine's frame will remain 'final suspended' after co_return . See the final_suspend in the definiton below. Like no_return , the type doesn't allows co_return; . Definition (Promise) \u00b6 The type's size is equal to that of coroutine_handle<void> . namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; // !!!!! } void return_void () noexcept ; void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * ; static auto get_return_object_on_allocation_failure () noexcept -> promise_type * ; }; public : void await_suspend ( coroutine_handle < void > coro ) noexcept ; frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro frame as an Awaitable \u00b6 The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this harms the SRP(Single Responsibility Principle), but writing another type for the purpose will make the code tedious. Remark \u00b6 The following example shows frame doesn't guarantee it's target(coroutine's frame) is alive. See the following example. In the co_await expression, it must be used by reference . Example \u00b6 Please, be cautious. #include <gsl/gsl> #include <coroutine/return.h> using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame type as an awaitable. status = 2 ; co_await fh ; co_return ; } auto coro_frame_awaitable_test () -> void { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); // `frame` inherits `coroutine_handle<void>` coro . resume (); REQUIRE ( status == 2 ); // coroutine reached end. // so `defer` in the routine will change status coro . resume (); REQUIRE ( status == 3 ); // however, `no_return` destroyed the coroutine's frame. // so `destroy` through `coro` will be undefined behavior... } Definition (Awaitable) \u00b6 It inherits await_ready and await_resume from the suspend_always type. However, it overrides await_suspend to save given handle. namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final ; public : // override `suspend_always::await_suspend` // assumed to be used as an argument of `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept ; }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Return frame"},{"location":"features/return-frame/#see-also","text":"C++ Coroutines: Understanding the promise type Exploring The C++ Coroutine Coroutine Promise Requirements (N4736)","title":"See Also"},{"location":"features/return-frame/#frame-as-a-returntype","text":"When user wants to (or have to) manage the destruction of coroutine frame, frame opens a way to acquire the coroutine_handle<void> . Basically, this type is a shallow extension of coroutine_handle<void> .","title":"frame as a ReturnType"},{"location":"features/return-frame/#example","text":"The type can be empty. In the case, using done() member function will access to nullptr . #include <coroutine/return.h> using namespace coro ; auto coro_frame_empty_test () -> void { frame fh {}; auto coro = static_cast < coroutine_handle < void >> ( fh ); REQUIRE ( coro . address () == nullptr ); } When the coroutine frame's destuction need to be controlled manually, just suspend( co_await ) or return( co_return , the final suspend) in the function. #include <coroutine/return.h> using namespace coro ; auto invoke_and_suspend () -> frame { co_await suspend_always {}; co_return ; }; auto coro_frame_first_suspend_test () -> void { auto frame = invoke_and_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done () == false ); // it is susepended, but not return. frame . destroy (); }","title":"Example"},{"location":"features/return-frame/#remarks","text":"The coroutine's frame will remain 'final suspended' after co_return . See the final_suspend in the definiton below. Like no_return , the type doesn't allows co_return; .","title":"Remarks"},{"location":"features/return-frame/#definition-promise","text":"The type's size is equal to that of coroutine_handle<void> . namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; // !!!!! } void return_void () noexcept ; void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * ; static auto get_return_object_on_allocation_failure () noexcept -> promise_type * ; }; public : void await_suspend ( coroutine_handle < void > coro ) noexcept ; frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Definition (Promise)"},{"location":"features/return-frame/#frame-as-an-awaitable","text":"The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this harms the SRP(Single Responsibility Principle), but writing another type for the purpose will make the code tedious.","title":"frame as an Awaitable"},{"location":"features/return-frame/#remark","text":"The following example shows frame doesn't guarantee it's target(coroutine's frame) is alive. See the following example. In the co_await expression, it must be used by reference .","title":"Remark"},{"location":"features/return-frame/#example_1","text":"Please, be cautious. #include <gsl/gsl> #include <coroutine/return.h> using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame type as an awaitable. status = 2 ; co_await fh ; co_return ; } auto coro_frame_awaitable_test () -> void { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); // `frame` inherits `coroutine_handle<void>` coro . resume (); REQUIRE ( status == 2 ); // coroutine reached end. // so `defer` in the routine will change status coro . resume (); REQUIRE ( status == 3 ); // however, `no_return` destroyed the coroutine's frame. // so `destroy` through `coro` will be undefined behavior... }","title":"Example"},{"location":"features/return-frame/#definition-awaitable","text":"It inherits await_ready and await_resume from the suspend_always type. However, it overrides await_suspend to save given handle. namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final ; public : // override `suspend_always::await_suspend` // assumed to be used as an argument of `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept ; }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Definition (Awaitable)"},{"location":"features/return-no_return/","text":"See Also \u00b6 C++ coroutiness: Understanding the promise type Exploring The C++ coroutines Coroutine Promise Requirements (N4736) no_return \u00b6 This is a void return type for the general coroutine functions. Since a coroutine might suspend without return, it is not recommended to rely heavily on co_return from its caller/resumer. If the return can be ignored, class no_return can do the work. Remarks \u00b6 Since the promise_type does not final suspend, a frame of the coroutine that return no_return type will be destroyed immediately . Example \u00b6 If you doesn't care about coroutine's life cycle, use no_return . At least the routine will be resumed(continued) properly, co_return will destroy the frame #include <coroutine/return.h> using namespace coro ; auto fire_and_forget () -> no_return { co_await suspend_never {}; co_return ; }; auto example_caller () -> void { fire_and_forget (); // spawn a new coroutine frame. // the routine will be finished somehow // and destroy the frame. // do some other works ... } Definition \u00b6 It's definition is in the <coroutine/return.h> namespace coro { // General `void` return for the coroutine functions class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : no_return ( const promise_type * ) noexcept { // the type truncates all given info about its frame } }; } // namespace coro Possible customization points are ... unhandled_exception : We can throw the exception again and handle it , but mostly it depends on the scenario. This version assumes it's a somthing irrecoverable. get_return_object_on_allocation_failure : with operator new and operator delete , you can customise memory management for the coroutine frames.","title":"Return no return"},{"location":"features/return-no_return/#see-also","text":"C++ coroutiness: Understanding the promise type Exploring The C++ coroutines Coroutine Promise Requirements (N4736)","title":"See Also"},{"location":"features/return-no_return/#no_return","text":"This is a void return type for the general coroutine functions. Since a coroutine might suspend without return, it is not recommended to rely heavily on co_return from its caller/resumer. If the return can be ignored, class no_return can do the work.","title":"no_return"},{"location":"features/return-no_return/#remarks","text":"Since the promise_type does not final suspend, a frame of the coroutine that return no_return type will be destroyed immediately .","title":"Remarks"},{"location":"features/return-no_return/#example","text":"If you doesn't care about coroutine's life cycle, use no_return . At least the routine will be resumed(continued) properly, co_return will destroy the frame #include <coroutine/return.h> using namespace coro ; auto fire_and_forget () -> no_return { co_await suspend_never {}; co_return ; }; auto example_caller () -> void { fire_and_forget (); // spawn a new coroutine frame. // the routine will be finished somehow // and destroy the frame. // do some other works ... }","title":"Example"},{"location":"features/return-no_return/#definition","text":"It's definition is in the <coroutine/return.h> namespace coro { // General `void` return for the coroutine functions class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : no_return ( const promise_type * ) noexcept { // the type truncates all given info about its frame } }; } // namespace coro Possible customization points are ... unhandled_exception : We can throw the exception again and handle it , but mostly it depends on the scenario. This version assumes it's a somthing irrecoverable. get_return_object_on_allocation_failure : with operator new and operator delete , you can customise memory management for the coroutine frames.","title":"Definition"},{"location":"features/return-overview/","text":"#include <coroutine/return.h> using namespace coro ; References \u00b6 N4820 Working Draft N4736 Working Draft Background \u00b6 One of the entry barriers for the coroutine function is to write a return type. The return type's promise_type must fulfills the Coroutine Promise Requirement (Actually it's coroutine_traits<R>::promise_type , but just let me skip the detail for now). To save your time, start with the article of Lewiss Baker . I also wrote about it with N4402 , and with my talk in C++ Korea (see the page 60) . In my opinion, N4402 was short enough and explains well about the role of those requirements. Contents \u00b6 Currently, this library provides 2 types. #include <coroutine/return.h> using namespace coro ; no_return frame You may noticed that there is no task<T> . I don't have a plan to support the type for 2 reasons. To encourage use of https://github.com/lewissbaker/cppcoro which already implemented it To encourage use of the suspension( co_await and co_yield ) insead of the return( co_return ) In my perspective, the coroutine is a routine with multiple entry points and multiple suspend points. Therefore we should be familiar with the suspension and have concern about its usage rather than just using return(the last suspension).","title":"Return overview"},{"location":"features/return-overview/#references","text":"N4820 Working Draft N4736 Working Draft","title":"References"},{"location":"features/return-overview/#background","text":"One of the entry barriers for the coroutine function is to write a return type. The return type's promise_type must fulfills the Coroutine Promise Requirement (Actually it's coroutine_traits<R>::promise_type , but just let me skip the detail for now). To save your time, start with the article of Lewiss Baker . I also wrote about it with N4402 , and with my talk in C++ Korea (see the page 60) . In my opinion, N4402 was short enough and explains well about the role of those requirements.","title":"Background"},{"location":"features/return-overview/#contents","text":"Currently, this library provides 2 types. #include <coroutine/return.h> using namespace coro ; no_return frame You may noticed that there is no task<T> . I don't have a plan to support the type for 2 reasons. To encourage use of https://github.com/lewissbaker/cppcoro which already implemented it To encourage use of the suspension( co_await and co_yield ) insead of the return( co_return ) In my perspective, the coroutine is a routine with multiple entry points and multiple suspend points. Therefore we should be familiar with the suspension and have concern about its usage rather than just using return(the last suspension).","title":"Contents"},{"location":"features/yield-enumerable/","text":"Generator with the coroutine See Also \u00b6 <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck enumerable<T> \u00b6 This is an implementation of the 'Coroutine-based Generator' concept. However, because of some known implementations, the name can be considered as a reserved one. In this library, the impl is is named as enumerable . Even though there are existing implementations like the generator of VC++, I had to write my own one to test coroutine_handle<void> because the type is compiler-dependent. If you're clang/libc++ user, you can use mine or generator of the cppcoro . template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters \u00b6 T : The type of element in the enumerable. Default Operations \u00b6 Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator follows RAII. So it will destroy its handle in destructor. Functions \u00b6 The type supports ranged- for statment. Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Type: promise_type \u00b6 The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it Remark \u00b6 It only takes lvalue reference( T& ) for the operand of co_yield . template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Type: iterator \u00b6 Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent misusage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; }; Examples \u00b6 You can see the usage with test codes. Use of co_yield What if the function yields 0-time? Move Semantics Iteration std::accumulate std::max_element","title":"Yield enumerable"},{"location":"features/yield-enumerable/#see-also","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"See Also"},{"location":"features/yield-enumerable/#enumerablelttgt","text":"This is an implementation of the 'Coroutine-based Generator' concept. However, because of some known implementations, the name can be considered as a reserved one. In this library, the impl is is named as enumerable . Even though there are existing implementations like the generator of VC++, I had to write my own one to test coroutine_handle<void> because the type is compiler-dependent. If you're clang/libc++ user, you can use mine or generator of the cppcoro . template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"enumerable&lt;T&gt;"},{"location":"features/yield-enumerable/#template-parameters","text":"T : The type of element in the enumerable.","title":"Template Parameters"},{"location":"features/yield-enumerable/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator follows RAII. So it will destroy its handle in destructor.","title":"Default Operations"},{"location":"features/yield-enumerable/#functions","text":"The type supports ranged- for statment. Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"features/yield-enumerable/#type-promise_type","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it","title":"Type: promise_type"},{"location":"features/yield-enumerable/#remark","text":"It only takes lvalue reference( T& ) for the operand of co_yield . template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Remark"},{"location":"features/yield-enumerable/#type-iterator","text":"Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent misusage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Type: iterator"},{"location":"features/yield-enumerable/#examples","text":"You can see the usage with test codes. Use of co_yield What if the function yields 0-time? Move Semantics Iteration std::accumulate std::max_element","title":"Examples"},{"location":"features/yield-overview/","text":"#include <coroutine/yield.hpp> using namespace coro ; References \u00b6 <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck Background \u00b6 I strongly recomment the last two materials. Andreas Reischuck's explanation will be a good time saver for you. ToDo: The essense of co_yield ? Contents \u00b6 enumerable<T> sequence<T>","title":"Yield overview"},{"location":"features/yield-overview/#references","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"References"},{"location":"features/yield-overview/#background","text":"I strongly recomment the last two materials. Andreas Reischuck's explanation will be a good time saver for you. ToDo: The essense of co_yield ?","title":"Background"},{"location":"features/yield-overview/#contents","text":"enumerable<T> sequence<T>","title":"Contents"},{"location":"features/yield-sequence/","text":"Generator + Async Iterator See Also \u00b6 <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck sequence<T> \u00b6 sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. This type should be used carefully . It is not recommended in general, and there might be a bug(failure) on release mode with clang compiler . Contrary to that, MSVC works well with the optimization flag . template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters \u00b6 T : the type of element in the sequence. Default Operations \u00b6 Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... } Functions \u00b6 Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Type: promise_type \u00b6 The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Type: iterator \u00b6 Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; }; Examples \u00b6 You can see the usage with test codes. Use of co_yield with awaitable What if the function yields 0-time? Destruction Frame's status Iteration Suspend with co_await Suspend with co_yield See Also \u00b6 In this library: Type frame","title":"Yield sequence"},{"location":"features/yield-sequence/#see-also","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"See Also"},{"location":"features/yield-sequence/#sequencelttgt","text":"sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. This type should be used carefully . It is not recommended in general, and there might be a bug(failure) on release mode with clang compiler . Contrary to that, MSVC works well with the optimization flag . template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"sequence&lt;T&gt;"},{"location":"features/yield-sequence/#template-parameters","text":"T : the type of element in the sequence.","title":"Template Parameters"},{"location":"features/yield-sequence/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... }","title":"Default Operations"},{"location":"features/yield-sequence/#functions","text":"Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"features/yield-sequence/#type-promise_type","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Type: promise_type"},{"location":"features/yield-sequence/#type-iterator","text":"Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Type: iterator"},{"location":"features/yield-sequence/#examples","text":"You can see the usage with test codes. Use of co_yield with awaitable What if the function yields 0-time? Destruction Frame's status Iteration Suspend with co_await Suspend with co_yield","title":"Examples"},{"location":"features/yield-sequence/#see-also_1","text":"In this library: Type frame","title":"See Also"},{"location":"howto/build-using-cmake/","text":"How To Build: CMake Project \u00b6 Known Configurations? \u00b6 This library relies on various CI services. I'm testing the build with the multiple config files. Just follow those files and compare with the build log. It won't be that hard :) You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue! Ubuntu Linux \u00b6 Travis CI : dist: xenial Azure Pipelines : ubuntu-16.04 AppVeyor : Ubuntu 18.04 I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions. Installing libc++ \u00b6 By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ; Android \u00b6 Travis CI : language: android I'm considering to deprecate Android build with NDK because of the CMake version in it :( Mac OS \u00b6 Azure Pipelines : macos-latest iPhone OS \u00b6 Travis CI : osx_image: xcode10.1 Special thanks to https://github.com/leetal/ios-cmake !!! Windows \u00b6 Azure Pipelines : Visual Studio 2017 AppVeyor : Visual Studio 2017, 2019 You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build. Visual Studio \u00b6 Just set the Generator as Visual Studio. git clone https : // github . com / luncliff / coroutine Push-Location coroutine ; cmake .. -G \"Visual Studio 15 2017 Win64\" -DUSE_PORTABLE_HEADER = \"true\" Pop-Location ; LLVM Clang-cl \u00b6 Currently, I recommend static build for clang-cl . But the DLL build is also available for current master branch. To do so, please reference the AppVeyor build steps . Install Chocolatey & Required Packages \u00b6 Chocolatey can be installed easily. Follow guide of the official page . We need 2 packages. choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... The clang-cl will invoke the clang appropriately . So if clang-cl works well, then all setup is done correctly. $ clang-cl --version ...","title":"How To Build: CMake Project"},{"location":"howto/build-using-cmake/#how-to-build-cmake-project","text":"","title":"How To Build: CMake Project"},{"location":"howto/build-using-cmake/#known-configurations","text":"This library relies on various CI services. I'm testing the build with the multiple config files. Just follow those files and compare with the build log. It won't be that hard :) You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue!","title":"Known Configurations?"},{"location":"howto/build-using-cmake/#ubuntu-linux","text":"Travis CI : dist: xenial Azure Pipelines : ubuntu-16.04 AppVeyor : Ubuntu 18.04 I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions.","title":"Ubuntu Linux"},{"location":"howto/build-using-cmake/#installing-libc","text":"By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ;","title":"Installing libc++"},{"location":"howto/build-using-cmake/#android","text":"Travis CI : language: android I'm considering to deprecate Android build with NDK because of the CMake version in it :(","title":"Android"},{"location":"howto/build-using-cmake/#mac-os","text":"Azure Pipelines : macos-latest","title":"Mac OS"},{"location":"howto/build-using-cmake/#iphone-os","text":"Travis CI : osx_image: xcode10.1 Special thanks to https://github.com/leetal/ios-cmake !!!","title":"iPhone OS"},{"location":"howto/build-using-cmake/#windows","text":"Azure Pipelines : Visual Studio 2017 AppVeyor : Visual Studio 2017, 2019 You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build.","title":"Windows"},{"location":"howto/build-using-cmake/#visual-studio","text":"Just set the Generator as Visual Studio. git clone https : // github . com / luncliff / coroutine Push-Location coroutine ; cmake .. -G \"Visual Studio 15 2017 Win64\" -DUSE_PORTABLE_HEADER = \"true\" Pop-Location ;","title":"Visual Studio"},{"location":"howto/build-using-cmake/#llvm-clang-cl","text":"Currently, I recommend static build for clang-cl . But the DLL build is also available for current master branch. To do so, please reference the AppVeyor build steps .","title":"LLVM Clang-cl"},{"location":"howto/build-using-cmake/#install-chocolatey-required-packages","text":"Chocolatey can be installed easily. Follow guide of the official page . We need 2 packages. choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... The clang-cl will invoke the clang appropriately . So if clang-cl works well, then all setup is done correctly. $ clang-cl --version ...","title":"Install Chocolatey &amp; Required Packages"},{"location":"howto/build-using-visualstudio/","text":"How To Build: Visual Studio \u00b6 Before Build ... \u00b6 Check the Windows SDK and Visual Studio \u00b6 Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration . Follow the steps! \u00b6 Clone the repo and submodules \u00b6 Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' Open the Visual Studio \u00b6 Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now. Review the modules/windows.vcxproj \u00b6 Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!) Try The Build/Test! \u00b6 Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"How To Build: Visual Studio"},{"location":"howto/build-using-visualstudio/#how-to-build-visual-studio","text":"","title":"How To Build: Visual Studio"},{"location":"howto/build-using-visualstudio/#before-build","text":"","title":"Before Build ..."},{"location":"howto/build-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration .","title":"Check the Windows SDK and Visual Studio"},{"location":"howto/build-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"howto/build-using-visualstudio/#clone-the-repo-and-submodules","text":"Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a'","title":"Clone the repo and submodules"},{"location":"howto/build-using-visualstudio/#open-the-visual-studio","text":"Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Open the Visual Studio"},{"location":"howto/build-using-visualstudio/#review-the-moduleswindowsvcxproj","text":"Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!)","title":"Review the modules/windows.vcxproj"},{"location":"howto/build-using-visualstudio/#try-the-buildtest","text":"Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"Try The Build/Test!"},{"location":"howto/import-using-cmake/","text":"How To Import: CMake Project \u00b6 Package Support? \u00b6 Does this library support any package manager? \u00b6 Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well! Try with the Vcpkg \u00b6 This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine) Follow the steps! \u00b6 Check your environment \u00b6 If you didn't checked your project's configuration, please do review this document first . Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD . You don't have to check yourself since CMake will do that. Just be aware of it. cmake_minimum_required ( VERSION 3.8 ) Installing GSL(Guideline Support Library) \u00b6 The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include Call add_subdirectory \u00b6 Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine ) Test will be skipped automatically \u00b6 The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif () Call target_link_libraries \u00b6 The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine ) Questions & Trouble Shooting \u00b6 Report your troubles!","title":"How To Import: CMake Project"},{"location":"howto/import-using-cmake/#how-to-import-cmake-project","text":"","title":"How To Import: CMake Project"},{"location":"howto/import-using-cmake/#package-support","text":"","title":"Package Support?"},{"location":"howto/import-using-cmake/#does-this-library-support-any-package-manager","text":"Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well!","title":"Does this library support any package manager?"},{"location":"howto/import-using-cmake/#try-with-the-vcpkg","text":"This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine)","title":"Try with the Vcpkg"},{"location":"howto/import-using-cmake/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"howto/import-using-cmake/#check-your-environment","text":"If you didn't checked your project's configuration, please do review this document first . Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD . You don't have to check yourself since CMake will do that. Just be aware of it. cmake_minimum_required ( VERSION 3.8 )","title":"Check your environment"},{"location":"howto/import-using-cmake/#installing-gslguideline-support-library","text":"The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include","title":"Installing GSL(Guideline Support Library)"},{"location":"howto/import-using-cmake/#call-add_subdirectory","text":"Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine )","title":"Call add_subdirectory"},{"location":"howto/import-using-cmake/#test-will-be-skipped-automatically","text":"The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif ()","title":"Test will be skipped automatically"},{"location":"howto/import-using-cmake/#call-target_link_libraries","text":"The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine )","title":"Call target_link_libraries"},{"location":"howto/import-using-cmake/#questions-trouble-shooting","text":"Report your troubles!","title":"Questions &amp; Trouble Shooting"},{"location":"howto/import-using-visualstudio/","text":"How To Import: Visual Studio \u00b6 Before Import ... \u00b6 Check the Windows SDK and Visual Studio ! \u00b6 The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ... Follow the steps! \u00b6 Create a new C++ Solution/Project \u00b6 Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :) Import VC++ Project \u00b6 We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now. Add Existing Project \u00b6 If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters. Add Reference \u00b6 Now, change the reference of the ConsoleApplication1 project. Adjustment for the modules/windows.vcxproj \u00b6 Include Directories \u00b6 With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option. MSVC Compier Options \u00b6 To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image. Linker Options \u00b6 Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you. Try this example \u00b6 So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include <iostream> #include <gsl/gsl> #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using namespace coro ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> forget_frame { co_await suspend_never {}; std :: cout << \"C++ Coroutines! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } You can run the code with the Compiler Explorer . Questions & Trouble Shooting \u00b6 Report your troubles! Build with the Clang-cl ? \u00b6 Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"How To Import: Visual Studio"},{"location":"howto/import-using-visualstudio/#how-to-import-visual-studio","text":"","title":"How To Import: Visual Studio"},{"location":"howto/import-using-visualstudio/#before-import","text":"","title":"Before Import ..."},{"location":"howto/import-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ...","title":"Check the Windows SDK and Visual Studio !"},{"location":"howto/import-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"howto/import-using-visualstudio/#create-a-new-c-solutionproject","text":"Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :)","title":"Create a new C++ Solution/Project"},{"location":"howto/import-using-visualstudio/#import-vc-project","text":"We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Import VC++ Project"},{"location":"howto/import-using-visualstudio/#add-existing-project","text":"If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters.","title":"Add Existing Project"},{"location":"howto/import-using-visualstudio/#add-reference","text":"Now, change the reference of the ConsoleApplication1 project.","title":"Add Reference"},{"location":"howto/import-using-visualstudio/#adjustment-for-the-moduleswindowsvcxproj","text":"","title":"Adjustment for the modules/windows.vcxproj"},{"location":"howto/import-using-visualstudio/#include-directories","text":"With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option.","title":"Include Directories"},{"location":"howto/import-using-visualstudio/#msvc-compier-options","text":"To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image.","title":"MSVC Compier Options"},{"location":"howto/import-using-visualstudio/#linker-options","text":"Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you.","title":"Linker Options"},{"location":"howto/import-using-visualstudio/#try-this-example","text":"So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include <iostream> #include <gsl/gsl> #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using namespace coro ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> forget_frame { co_await suspend_never {}; std :: cout << \"C++ Coroutines! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } You can run the code with the Compiler Explorer .","title":"Try this example"},{"location":"howto/import-using-visualstudio/#questions-trouble-shooting","text":"Report your troubles!","title":"Questions &amp; Trouble Shooting"},{"location":"howto/import-using-visualstudio/#build-with-the-clang-cl","text":"Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"Build with the Clang-cl ?"},{"location":"howto/start-using-cmake/","text":"How To Start: CMake \u00b6 Welcome! Well, this part is not about CMake's usage, nor setup of the CMake for your environment. I'd like to give the minimum CMake example for your project here. CMake's Version ? \u00b6 At this moment(2019), I recommend you to use at least CMake 3.8 or later. The version is allows you to specify 17 for the CXX_STANDARD property(It will be commented). But that's not the necessary step . Indeed the key part not the cmake but the compiler itself! If you already aware of your developer environment, forget about that recommendation! For the examples below, I will keep specifing flags related to C++ standard. Unless you are in some complicated situation, just 3.x will be fine. Library: Header-Only \u00b6 coroutine_portable is the only interface target in this example project. If you prefer to write header-only style codes, simply designating the path and flags will be enough. cmake_minimum_requried ( VERSION 3.6 ) # start a project. # defines cmake variables like PROJECT_NAME and PROJECT_SOURCE_DIR project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_headers INTERFACE ) set_target_properties ( my_coroutine_headers PROPERTIES # macro defintions INTERFACE_COMPILE_DEFINITIONS \"${CMAKE_SYSTEM_NAME}\" ) message ( STATUS \"macro defined: ${CMAKE_SYSTEM_NAME}\" ) # header include path target_include_directories ( my_coroutine_headers INTERFACE # path for `add_subdirectoy` $< BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include > # path after installation ( cmake --build . --target install ) $< INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include > ) Dealing with the compilers and their flags \u00b6 I strongly recommend to define compile options together so CMake can propagate them and reduce redundant compile option definitons in 'CMakeLists.txt' or '*.cmake' files. To do that, you have to check compiler. if ( ${ CMAKE_CXX_COMPILER_ID } MATCHES Clang ) if ( WIN32 ) # clang-cl for windows target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest -fms-compatibility -Xclang -fcoroutines-ts ) # for multiple definitions, you can do like this set_target_properties ( my_coroutine_headers PROPERTIES INTERFACE_COMPILE_DEFINITIONS \"CLANG_CL;_RESUMABLE_FUNCTIONS_SUPPORTED\" ) elseif ( UNIX OR APPLE ) # Clang or AppleClang target_compile_options ( my_coroutine_headers INTERFACE -std=c++2a -stdlib=libc++ -fcoroutines-ts ) endif () elseif ( MSVC ) target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest /await ) elseif ( ${ CMAKE_CXX_COMPILER_ID } MATCHES GNU ) target_compile_options ( my_coroutine_headers INTERFACE -std=gnu++2a -fcoroutines -fno-exceptions ) endif () Notice that I placed Clang ahead of MSVC. Even though clang-cl is specified with CMAKE_CXX_COMPILER , the CMake branch into the MSVC scope. In ohter words, it behaves like it's reusing WIN32 for the variable. So to be precise you always have to check the compiler familiy is clang. Library \u00b6 The only difference is that you have to list your source/header files in add_libary . cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_lib # ... list of source files in relative path ... # ... libmain.cpp ) set_target_properties ( my_coroutine_lib PROPERTIES CXX_STANDARD 14 # for CMake 3.8, you can use '17' here # for CMake 3.14, it can be '20' ) If some source files are platform dependent or requires some condition, use target_source function. if ( WIN32 ) target_source ( my_coroutine_lib PRIVATE impl_windows.cpp ) elseif ( APPLE ) target_source ( my_coroutine_lib PRIVATE impl_darwin.cpp ) elseif ( UNIX ) target_source ( my_coroutine_lib PRIVATE impl_unix.cpp ) endif () Since I already showed how to use compiler flags for C++ Coroutines, you can just copy & paste the part. The other way is to use target_link_libraries function, and inherit those 'interface' or 'public' compiler options. # PUBLIC: propagate these library dependencies # PRIVATE: consume and hide those dependencies target_link_libraries ( my_coroutine_lib PUBLIC my_coroutine_headers ) Isn't it simple? In this project, coroutine_event is defined like this. Executable \u00b6 If you already created some targets with add_library , the only thing you have to do is define an executable and to link it with the library. cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_executable ( my_coroutine_exe # ... list of source files in relative path ... # ... main.cpp ) target_link_libraries ( my_coroutine_exe PRIVATE my_coroutine_headers my_coroutine_lib ) That's all ! \u00b6 If you want to know more about the CMake and its usage, I recommend these materials. https://github.com/ruslo/CGold https://cliutils.gitlab.io/modern-cmake/","title":"How To Start: CMake"},{"location":"howto/start-using-cmake/#how-to-start-cmake","text":"Welcome! Well, this part is not about CMake's usage, nor setup of the CMake for your environment. I'd like to give the minimum CMake example for your project here.","title":"How To Start: CMake"},{"location":"howto/start-using-cmake/#cmakes-version","text":"At this moment(2019), I recommend you to use at least CMake 3.8 or later. The version is allows you to specify 17 for the CXX_STANDARD property(It will be commented). But that's not the necessary step . Indeed the key part not the cmake but the compiler itself! If you already aware of your developer environment, forget about that recommendation! For the examples below, I will keep specifing flags related to C++ standard. Unless you are in some complicated situation, just 3.x will be fine.","title":"CMake's Version ?"},{"location":"howto/start-using-cmake/#library-header-only","text":"coroutine_portable is the only interface target in this example project. If you prefer to write header-only style codes, simply designating the path and flags will be enough. cmake_minimum_requried ( VERSION 3.6 ) # start a project. # defines cmake variables like PROJECT_NAME and PROJECT_SOURCE_DIR project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_headers INTERFACE ) set_target_properties ( my_coroutine_headers PROPERTIES # macro defintions INTERFACE_COMPILE_DEFINITIONS \"${CMAKE_SYSTEM_NAME}\" ) message ( STATUS \"macro defined: ${CMAKE_SYSTEM_NAME}\" ) # header include path target_include_directories ( my_coroutine_headers INTERFACE # path for `add_subdirectoy` $< BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include > # path after installation ( cmake --build . --target install ) $< INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include > )","title":"Library: Header-Only"},{"location":"howto/start-using-cmake/#dealing-with-the-compilers-and-their-flags","text":"I strongly recommend to define compile options together so CMake can propagate them and reduce redundant compile option definitons in 'CMakeLists.txt' or '*.cmake' files. To do that, you have to check compiler. if ( ${ CMAKE_CXX_COMPILER_ID } MATCHES Clang ) if ( WIN32 ) # clang-cl for windows target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest -fms-compatibility -Xclang -fcoroutines-ts ) # for multiple definitions, you can do like this set_target_properties ( my_coroutine_headers PROPERTIES INTERFACE_COMPILE_DEFINITIONS \"CLANG_CL;_RESUMABLE_FUNCTIONS_SUPPORTED\" ) elseif ( UNIX OR APPLE ) # Clang or AppleClang target_compile_options ( my_coroutine_headers INTERFACE -std=c++2a -stdlib=libc++ -fcoroutines-ts ) endif () elseif ( MSVC ) target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest /await ) elseif ( ${ CMAKE_CXX_COMPILER_ID } MATCHES GNU ) target_compile_options ( my_coroutine_headers INTERFACE -std=gnu++2a -fcoroutines -fno-exceptions ) endif () Notice that I placed Clang ahead of MSVC. Even though clang-cl is specified with CMAKE_CXX_COMPILER , the CMake branch into the MSVC scope. In ohter words, it behaves like it's reusing WIN32 for the variable. So to be precise you always have to check the compiler familiy is clang.","title":"Dealing with the compilers and their flags"},{"location":"howto/start-using-cmake/#library","text":"The only difference is that you have to list your source/header files in add_libary . cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_lib # ... list of source files in relative path ... # ... libmain.cpp ) set_target_properties ( my_coroutine_lib PROPERTIES CXX_STANDARD 14 # for CMake 3.8, you can use '17' here # for CMake 3.14, it can be '20' ) If some source files are platform dependent or requires some condition, use target_source function. if ( WIN32 ) target_source ( my_coroutine_lib PRIVATE impl_windows.cpp ) elseif ( APPLE ) target_source ( my_coroutine_lib PRIVATE impl_darwin.cpp ) elseif ( UNIX ) target_source ( my_coroutine_lib PRIVATE impl_unix.cpp ) endif () Since I already showed how to use compiler flags for C++ Coroutines, you can just copy & paste the part. The other way is to use target_link_libraries function, and inherit those 'interface' or 'public' compiler options. # PUBLIC: propagate these library dependencies # PRIVATE: consume and hide those dependencies target_link_libraries ( my_coroutine_lib PUBLIC my_coroutine_headers ) Isn't it simple? In this project, coroutine_event is defined like this.","title":"Library"},{"location":"howto/start-using-cmake/#executable","text":"If you already created some targets with add_library , the only thing you have to do is define an executable and to link it with the library. cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_executable ( my_coroutine_exe # ... list of source files in relative path ... # ... main.cpp ) target_link_libraries ( my_coroutine_exe PRIVATE my_coroutine_headers my_coroutine_lib )","title":"Executable"},{"location":"howto/start-using-cmake/#thats-all","text":"If you want to know more about the CMake and its usage, I recommend these materials. https://github.com/ruslo/CGold https://cliutils.gitlab.io/modern-cmake/","title":"That's all !"},{"location":"ppt/Exploring-the-Cpp-Coroutine/","text":"Exploring the C++ Coroutine: Approach, Compiler, and Issues \u00b6 Note \u00b6 I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :) Links \u00b6 PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"C++ Korea 5th Seminar"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#exploring-the-c-coroutine-approach-compiler-and-issues","text":"","title":"Exploring the C++ Coroutine: Approach, Compiler, and Issues"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#note","text":"I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :)","title":"Note"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#links","text":"PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"Links"}]}