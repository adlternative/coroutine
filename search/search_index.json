{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The document follows master branch If you have opinion for the docs, please create an issue and suggest your idea. Let me hear you and write more helpful contents. :D First with the C++ 20 Coroutines? \u00b6 If you're longing for the good references , visit the MattPD's collection ! Developer Note \u00b6 This example project started with the post in 2017.02 . Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here! Library Features? \u00b6 Clone the master branch and start your dive! :)","title":"Home"},{"location":"#first-with-the-c-20-coroutines","text":"If you're longing for the good references , visit the MattPD's collection !","title":"First with the C++ 20 Coroutines?"},{"location":"#developer-note","text":"This example project started with the post in 2017.02 . Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here!","title":"Developer Note"},{"location":"#library-features","text":"Clone the master branch and start your dive! :)","title":"Library Features?"},{"location":"annotated/","text":"Class List \u00b6 Here are the classes, structs, unions and interfaces with brief descriptions: struct clang_frame_prefix namespace coro struct bypass_mutex Lockable without lock operation. class channel C++ Coroutines based channel. class channel_peeker Extension of channel_reader for subroutines. class channel_reader Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class channel_writer Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class enumerable class iterator class promise_type class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __ namespace internal class list Linked list without allocation. class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class kqueue_owner RAII wrapping for kqueue file descriptor. class promise_aa class promise_an class promise_na class promise_nn class pthread_detacher_t Special return type that wraps pthread_detach __ class promise_type class pthread_joiner_t Special return type that wraps pthread_join __ class promise_type class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class section Standard lockable with win32 criticial section. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. struct gcc_frame_prefix namespace gsl struct msvc_frame_prefix namespace std namespace experimental class coroutine_handle class coroutine_handle< noop_coroutine_promise > class coroutine_handle< void > union prefix_t struct coroutine_traits struct coroutine_traits< void, P... > Allow void return of the coroutine. struct promise_type struct noop_coroutine_promise class suspend_always class suspend_never namespace chrono","title":"Class List"},{"location":"annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: struct clang_frame_prefix namespace coro struct bypass_mutex Lockable without lock operation. class channel C++ Coroutines based channel. class channel_peeker Extension of channel_reader for subroutines. class channel_reader Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class channel_writer Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class enumerable class iterator class promise_type class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __ namespace internal class list Linked list without allocation. class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class kqueue_owner RAII wrapping for kqueue file descriptor. class promise_aa class promise_an class promise_na class promise_nn class pthread_detacher_t Special return type that wraps pthread_detach __ class promise_type class pthread_joiner_t Special return type that wraps pthread_join __ class promise_type class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class section Standard lockable with win32 criticial section. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. struct gcc_frame_prefix namespace gsl struct msvc_frame_prefix namespace std namespace experimental class coroutine_handle class coroutine_handle< noop_coroutine_promise > class coroutine_handle< void > union prefix_t struct coroutine_traits struct coroutine_traits< void, P... > Allow void return of the coroutine. struct promise_type struct noop_coroutine_promise class suspend_always class suspend_never namespace chrono","title":"Class List"},{"location":"channel_8hpp/","text":"File channel.hpp \u00b6 File List > coroutine > channel.hpp Go to the source code of this file. C++ Coroutines based channel. It's a simplified form of the channel in The Go Language. More... #include <mutex> #include <tuple> Namespaces \u00b6 Type Name namespace coro namespace internal Classes \u00b6 Type Name struct bypass_mutex Lockable without lock operation. class channel <T, M> C++ Coroutines based channel. class channel <T, M> C++ Coroutines based channel. class channel_peeker <typename T, typename M> Extension of channel_reader for subroutines. class channel_peeker <typename T, typename M> Extension of channel_reader for subroutines. class channel_reader <typename T, typename M> Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class channel_reader <typename T, typename M> Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class channel_writer <typename T, typename M> Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class channel_writer <typename T, typename M> Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class list <T> Linked list without allocation. Macros \u00b6 Type Name define LUNCLIFF_COROUTINE_CHANNEL_HPP Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 Macro Definition Documentation \u00b6 define LUNCLIFF_COROUTINE_CHANNEL_HPP \u00b6 #define LUNCLIFF_COROUTINE_CHANNEL_HPP The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"File channel.hpp"},{"location":"channel_8hpp/#file-channelhpp","text":"File List > coroutine > channel.hpp Go to the source code of this file. C++ Coroutines based channel. It's a simplified form of the channel in The Go Language. More... #include <mutex> #include <tuple>","title":"File channel.hpp"},{"location":"channel_8hpp/#namespaces","text":"Type Name namespace coro namespace internal","title":"Namespaces"},{"location":"channel_8hpp/#classes","text":"Type Name struct bypass_mutex Lockable without lock operation. class channel <T, M> C++ Coroutines based channel. class channel <T, M> C++ Coroutines based channel. class channel_peeker <typename T, typename M> Extension of channel_reader for subroutines. class channel_peeker <typename T, typename M> Extension of channel_reader for subroutines. class channel_reader <typename T, typename M> Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class channel_reader <typename T, typename M> Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class channel_writer <typename T, typename M> Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class channel_writer <typename T, typename M> Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class list <T> Linked list without allocation.","title":"Classes"},{"location":"channel_8hpp/#macros","text":"Type Name define LUNCLIFF_COROUTINE_CHANNEL_HPP","title":"Macros"},{"location":"channel_8hpp/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0","title":"Detailed Description"},{"location":"channel_8hpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"channel_8hpp/#define-luncliff_coroutine_channel_hpp","text":"#define LUNCLIFF_COROUTINE_CHANNEL_HPP The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"define LUNCLIFF_COROUTINE_CHANNEL_HPP"},{"location":"channel_8hpp_source/","text":"File channel.hpp \u00b6 File List > coroutine > channel.hpp Go to the documentation of this file. #pragma once #ifndef LUNCLIFF_COROUTINE_CHANNEL_HPP #define LUNCLIFF_COROUTINE_CHANNEL_HPP #include <mutex> #include <tuple> #if __has_include(<coroutine>) // C++ 20 #include <coroutine> namespace coro { using namespace std ; #elif __has_include(<coroutine/frame.h>) #include <coroutine/frame.h> namespace coro { using namespace std ; using namespace std :: experimental ; #elif __has_include(<experimental/coroutine>) // C++ 17 #include <experimental/coroutine> namespace coro { using namespace std ; using namespace std :: experimental ; #else #error \"expect header <experimental/coroutine> or <coroutine/frame.h>\" namespace coro { #endif struct bypass_mutex final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { } constexpr void unlock () noexcept { } }; namespace internal { static void * poison () noexcept ( false ) { return reinterpret_cast < void *> ( 0xFADE ' 03 8 C ' BCFA ' 9E64 ); } template < typename T > class list { T * head {}; T * tail {}; public : bool is_empty () const noexcept ( false ) { return head == nullptr ; } void push ( T * node ) noexcept ( false ) { if ( tail ) { tail -> next = node ; tail = node ; } else head = tail = node ; } auto pop () noexcept ( false ) -> T * { T * node = head ; if ( head == tail ) // empty or 1 head = tail = nullptr ; else // 2 or more head = head -> next ; return node ; } }; } // namespace internal template < typename T , typename M = bypass_mutex > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel_reader ; template < typename T , typename M > class channel_writer ; template < typename T , typename M > class channel_peeker ; template < typename T , typename M > class channel_reader { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader_list = typename channel_type :: reader_list ; using writer = typename channel_type :: writer ; using writer_list = typename channel_type :: writer_list ; friend channel_type ; friend writer ; friend reader_list ; protected : mutable pointer ptr ; mutable void * frame ; union { channel_reader * next = nullptr ; channel_type * chan ; }; protected : explicit channel_reader ( channel_type & ch ) noexcept ( false ) : ptr {}, frame { nullptr }, chan { addressof ( ch )} { } channel_reader ( const channel_reader & ) noexcept = delete ; channel_reader & operator = ( const channel_reader & ) noexcept = delete ; channel_reader ( channel_reader && ) noexcept = delete ; channel_reader & operator = ( channel_reader && ) noexcept = delete ; public : ~ channel_reader () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> writer_list :: is_empty ()) // await_suspend will unlock in the case return false ; writer * w = chan -> writer_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); // remember handle before push/unlock this -> frame = coro . address (); this -> next = nullptr ; // push to channel ch . reader_list :: push ( this ); ch . mtx . unlock (); } auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is under destruction if ( this -> frame == internal :: poison ()) return t ; // the resume operation can destroy the other coroutine // store before resume get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; template < typename T , typename M > class channel_writer { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader = typename channel_type :: reader ; using reader_list = typename channel_type :: reader_list ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend reader ; friend writer_list ; friend peeker ; // for `peek()` implementation private : mutable pointer ptr ; mutable void * frame ; union { channel_writer * next = nullptr ; channel_type * chan ; }; private : explicit channel_writer ( channel_type & ch , pointer pv ) noexcept ( false ) : ptr { pv }, frame { nullptr }, chan { addressof ( ch )} { } channel_writer ( const channel_writer & ) noexcept = delete ; channel_writer & operator = ( const channel_writer & ) noexcept = delete ; channel_writer ( channel_writer && ) noexcept = delete ; channel_writer & operator = ( channel_writer && ) noexcept = delete ; public : ~ channel_writer () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> reader_list :: is_empty ()) // await_suspend will unlock in the case return false ; reader * r = chan -> reader_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , r -> ptr ); swap ( this -> frame , r -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . writer_list :: push ( this ); // push to channel ch . mtx . unlock (); } bool await_resume () noexcept ( false ) { // frame holds poision if the channel is under destruction if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; template < typename T , typename M > class channel final : internal :: list < channel_reader < T , M >> , internal :: list < channel_writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); public : using value_type = T ; using pointer = value_type * ; using reference = value_type & ; using mutex_type = M ; private : using reader = channel_reader < value_type , mutex_type > ; using reader_list = internal :: list < reader > ; using writer = channel_writer < value_type , mutex_type > ; using writer_list = internal :: list < writer > ; using peeker = channel_peeker < value_type , mutex_type > ; friend reader ; friend writer ; friend peeker ; // for `peek()` implementation private : mutex_type mtx {}; private : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; public : channel () noexcept ( false ) : reader_list {}, writer_list {}, mtx {} { } ~ channel () noexcept ( false ) { void * closing = internal :: poison (); writer_list & writers = * this ; reader_list & readers = * this ; // even 5'000+ can be unsafe for hazard usage ... size_t repeat = 1 ; do { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = closing ; coro . resume (); } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = closing ; coro . resume (); } } while ( repeat -- ); } public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return channel_writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return channel_reader { * this }; } }; template < typename T , typename M > class channel_peeker final : protected channel_reader < T , M > { using channel_type = channel < T , M > ; using writer = typename channel_type :: writer ; private : channel_peeker ( const channel_peeker & ) noexcept ( false ) = delete ; channel_peeker ( channel_peeker && ) noexcept ( false ) = delete ; channel_peeker & operator = ( const channel_peeker & ) noexcept ( false ) = delete ; channel_peeker & operator = ( channel_peeker && ) noexcept ( false ) = delete ; public : explicit channel_peeker ( channel_type & ch ) noexcept ( false ) : channel_reader < T , M > { ch } { } ~ channel_peeker () noexcept = default ; public : void peek () const noexcept ( false ) { unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( T & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( channel_reader < T , M > ) == sizeof ( channel_peeker < T , M > )); channel_peeker p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } template < typename ... Args , typename Ch , typename Fn > void select ( Ch & ch , Fn && fn , Args && ... args ) noexcept ( false ) { select ( ch , forward < Fn &&> ( fn )); // evaluate return select ( forward < Args &&> ( args )...); // try next pair } } // namespace coro #endif // LUNCLIFF_COROUTINE_CHANNEL_HPP","title":"File channel.hpp"},{"location":"channel_8hpp_source/#file-channelhpp","text":"File List > coroutine > channel.hpp Go to the documentation of this file. #pragma once #ifndef LUNCLIFF_COROUTINE_CHANNEL_HPP #define LUNCLIFF_COROUTINE_CHANNEL_HPP #include <mutex> #include <tuple> #if __has_include(<coroutine>) // C++ 20 #include <coroutine> namespace coro { using namespace std ; #elif __has_include(<coroutine/frame.h>) #include <coroutine/frame.h> namespace coro { using namespace std ; using namespace std :: experimental ; #elif __has_include(<experimental/coroutine>) // C++ 17 #include <experimental/coroutine> namespace coro { using namespace std ; using namespace std :: experimental ; #else #error \"expect header <experimental/coroutine> or <coroutine/frame.h>\" namespace coro { #endif struct bypass_mutex final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { } constexpr void unlock () noexcept { } }; namespace internal { static void * poison () noexcept ( false ) { return reinterpret_cast < void *> ( 0xFADE ' 03 8 C ' BCFA ' 9E64 ); } template < typename T > class list { T * head {}; T * tail {}; public : bool is_empty () const noexcept ( false ) { return head == nullptr ; } void push ( T * node ) noexcept ( false ) { if ( tail ) { tail -> next = node ; tail = node ; } else head = tail = node ; } auto pop () noexcept ( false ) -> T * { T * node = head ; if ( head == tail ) // empty or 1 head = tail = nullptr ; else // 2 or more head = head -> next ; return node ; } }; } // namespace internal template < typename T , typename M = bypass_mutex > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel_reader ; template < typename T , typename M > class channel_writer ; template < typename T , typename M > class channel_peeker ; template < typename T , typename M > class channel_reader { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader_list = typename channel_type :: reader_list ; using writer = typename channel_type :: writer ; using writer_list = typename channel_type :: writer_list ; friend channel_type ; friend writer ; friend reader_list ; protected : mutable pointer ptr ; mutable void * frame ; union { channel_reader * next = nullptr ; channel_type * chan ; }; protected : explicit channel_reader ( channel_type & ch ) noexcept ( false ) : ptr {}, frame { nullptr }, chan { addressof ( ch )} { } channel_reader ( const channel_reader & ) noexcept = delete ; channel_reader & operator = ( const channel_reader & ) noexcept = delete ; channel_reader ( channel_reader && ) noexcept = delete ; channel_reader & operator = ( channel_reader && ) noexcept = delete ; public : ~ channel_reader () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> writer_list :: is_empty ()) // await_suspend will unlock in the case return false ; writer * w = chan -> writer_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); // remember handle before push/unlock this -> frame = coro . address (); this -> next = nullptr ; // push to channel ch . reader_list :: push ( this ); ch . mtx . unlock (); } auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is under destruction if ( this -> frame == internal :: poison ()) return t ; // the resume operation can destroy the other coroutine // store before resume get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; template < typename T , typename M > class channel_writer { public : using value_type = T ; using pointer = T * ; using reference = T & ; using channel_type = channel < T , M > ; private : using reader = typename channel_type :: reader ; using reader_list = typename channel_type :: reader_list ; using writer_list = typename channel_type :: writer_list ; using peeker = typename channel_type :: peeker ; friend channel_type ; friend reader ; friend writer_list ; friend peeker ; // for `peek()` implementation private : mutable pointer ptr ; mutable void * frame ; union { channel_writer * next = nullptr ; channel_type * chan ; }; private : explicit channel_writer ( channel_type & ch , pointer pv ) noexcept ( false ) : ptr { pv }, frame { nullptr }, chan { addressof ( ch )} { } channel_writer ( const channel_writer & ) noexcept = delete ; channel_writer & operator = ( const channel_writer & ) noexcept = delete ; channel_writer ( channel_writer && ) noexcept = delete ; channel_writer & operator = ( channel_writer && ) noexcept = delete ; public : ~ channel_writer () noexcept = default ; public : bool await_ready () const noexcept ( false ) { chan -> mtx . lock (); if ( chan -> reader_list :: is_empty ()) // await_suspend will unlock in the case return false ; reader * r = chan -> reader_list :: pop (); // exchange address & resumeable_handle swap ( this -> ptr , r -> ptr ); swap ( this -> frame , r -> frame ); chan -> mtx . unlock (); return true ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // notice that next & chan are sharing memory channel_type & ch = * ( this -> chan ); this -> frame = coro . address (); // remember handle before push/unlock this -> next = nullptr ; // clear to prevent confusing ch . writer_list :: push ( this ); // push to channel ch . mtx . unlock (); } bool await_resume () noexcept ( false ) { // frame holds poision if the channel is under destruction if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; template < typename T , typename M > class channel final : internal :: list < channel_reader < T , M >> , internal :: list < channel_writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); public : using value_type = T ; using pointer = value_type * ; using reference = value_type & ; using mutex_type = M ; private : using reader = channel_reader < value_type , mutex_type > ; using reader_list = internal :: list < reader > ; using writer = channel_writer < value_type , mutex_type > ; using writer_list = internal :: list < writer > ; using peeker = channel_peeker < value_type , mutex_type > ; friend reader ; friend writer ; friend peeker ; // for `peek()` implementation private : mutex_type mtx {}; private : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; public : channel () noexcept ( false ) : reader_list {}, writer_list {}, mtx {} { } ~ channel () noexcept ( false ) { void * closing = internal :: poison (); writer_list & writers = * this ; reader_list & readers = * this ; // even 5'000+ can be unsafe for hazard usage ... size_t repeat = 1 ; do { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = closing ; coro . resume (); } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = closing ; coro . resume (); } } while ( repeat -- ); } public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return channel_writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return channel_reader { * this }; } }; template < typename T , typename M > class channel_peeker final : protected channel_reader < T , M > { using channel_type = channel < T , M > ; using writer = typename channel_type :: writer ; private : channel_peeker ( const channel_peeker & ) noexcept ( false ) = delete ; channel_peeker ( channel_peeker && ) noexcept ( false ) = delete ; channel_peeker & operator = ( const channel_peeker & ) noexcept ( false ) = delete ; channel_peeker & operator = ( channel_peeker && ) noexcept ( false ) = delete ; public : explicit channel_peeker ( channel_type & ch ) noexcept ( false ) : channel_reader < T , M > { ch } { } ~ channel_peeker () noexcept = default ; public : void peek () const noexcept ( false ) { unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( T & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( channel_reader < T , M > ) == sizeof ( channel_peeker < T , M > )); channel_peeker p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } template < typename ... Args , typename Ch , typename Fn > void select ( Ch & ch , Fn && fn , Args && ... args ) noexcept ( false ) { select ( ch , forward < Fn &&> ( fn )); // evaluate return select ( forward < Args &&> ( args )...); // try next pair } } // namespace coro #endif // LUNCLIFF_COROUTINE_CHANNEL_HPP","title":"File channel.hpp"},{"location":"class_member_enums/","text":"Class Member Enums \u00b6","title":"Class Member Enums"},{"location":"class_member_enums/#class-member-enums","text":"","title":"Class Member Enums"},{"location":"class_member_functions/","text":"Class Member Functions \u00b6 a \u00b6 acquire ( coro::channel_peeker ) await_ready ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_transform ( coro::pthread_spawn_promise ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) b \u00b6 begin ( coro::enumerable ) c \u00b6 channel ( coro::channel ) channel_peeker ( coro::channel_peeker ) channel_reader ( coro::channel_reader ) channel_writer ( coro::channel_writer ) continue_on_apc ( coro::continue_on_apc ) create_and_submit_work ( coro::continue_on_thread_pool ) change ( coro::kqueue_owner ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) d \u00b6 destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) e \u00b6 end ( coro::enumerable ) enumerable ( coro::enumerable ) epoll_owner ( coro::epoll_owner ) event ( coro::event ) error ( coro::io_work_t ) events ( coro::kqueue_owner ) f \u00b6 fd ( coro::event ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle ) g \u00b6 get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) i \u00b6 iterator ( coro::enumerable::iterator ) is_set ( coro::event ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_spawn_promise , std::experimental::coroutine_traits< void, P... >::promise_type ) k \u00b6 kqueue_owner ( coro::kqueue_owner ) l \u00b6 lock ( coro::bypass_mutex , coro::section ) o \u00b6 operator= ( coro::channel , coro::channel_peeker , coro::channel_reader , coro::channel_writer , coro::enumerable , coro::epoll_owner , coro::event , coro::kqueue_owner , coro::section , coro::set_or_cancel , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator!= ( coro::enumerable::iterator ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator pthread_t ( coro::pthread_knower_t ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > ) p \u00b6 peek ( coro::channel_peeker ) pop ( coro::internal::list ) push ( coro::internal::list ) pthread_detacher_t ( coro::pthread_detacher_t ) pthread_joiner_t ( coro::pthread_joiner_t ) pthread_knower_t ( coro::pthread_knower_t ) pthread_resume ( coro::pthread_spawner_t ) pthread_spawner_t ( coro::pthread_spawner_t ) promise ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > ) q \u00b6 queue_user_apc ( coro::continue_on_apc ) r \u00b6 read ( coro::channel ) resume_on_apc ( coro::continue_on_apc ) resume_on_thread_pool ( coro::continue_on_thread_pool ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) remove ( coro::epoll_owner ) reset ( coro::event ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) resume_on_pthread ( coro::pthread_spawner_t ) s \u00b6 submit ( coro::epoll_owner , coro::kqueue_owner ) set ( coro::event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::set_or_cancel ) section ( coro::section ) set_or_cancel ( coro::set_or_cancel ) t \u00b6 try_lock ( coro::bypass_mutex , coro::section ) try_add ( coro::epoll_owner ) try_detach ( coro::pthread_detacher_t ) try_join ( coro::pthread_joiner_t ) u \u00b6 unlock ( coro::bypass_mutex , coro::section ) unhandled_exception ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_spawn_promise , std::experimental::coroutine_traits< void, P... >::promise_type ) unregister ( coro::set_or_cancel ) w \u00b6 write ( coro::channel ) wait ( coro::epoll_owner ) y \u00b6 yield_value ( coro::enumerable::promise_type ) ~ \u00b6 ~channel ( coro::channel ) ~channel_reader ( coro::channel_reader ) ~channel_writer ( coro::channel_writer ) ~enumerable ( coro::enumerable ) ~epoll_owner ( coro::epoll_owner ) ~event ( coro::event ) ~kqueue_owner ( coro::kqueue_owner ) ~pthread_detacher_t ( coro::pthread_detacher_t ) ~pthread_joiner_t ( coro::pthread_joiner_t ) ~pthread_spawner_t ( coro::pthread_spawner_t ) ~section ( coro::section ) ~set_or_cancel ( coro::set_or_cancel ) ~coroutine_handle ( std::experimental::coroutine_handle< void > )","title":"Class Member Functions"},{"location":"class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"class_member_functions/#a","text":"acquire ( coro::channel_peeker ) await_ready ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_transform ( coro::pthread_spawn_promise ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"a"},{"location":"class_member_functions/#b","text":"begin ( coro::enumerable )","title":"b"},{"location":"class_member_functions/#c","text":"channel ( coro::channel ) channel_peeker ( coro::channel_peeker ) channel_reader ( coro::channel_reader ) channel_writer ( coro::channel_writer ) continue_on_apc ( coro::continue_on_apc ) create_and_submit_work ( coro::continue_on_thread_pool ) change ( coro::kqueue_owner ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"c"},{"location":"class_member_functions/#d","text":"destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"d"},{"location":"class_member_functions/#e","text":"end ( coro::enumerable ) enumerable ( coro::enumerable ) epoll_owner ( coro::epoll_owner ) event ( coro::event ) error ( coro::io_work_t ) events ( coro::kqueue_owner )","title":"e"},{"location":"class_member_functions/#f","text":"fd ( coro::event ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle )","title":"f"},{"location":"class_member_functions/#g","text":"get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type )","title":"g"},{"location":"class_member_functions/#i","text":"iterator ( coro::enumerable::iterator ) is_set ( coro::event ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_spawn_promise , std::experimental::coroutine_traits< void, P... >::promise_type )","title":"i"},{"location":"class_member_functions/#k","text":"kqueue_owner ( coro::kqueue_owner )","title":"k"},{"location":"class_member_functions/#l","text":"lock ( coro::bypass_mutex , coro::section )","title":"l"},{"location":"class_member_functions/#o","text":"operator= ( coro::channel , coro::channel_peeker , coro::channel_reader , coro::channel_writer , coro::enumerable , coro::epoll_owner , coro::event , coro::kqueue_owner , coro::section , coro::set_or_cancel , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator!= ( coro::enumerable::iterator ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator pthread_t ( coro::pthread_knower_t ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"o"},{"location":"class_member_functions/#p","text":"peek ( coro::channel_peeker ) pop ( coro::internal::list ) push ( coro::internal::list ) pthread_detacher_t ( coro::pthread_detacher_t ) pthread_joiner_t ( coro::pthread_joiner_t ) pthread_knower_t ( coro::pthread_knower_t ) pthread_resume ( coro::pthread_spawner_t ) pthread_spawner_t ( coro::pthread_spawner_t ) promise ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"p"},{"location":"class_member_functions/#q","text":"queue_user_apc ( coro::continue_on_apc )","title":"q"},{"location":"class_member_functions/#r","text":"read ( coro::channel ) resume_on_apc ( coro::continue_on_apc ) resume_on_thread_pool ( coro::continue_on_thread_pool ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) remove ( coro::epoll_owner ) reset ( coro::event ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) resume_on_pthread ( coro::pthread_spawner_t )","title":"r"},{"location":"class_member_functions/#s","text":"submit ( coro::epoll_owner , coro::kqueue_owner ) set ( coro::event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::set_or_cancel ) section ( coro::section ) set_or_cancel ( coro::set_or_cancel )","title":"s"},{"location":"class_member_functions/#t","text":"try_lock ( coro::bypass_mutex , coro::section ) try_add ( coro::epoll_owner ) try_detach ( coro::pthread_detacher_t ) try_join ( coro::pthread_joiner_t )","title":"t"},{"location":"class_member_functions/#u","text":"unlock ( coro::bypass_mutex , coro::section ) unhandled_exception ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_spawn_promise , std::experimental::coroutine_traits< void, P... >::promise_type ) unregister ( coro::set_or_cancel )","title":"u"},{"location":"class_member_functions/#w","text":"write ( coro::channel ) wait ( coro::epoll_owner )","title":"w"},{"location":"class_member_functions/#y","text":"yield_value ( coro::enumerable::promise_type )","title":"y"},{"location":"class_member_functions/#_1","text":"~channel ( coro::channel ) ~channel_reader ( coro::channel_reader ) ~channel_writer ( coro::channel_writer ) ~enumerable ( coro::enumerable ) ~epoll_owner ( coro::epoll_owner ) ~event ( coro::event ) ~kqueue_owner ( coro::kqueue_owner ) ~pthread_detacher_t ( coro::pthread_detacher_t ) ~pthread_joiner_t ( coro::pthread_joiner_t ) ~pthread_spawner_t ( coro::pthread_spawner_t ) ~section ( coro::section ) ~set_or_cancel ( coro::set_or_cancel ) ~coroutine_handle ( std::experimental::coroutine_handle< void > )","title":"~"},{"location":"class_member_typedefs/","text":"Class Member Typedefs \u00b6 c \u00b6 channel_type ( coro::channel_peeker , coro::channel_reader , coro::channel_writer ) d \u00b6 difference_type ( coro::enumerable::iterator ) i \u00b6 iterator_category ( coro::enumerable::iterator ) m \u00b6 mutex_type ( coro::channel ) p \u00b6 peeker ( coro::channel , coro::channel_writer ) pointer ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits ) r \u00b6 reader ( coro::channel , coro::channel_writer ) reader_list ( coro::channel , coro::channel_reader , coro::channel_writer ) reference ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) v \u00b6 value_type ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) w \u00b6 writer ( coro::channel , coro::channel_peeker , coro::channel_reader ) writer_list ( coro::channel , coro::channel_reader , coro::channel_writer )","title":"Class Member Typedefs"},{"location":"class_member_typedefs/#class-member-typedefs","text":"","title":"Class Member Typedefs"},{"location":"class_member_typedefs/#c","text":"channel_type ( coro::channel_peeker , coro::channel_reader , coro::channel_writer )","title":"c"},{"location":"class_member_typedefs/#d","text":"difference_type ( coro::enumerable::iterator )","title":"d"},{"location":"class_member_typedefs/#i","text":"iterator_category ( coro::enumerable::iterator )","title":"i"},{"location":"class_member_typedefs/#m","text":"mutex_type ( coro::channel )","title":"m"},{"location":"class_member_typedefs/#p","text":"peeker ( coro::channel , coro::channel_writer ) pointer ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits )","title":"p"},{"location":"class_member_typedefs/#r","text":"reader ( coro::channel , coro::channel_writer ) reader_list ( coro::channel , coro::channel_reader , coro::channel_writer ) reference ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable )","title":"r"},{"location":"class_member_typedefs/#v","text":"value_type ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable )","title":"v"},{"location":"class_member_typedefs/#w","text":"writer ( coro::channel , coro::channel_peeker , coro::channel_reader ) writer_list ( coro::channel , coro::channel_reader , coro::channel_writer )","title":"w"},{"location":"class_member_variables/","text":"Class Member Variables \u00b6 a \u00b6 attr ( coro::pthread_spawner_t ) b \u00b6 buffer ( coro::io_work_t ) c \u00b6 chan ( coro::channel_reader , coro::channel_writer ) channel_type ( coro::channel_reader , coro::channel_writer ) coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) e \u00b6 epfd ( coro::epoll_owner ) f \u00b6 factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) frame ( coro::channel_reader , coro::channel_writer ) flag ( msvc_frame_prefix ) h \u00b6 head ( coro::internal::list ) hobject ( coro::set_or_cancel ) i \u00b6 index ( msvc_frame_prefix ) k \u00b6 kqfd ( coro::kqueue_owner ) m \u00b6 mtx ( coro::channel ) n \u00b6 next ( coro::channel_reader , coro::channel_writer ) p \u00b6 peeker ( coro::channel , coro::channel_writer ) ptr ( coro::channel_reader , coro::channel_writer ) promise ( coro::pthread_knower_t ) prefix ( std::experimental::coroutine_handle< void > ) r \u00b6 reader ( coro::channel , coro::channel_writer ) reader_list ( coro::channel_reader ) rwlock ( coro::section ) s \u00b6 state ( coro::event ) t \u00b6 thread ( coro::continue_on_apc ) tail ( coro::internal::list ) task ( coro::io_work_t ) tid ( coro::pthread_spawn_promise , coro::pthread_spawner_t ) v \u00b6 v ( std::experimental::coroutine_handle< noop_coroutine_promise > ) w \u00b6 writer ( coro::channel , coro::channel_reader ) writer_list ( coro::channel_writer ) _ \u00b6 _unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix ) @ \u00b6 @1 ( coro::channel_reader ) @3 ( coro::channel_writer )","title":"Class Member Variables"},{"location":"class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"class_member_variables/#a","text":"attr ( coro::pthread_spawner_t )","title":"a"},{"location":"class_member_variables/#b","text":"buffer ( coro::io_work_t )","title":"b"},{"location":"class_member_variables/#c","text":"chan ( coro::channel_reader , coro::channel_writer ) channel_type ( coro::channel_reader , coro::channel_writer ) coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type )","title":"c"},{"location":"class_member_variables/#e","text":"epfd ( coro::epoll_owner )","title":"e"},{"location":"class_member_variables/#f","text":"factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) frame ( coro::channel_reader , coro::channel_writer ) flag ( msvc_frame_prefix )","title":"f"},{"location":"class_member_variables/#h","text":"head ( coro::internal::list ) hobject ( coro::set_or_cancel )","title":"h"},{"location":"class_member_variables/#i","text":"index ( msvc_frame_prefix )","title":"i"},{"location":"class_member_variables/#k","text":"kqfd ( coro::kqueue_owner )","title":"k"},{"location":"class_member_variables/#m","text":"mtx ( coro::channel )","title":"m"},{"location":"class_member_variables/#n","text":"next ( coro::channel_reader , coro::channel_writer )","title":"n"},{"location":"class_member_variables/#p","text":"peeker ( coro::channel , coro::channel_writer ) ptr ( coro::channel_reader , coro::channel_writer ) promise ( coro::pthread_knower_t ) prefix ( std::experimental::coroutine_handle< void > )","title":"p"},{"location":"class_member_variables/#r","text":"reader ( coro::channel , coro::channel_writer ) reader_list ( coro::channel_reader ) rwlock ( coro::section )","title":"r"},{"location":"class_member_variables/#s","text":"state ( coro::event )","title":"s"},{"location":"class_member_variables/#t","text":"thread ( coro::continue_on_apc ) tail ( coro::internal::list ) task ( coro::io_work_t ) tid ( coro::pthread_spawn_promise , coro::pthread_spawner_t )","title":"t"},{"location":"class_member_variables/#v","text":"v ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"v"},{"location":"class_member_variables/#w","text":"writer ( coro::channel , coro::channel_reader ) writer_list ( coro::channel_writer )","title":"w"},{"location":"class_member_variables/#_","text":"_unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix )","title":"_"},{"location":"class_member_variables/#_1","text":"@1 ( coro::channel_reader ) @3 ( coro::channel_writer )","title":"@"},{"location":"class_members/","text":"Class Members \u00b6 a \u00b6 acquire ( coro::channel_peeker ) await_ready ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_transform ( coro::pthread_spawn_promise ) attr ( coro::pthread_spawner_t ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) b \u00b6 begin ( coro::enumerable ) buffer ( coro::io_work_t ) c \u00b6 channel ( coro::channel ) channel_peeker ( coro::channel_peeker ) channel_type ( coro::channel_peeker , coro::channel_reader , coro::channel_writer ) chan ( coro::channel_reader , coro::channel_writer ) channel_reader ( coro::channel_reader ) channel_writer ( coro::channel_writer ) continue_on_apc ( coro::continue_on_apc ) create_and_submit_work ( coro::continue_on_thread_pool ) coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) change ( coro::kqueue_owner ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) d \u00b6 difference_type ( coro::enumerable::iterator ) destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) e \u00b6 end ( coro::enumerable ) enumerable ( coro::enumerable ) epfd ( coro::epoll_owner ) epoll_owner ( coro::epoll_owner ) event ( coro::event ) error ( coro::io_work_t ) events ( coro::kqueue_owner ) f \u00b6 factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) frame ( coro::channel_reader , coro::channel_writer ) fd ( coro::event ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) flag ( msvc_frame_prefix ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle ) g \u00b6 get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) h \u00b6 head ( coro::internal::list ) hobject ( coro::set_or_cancel ) i \u00b6 iterator ( coro::enumerable::iterator ) iterator_category ( coro::enumerable::iterator ) is_set ( coro::event ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_spawn_promise , std::experimental::coroutine_traits< void, P... >::promise_type ) index ( msvc_frame_prefix ) k \u00b6 kqfd ( coro::kqueue_owner ) kqueue_owner ( coro::kqueue_owner ) l \u00b6 lock ( coro::bypass_mutex , coro::section ) m \u00b6 mtx ( coro::channel ) mutex_type ( coro::channel ) n \u00b6 next ( coro::channel_reader , coro::channel_writer ) o \u00b6 operator= ( coro::channel , coro::channel_peeker , coro::channel_reader , coro::channel_writer , coro::enumerable , coro::epoll_owner , coro::event , coro::kqueue_owner , coro::section , coro::set_or_cancel , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator!= ( coro::enumerable::iterator ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator pthread_t ( coro::pthread_knower_t ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > ) p \u00b6 peeker ( coro::channel , coro::channel_writer ) pointer ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) peek ( coro::channel_peeker ) ptr ( coro::channel_reader , coro::channel_writer ) pop ( coro::internal::list ) push ( coro::internal::list ) pthread_detacher_t ( coro::pthread_detacher_t ) pthread_joiner_t ( coro::pthread_joiner_t ) promise ( coro::pthread_knower_t , std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > ) pthread_knower_t ( coro::pthread_knower_t ) pthread_resume ( coro::pthread_spawner_t ) pthread_spawner_t ( coro::pthread_spawner_t ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits ) prefix ( std::experimental::coroutine_handle< void > ) q \u00b6 queue_user_apc ( coro::continue_on_apc ) r \u00b6 read ( coro::channel ) reader ( coro::channel , coro::channel_writer ) reader_list ( coro::channel , coro::channel_reader , coro::channel_writer ) reference ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) resume_on_apc ( coro::continue_on_apc ) resume_on_thread_pool ( coro::continue_on_thread_pool ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) remove ( coro::epoll_owner ) reset ( coro::event ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) resume_on_pthread ( coro::pthread_spawner_t ) rwlock ( coro::section ) s \u00b6 submit ( coro::epoll_owner , coro::kqueue_owner ) set ( coro::event ) state ( coro::event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::set_or_cancel ) section ( coro::section ) set_or_cancel ( coro::set_or_cancel ) t \u00b6 try_lock ( coro::bypass_mutex , coro::section ) thread ( coro::continue_on_apc ) try_add ( coro::epoll_owner ) tail ( coro::internal::list ) task ( coro::io_work_t ) try_detach ( coro::pthread_detacher_t ) try_join ( coro::pthread_joiner_t ) tid ( coro::pthread_spawn_promise , coro::pthread_spawner_t ) u \u00b6 unlock ( coro::bypass_mutex , coro::section ) unhandled_exception ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_spawn_promise , std::experimental::coroutine_traits< void, P... >::promise_type ) unregister ( coro::set_or_cancel ) v \u00b6 value_type ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) v ( std::experimental::coroutine_handle< noop_coroutine_promise > ) w \u00b6 write ( coro::channel ) writer ( coro::channel , coro::channel_peeker , coro::channel_reader ) writer_list ( coro::channel , coro::channel_reader , coro::channel_writer ) wait ( coro::epoll_owner ) y \u00b6 yield_value ( coro::enumerable::promise_type ) ~ \u00b6 ~channel ( coro::channel ) ~channel_reader ( coro::channel_reader ) ~channel_writer ( coro::channel_writer ) ~enumerable ( coro::enumerable ) ~epoll_owner ( coro::epoll_owner ) ~event ( coro::event ) ~kqueue_owner ( coro::kqueue_owner ) ~pthread_detacher_t ( coro::pthread_detacher_t ) ~pthread_joiner_t ( coro::pthread_joiner_t ) ~pthread_spawner_t ( coro::pthread_spawner_t ) ~section ( coro::section ) ~set_or_cancel ( coro::set_or_cancel ) ~coroutine_handle ( std::experimental::coroutine_handle< void > ) _ \u00b6 _unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix ) @ \u00b6 @1 ( coro::channel_reader ) @3 ( coro::channel_writer )","title":"Class Members"},{"location":"class_members/#class-members","text":"","title":"Class Members"},{"location":"class_members/#a","text":"acquire ( coro::channel_peeker ) await_ready ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_resume ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_suspend ( coro::channel_reader , coro::channel_writer , coro::continue_on_apc , coro::continue_on_thread_pool , coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::pthread_spawner_t , coro::set_or_cancel , std::experimental::suspend_always , std::experimental::suspend_never ) await_transform ( coro::pthread_spawn_promise ) attr ( coro::pthread_spawner_t ) address ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"a"},{"location":"class_members/#b","text":"begin ( coro::enumerable ) buffer ( coro::io_work_t )","title":"b"},{"location":"class_members/#c","text":"channel ( coro::channel ) channel_peeker ( coro::channel_peeker ) channel_type ( coro::channel_peeker , coro::channel_reader , coro::channel_writer ) chan ( coro::channel_reader , coro::channel_writer ) channel_reader ( coro::channel_reader ) channel_writer ( coro::channel_writer ) continue_on_apc ( coro::continue_on_apc ) create_and_submit_work ( coro::continue_on_thread_pool ) coro ( coro::enumerable , coro::enumerable::iterator ) current ( coro::enumerable::promise_type ) change ( coro::kqueue_owner ) coroutine_handle ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"c"},{"location":"class_members/#d","text":"difference_type ( coro::enumerable::iterator ) destroy ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) done ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > )","title":"d"},{"location":"class_members/#e","text":"end ( coro::enumerable ) enumerable ( coro::enumerable ) epfd ( coro::epoll_owner ) epoll_owner ( coro::epoll_owner ) event ( coro::event ) error ( coro::io_work_t ) events ( coro::kqueue_owner )","title":"e"},{"location":"class_members/#f","text":"factivate ( clang_frame_prefix , msvc_frame_prefix ) fdestroy ( clang_frame_prefix ) frame ( coro::channel_reader , coro::channel_writer ) fd ( coro::event ) final_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) flag ( msvc_frame_prefix ) from_address ( std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) from_frame ( std::experimental::coroutine_handle ) from_promise ( std::experimental::coroutine_handle )","title":"f"},{"location":"class_members/#g","text":"get_return_object ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type )","title":"g"},{"location":"class_members/#h","text":"head ( coro::internal::list ) hobject ( coro::set_or_cancel )","title":"h"},{"location":"class_members/#i","text":"iterator ( coro::enumerable::iterator ) iterator_category ( coro::enumerable::iterator ) is_set ( coro::event ) is_empty ( coro::internal::list ) initial_suspend ( coro::promise_aa , coro::promise_an , coro::promise_na , coro::promise_nn , coro::pthread_spawn_promise , std::experimental::coroutine_traits< void, P... >::promise_type ) index ( msvc_frame_prefix )","title":"i"},{"location":"class_members/#k","text":"kqfd ( coro::kqueue_owner ) kqueue_owner ( coro::kqueue_owner )","title":"k"},{"location":"class_members/#l","text":"lock ( coro::bypass_mutex , coro::section )","title":"l"},{"location":"class_members/#m","text":"mtx ( coro::channel ) mutex_type ( coro::channel )","title":"m"},{"location":"class_members/#n","text":"next ( coro::channel_reader , coro::channel_writer )","title":"n"},{"location":"class_members/#o","text":"operator= ( coro::channel , coro::channel_peeker , coro::channel_reader , coro::channel_writer , coro::enumerable , coro::epoll_owner , coro::event , coro::kqueue_owner , coro::section , coro::set_or_cancel , std::experimental::coroutine_handle , std::experimental::coroutine_handle< void > ) operator!= ( coro::enumerable::iterator ) operator* ( coro::enumerable::iterator ) operator++ ( coro::enumerable::iterator ) operator-> ( coro::enumerable::iterator ) operator== ( coro::enumerable::iterator ) operator pthread_t ( coro::pthread_knower_t ) operator bool ( std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) operator() ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"o"},{"location":"class_members/#p","text":"peeker ( coro::channel , coro::channel_writer ) pointer ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) peek ( coro::channel_peeker ) ptr ( coro::channel_reader , coro::channel_writer ) pop ( coro::internal::list ) push ( coro::internal::list ) pthread_detacher_t ( coro::pthread_detacher_t ) pthread_joiner_t ( coro::pthread_joiner_t ) promise ( coro::pthread_knower_t , std::experimental::coroutine_handle , std::experimental::coroutine_handle< noop_coroutine_promise > ) pthread_knower_t ( coro::pthread_knower_t ) pthread_resume ( coro::pthread_spawner_t ) pthread_spawner_t ( coro::pthread_spawner_t ) promise_type ( std::experimental::coroutine_handle , std::experimental::coroutine_traits ) prefix ( std::experimental::coroutine_handle< void > )","title":"p"},{"location":"class_members/#q","text":"queue_user_apc ( coro::continue_on_apc )","title":"q"},{"location":"class_members/#r","text":"read ( coro::channel ) reader ( coro::channel , coro::channel_writer ) reader_list ( coro::channel , coro::channel_reader , coro::channel_writer ) reference ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) resume_on_apc ( coro::continue_on_apc ) resume_on_thread_pool ( coro::continue_on_thread_pool ) return_void ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type , std::experimental::coroutine_traits< void, P... >::promise_type ) remove ( coro::epoll_owner ) reset ( coro::event ) resume ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , std::experimental::coroutine_handle< noop_coroutine_promise > , std::experimental::coroutine_handle< void > ) ready ( coro::io_work_t ) resume_on_pthread ( coro::pthread_spawner_t ) rwlock ( coro::section )","title":"r"},{"location":"class_members/#s","text":"submit ( coro::epoll_owner , coro::kqueue_owner ) set ( coro::event ) state ( coro::event ) suspend ( coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to , coro::set_or_cancel ) section ( coro::section ) set_or_cancel ( coro::set_or_cancel )","title":"s"},{"location":"class_members/#t","text":"try_lock ( coro::bypass_mutex , coro::section ) thread ( coro::continue_on_apc ) try_add ( coro::epoll_owner ) tail ( coro::internal::list ) task ( coro::io_work_t ) try_detach ( coro::pthread_detacher_t ) try_join ( coro::pthread_joiner_t ) tid ( coro::pthread_spawn_promise , coro::pthread_spawner_t )","title":"t"},{"location":"class_members/#u","text":"unlock ( coro::bypass_mutex , coro::section ) unhandled_exception ( coro::enumerable::promise_type , coro::frame_t::promise_type , coro::pthread_spawn_promise , std::experimental::coroutine_traits< void, P... >::promise_type ) unregister ( coro::set_or_cancel )","title":"u"},{"location":"class_members/#v","text":"value_type ( coro::channel , coro::channel_reader , coro::channel_writer , coro::enumerable::iterator , coro::enumerable ) v ( std::experimental::coroutine_handle< noop_coroutine_promise > )","title":"v"},{"location":"class_members/#w","text":"write ( coro::channel ) writer ( coro::channel , coro::channel_peeker , coro::channel_reader ) writer_list ( coro::channel , coro::channel_reader , coro::channel_writer ) wait ( coro::epoll_owner )","title":"w"},{"location":"class_members/#y","text":"yield_value ( coro::enumerable::promise_type )","title":"y"},{"location":"class_members/#_1","text":"~channel ( coro::channel ) ~channel_reader ( coro::channel_reader ) ~channel_writer ( coro::channel_writer ) ~enumerable ( coro::enumerable ) ~epoll_owner ( coro::epoll_owner ) ~event ( coro::event ) ~kqueue_owner ( coro::kqueue_owner ) ~pthread_detacher_t ( coro::pthread_detacher_t ) ~pthread_joiner_t ( coro::pthread_joiner_t ) ~pthread_spawner_t ( coro::pthread_spawner_t ) ~section ( coro::section ) ~set_or_cancel ( coro::set_or_cancel ) ~coroutine_handle ( std::experimental::coroutine_handle< void > )","title":"~"},{"location":"class_members/#_","text":"_unknown1 ( gcc_frame_prefix ) _unknown2 ( gcc_frame_prefix )","title":"_"},{"location":"class_members/#_2","text":"@1 ( coro::channel_reader ) @3 ( coro::channel_writer )","title":"@"},{"location":"classcoro_1_1channel/","text":"Class coro::channel \u00b6 template <typename T, typename M> Class List > coro > channel C++ Coroutines based channel. More... #include <channel.hpp> Inherits the following classes: coro::internal::list , coro::internal::list Public Types \u00b6 Type Name typedef M mutex_type typedef value_type * pointer typedef value_type & reference typedef T value_type Public Functions \u00b6 Type Name channel () noexcept initialized 2 linked list and given mutex decltype(auto) read () noexcept construct a new reader which references this channel decltype(auto) write ( reference ref) noexcept construct a new writer which references this channel ~channel () noexcept Resume all attached coroutine read/write operations. Public Functions inherited from coro::internal::list \u00b6 See coro::internal::list Type Name bool is_empty () noexcept const auto pop () noexcept void push (T * node) noexcept Public Functions inherited from coro::internal::list \u00b6 See coro::internal::list Type Name bool is_empty () noexcept const auto pop () noexcept void push (T * node) noexcept Detailed Description \u00b6 Note: It works as synchronizer of channel_writer / channel_reader . The parameter mutex must meet the requirement of the synchronization. Template parameters: T type of the element M Type of the mutex(lockable) for its member Public Types Documentation \u00b6 typedef mutex_type \u00b6 using coro :: channel < T , M >:: mutex_type = M ; typedef pointer \u00b6 using coro :: channel < T , M >:: pointer = value_type * ; typedef reference \u00b6 using coro :: channel < T , M >:: reference = value_type & ; typedef value_type \u00b6 using coro :: channel < T , M >:: value_type = T ; Public Functions Documentation \u00b6 function channel [3/3] \u00b6 inline coro :: channel :: channel () noexcept function read \u00b6 inline decltype ( auto ) coro :: channel :: read () noexcept Returns: channel_reader function write \u00b6 inline decltype ( auto ) coro :: channel :: write ( reference ref ) noexcept Parameters: ref T& which holds a value to be move d to reader. Returns: channel_writer function ~channel \u00b6 inline coro :: channel ::~ channel () noexcept Note: Channel can't provide exception guarantee since the destruction contains coroutines' resume If the channel is raced hardly, some coroutines can be enqueued into list just after this destructor unlocks mutex. Unfortunately, this can't be detected at once since we have 2 list (readers/writers) in the channel. Current implementation allows checking repeatedly to reduce the probability of such interleaving. Modify the repeat count in the code if the situation occurs. The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::channel"},{"location":"classcoro_1_1channel/#class-corochannel","text":"template <typename T, typename M> Class List > coro > channel C++ Coroutines based channel. More... #include <channel.hpp> Inherits the following classes: coro::internal::list , coro::internal::list","title":"Class coro::channel"},{"location":"classcoro_1_1channel/#public-types","text":"Type Name typedef M mutex_type typedef value_type * pointer typedef value_type & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1channel/#public-functions","text":"Type Name channel () noexcept initialized 2 linked list and given mutex decltype(auto) read () noexcept construct a new reader which references this channel decltype(auto) write ( reference ref) noexcept construct a new writer which references this channel ~channel () noexcept Resume all attached coroutine read/write operations.","title":"Public Functions"},{"location":"classcoro_1_1channel/#public-functions-inherited-from-corointernallist","text":"See coro::internal::list Type Name bool is_empty () noexcept const auto pop () noexcept void push (T * node) noexcept","title":"Public Functions inherited from coro::internal::list"},{"location":"classcoro_1_1channel/#public-functions-inherited-from-corointernallist_1","text":"See coro::internal::list Type Name bool is_empty () noexcept const auto pop () noexcept void push (T * node) noexcept","title":"Public Functions inherited from coro::internal::list"},{"location":"classcoro_1_1channel/#detailed-description","text":"Note: It works as synchronizer of channel_writer / channel_reader . The parameter mutex must meet the requirement of the synchronization. Template parameters: T type of the element M Type of the mutex(lockable) for its member","title":"Detailed Description"},{"location":"classcoro_1_1channel/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1channel/#typedef-mutex_type","text":"using coro :: channel < T , M >:: mutex_type = M ;","title":"typedef mutex_type"},{"location":"classcoro_1_1channel/#typedef-pointer","text":"using coro :: channel < T , M >:: pointer = value_type * ;","title":"typedef pointer"},{"location":"classcoro_1_1channel/#typedef-reference","text":"using coro :: channel < T , M >:: reference = value_type & ;","title":"typedef reference"},{"location":"classcoro_1_1channel/#typedef-value_type","text":"using coro :: channel < T , M >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1channel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1channel/#function-channel-33","text":"inline coro :: channel :: channel () noexcept","title":"function channel [3/3]"},{"location":"classcoro_1_1channel/#function-read","text":"inline decltype ( auto ) coro :: channel :: read () noexcept Returns: channel_reader","title":"function read"},{"location":"classcoro_1_1channel/#function-write","text":"inline decltype ( auto ) coro :: channel :: write ( reference ref ) noexcept Parameters: ref T& which holds a value to be move d to reader. Returns: channel_writer","title":"function write"},{"location":"classcoro_1_1channel/#function-channel","text":"inline coro :: channel ::~ channel () noexcept Note: Channel can't provide exception guarantee since the destruction contains coroutines' resume If the channel is raced hardly, some coroutines can be enqueued into list just after this destructor unlocks mutex. Unfortunately, this can't be detected at once since we have 2 list (readers/writers) in the channel. Current implementation allows checking repeatedly to reduce the probability of such interleaving. Modify the repeat count in the code if the situation occurs. The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function ~channel"},{"location":"classcoro_1_1channel__peeker/","text":"Class coro::channel_peeker \u00b6 template <typename T typename T, typename M typename M> Class List > coro > channel_peeker Extension of channel_reader for subroutines. More... #include <channel.hpp> Inherits the following classes: coro::channel_reader Public Types inherited from coro::channel_reader \u00b6 See coro::channel_reader Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type Public Attributes inherited from coro::channel_reader \u00b6 See coro::channel_reader Type Name channel_type * chan Next reader in channel. channel_reader * next = = nullptr Public Functions \u00b6 Type Name bool acquire (T & storage) noexcept Move a value from matches writer to designated storage. After then, resume the writer coroutine. channel_peeker ( channel_type & ch) noexcept void peek () noexcept const Since there is no suspension for the peeker , the implementation will use scoped locking. Public Functions inherited from coro::channel_reader \u00b6 See coro::channel_reader Type Name bool await_ready () noexcept const Lock the channel and find available channel_writer __ auto await_resume () noexcept Returns value from writer coroutine, and bool indicator for the associtated channel's destruction. void await_suspend ( coroutine_handle < void > coro) noexcept Push to the channel and wait for channel_writer . ~channel_reader () noexcept Protected Attributes inherited from coro::channel_reader \u00b6 See coro::channel_reader Type Name union coro::channel_reader::@0 @1 Resumeable Handle. void * frame Address of value. pointer ptr Protected Functions inherited from coro::channel_reader \u00b6 See coro::channel_reader Type Name channel_reader ( channel_type & ch) noexcept channel_reader (const channel_reader &) noexcept channel_reader ( channel_reader &&) noexcept channel_reader & operator= (const channel_reader &) noexcept channel_reader & operator= ( channel_reader &&) noexcept Detailed Description \u00b6 Template parameters: T type of the element M mutex for the channel See also: channel_reader Public Functions Documentation \u00b6 function acquire \u00b6 inline bool coro :: channel_peeker :: acquire ( T & storage ) noexcept Note: Unless the caller has invoked peek , nothing will happen. bool peek_channel ( channel < string >& ch , string & out ){ peeker p { ch }; p . peek (); return p . acquire ( out ); } Parameters: storage memory object to store the value from writer Returns: true Acquired the value Returns: false No writer found or peek is not invoked See also: peek function channel_peeker [3/3] \u00b6 inline explicit coro :: channel_peeker :: channel_peeker ( channel_type & ch ) noexcept function peek \u00b6 inline void coro :: channel_peeker :: peek () noexcept const The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::channel\\_peeker"},{"location":"classcoro_1_1channel__peeker/#class-corochannel_peeker","text":"template <typename T typename T, typename M typename M> Class List > coro > channel_peeker Extension of channel_reader for subroutines. More... #include <channel.hpp> Inherits the following classes: coro::channel_reader","title":"Class coro::channel_peeker"},{"location":"classcoro_1_1channel__peeker/#public-types-inherited-from-corochannel_reader","text":"See coro::channel_reader Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type","title":"Public Types inherited from coro::channel_reader"},{"location":"classcoro_1_1channel__peeker/#public-attributes-inherited-from-corochannel_reader","text":"See coro::channel_reader Type Name channel_type * chan Next reader in channel. channel_reader * next = = nullptr","title":"Public Attributes inherited from coro::channel_reader"},{"location":"classcoro_1_1channel__peeker/#public-functions","text":"Type Name bool acquire (T & storage) noexcept Move a value from matches writer to designated storage. After then, resume the writer coroutine. channel_peeker ( channel_type & ch) noexcept void peek () noexcept const Since there is no suspension for the peeker , the implementation will use scoped locking.","title":"Public Functions"},{"location":"classcoro_1_1channel__peeker/#public-functions-inherited-from-corochannel_reader","text":"See coro::channel_reader Type Name bool await_ready () noexcept const Lock the channel and find available channel_writer __ auto await_resume () noexcept Returns value from writer coroutine, and bool indicator for the associtated channel's destruction. void await_suspend ( coroutine_handle < void > coro) noexcept Push to the channel and wait for channel_writer . ~channel_reader () noexcept","title":"Public Functions inherited from coro::channel_reader"},{"location":"classcoro_1_1channel__peeker/#protected-attributes-inherited-from-corochannel_reader","text":"See coro::channel_reader Type Name union coro::channel_reader::@0 @1 Resumeable Handle. void * frame Address of value. pointer ptr","title":"Protected Attributes inherited from coro::channel_reader"},{"location":"classcoro_1_1channel__peeker/#protected-functions-inherited-from-corochannel_reader","text":"See coro::channel_reader Type Name channel_reader ( channel_type & ch) noexcept channel_reader (const channel_reader &) noexcept channel_reader ( channel_reader &&) noexcept channel_reader & operator= (const channel_reader &) noexcept channel_reader & operator= ( channel_reader &&) noexcept","title":"Protected Functions inherited from coro::channel_reader"},{"location":"classcoro_1_1channel__peeker/#detailed-description","text":"Template parameters: T type of the element M mutex for the channel See also: channel_reader","title":"Detailed Description"},{"location":"classcoro_1_1channel__peeker/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1channel__peeker/#function-acquire","text":"inline bool coro :: channel_peeker :: acquire ( T & storage ) noexcept Note: Unless the caller has invoked peek , nothing will happen. bool peek_channel ( channel < string >& ch , string & out ){ peeker p { ch }; p . peek (); return p . acquire ( out ); } Parameters: storage memory object to store the value from writer Returns: true Acquired the value Returns: false No writer found or peek is not invoked See also: peek","title":"function acquire"},{"location":"classcoro_1_1channel__peeker/#function-channel_peeker-33","text":"inline explicit coro :: channel_peeker :: channel_peeker ( channel_type & ch ) noexcept","title":"function channel_peeker [3/3]"},{"location":"classcoro_1_1channel__peeker/#function-peek","text":"inline void coro :: channel_peeker :: peek () noexcept const The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function peek"},{"location":"classcoro_1_1channel__reader/","text":"Class coro::channel_reader \u00b6 template <typename T typename T, typename M typename M> Class List > coro > channel_reader Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. More... #include <channel.hpp> Inherited by the following classes: coro::channel_peeker Public Types \u00b6 Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type Public Attributes \u00b6 Type Name channel_type * chan Next reader in channel. channel_reader * next = = nullptr Public Functions \u00b6 Type Name bool await_ready () noexcept const Lock the channel and find available channel_writer __ auto await_resume () noexcept Returns value from writer coroutine, and bool indicator for the associtated channel's destruction. void await_suspend ( coroutine_handle < void > coro) noexcept Push to the channel and wait for channel_writer . ~channel_reader () noexcept Protected Attributes \u00b6 Type Name union coro::channel_reader::@0 @1 Resumeable Handle. void * frame Address of value. pointer ptr Protected Functions \u00b6 Type Name channel_reader ( channel_type & ch) noexcept channel_reader (const channel_reader &) noexcept channel_reader ( channel_reader &&) noexcept channel_reader & operator= (const channel_reader &) noexcept channel_reader & operator= ( channel_reader &&) noexcept Detailed Description \u00b6 void read_from ( channel < int >& ch , int & ref , bool ok = false ) { tie ( ref , ok ) = co_await ch . read (); if ( ok == false ) ; // channel is under destruction !!! } Template parameters: T type of the element M mutex for the channel See also: channel_writer Public Types Documentation \u00b6 typedef channel_type [1/2] \u00b6 using coro :: channel_reader < T , M >:: channel_type = channel < T , M > ; typedef pointer \u00b6 using coro :: channel_reader < T , M >:: pointer = T * ; typedef reference \u00b6 using coro :: channel_reader < T , M >:: reference = T & ; typedef value_type \u00b6 using coro :: channel_reader < T , M >:: value_type = T ; Public Attributes Documentation \u00b6 variable chan \u00b6 channel_type * coro :: channel_reader < T , M >:: chan ; variable next \u00b6 channel_reader * coro :: channel_reader < T , M >:: next ; Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: channel_reader :: await_ready () noexcept const Returns: true Matched with channel_writer Returns: false There was no available channel_writer . The channel will be **lock**ed for this case. function await_resume \u00b6 inline auto coro :: channel_reader :: await_resume () noexcept Returns: tuple<value_type, bool> function await_suspend \u00b6 inline void coro :: channel_reader :: await_suspend ( coroutine_handle < void > coro ) noexcept Note: The channel will be **unlock**ed after return. Parameters: coro Remember current coroutine's handle to resume later See also: await_ready function ~channel_reader \u00b6 coro :: channel_reader ::~ channel_reader () noexcept Protected Attributes Documentation \u00b6 variable @1 \u00b6 union coro :: channel_reader :: @ 0 coro :: channel_reader < T , M >:: @ 1 ; variable frame \u00b6 void * coro :: channel_reader < T , M >:: frame ; variable ptr \u00b6 pointer coro :: channel_reader < T , M >:: ptr ; Protected Functions Documentation \u00b6 function channel_reader [1/3] \u00b6 inline explicit coro :: channel_reader :: channel_reader ( channel_type & ch ) noexcept function channel_reader [2/3] \u00b6 coro :: channel_reader :: channel_reader ( const channel_reader & ) noexcept function channel_reader [3/3] \u00b6 coro :: channel_reader :: channel_reader ( channel_reader && ) noexcept function operator= \u00b6 channel_reader & coro :: channel_reader :: operator = ( const channel_reader & ) noexcept function operator= \u00b6 channel_reader & coro :: channel_reader :: operator = ( channel_reader && ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::channel\\_reader"},{"location":"classcoro_1_1channel__reader/#class-corochannel_reader","text":"template <typename T typename T, typename M typename M> Class List > coro > channel_reader Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. More... #include <channel.hpp> Inherited by the following classes: coro::channel_peeker","title":"Class coro::channel_reader"},{"location":"classcoro_1_1channel__reader/#public-types","text":"Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1channel__reader/#public-attributes","text":"Type Name channel_type * chan Next reader in channel. channel_reader * next = = nullptr","title":"Public Attributes"},{"location":"classcoro_1_1channel__reader/#public-functions","text":"Type Name bool await_ready () noexcept const Lock the channel and find available channel_writer __ auto await_resume () noexcept Returns value from writer coroutine, and bool indicator for the associtated channel's destruction. void await_suspend ( coroutine_handle < void > coro) noexcept Push to the channel and wait for channel_writer . ~channel_reader () noexcept","title":"Public Functions"},{"location":"classcoro_1_1channel__reader/#protected-attributes","text":"Type Name union coro::channel_reader::@0 @1 Resumeable Handle. void * frame Address of value. pointer ptr","title":"Protected Attributes"},{"location":"classcoro_1_1channel__reader/#protected-functions","text":"Type Name channel_reader ( channel_type & ch) noexcept channel_reader (const channel_reader &) noexcept channel_reader ( channel_reader &&) noexcept channel_reader & operator= (const channel_reader &) noexcept channel_reader & operator= ( channel_reader &&) noexcept","title":"Protected Functions"},{"location":"classcoro_1_1channel__reader/#detailed-description","text":"void read_from ( channel < int >& ch , int & ref , bool ok = false ) { tie ( ref , ok ) = co_await ch . read (); if ( ok == false ) ; // channel is under destruction !!! } Template parameters: T type of the element M mutex for the channel See also: channel_writer","title":"Detailed Description"},{"location":"classcoro_1_1channel__reader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1channel__reader/#typedef-channel_type-12","text":"using coro :: channel_reader < T , M >:: channel_type = channel < T , M > ;","title":"typedef channel_type [1/2]"},{"location":"classcoro_1_1channel__reader/#typedef-pointer","text":"using coro :: channel_reader < T , M >:: pointer = T * ;","title":"typedef pointer"},{"location":"classcoro_1_1channel__reader/#typedef-reference","text":"using coro :: channel_reader < T , M >:: reference = T & ;","title":"typedef reference"},{"location":"classcoro_1_1channel__reader/#typedef-value_type","text":"using coro :: channel_reader < T , M >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1channel__reader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1channel__reader/#variable-chan","text":"channel_type * coro :: channel_reader < T , M >:: chan ;","title":"variable chan"},{"location":"classcoro_1_1channel__reader/#variable-next","text":"channel_reader * coro :: channel_reader < T , M >:: next ;","title":"variable next"},{"location":"classcoro_1_1channel__reader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1channel__reader/#function-await_ready","text":"inline bool coro :: channel_reader :: await_ready () noexcept const Returns: true Matched with channel_writer Returns: false There was no available channel_writer . The channel will be **lock**ed for this case.","title":"function await_ready"},{"location":"classcoro_1_1channel__reader/#function-await_resume","text":"inline auto coro :: channel_reader :: await_resume () noexcept Returns: tuple<value_type, bool>","title":"function await_resume"},{"location":"classcoro_1_1channel__reader/#function-await_suspend","text":"inline void coro :: channel_reader :: await_suspend ( coroutine_handle < void > coro ) noexcept Note: The channel will be **unlock**ed after return. Parameters: coro Remember current coroutine's handle to resume later See also: await_ready","title":"function await_suspend"},{"location":"classcoro_1_1channel__reader/#function-channel_reader","text":"coro :: channel_reader ::~ channel_reader () noexcept","title":"function ~channel_reader"},{"location":"classcoro_1_1channel__reader/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"classcoro_1_1channel__reader/#variable-1","text":"union coro :: channel_reader :: @ 0 coro :: channel_reader < T , M >:: @ 1 ;","title":"variable @1"},{"location":"classcoro_1_1channel__reader/#variable-frame","text":"void * coro :: channel_reader < T , M >:: frame ;","title":"variable frame"},{"location":"classcoro_1_1channel__reader/#variable-ptr","text":"pointer coro :: channel_reader < T , M >:: ptr ;","title":"variable ptr"},{"location":"classcoro_1_1channel__reader/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"classcoro_1_1channel__reader/#function-channel_reader-13","text":"inline explicit coro :: channel_reader :: channel_reader ( channel_type & ch ) noexcept","title":"function channel_reader [1/3]"},{"location":"classcoro_1_1channel__reader/#function-channel_reader-23","text":"coro :: channel_reader :: channel_reader ( const channel_reader & ) noexcept","title":"function channel_reader [2/3]"},{"location":"classcoro_1_1channel__reader/#function-channel_reader-33","text":"coro :: channel_reader :: channel_reader ( channel_reader && ) noexcept","title":"function channel_reader [3/3]"},{"location":"classcoro_1_1channel__reader/#function-operator","text":"channel_reader & coro :: channel_reader :: operator = ( const channel_reader & ) noexcept","title":"function operator="},{"location":"classcoro_1_1channel__reader/#function-operator_1","text":"channel_reader & coro :: channel_reader :: operator = ( channel_reader && ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function operator="},{"location":"classcoro_1_1channel__writer/","text":"Class coro::channel_writer \u00b6 template <typename T typename T, typename M typename M> Class List > coro > channel_writer Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . More... #include <channel.hpp> Public Types \u00b6 Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type Public Attributes \u00b6 Type Name channel_type * chan Next writer in channel. channel_writer * next = = nullptr Public Functions \u00b6 Type Name bool await_ready () noexcept const Lock the channel and find available channel_reader __ bool await_resume () noexcept Returns bool indicator for the associtated channel's destruction. void await_suspend ( coroutine_handle < void > coro) noexcept Push to the channel and wait for channel_reader . ~channel_writer () noexcept Detailed Description \u00b6 void write_to ( channel < int >& ch , int value ) { bool ok = co_await ch . write ( value ); if ( ok == false ) ; // channel is under destruction !!! } Template parameters: T type of the element M mutex for the channel See also: channel_reader Public Types Documentation \u00b6 typedef channel_type [1/2] \u00b6 using coro :: channel_writer < T , M >:: channel_type = channel < T , M > ; typedef pointer \u00b6 using coro :: channel_writer < T , M >:: pointer = T * ; typedef reference \u00b6 using coro :: channel_writer < T , M >:: reference = T & ; typedef value_type \u00b6 using coro :: channel_writer < T , M >:: value_type = T ; Public Attributes Documentation \u00b6 variable chan \u00b6 channel_type * coro :: channel_writer < T , M >:: chan ; variable next \u00b6 channel_writer * coro :: channel_writer < T , M >:: next ; Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: channel_writer :: await_ready () noexcept const Returns: true Matched with channel_reader Returns: false There was no available channel_reader . The channel will be **lock**ed for this case. function await_resume \u00b6 inline bool coro :: channel_writer :: await_resume () noexcept Returns: true successfully sent the value to channel_reader Returns: false The channel is under destruction function await_suspend \u00b6 inline void coro :: channel_writer :: await_suspend ( coroutine_handle < void > coro ) noexcept Note: The channel will be **unlock**ed after return. Parameters: coro Remember current coroutine's handle to resume later See also: await_ready function ~channel_writer \u00b6 coro :: channel_writer ::~ channel_writer () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::channel\\_writer"},{"location":"classcoro_1_1channel__writer/#class-corochannel_writer","text":"template <typename T typename T, typename M typename M> Class List > coro > channel_writer Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . More... #include <channel.hpp>","title":"Class coro::channel_writer"},{"location":"classcoro_1_1channel__writer/#public-types","text":"Type Name typedef channel < T, M > channel_type typedef T * pointer typedef T & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1channel__writer/#public-attributes","text":"Type Name channel_type * chan Next writer in channel. channel_writer * next = = nullptr","title":"Public Attributes"},{"location":"classcoro_1_1channel__writer/#public-functions","text":"Type Name bool await_ready () noexcept const Lock the channel and find available channel_reader __ bool await_resume () noexcept Returns bool indicator for the associtated channel's destruction. void await_suspend ( coroutine_handle < void > coro) noexcept Push to the channel and wait for channel_reader . ~channel_writer () noexcept","title":"Public Functions"},{"location":"classcoro_1_1channel__writer/#detailed-description","text":"void write_to ( channel < int >& ch , int value ) { bool ok = co_await ch . write ( value ); if ( ok == false ) ; // channel is under destruction !!! } Template parameters: T type of the element M mutex for the channel See also: channel_reader","title":"Detailed Description"},{"location":"classcoro_1_1channel__writer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1channel__writer/#typedef-channel_type-12","text":"using coro :: channel_writer < T , M >:: channel_type = channel < T , M > ;","title":"typedef channel_type [1/2]"},{"location":"classcoro_1_1channel__writer/#typedef-pointer","text":"using coro :: channel_writer < T , M >:: pointer = T * ;","title":"typedef pointer"},{"location":"classcoro_1_1channel__writer/#typedef-reference","text":"using coro :: channel_writer < T , M >:: reference = T & ;","title":"typedef reference"},{"location":"classcoro_1_1channel__writer/#typedef-value_type","text":"using coro :: channel_writer < T , M >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1channel__writer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1channel__writer/#variable-chan","text":"channel_type * coro :: channel_writer < T , M >:: chan ;","title":"variable chan"},{"location":"classcoro_1_1channel__writer/#variable-next","text":"channel_writer * coro :: channel_writer < T , M >:: next ;","title":"variable next"},{"location":"classcoro_1_1channel__writer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1channel__writer/#function-await_ready","text":"inline bool coro :: channel_writer :: await_ready () noexcept const Returns: true Matched with channel_reader Returns: false There was no available channel_reader . The channel will be **lock**ed for this case.","title":"function await_ready"},{"location":"classcoro_1_1channel__writer/#function-await_resume","text":"inline bool coro :: channel_writer :: await_resume () noexcept Returns: true successfully sent the value to channel_reader Returns: false The channel is under destruction","title":"function await_resume"},{"location":"classcoro_1_1channel__writer/#function-await_suspend","text":"inline void coro :: channel_writer :: await_suspend ( coroutine_handle < void > coro ) noexcept Note: The channel will be **unlock**ed after return. Parameters: coro Remember current coroutine's handle to resume later See also: await_ready","title":"function await_suspend"},{"location":"classcoro_1_1channel__writer/#function-channel_writer","text":"coro :: channel_writer ::~ channel_writer () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function ~channel_writer"},{"location":"classcoro_1_1continue__on__apc/","text":"Class coro::continue_on_apc \u00b6 Class List > coro > continue_on_apc Move into the designated thread's APC queue and continue the routine. More... #include <windows.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept Try to submit the coroutine to the thread's APC queue. continue_on_apc (HANDLE hThread) noexcept Detailed Description \u00b6 See also: QueueUserAPC See also: OpenThread Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool coro :: continue_on_apc :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void coro :: continue_on_apc :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: continue_on_apc :: await_suspend ( coroutine_handle < void > coro ) noexcept Parameters: coro Exception: system_error function continue_on_apc \u00b6 inline explicit coro :: continue_on_apc :: continue_on_apc ( HANDLE hThread ) noexcept Parameters: hThread Target thread's handle See also: OpenThread The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"Class coro::continue\\_on\\_apc"},{"location":"classcoro_1_1continue__on__apc/#class-corocontinue_on_apc","text":"Class List > coro > continue_on_apc Move into the designated thread's APC queue and continue the routine. More... #include <windows.h>","title":"Class coro::continue_on_apc"},{"location":"classcoro_1_1continue__on__apc/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept Try to submit the coroutine to the thread's APC queue. continue_on_apc (HANDLE hThread) noexcept","title":"Public Functions"},{"location":"classcoro_1_1continue__on__apc/#detailed-description","text":"See also: QueueUserAPC See also: OpenThread","title":"Detailed Description"},{"location":"classcoro_1_1continue__on__apc/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1continue__on__apc/#function-await_ready","text":"inline constexpr bool coro :: continue_on_apc :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1continue__on__apc/#function-await_resume","text":"inline constexpr void coro :: continue_on_apc :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1continue__on__apc/#function-await_suspend","text":"inline void coro :: continue_on_apc :: await_suspend ( coroutine_handle < void > coro ) noexcept Parameters: coro Exception: system_error","title":"function await_suspend"},{"location":"classcoro_1_1continue__on__apc/#function-continue_on_apc","text":"inline explicit coro :: continue_on_apc :: continue_on_apc ( HANDLE hThread ) noexcept Parameters: hThread Target thread's handle See also: OpenThread The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"function continue_on_apc"},{"location":"classcoro_1_1continue__on__thread__pool/","text":"Class coro::continue_on_thread_pool \u00b6 Class List > coro > continue_on_thread_pool Move into the win32 thread pool and continue the routine. More... #include <windows.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept Try to submit the coroutine to thread pool. Detailed Description \u00b6 See also: CreateThreadpoolWork See also: SubmitThreadpoolWork See also: CloseThreadpoolWork Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool coro :: continue_on_thread_pool :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void coro :: continue_on_thread_pool :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: continue_on_thread_pool :: await_suspend ( coroutine_handle < void > coro ) noexcept Parameters: coro Exception: system_error The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"Class coro::continue\\_on\\_thread\\_pool"},{"location":"classcoro_1_1continue__on__thread__pool/#class-corocontinue_on_thread_pool","text":"Class List > coro > continue_on_thread_pool Move into the win32 thread pool and continue the routine. More... #include <windows.h>","title":"Class coro::continue_on_thread_pool"},{"location":"classcoro_1_1continue__on__thread__pool/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept Try to submit the coroutine to thread pool.","title":"Public Functions"},{"location":"classcoro_1_1continue__on__thread__pool/#detailed-description","text":"See also: CreateThreadpoolWork See also: SubmitThreadpoolWork See also: CloseThreadpoolWork","title":"Detailed Description"},{"location":"classcoro_1_1continue__on__thread__pool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1continue__on__thread__pool/#function-await_ready","text":"inline constexpr bool coro :: continue_on_thread_pool :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1continue__on__thread__pool/#function-await_resume","text":"inline constexpr void coro :: continue_on_thread_pool :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1continue__on__thread__pool/#function-await_suspend","text":"inline void coro :: continue_on_thread_pool :: await_suspend ( coroutine_handle < void > coro ) noexcept Parameters: coro Exception: system_error The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"function await_suspend"},{"location":"classcoro_1_1enumerable/","text":"Class coro::enumerable \u00b6 template <typename T typename T> Class List > coro > enumerable #include <yield.hpp> Classes \u00b6 Type Name class iterator class promise_type Public Types \u00b6 Type Name typedef value_type * pointer typedef value_type & reference typedef T value_type Public Functions \u00b6 Type Name iterator begin () noexcept iterator end () noexcept enumerable (const enumerable &) = delete enumerable ( enumerable && rhs) noexcept enumerable () noexcept enumerable ( promise_type * ptr) noexcept enumerable & operator= (const enumerable &) = delete enumerable & operator= ( enumerable && rhs) noexcept ~enumerable () noexcept Public Types Documentation \u00b6 typedef pointer \u00b6 using coro :: enumerable < T >:: pointer = value_type * ; typedef reference \u00b6 using coro :: enumerable < T >:: reference = value_type & ; typedef value_type \u00b6 using coro :: enumerable < T >:: value_type = T ; Public Functions Documentation \u00b6 function begin \u00b6 inline iterator coro :: enumerable :: begin () noexcept function end \u00b6 inline iterator coro :: enumerable :: end () noexcept function enumerable [1/4] \u00b6 coro :: enumerable :: enumerable ( const enumerable & ) = delete function enumerable [2/4] \u00b6 inline coro :: enumerable :: enumerable ( enumerable && rhs ) noexcept function enumerable [3/4] \u00b6 coro :: enumerable :: enumerable () noexcept function enumerable [4/4] \u00b6 inline coro :: enumerable :: enumerable ( promise_type * ptr ) noexcept function operator= \u00b6 enumerable & coro :: enumerable :: operator = ( const enumerable & ) = delete function operator= \u00b6 inline enumerable & coro :: enumerable :: operator = ( enumerable && rhs ) noexcept function ~enumerable \u00b6 inline coro :: enumerable ::~ enumerable () noexcept The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"Class coro::enumerable"},{"location":"classcoro_1_1enumerable/#class-coroenumerable","text":"template <typename T typename T> Class List > coro > enumerable #include <yield.hpp>","title":"Class coro::enumerable"},{"location":"classcoro_1_1enumerable/#classes","text":"Type Name class iterator class promise_type","title":"Classes"},{"location":"classcoro_1_1enumerable/#public-types","text":"Type Name typedef value_type * pointer typedef value_type & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1enumerable/#public-functions","text":"Type Name iterator begin () noexcept iterator end () noexcept enumerable (const enumerable &) = delete enumerable ( enumerable && rhs) noexcept enumerable () noexcept enumerable ( promise_type * ptr) noexcept enumerable & operator= (const enumerable &) = delete enumerable & operator= ( enumerable && rhs) noexcept ~enumerable () noexcept","title":"Public Functions"},{"location":"classcoro_1_1enumerable/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1enumerable/#typedef-pointer","text":"using coro :: enumerable < T >:: pointer = value_type * ;","title":"typedef pointer"},{"location":"classcoro_1_1enumerable/#typedef-reference","text":"using coro :: enumerable < T >:: reference = value_type & ;","title":"typedef reference"},{"location":"classcoro_1_1enumerable/#typedef-value_type","text":"using coro :: enumerable < T >:: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1enumerable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1enumerable/#function-begin","text":"inline iterator coro :: enumerable :: begin () noexcept","title":"function begin"},{"location":"classcoro_1_1enumerable/#function-end","text":"inline iterator coro :: enumerable :: end () noexcept","title":"function end"},{"location":"classcoro_1_1enumerable/#function-enumerable-14","text":"coro :: enumerable :: enumerable ( const enumerable & ) = delete","title":"function enumerable [1/4]"},{"location":"classcoro_1_1enumerable/#function-enumerable-24","text":"inline coro :: enumerable :: enumerable ( enumerable && rhs ) noexcept","title":"function enumerable [2/4]"},{"location":"classcoro_1_1enumerable/#function-enumerable-34","text":"coro :: enumerable :: enumerable () noexcept","title":"function enumerable [3/4]"},{"location":"classcoro_1_1enumerable/#function-enumerable-44","text":"inline coro :: enumerable :: enumerable ( promise_type * ptr ) noexcept","title":"function enumerable [4/4]"},{"location":"classcoro_1_1enumerable/#function-operator","text":"enumerable & coro :: enumerable :: operator = ( const enumerable & ) = delete","title":"function operator="},{"location":"classcoro_1_1enumerable/#function-operator_1","text":"inline enumerable & coro :: enumerable :: operator = ( enumerable && rhs ) noexcept","title":"function operator="},{"location":"classcoro_1_1enumerable/#function-enumerable","text":"inline coro :: enumerable ::~ enumerable () noexcept The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"function ~enumerable"},{"location":"classcoro_1_1enumerable_1_1iterator/","text":"Class coro::enumerable::iterator \u00b6 Class List > coro > enumerable > iterator #include <yield.hpp> Public Types \u00b6 Type Name typedef ptrdiff_t difference_type typedef std::forward_iterator_tag iterator_category typedef value_type * pointer typedef value_type & reference typedef T value_type Public Attributes \u00b6 Type Name coroutine_handle < promise_type > coro Public Functions \u00b6 Type Name iterator (std::nullptr_t) noexcept iterator ( coroutine_handle < promise_type > handle) noexcept bool operator!= (const iterator & rhs) noexcept const reference operator* () noexcept iterator & operator++ (int) = delete iterator & operator++ () noexcept pointer operator-> () noexcept bool operator== (const iterator & rhs) noexcept const Public Types Documentation \u00b6 typedef difference_type \u00b6 using coro :: enumerable < T >:: iterator :: difference_type = ptrdiff_t ; typedef iterator_category \u00b6 using coro :: enumerable < T >:: iterator :: iterator_category = std :: forward_iterator_tag ; typedef pointer \u00b6 using coro :: enumerable < T >:: iterator :: pointer = value_type * ; typedef reference \u00b6 using coro :: enumerable < T >:: iterator :: reference = value_type & ; typedef value_type \u00b6 using coro :: enumerable < T >:: iterator :: value_type = T ; Public Attributes Documentation \u00b6 variable coro \u00b6 coroutine_handle < promise_type > coro :: enumerable < T >:: iterator :: coro ; Public Functions Documentation \u00b6 function iterator [1/2] \u00b6 inline explicit coro :: enumerable :: iterator :: iterator ( std :: nullptr_t ) noexcept function iterator [2/2] \u00b6 inline explicit coro :: enumerable :: iterator :: iterator ( coroutine_handle < promise_type > handle ) noexcept function operator!= \u00b6 inline bool coro :: enumerable :: iterator :: operator != ( const iterator & rhs ) noexcept const function operator* \u00b6 inline reference coro :: enumerable :: iterator :: operator * () noexcept function operator++ \u00b6 iterator & coro :: enumerable :: iterator :: operator ++ ( int ) = delete function operator++ \u00b6 inline iterator & coro :: enumerable :: iterator :: operator ++ () noexcept function operator-> \u00b6 inline pointer coro :: enumerable :: iterator :: operator -> () noexcept function operator== \u00b6 inline bool coro :: enumerable :: iterator :: operator == ( const iterator & rhs ) noexcept const The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"Class coro::enumerable::iterator"},{"location":"classcoro_1_1enumerable_1_1iterator/#class-coroenumerableiterator","text":"Class List > coro > enumerable > iterator #include <yield.hpp>","title":"Class coro::enumerable::iterator"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-types","text":"Type Name typedef ptrdiff_t difference_type typedef std::forward_iterator_tag iterator_category typedef value_type * pointer typedef value_type & reference typedef T value_type","title":"Public Types"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-attributes","text":"Type Name coroutine_handle < promise_type > coro","title":"Public Attributes"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-functions","text":"Type Name iterator (std::nullptr_t) noexcept iterator ( coroutine_handle < promise_type > handle) noexcept bool operator!= (const iterator & rhs) noexcept const reference operator* () noexcept iterator & operator++ (int) = delete iterator & operator++ () noexcept pointer operator-> () noexcept bool operator== (const iterator & rhs) noexcept const","title":"Public Functions"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-difference_type","text":"using coro :: enumerable < T >:: iterator :: difference_type = ptrdiff_t ;","title":"typedef difference_type"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-iterator_category","text":"using coro :: enumerable < T >:: iterator :: iterator_category = std :: forward_iterator_tag ;","title":"typedef iterator_category"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-pointer","text":"using coro :: enumerable < T >:: iterator :: pointer = value_type * ;","title":"typedef pointer"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-reference","text":"using coro :: enumerable < T >:: iterator :: reference = value_type & ;","title":"typedef reference"},{"location":"classcoro_1_1enumerable_1_1iterator/#typedef-value_type","text":"using coro :: enumerable < T >:: iterator :: value_type = T ;","title":"typedef value_type"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1enumerable_1_1iterator/#variable-coro","text":"coroutine_handle < promise_type > coro :: enumerable < T >:: iterator :: coro ;","title":"variable coro"},{"location":"classcoro_1_1enumerable_1_1iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-iterator-12","text":"inline explicit coro :: enumerable :: iterator :: iterator ( std :: nullptr_t ) noexcept","title":"function iterator [1/2]"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-iterator-22","text":"inline explicit coro :: enumerable :: iterator :: iterator ( coroutine_handle < promise_type > handle ) noexcept","title":"function iterator [2/2]"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator","text":"inline bool coro :: enumerable :: iterator :: operator != ( const iterator & rhs ) noexcept const","title":"function operator!="},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_1","text":"inline reference coro :: enumerable :: iterator :: operator * () noexcept","title":"function operator*"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_2","text":"iterator & coro :: enumerable :: iterator :: operator ++ ( int ) = delete","title":"function operator++"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_3","text":"inline iterator & coro :: enumerable :: iterator :: operator ++ () noexcept","title":"function operator++"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator-","text":"inline pointer coro :: enumerable :: iterator :: operator -> () noexcept","title":"function operator-&gt;"},{"location":"classcoro_1_1enumerable_1_1iterator/#function-operator_4","text":"inline bool coro :: enumerable :: iterator :: operator == ( const iterator & rhs ) noexcept const The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"function operator=="},{"location":"classcoro_1_1enumerable_1_1promise__type/","text":"Class coro::enumerable::promise_type \u00b6 Class List > coro > enumerable > promise_type #include <yield.hpp> Inherits the following classes: coro::promise_aa Public Functions \u00b6 Type Name promise_type * get_return_object () noexcept void return_void () noexcept void unhandled_exception () noexcept auto yield_value ( reference ref) noexcept auto yield_value ( value_type && v) noexcept Public Functions inherited from coro::promise_aa \u00b6 See coro::promise_aa Type Name suspend_always final_suspend () noexcept suspend after return suspend_always initial_suspend () noexcept suspend after invoke Public Functions Documentation \u00b6 function get_return_object \u00b6 inline promise_type * coro :: enumerable :: promise_type :: get_return_object () noexcept function return_void \u00b6 inline void coro :: enumerable :: promise_type :: return_void () noexcept function unhandled_exception \u00b6 inline void coro :: enumerable :: promise_type :: unhandled_exception () noexcept function yield_value [1/2] \u00b6 inline auto coro :: enumerable :: promise_type :: yield_value ( reference ref ) noexcept function yield_value [2/2] \u00b6 inline auto coro :: enumerable :: promise_type :: yield_value ( value_type && v ) noexcept The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"Class coro::enumerable::promise\\_type"},{"location":"classcoro_1_1enumerable_1_1promise__type/#class-coroenumerablepromise_type","text":"Class List > coro > enumerable > promise_type #include <yield.hpp> Inherits the following classes: coro::promise_aa","title":"Class coro::enumerable::promise_type"},{"location":"classcoro_1_1enumerable_1_1promise__type/#public-functions","text":"Type Name promise_type * get_return_object () noexcept void return_void () noexcept void unhandled_exception () noexcept auto yield_value ( reference ref) noexcept auto yield_value ( value_type && v) noexcept","title":"Public Functions"},{"location":"classcoro_1_1enumerable_1_1promise__type/#public-functions-inherited-from-coropromise_aa","text":"See coro::promise_aa Type Name suspend_always final_suspend () noexcept suspend after return suspend_always initial_suspend () noexcept suspend after invoke","title":"Public Functions inherited from coro::promise_aa"},{"location":"classcoro_1_1enumerable_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-get_return_object","text":"inline promise_type * coro :: enumerable :: promise_type :: get_return_object () noexcept","title":"function get_return_object"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-return_void","text":"inline void coro :: enumerable :: promise_type :: return_void () noexcept","title":"function return_void"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-unhandled_exception","text":"inline void coro :: enumerable :: promise_type :: unhandled_exception () noexcept","title":"function unhandled_exception"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-yield_value-12","text":"inline auto coro :: enumerable :: promise_type :: yield_value ( reference ref ) noexcept","title":"function yield_value [1/2]"},{"location":"classcoro_1_1enumerable_1_1promise__type/#function-yield_value-22","text":"inline auto coro :: enumerable :: promise_type :: yield_value ( value_type && v ) noexcept The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"function yield_value [2/2]"},{"location":"classcoro_1_1epoll__owner/","text":"Class coro::epoll_owner \u00b6 Class List > coro > epoll_owner RAII wrapping for epoll file descriptor. #include <linux.h> Public Functions \u00b6 Type Name epoll_owner () noexcept create a fd with epoll . Throw if the function fails. epoll_owner (const epoll_owner &) = delete epoll_owner ( epoll_owner &&) = delete epoll_owner & operator= (const epoll_owner &) = delete epoll_owner & operator= ( epoll_owner &&) = delete void remove (uint64_t fd) unbind the fd to epoll auto submit (int64_t fd, epoll_event & req) noexcept return temporary awaitable object for given event void try_add (uint64_t fd, epoll_event & req) noexcept bind the fd to epoll ptrdiff_t wait (uint32_t wait_ms, gsl::span< epoll_event > list) noexcept fetch all events for the given kqeueue descriptor ~epoll_owner () noexcept close the current epoll file descriptor Public Functions Documentation \u00b6 function epoll_owner [1/3] \u00b6 coro :: epoll_owner :: epoll_owner () noexcept See also: kqeueue Exception: system_error function epoll_owner [2/3] \u00b6 coro :: epoll_owner :: epoll_owner ( const epoll_owner & ) = delete function epoll_owner [3/3] \u00b6 coro :: epoll_owner :: epoll_owner ( epoll_owner && ) = delete function operator= \u00b6 epoll_owner & coro :: epoll_owner :: operator = ( const epoll_owner & ) = delete function operator= \u00b6 epoll_owner & coro :: epoll_owner :: operator = ( epoll_owner && ) = delete function remove \u00b6 void coro :: epoll_owner :: remove ( uint64_t fd ) Parameters: fd See also: epoll_ctl function submit \u00b6 inline auto coro :: epoll_owner :: submit ( int64_t fd , epoll_event & req ) noexcept Parameters: req input for change operation See also: change There is no guarantee of reusage of returned awaiter object When it is awaited, and req.udata is null(0), the value is set to coroutine_handle<void> auto edge_in_async ( epoll_owner & ep , int64_t fd ) -> frame_t { epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = nullptr ; co_await ep . submit ( fd , req ); } function try_add \u00b6 void coro :: epoll_owner :: try_add ( uint64_t fd , epoll_event & req ) noexcept Parameters: fd req See also: epoll_ctl Exception: system_error function wait \u00b6 ptrdiff_t coro :: epoll_owner :: wait ( uint32_t wait_ms , gsl :: span < epoll_event > list ) noexcept Parameters: wait_ms millisecond to wait list Returns: ptrdiff_t See also: epoll_wait Exception: system_error Timeout is not an error for this function function ~epoll_owner \u00b6 coro :: epoll_owner ::~ epoll_owner () noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"Class coro::epoll\\_owner"},{"location":"classcoro_1_1epoll__owner/#class-coroepoll_owner","text":"Class List > coro > epoll_owner RAII wrapping for epoll file descriptor. #include <linux.h>","title":"Class coro::epoll_owner"},{"location":"classcoro_1_1epoll__owner/#public-functions","text":"Type Name epoll_owner () noexcept create a fd with epoll . Throw if the function fails. epoll_owner (const epoll_owner &) = delete epoll_owner ( epoll_owner &&) = delete epoll_owner & operator= (const epoll_owner &) = delete epoll_owner & operator= ( epoll_owner &&) = delete void remove (uint64_t fd) unbind the fd to epoll auto submit (int64_t fd, epoll_event & req) noexcept return temporary awaitable object for given event void try_add (uint64_t fd, epoll_event & req) noexcept bind the fd to epoll ptrdiff_t wait (uint32_t wait_ms, gsl::span< epoll_event > list) noexcept fetch all events for the given kqeueue descriptor ~epoll_owner () noexcept close the current epoll file descriptor","title":"Public Functions"},{"location":"classcoro_1_1epoll__owner/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1epoll__owner/#function-epoll_owner-13","text":"coro :: epoll_owner :: epoll_owner () noexcept See also: kqeueue Exception: system_error","title":"function epoll_owner [1/3]"},{"location":"classcoro_1_1epoll__owner/#function-epoll_owner-23","text":"coro :: epoll_owner :: epoll_owner ( const epoll_owner & ) = delete","title":"function epoll_owner [2/3]"},{"location":"classcoro_1_1epoll__owner/#function-epoll_owner-33","text":"coro :: epoll_owner :: epoll_owner ( epoll_owner && ) = delete","title":"function epoll_owner [3/3]"},{"location":"classcoro_1_1epoll__owner/#function-operator","text":"epoll_owner & coro :: epoll_owner :: operator = ( const epoll_owner & ) = delete","title":"function operator="},{"location":"classcoro_1_1epoll__owner/#function-operator_1","text":"epoll_owner & coro :: epoll_owner :: operator = ( epoll_owner && ) = delete","title":"function operator="},{"location":"classcoro_1_1epoll__owner/#function-remove","text":"void coro :: epoll_owner :: remove ( uint64_t fd ) Parameters: fd See also: epoll_ctl","title":"function remove"},{"location":"classcoro_1_1epoll__owner/#function-submit","text":"inline auto coro :: epoll_owner :: submit ( int64_t fd , epoll_event & req ) noexcept Parameters: req input for change operation See also: change There is no guarantee of reusage of returned awaiter object When it is awaited, and req.udata is null(0), the value is set to coroutine_handle<void> auto edge_in_async ( epoll_owner & ep , int64_t fd ) -> frame_t { epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = nullptr ; co_await ep . submit ( fd , req ); }","title":"function submit"},{"location":"classcoro_1_1epoll__owner/#function-try_add","text":"void coro :: epoll_owner :: try_add ( uint64_t fd , epoll_event & req ) noexcept Parameters: fd req See also: epoll_ctl Exception: system_error","title":"function try_add"},{"location":"classcoro_1_1epoll__owner/#function-wait","text":"ptrdiff_t coro :: epoll_owner :: wait ( uint32_t wait_ms , gsl :: span < epoll_event > list ) noexcept Parameters: wait_ms millisecond to wait list Returns: ptrdiff_t See also: epoll_wait Exception: system_error Timeout is not an error for this function","title":"function wait"},{"location":"classcoro_1_1epoll__owner/#function-epoll_owner","text":"coro :: epoll_owner ::~ epoll_owner () noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"function ~epoll_owner"},{"location":"classcoro_1_1event/","text":"Class coro::event \u00b6 Class List > coro > event RAII + stateful eventfd __ More... #include <linux.h> Public Functions \u00b6 Type Name event () noexcept event (const event &) = delete event ( event &&) = delete uint64_t fd () noexcept const bool is_set () noexcept const event & operator= (const event &) = delete event & operator= ( event &&) = delete void reset () noexcept void set () noexcept ~event () noexcept Detailed Description \u00b6 See also: https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/is_epollexclusive_available.cc If the object is signaled( set ), the bound epoll_owner will yield suspended coroutine through epoll_event 's user data. Its object can be co_await ed multiple times Public Functions Documentation \u00b6 function event [1/3] \u00b6 coro :: event :: event () noexcept function event [2/3] \u00b6 coro :: event :: event ( const event & ) = delete function event [3/3] \u00b6 coro :: event :: event ( event && ) = delete function fd \u00b6 uint64_t coro :: event :: fd () noexcept const function is_set \u00b6 bool coro :: event :: is_set () noexcept const function operator= \u00b6 event & coro :: event :: operator = ( const event & ) = delete function operator= \u00b6 event & coro :: event :: operator = ( event && ) = delete function reset \u00b6 void coro :: event :: reset () noexcept function set \u00b6 void coro :: event :: set () noexcept function ~event \u00b6 coro :: event ::~ event () noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"Class coro::event"},{"location":"classcoro_1_1event/#class-coroevent","text":"Class List > coro > event RAII + stateful eventfd __ More... #include <linux.h>","title":"Class coro::event"},{"location":"classcoro_1_1event/#public-functions","text":"Type Name event () noexcept event (const event &) = delete event ( event &&) = delete uint64_t fd () noexcept const bool is_set () noexcept const event & operator= (const event &) = delete event & operator= ( event &&) = delete void reset () noexcept void set () noexcept ~event () noexcept","title":"Public Functions"},{"location":"classcoro_1_1event/#detailed-description","text":"See also: https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/is_epollexclusive_available.cc If the object is signaled( set ), the bound epoll_owner will yield suspended coroutine through epoll_event 's user data. Its object can be co_await ed multiple times","title":"Detailed Description"},{"location":"classcoro_1_1event/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1event/#function-event-13","text":"coro :: event :: event () noexcept","title":"function event [1/3]"},{"location":"classcoro_1_1event/#function-event-23","text":"coro :: event :: event ( const event & ) = delete","title":"function event [2/3]"},{"location":"classcoro_1_1event/#function-event-33","text":"coro :: event :: event ( event && ) = delete","title":"function event [3/3]"},{"location":"classcoro_1_1event/#function-fd","text":"uint64_t coro :: event :: fd () noexcept const","title":"function fd"},{"location":"classcoro_1_1event/#function-is_set","text":"bool coro :: event :: is_set () noexcept const","title":"function is_set"},{"location":"classcoro_1_1event/#function-operator","text":"event & coro :: event :: operator = ( const event & ) = delete","title":"function operator="},{"location":"classcoro_1_1event/#function-operator_1","text":"event & coro :: event :: operator = ( event && ) = delete","title":"function operator="},{"location":"classcoro_1_1event/#function-reset","text":"void coro :: event :: reset () noexcept","title":"function reset"},{"location":"classcoro_1_1event/#function-set","text":"void coro :: event :: set () noexcept","title":"function set"},{"location":"classcoro_1_1event/#function-event","text":"coro :: event ::~ event () noexcept The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"function ~event"},{"location":"classcoro_1_1frame__t/","text":"Class coro::frame_t \u00b6 Class List > coro > frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. More... #include <return.h> Inherits the following classes: std::experimental::coroutine_handle< void > Classes \u00b6 Type Name class promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __ Public Types inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name union prefix_t Public Attributes inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name prefix_t prefix Public Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept Public Static Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept Detailed Description \u00b6 See also: coroutine_handle<void> The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::frame\\_t"},{"location":"classcoro_1_1frame__t/#class-coroframe_t","text":"Class List > coro > frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. More... #include <return.h> Inherits the following classes: std::experimental::coroutine_handle< void >","title":"Class coro::frame_t"},{"location":"classcoro_1_1frame__t/#classes","text":"Type Name class promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __","title":"Classes"},{"location":"classcoro_1_1frame__t/#public-types-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name union prefix_t","title":"Public Types inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#public-attributes-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name prefix_t prefix","title":"Public Attributes inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#public-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept","title":"Public Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#public-static-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept","title":"Public Static Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classcoro_1_1frame__t/#detailed-description","text":"See also: coroutine_handle<void> The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Detailed Description"},{"location":"classcoro_1_1frame__t_1_1promise__type/","text":"Class coro::frame_t::promise_type \u00b6 Class List > coro > frame_t > promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __ #include <return.h> Inherits the following classes: coro::promise_na Public Functions \u00b6 Type Name frame_t get_return_object () noexcept Acquire coroutine_handle<void> from current promise and return it. void return_void () noexcept this is a void return for the coroutines void unhandled_exception () noexcept The frame_t will do nothing for exception handling. Public Functions inherited from coro::promise_na \u00b6 See coro::promise_na Type Name suspend_always final_suspend () noexcept suspend after return suspend_never initial_suspend () noexcept no suspend after invoke Public Functions Documentation \u00b6 function get_return_object \u00b6 inline frame_t coro :: frame_t :: promise_type :: get_return_object () noexcept Returns: frame_t function return_void \u00b6 inline void coro :: frame_t :: promise_type :: return_void () noexcept function unhandled_exception \u00b6 inline void coro :: frame_t :: promise_type :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::frame\\_t::promise\\_type"},{"location":"classcoro_1_1frame__t_1_1promise__type/#class-coroframe_tpromise_type","text":"Class List > coro > frame_t > promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __ #include <return.h> Inherits the following classes: coro::promise_na","title":"Class coro::frame_t::promise_type"},{"location":"classcoro_1_1frame__t_1_1promise__type/#public-functions","text":"Type Name frame_t get_return_object () noexcept Acquire coroutine_handle<void> from current promise and return it. void return_void () noexcept this is a void return for the coroutines void unhandled_exception () noexcept The frame_t will do nothing for exception handling.","title":"Public Functions"},{"location":"classcoro_1_1frame__t_1_1promise__type/#public-functions-inherited-from-coropromise_na","text":"See coro::promise_na Type Name suspend_always final_suspend () noexcept suspend after return suspend_never initial_suspend () noexcept no suspend after invoke","title":"Public Functions inherited from coro::promise_na"},{"location":"classcoro_1_1frame__t_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1frame__t_1_1promise__type/#function-get_return_object","text":"inline frame_t coro :: frame_t :: promise_type :: get_return_object () noexcept Returns: frame_t","title":"function get_return_object"},{"location":"classcoro_1_1frame__t_1_1promise__type/#function-return_void","text":"inline void coro :: frame_t :: promise_type :: return_void () noexcept","title":"function return_void"},{"location":"classcoro_1_1frame__t_1_1promise__type/#function-unhandled_exception","text":"inline void coro :: frame_t :: promise_type :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function unhandled_exception"},{"location":"classcoro_1_1internal_1_1list/","text":"Class coro::internal::list \u00b6 template <typename T> Class List > coro > internal > list Linked list without allocation. More... #include <channel.hpp> Public Functions \u00b6 Type Name bool is_empty () noexcept const auto pop () noexcept void push (T * node) noexcept Detailed Description \u00b6 Template parameters: T Type of the node. Its member must have next pointer Public Functions Documentation \u00b6 function is_empty \u00b6 inline bool coro :: internal :: list :: is_empty () noexcept const function pop \u00b6 inline auto coro :: internal :: list :: pop () noexcept Returns: T* The return can be nullptr function push \u00b6 inline void coro :: internal :: list :: push ( T * node ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Class coro::internal::list"},{"location":"classcoro_1_1internal_1_1list/#class-corointernallist","text":"template <typename T> Class List > coro > internal > list Linked list without allocation. More... #include <channel.hpp>","title":"Class coro::internal::list"},{"location":"classcoro_1_1internal_1_1list/#public-functions","text":"Type Name bool is_empty () noexcept const auto pop () noexcept void push (T * node) noexcept","title":"Public Functions"},{"location":"classcoro_1_1internal_1_1list/#detailed-description","text":"Template parameters: T Type of the node. Its member must have next pointer","title":"Detailed Description"},{"location":"classcoro_1_1internal_1_1list/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1internal_1_1list/#function-is_empty","text":"inline bool coro :: internal :: list :: is_empty () noexcept const","title":"function is_empty"},{"location":"classcoro_1_1internal_1_1list/#function-pop","text":"inline auto coro :: internal :: list :: pop () noexcept Returns: T* The return can be nullptr","title":"function pop"},{"location":"classcoro_1_1internal_1_1list/#function-push","text":"inline void coro :: internal :: list :: push ( T * node ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function push"},{"location":"classcoro_1_1io__recv/","text":"Class coro::io_recv \u00b6 Class List > coro > io_recv Awaitable type to perform recv I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name bool ready () noexcept const Detailed Description \u00b6 See also: recv See also: WSARecv Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_recv :: await_ready () noexcept const function await_resume \u00b6 inline int64_t coro :: io_recv :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_recv :: await_suspend ( coroutine_handle < void > t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_recv"},{"location":"classcoro_1_1io__recv/#class-coroio_recv","text":"Class List > coro > io_recv Awaitable type to perform recv I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t","title":"Class coro::io_recv"},{"location":"classcoro_1_1io__recv/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv/#public-functions","text":"Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__recv/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv/#detailed-description","text":"See also: recv See also: WSARecv","title":"Detailed Description"},{"location":"classcoro_1_1io__recv/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__recv/#function-await_ready","text":"inline bool coro :: io_recv :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__recv/#function-await_resume","text":"inline int64_t coro :: io_recv :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__recv/#function-await_suspend","text":"inline void coro :: io_recv :: await_suspend ( coroutine_handle < void > t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__recv__from/","text":"Class coro::io_recv_from \u00b6 Class List > coro > io_recv_from Awaitable type to perform recvfrom I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name bool ready () noexcept const Detailed Description \u00b6 See also: recvfrom See also: WSARecvFrom Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_recv_from :: await_ready () noexcept const function await_resume \u00b6 inline int64_t coro :: io_recv_from :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_recv_from :: await_suspend ( coroutine_handle < void > t ) noexcept Exception: std::system_error The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_recv\\_from"},{"location":"classcoro_1_1io__recv__from/#class-coroio_recv_from","text":"Class List > coro > io_recv_from Awaitable type to perform recvfrom I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t","title":"Class coro::io_recv_from"},{"location":"classcoro_1_1io__recv__from/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv__from/#public-functions","text":"Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__recv__from/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv__from/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__recv__from/#detailed-description","text":"See also: recvfrom See also: WSARecvFrom","title":"Detailed Description"},{"location":"classcoro_1_1io__recv__from/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__recv__from/#function-await_ready","text":"inline bool coro :: io_recv_from :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__recv__from/#function-await_resume","text":"inline int64_t coro :: io_recv_from :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__recv__from/#function-await_suspend","text":"inline void coro :: io_recv_from :: await_suspend ( coroutine_handle < void > t ) noexcept Exception: std::system_error The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__send/","text":"Class coro::io_send \u00b6 Class List > coro > io_send Awaitable type to perform send I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name bool ready () noexcept const Detailed Description \u00b6 See also: send See also: WSASend Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_send :: await_ready () noexcept const function await_resume \u00b6 inline int64_t coro :: io_send :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_send :: await_suspend ( coroutine_handle < void > t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_send"},{"location":"classcoro_1_1io__send/#class-coroio_send","text":"Class List > coro > io_send Awaitable type to perform send I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t","title":"Class coro::io_send"},{"location":"classcoro_1_1io__send/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send/#public-functions","text":"Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__send/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send/#detailed-description","text":"See also: send See also: WSASend","title":"Detailed Description"},{"location":"classcoro_1_1io__send/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__send/#function-await_ready","text":"inline bool coro :: io_send :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__send/#function-await_resume","text":"inline int64_t coro :: io_send :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__send/#function-await_suspend","text":"inline void coro :: io_send :: await_suspend ( coroutine_handle < void > t ) noexcept The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__send__to/","text":"Class coro::io_send_to \u00b6 Class List > coro > io_send_to Awaitable type to perform sendto I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t Public Attributes inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept Public Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions inherited from coro::io_work_t \u00b6 See coro::io_work_t Type Name bool ready () noexcept const Detailed Description \u00b6 See also: sendto See also: WSASendTo Public Functions Documentation \u00b6 function await_ready \u00b6 inline bool coro :: io_send_to :: await_ready () noexcept const function await_resume \u00b6 inline int64_t coro :: io_send_to :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: io_send_to :: await_suspend ( coroutine_handle < void > t ) noexcept Exception: std::system_error The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_send\\_to"},{"location":"classcoro_1_1io__send__to/#class-coroio_send_to","text":"Class List > coro > io_send_to Awaitable type to perform sendto I/O request. More... #include <net.h> Inherits the following classes: coro::io_work_t","title":"Class coro::io_send_to"},{"location":"classcoro_1_1io__send__to/#public-attributes-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send__to/#public-functions","text":"Type Name bool await_ready () noexcept const int64_t await_resume () noexcept void await_suspend ( coroutine_handle < void > t) noexcept","title":"Public Functions"},{"location":"classcoro_1_1io__send__to/#public-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send__to/#protected-functions-inherited-from-coroio_work_t","text":"See coro::io_work_t Type Name bool ready () noexcept const","title":"Protected Functions inherited from coro::io_work_t"},{"location":"classcoro_1_1io__send__to/#detailed-description","text":"See also: sendto See also: WSASendTo","title":"Detailed Description"},{"location":"classcoro_1_1io__send__to/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__send__to/#function-await_ready","text":"inline bool coro :: io_send_to :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1io__send__to/#function-await_resume","text":"inline int64_t coro :: io_send_to :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1io__send__to/#function-await_suspend","text":"inline void coro :: io_send_to :: await_suspend ( coroutine_handle < void > t ) noexcept Exception: std::system_error The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function await_suspend"},{"location":"classcoro_1_1io__work__t/","text":"Class coro::io_work_t \u00b6 Class List > coro > io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. #include <net.h> Inherits the following classes: io_control_block Inherited by the following classes: coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to Public Attributes \u00b6 Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {} Public Functions \u00b6 Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter. Protected Functions \u00b6 Type Name bool ready () noexcept const Public Attributes Documentation \u00b6 variable buffer \u00b6 io_buffer_t coro :: io_work_t :: buffer ; variable task \u00b6 coroutine_handle < void > coro :: io_work_t :: task ; Public Functions Documentation \u00b6 function error \u00b6 uint32_t coro :: io_work_t :: error () noexcept const Returns: uint32_t error code from the system Protected Functions Documentation \u00b6 function ready \u00b6 bool coro :: io_work_t :: ready () noexcept const See also: await_ready Returns: true The given socket can be use for non-blocking operations Returns: false For Windows, the return is always false The documentation for this class was generated from the following file interface/coroutine/net.h","title":"Class coro::io\\_work\\_t"},{"location":"classcoro_1_1io__work__t/#class-coroio_work_t","text":"Class List > coro > io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. #include <net.h> Inherits the following classes: io_control_block Inherited by the following classes: coro::io_recv , coro::io_recv_from , coro::io_send , coro::io_send_to","title":"Class coro::io_work_t"},{"location":"classcoro_1_1io__work__t/#public-attributes","text":"Type Name io_buffer_t buffer = {} coroutine_handle < void > task = {}","title":"Public Attributes"},{"location":"classcoro_1_1io__work__t/#public-functions","text":"Type Name uint32_t error () noexcept const Multiple retrieving won't be a matter.","title":"Public Functions"},{"location":"classcoro_1_1io__work__t/#protected-functions","text":"Type Name bool ready () noexcept const","title":"Protected Functions"},{"location":"classcoro_1_1io__work__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1io__work__t/#variable-buffer","text":"io_buffer_t coro :: io_work_t :: buffer ;","title":"variable buffer"},{"location":"classcoro_1_1io__work__t/#variable-task","text":"coroutine_handle < void > coro :: io_work_t :: task ;","title":"variable task"},{"location":"classcoro_1_1io__work__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1io__work__t/#function-error","text":"uint32_t coro :: io_work_t :: error () noexcept const Returns: uint32_t error code from the system","title":"function error"},{"location":"classcoro_1_1io__work__t/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"classcoro_1_1io__work__t/#function-ready","text":"bool coro :: io_work_t :: ready () noexcept const See also: await_ready Returns: true The given socket can be use for non-blocking operations Returns: false For Windows, the return is always false The documentation for this class was generated from the following file interface/coroutine/net.h","title":"function ready"},{"location":"classcoro_1_1kqueue__owner/","text":"Class coro::kqueue_owner \u00b6 Class List > coro > kqueue_owner RAII wrapping for kqueue file descriptor. #include <unix.h> Public Functions \u00b6 Type Name void change (kevent64_s & req) noexcept bind the event to kqueue ptrdiff_t events (const timespec & wait_time, gsl::span< kevent64_s > list) noexcept fetch all events for the given kqeueue descriptor kqueue_owner () noexcept create a fd with kqueue . Throw if the function fails. kqueue_owner (const kqueue_owner &) = delete kqueue_owner ( kqueue_owner &&) = delete kqueue_owner & operator= (const kqueue_owner &) = delete kqueue_owner & operator= ( kqueue_owner &&) = delete auto submit (kevent64_s & req) noexcept return temporary awaitable object for given event ~kqueue_owner () noexcept close the current kqueue file descriptor Public Functions Documentation \u00b6 function change \u00b6 void coro :: kqueue_owner :: change ( kevent64_s & req ) noexcept Parameters: req See also: kevent64 Exception: system_error The function is named change because the given argument is used for 'change list' fo kqueue64 function events \u00b6 ptrdiff_t coro :: kqueue_owner :: events ( const timespec & wait_time , gsl :: span < kevent64_s > list ) noexcept Parameters: wait_time list Returns: ptrdiff_t See also: kevent64 Exception: system_error The function is named events because the given argument is used for 'event list' fo kqueue64 Timeout is not an error for this function function kqueue_owner [1/3] \u00b6 coro :: kqueue_owner :: kqueue_owner () noexcept See also: kqeueue Exception: system_error function kqueue_owner [2/3] \u00b6 coro :: kqueue_owner :: kqueue_owner ( const kqueue_owner & ) = delete function kqueue_owner [3/3] \u00b6 coro :: kqueue_owner :: kqueue_owner ( kqueue_owner && ) = delete function operator= \u00b6 kqueue_owner & coro :: kqueue_owner :: operator = ( const kqueue_owner & ) = delete function operator= \u00b6 kqueue_owner & coro :: kqueue_owner :: operator = ( kqueue_owner && ) = delete function submit \u00b6 inline auto coro :: kqueue_owner :: submit ( kevent64_s & req ) noexcept Parameters: req input for change operation See also: change There is no guarantee of reusage of returned awaiter object When it is awaited, and req.udata is null(0), the value is set to coroutine_handle<void> auto read_async ( kqueue_owner & kq , uint64_t fd ) -> frame_t { kevent64_s req {. ident = fd , . filter = EVFILT_READ , . flags = EV_ADD | EV_ENABLE | EV_ONESHOT }; co_await kq . submit ( req ); // ... co_await kq . submit ( req ); // ... } function ~kqueue_owner \u00b6 coro :: kqueue_owner ::~ kqueue_owner () noexcept The documentation for this class was generated from the following file interface/coroutine/unix.h","title":"Class coro::kqueue\\_owner"},{"location":"classcoro_1_1kqueue__owner/#class-corokqueue_owner","text":"Class List > coro > kqueue_owner RAII wrapping for kqueue file descriptor. #include <unix.h>","title":"Class coro::kqueue_owner"},{"location":"classcoro_1_1kqueue__owner/#public-functions","text":"Type Name void change (kevent64_s & req) noexcept bind the event to kqueue ptrdiff_t events (const timespec & wait_time, gsl::span< kevent64_s > list) noexcept fetch all events for the given kqeueue descriptor kqueue_owner () noexcept create a fd with kqueue . Throw if the function fails. kqueue_owner (const kqueue_owner &) = delete kqueue_owner ( kqueue_owner &&) = delete kqueue_owner & operator= (const kqueue_owner &) = delete kqueue_owner & operator= ( kqueue_owner &&) = delete auto submit (kevent64_s & req) noexcept return temporary awaitable object for given event ~kqueue_owner () noexcept close the current kqueue file descriptor","title":"Public Functions"},{"location":"classcoro_1_1kqueue__owner/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1kqueue__owner/#function-change","text":"void coro :: kqueue_owner :: change ( kevent64_s & req ) noexcept Parameters: req See also: kevent64 Exception: system_error The function is named change because the given argument is used for 'change list' fo kqueue64","title":"function change"},{"location":"classcoro_1_1kqueue__owner/#function-events","text":"ptrdiff_t coro :: kqueue_owner :: events ( const timespec & wait_time , gsl :: span < kevent64_s > list ) noexcept Parameters: wait_time list Returns: ptrdiff_t See also: kevent64 Exception: system_error The function is named events because the given argument is used for 'event list' fo kqueue64 Timeout is not an error for this function","title":"function events"},{"location":"classcoro_1_1kqueue__owner/#function-kqueue_owner-13","text":"coro :: kqueue_owner :: kqueue_owner () noexcept See also: kqeueue Exception: system_error","title":"function kqueue_owner [1/3]"},{"location":"classcoro_1_1kqueue__owner/#function-kqueue_owner-23","text":"coro :: kqueue_owner :: kqueue_owner ( const kqueue_owner & ) = delete","title":"function kqueue_owner [2/3]"},{"location":"classcoro_1_1kqueue__owner/#function-kqueue_owner-33","text":"coro :: kqueue_owner :: kqueue_owner ( kqueue_owner && ) = delete","title":"function kqueue_owner [3/3]"},{"location":"classcoro_1_1kqueue__owner/#function-operator","text":"kqueue_owner & coro :: kqueue_owner :: operator = ( const kqueue_owner & ) = delete","title":"function operator="},{"location":"classcoro_1_1kqueue__owner/#function-operator_1","text":"kqueue_owner & coro :: kqueue_owner :: operator = ( kqueue_owner && ) = delete","title":"function operator="},{"location":"classcoro_1_1kqueue__owner/#function-submit","text":"inline auto coro :: kqueue_owner :: submit ( kevent64_s & req ) noexcept Parameters: req input for change operation See also: change There is no guarantee of reusage of returned awaiter object When it is awaited, and req.udata is null(0), the value is set to coroutine_handle<void> auto read_async ( kqueue_owner & kq , uint64_t fd ) -> frame_t { kevent64_s req {. ident = fd , . filter = EVFILT_READ , . flags = EV_ADD | EV_ENABLE | EV_ONESHOT }; co_await kq . submit ( req ); // ... co_await kq . submit ( req ); // ... }","title":"function submit"},{"location":"classcoro_1_1kqueue__owner/#function-kqueue_owner","text":"coro :: kqueue_owner ::~ kqueue_owner () noexcept The documentation for this class was generated from the following file interface/coroutine/unix.h","title":"function ~kqueue_owner"},{"location":"classcoro_1_1promise__aa/","text":"Class coro::promise_aa \u00b6 Class List > coro > promise_aa More... #include <return.h> Inherited by the following classes: coro::enumerable::promise_type Public Functions \u00b6 Type Name suspend_always final_suspend () noexcept suspend after return suspend_always initial_suspend () noexcept suspend after invoke Detailed Description \u00b6 Note: suspend_always (initial) + suspend_always (final) Public Functions Documentation \u00b6 function final_suspend \u00b6 inline suspend_always coro :: promise_aa :: final_suspend () noexcept Returns: suspend_always function initial_suspend \u00b6 inline suspend_always coro :: promise_aa :: initial_suspend () noexcept Returns: suspend_always The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_aa"},{"location":"classcoro_1_1promise__aa/#class-coropromise_aa","text":"Class List > coro > promise_aa More... #include <return.h> Inherited by the following classes: coro::enumerable::promise_type","title":"Class coro::promise_aa"},{"location":"classcoro_1_1promise__aa/#public-functions","text":"Type Name suspend_always final_suspend () noexcept suspend after return suspend_always initial_suspend () noexcept suspend after invoke","title":"Public Functions"},{"location":"classcoro_1_1promise__aa/#detailed-description","text":"Note: suspend_always (initial) + suspend_always (final)","title":"Detailed Description"},{"location":"classcoro_1_1promise__aa/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__aa/#function-final_suspend","text":"inline suspend_always coro :: promise_aa :: final_suspend () noexcept Returns: suspend_always","title":"function final_suspend"},{"location":"classcoro_1_1promise__aa/#function-initial_suspend","text":"inline suspend_always coro :: promise_aa :: initial_suspend () noexcept Returns: suspend_always The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1promise__an/","text":"Class coro::promise_an \u00b6 Class List > coro > promise_an More... #include <return.h> Public Functions \u00b6 Type Name suspend_never final_suspend () noexcept destroy coroutine frame after return suspend_always initial_suspend () noexcept suspend after invoke Detailed Description \u00b6 Note: suspend_always (initial) + suspend_never (final) Public Functions Documentation \u00b6 function final_suspend \u00b6 inline suspend_never coro :: promise_an :: final_suspend () noexcept Returns: suspend_never function initial_suspend \u00b6 inline suspend_always coro :: promise_an :: initial_suspend () noexcept Returns: suspend_always The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_an"},{"location":"classcoro_1_1promise__an/#class-coropromise_an","text":"Class List > coro > promise_an More... #include <return.h>","title":"Class coro::promise_an"},{"location":"classcoro_1_1promise__an/#public-functions","text":"Type Name suspend_never final_suspend () noexcept destroy coroutine frame after return suspend_always initial_suspend () noexcept suspend after invoke","title":"Public Functions"},{"location":"classcoro_1_1promise__an/#detailed-description","text":"Note: suspend_always (initial) + suspend_never (final)","title":"Detailed Description"},{"location":"classcoro_1_1promise__an/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__an/#function-final_suspend","text":"inline suspend_never coro :: promise_an :: final_suspend () noexcept Returns: suspend_never","title":"function final_suspend"},{"location":"classcoro_1_1promise__an/#function-initial_suspend","text":"inline suspend_always coro :: promise_an :: initial_suspend () noexcept Returns: suspend_always The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1promise__na/","text":"Class coro::promise_na \u00b6 Class List > coro > promise_na More... #include <return.h> Inherited by the following classes: coro::frame_t::promise_type Public Functions \u00b6 Type Name suspend_always final_suspend () noexcept suspend after return suspend_never initial_suspend () noexcept no suspend after invoke Detailed Description \u00b6 Note: suspend_never (initial) + suspend_always (final) Public Functions Documentation \u00b6 function final_suspend \u00b6 inline suspend_always coro :: promise_na :: final_suspend () noexcept Returns: suspend_always function initial_suspend \u00b6 inline suspend_never coro :: promise_na :: initial_suspend () noexcept Returns: suspend_never The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_na"},{"location":"classcoro_1_1promise__na/#class-coropromise_na","text":"Class List > coro > promise_na More... #include <return.h> Inherited by the following classes: coro::frame_t::promise_type","title":"Class coro::promise_na"},{"location":"classcoro_1_1promise__na/#public-functions","text":"Type Name suspend_always final_suspend () noexcept suspend after return suspend_never initial_suspend () noexcept no suspend after invoke","title":"Public Functions"},{"location":"classcoro_1_1promise__na/#detailed-description","text":"Note: suspend_never (initial) + suspend_always (final)","title":"Detailed Description"},{"location":"classcoro_1_1promise__na/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__na/#function-final_suspend","text":"inline suspend_always coro :: promise_na :: final_suspend () noexcept Returns: suspend_always","title":"function final_suspend"},{"location":"classcoro_1_1promise__na/#function-initial_suspend","text":"inline suspend_never coro :: promise_na :: initial_suspend () noexcept Returns: suspend_never The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1promise__nn/","text":"Class coro::promise_nn \u00b6 Class List > coro > promise_nn More... #include <return.h> Public Functions \u00b6 Type Name suspend_never final_suspend () noexcept destroy coroutine frame after return suspend_never initial_suspend () noexcept no suspend after invoke Detailed Description \u00b6 Note: suspend_never (initial) + suspend_never (final) Public Functions Documentation \u00b6 function final_suspend \u00b6 inline suspend_never coro :: promise_nn :: final_suspend () noexcept Returns: suspend_never function initial_suspend \u00b6 inline suspend_never coro :: promise_nn :: initial_suspend () noexcept Returns: suspend_never The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Class coro::promise\\_nn"},{"location":"classcoro_1_1promise__nn/#class-coropromise_nn","text":"Class List > coro > promise_nn More... #include <return.h>","title":"Class coro::promise_nn"},{"location":"classcoro_1_1promise__nn/#public-functions","text":"Type Name suspend_never final_suspend () noexcept destroy coroutine frame after return suspend_never initial_suspend () noexcept no suspend after invoke","title":"Public Functions"},{"location":"classcoro_1_1promise__nn/#detailed-description","text":"Note: suspend_never (initial) + suspend_never (final)","title":"Detailed Description"},{"location":"classcoro_1_1promise__nn/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1promise__nn/#function-final_suspend","text":"inline suspend_never coro :: promise_nn :: final_suspend () noexcept Returns: suspend_never","title":"function final_suspend"},{"location":"classcoro_1_1promise__nn/#function-initial_suspend","text":"inline suspend_never coro :: promise_nn :: initial_suspend () noexcept Returns: suspend_never The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function initial_suspend"},{"location":"classcoro_1_1pthread__detacher__t/","text":"Class coro::pthread_detacher_t \u00b6 Class List > coro > pthread_detacher_t Special return type that wraps pthread_detach __ #include <pthread.h> Inherits the following classes: coro::pthread_knower_t Classes \u00b6 Type Name class promise_type Public Functions \u00b6 Type Name pthread_detacher_t ( promise_type * p) noexcept ~pthread_detacher_t () noexcept Public Functions inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name operator pthread_t () noexcept const allow access to the tid __ Protected Attributes inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name pthread_spawn_promise * promise Protected Functions inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept Public Functions Documentation \u00b6 function pthread_detacher_t \u00b6 coro :: pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept Exception: invalid_argument function ~pthread_detacher_t \u00b6 inline coro :: pthread_detacher_t ::~ pthread_detacher_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_detacher\\_t"},{"location":"classcoro_1_1pthread__detacher__t/#class-coropthread_detacher_t","text":"Class List > coro > pthread_detacher_t Special return type that wraps pthread_detach __ #include <pthread.h> Inherits the following classes: coro::pthread_knower_t","title":"Class coro::pthread_detacher_t"},{"location":"classcoro_1_1pthread__detacher__t/#classes","text":"Type Name class promise_type","title":"Classes"},{"location":"classcoro_1_1pthread__detacher__t/#public-functions","text":"Type Name pthread_detacher_t ( promise_type * p) noexcept ~pthread_detacher_t () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__detacher__t/#public-functions-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name operator pthread_t () noexcept const allow access to the tid __","title":"Public Functions inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__detacher__t/#protected-attributes-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name pthread_spawn_promise * promise","title":"Protected Attributes inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__detacher__t/#protected-functions-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept","title":"Protected Functions inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__detacher__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__detacher__t/#function-pthread_detacher_t","text":"coro :: pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept Exception: invalid_argument","title":"function pthread_detacher_t"},{"location":"classcoro_1_1pthread__detacher__t/#function-pthread_detacher_t_1","text":"inline coro :: pthread_detacher_t ::~ pthread_detacher_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function ~pthread_detacher_t"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/","text":"Class coro::pthread_detacher_t::promise_type \u00b6 Class List > coro > pthread_detacher_t > promise_type #include <pthread.h> Inherits the following classes: coro::pthread_spawn_promise Public Attributes inherited from coro::pthread_spawn_promise \u00b6 See coro::pthread_spawn_promise Type Name pthread_t tid = {} Public Functions \u00b6 Type Name auto final_suspend () noexcept auto get_return_object () noexcept void return_void () noexcept Public Functions inherited from coro::pthread_spawn_promise \u00b6 See coro::pthread_spawn_promise Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling Public Functions Documentation \u00b6 function final_suspend \u00b6 inline auto coro :: pthread_detacher_t :: promise_type :: final_suspend () noexcept function get_return_object \u00b6 inline auto coro :: pthread_detacher_t :: promise_type :: get_return_object () noexcept function return_void \u00b6 inline void coro :: pthread_detacher_t :: promise_type :: return_void () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_detacher\\_t::promise\\_type"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#class-coropthread_detacher_tpromise_type","text":"Class List > coro > pthread_detacher_t > promise_type #include <pthread.h> Inherits the following classes: coro::pthread_spawn_promise","title":"Class coro::pthread_detacher_t::promise_type"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#public-attributes-inherited-from-coropthread_spawn_promise","text":"See coro::pthread_spawn_promise Type Name pthread_t tid = {}","title":"Public Attributes inherited from coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#public-functions","text":"Type Name auto final_suspend () noexcept auto get_return_object () noexcept void return_void () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#public-functions-inherited-from-coropthread_spawn_promise","text":"See coro::pthread_spawn_promise Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling","title":"Public Functions inherited from coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#function-final_suspend","text":"inline auto coro :: pthread_detacher_t :: promise_type :: final_suspend () noexcept","title":"function final_suspend"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#function-get_return_object","text":"inline auto coro :: pthread_detacher_t :: promise_type :: get_return_object () noexcept","title":"function get_return_object"},{"location":"classcoro_1_1pthread__detacher__t_1_1promise__type/#function-return_void","text":"inline void coro :: pthread_detacher_t :: promise_type :: return_void () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function return_void"},{"location":"classcoro_1_1pthread__joiner__t/","text":"Class coro::pthread_joiner_t \u00b6 Class List > coro > pthread_joiner_t Special return type that wraps pthread_join __ More... #include <pthread.h> Inherits the following classes: coro::pthread_knower_t Classes \u00b6 Type Name class promise_type Public Functions \u00b6 Type Name pthread_joiner_t ( promise_type * p) noexcept ~pthread_joiner_t () noexcept Public Functions inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name operator pthread_t () noexcept const allow access to the tid __ Protected Attributes inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name pthread_spawn_promise * promise Protected Functions inherited from coro::pthread_knower_t \u00b6 See coro::pthread_knower_t Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept Detailed Description \u00b6 See also: pthread_join Public Functions Documentation \u00b6 function pthread_joiner_t \u00b6 coro :: pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept Exception: invalid_argument function ~pthread_joiner_t \u00b6 inline coro :: pthread_joiner_t ::~ pthread_joiner_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_joiner\\_t"},{"location":"classcoro_1_1pthread__joiner__t/#class-coropthread_joiner_t","text":"Class List > coro > pthread_joiner_t Special return type that wraps pthread_join __ More... #include <pthread.h> Inherits the following classes: coro::pthread_knower_t","title":"Class coro::pthread_joiner_t"},{"location":"classcoro_1_1pthread__joiner__t/#classes","text":"Type Name class promise_type","title":"Classes"},{"location":"classcoro_1_1pthread__joiner__t/#public-functions","text":"Type Name pthread_joiner_t ( promise_type * p) noexcept ~pthread_joiner_t () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__joiner__t/#public-functions-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name operator pthread_t () noexcept const allow access to the tid __","title":"Public Functions inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__joiner__t/#protected-attributes-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name pthread_spawn_promise * promise","title":"Protected Attributes inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__joiner__t/#protected-functions-inherited-from-coropthread_knower_t","text":"See coro::pthread_knower_t Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept","title":"Protected Functions inherited from coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__joiner__t/#detailed-description","text":"See also: pthread_join","title":"Detailed Description"},{"location":"classcoro_1_1pthread__joiner__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__joiner__t/#function-pthread_joiner_t","text":"coro :: pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept Exception: invalid_argument","title":"function pthread_joiner_t"},{"location":"classcoro_1_1pthread__joiner__t/#function-pthread_joiner_t_1","text":"inline coro :: pthread_joiner_t ::~ pthread_joiner_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function ~pthread_joiner_t"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/","text":"Class coro::pthread_joiner_t::promise_type \u00b6 Class List > coro > pthread_joiner_t > promise_type #include <pthread.h> Inherits the following classes: coro::pthread_spawn_promise Public Attributes inherited from coro::pthread_spawn_promise \u00b6 See coro::pthread_spawn_promise Type Name pthread_t tid = {} Public Functions \u00b6 Type Name auto final_suspend () noexcept auto get_return_object () noexcept void return_void () noexcept Public Functions inherited from coro::pthread_spawn_promise \u00b6 See coro::pthread_spawn_promise Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling Public Functions Documentation \u00b6 function final_suspend \u00b6 inline auto coro :: pthread_joiner_t :: promise_type :: final_suspend () noexcept function get_return_object \u00b6 inline auto coro :: pthread_joiner_t :: promise_type :: get_return_object () noexcept function return_void \u00b6 inline void coro :: pthread_joiner_t :: promise_type :: return_void () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_joiner\\_t::promise\\_type"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#class-coropthread_joiner_tpromise_type","text":"Class List > coro > pthread_joiner_t > promise_type #include <pthread.h> Inherits the following classes: coro::pthread_spawn_promise","title":"Class coro::pthread_joiner_t::promise_type"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#public-attributes-inherited-from-coropthread_spawn_promise","text":"See coro::pthread_spawn_promise Type Name pthread_t tid = {}","title":"Public Attributes inherited from coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#public-functions","text":"Type Name auto final_suspend () noexcept auto get_return_object () noexcept void return_void () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#public-functions-inherited-from-coropthread_spawn_promise","text":"See coro::pthread_spawn_promise Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling","title":"Public Functions inherited from coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#function-final_suspend","text":"inline auto coro :: pthread_joiner_t :: promise_type :: final_suspend () noexcept","title":"function final_suspend"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#function-get_return_object","text":"inline auto coro :: pthread_joiner_t :: promise_type :: get_return_object () noexcept","title":"function get_return_object"},{"location":"classcoro_1_1pthread__joiner__t_1_1promise__type/#function-return_void","text":"inline void coro :: pthread_joiner_t :: promise_type :: return_void () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function return_void"},{"location":"classcoro_1_1pthread__knower__t/","text":"Class coro::pthread_knower_t \u00b6 Class List > coro > pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. #include <pthread.h> Inherited by the following classes: coro::pthread_detacher_t , coro::pthread_joiner_t Public Functions \u00b6 Type Name operator pthread_t () noexcept const allow access to the tid __ Protected Attributes \u00b6 Type Name pthread_spawn_promise * promise Protected Functions \u00b6 Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept Public Functions Documentation \u00b6 function operator pthread_t \u00b6 inline coro :: pthread_knower_t :: operator pthread_t () noexcept const Returns: pthread_t Protected Attributes Documentation \u00b6 variable promise \u00b6 pthread_spawn_promise * coro :: pthread_knower_t :: promise ; Protected Functions Documentation \u00b6 function pthread_knower_t \u00b6 inline explicit coro :: pthread_knower_t :: pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_knower\\_t"},{"location":"classcoro_1_1pthread__knower__t/#class-coropthread_knower_t","text":"Class List > coro > pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. #include <pthread.h> Inherited by the following classes: coro::pthread_detacher_t , coro::pthread_joiner_t","title":"Class coro::pthread_knower_t"},{"location":"classcoro_1_1pthread__knower__t/#public-functions","text":"Type Name operator pthread_t () noexcept const allow access to the tid __","title":"Public Functions"},{"location":"classcoro_1_1pthread__knower__t/#protected-attributes","text":"Type Name pthread_spawn_promise * promise","title":"Protected Attributes"},{"location":"classcoro_1_1pthread__knower__t/#protected-functions","text":"Type Name pthread_knower_t ( pthread_spawn_promise * _promise) noexcept","title":"Protected Functions"},{"location":"classcoro_1_1pthread__knower__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__knower__t/#function-operator-pthread_t","text":"inline coro :: pthread_knower_t :: operator pthread_t () noexcept const Returns: pthread_t","title":"function operator pthread_t"},{"location":"classcoro_1_1pthread__knower__t/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"classcoro_1_1pthread__knower__t/#variable-promise","text":"pthread_spawn_promise * coro :: pthread_knower_t :: promise ;","title":"variable promise"},{"location":"classcoro_1_1pthread__knower__t/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"classcoro_1_1pthread__knower__t/#function-pthread_knower_t","text":"inline explicit coro :: pthread_knower_t :: pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function pthread_knower_t"},{"location":"classcoro_1_1pthread__spawn__promise/","text":"Class coro::pthread_spawn_promise \u00b6 Class List > coro > pthread_spawn_promise allows pthread_attr_t* for co_await operator More... #include <pthread.h> Inherited by the following classes: coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type Public Attributes \u00b6 Type Name pthread_t tid = {} Public Functions \u00b6 Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling Detailed Description \u00b6 See also: pthread_create See also: pthread_attr_t The type wraps pthread_create function. After spawn, it contains thread id of the brand-new thread. Public Attributes Documentation \u00b6 variable tid \u00b6 pthread_t coro :: pthread_spawn_promise :: tid ; Public Functions Documentation \u00b6 function await_transform [1/3] \u00b6 inline auto coro :: pthread_spawn_promise :: await_transform ( const pthread_attr_t * attr ) noexcept function await_transform [2/3] \u00b6 inline auto coro :: pthread_spawn_promise :: await_transform ( pthread_attr_t * attr ) noexcept function await_transform [3/3] \u00b6 template < typename Awaitable typename Awaitable > inline decltype ( auto ) coro :: pthread_spawn_promise :: await_transform ( Awaitable && a ) noexcept function initial_suspend \u00b6 inline auto coro :: pthread_spawn_promise :: initial_suspend () noexcept function unhandled_exception \u00b6 inline void coro :: pthread_spawn_promise :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_spawn\\_promise"},{"location":"classcoro_1_1pthread__spawn__promise/#class-coropthread_spawn_promise","text":"Class List > coro > pthread_spawn_promise allows pthread_attr_t* for co_await operator More... #include <pthread.h> Inherited by the following classes: coro::pthread_detacher_t::promise_type , coro::pthread_joiner_t::promise_type","title":"Class coro::pthread_spawn_promise"},{"location":"classcoro_1_1pthread__spawn__promise/#public-attributes","text":"Type Name pthread_t tid = {}","title":"Public Attributes"},{"location":"classcoro_1_1pthread__spawn__promise/#public-functions","text":"Type Name auto await_transform (const pthread_attr_t * attr) noexcept co_await for pthread_attr_t __ auto await_transform (pthread_attr_t * attr) noexcept decltype(auto) await_transform (Awaitable && a) noexcept general co_await auto initial_suspend () noexcept void unhandled_exception () noexcept the activator is responsible for the exception handling","title":"Public Functions"},{"location":"classcoro_1_1pthread__spawn__promise/#detailed-description","text":"See also: pthread_create See also: pthread_attr_t The type wraps pthread_create function. After spawn, it contains thread id of the brand-new thread.","title":"Detailed Description"},{"location":"classcoro_1_1pthread__spawn__promise/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classcoro_1_1pthread__spawn__promise/#variable-tid","text":"pthread_t coro :: pthread_spawn_promise :: tid ;","title":"variable tid"},{"location":"classcoro_1_1pthread__spawn__promise/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__spawn__promise/#function-await_transform-13","text":"inline auto coro :: pthread_spawn_promise :: await_transform ( const pthread_attr_t * attr ) noexcept","title":"function await_transform [1/3]"},{"location":"classcoro_1_1pthread__spawn__promise/#function-await_transform-23","text":"inline auto coro :: pthread_spawn_promise :: await_transform ( pthread_attr_t * attr ) noexcept","title":"function await_transform [2/3]"},{"location":"classcoro_1_1pthread__spawn__promise/#function-await_transform-33","text":"template < typename Awaitable typename Awaitable > inline decltype ( auto ) coro :: pthread_spawn_promise :: await_transform ( Awaitable && a ) noexcept","title":"function await_transform [3/3]"},{"location":"classcoro_1_1pthread__spawn__promise/#function-initial_suspend","text":"inline auto coro :: pthread_spawn_promise :: initial_suspend () noexcept","title":"function initial_suspend"},{"location":"classcoro_1_1pthread__spawn__promise/#function-unhandled_exception","text":"inline void coro :: pthread_spawn_promise :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function unhandled_exception"},{"location":"classcoro_1_1pthread__spawner__t/","text":"Class coro::pthread_spawner_t \u00b6 Class List > coro > pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. #include <pthread.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept pthread_spawner_t (pthread_t * _tid, const pthread_attr_t * _attr) ~pthread_spawner_t () noexcept Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool coro :: pthread_spawner_t :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void coro :: pthread_spawner_t :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: pthread_spawner_t :: await_suspend ( coroutine_handle < void > coro ) noexcept function pthread_spawner_t \u00b6 inline coro :: pthread_spawner_t :: pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) function ~pthread_spawner_t \u00b6 coro :: pthread_spawner_t ::~ pthread_spawner_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Class coro::pthread\\_spawner\\_t"},{"location":"classcoro_1_1pthread__spawner__t/#class-coropthread_spawner_t","text":"Class List > coro > pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. #include <pthread.h>","title":"Class coro::pthread_spawner_t"},{"location":"classcoro_1_1pthread__spawner__t/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept pthread_spawner_t (pthread_t * _tid, const pthread_attr_t * _attr) ~pthread_spawner_t () noexcept","title":"Public Functions"},{"location":"classcoro_1_1pthread__spawner__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1pthread__spawner__t/#function-await_ready","text":"inline constexpr bool coro :: pthread_spawner_t :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1pthread__spawner__t/#function-await_resume","text":"inline constexpr void coro :: pthread_spawner_t :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1pthread__spawner__t/#function-await_suspend","text":"inline void coro :: pthread_spawner_t :: await_suspend ( coroutine_handle < void > coro ) noexcept","title":"function await_suspend"},{"location":"classcoro_1_1pthread__spawner__t/#function-pthread_spawner_t","text":"inline coro :: pthread_spawner_t :: pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr )","title":"function pthread_spawner_t"},{"location":"classcoro_1_1pthread__spawner__t/#function-pthread_spawner_t_1","text":"coro :: pthread_spawner_t ::~ pthread_spawner_t () noexcept The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"function ~pthread_spawner_t"},{"location":"classcoro_1_1section/","text":"Class coro::section \u00b6 Class List > coro > section Standard lockable with win32 criticial section. Inherits the following classes: CRITICAL_SECTION Public Functions \u00b6 Type Name void lock () noexcept void lock () noexcept section & operator= (const section &) = delete section & operator= ( section &&) = delete section () noexcept section (const section &) = delete section ( section &&) = delete section () noexcept bool try_lock () noexcept bool try_lock () noexcept void unlock () noexcept void unlock () noexcept ~section () noexcept ~section () noexcept Public Functions Documentation \u00b6 function lock [1/2] \u00b6 void coro :: section :: lock () noexcept Note: pthread_mutex_ returned EINVAL for lock operation. replaced to rwlock See also: pthread_rwlock_wrlock function lock [1/2] \u00b6 void coro :: section :: lock () noexcept function operator= \u00b6 section & coro :: section :: operator = ( const section & ) = delete function operator= \u00b6 section & coro :: section :: operator = ( section && ) = delete function section [1/6] \u00b6 coro :: section :: section () noexcept See also: pthread_rwlock_init function section [2/6] \u00b6 coro :: section :: section ( const section & ) = delete function section [3/6] \u00b6 coro :: section :: section ( section && ) = delete function section [1/6] \u00b6 coro :: section :: section () noexcept function try_lock [1/2] \u00b6 bool coro :: section :: try_lock () noexcept possible errors are ... * EBUSY * EINVAL * EDEADLK See also: pthread_rwlock_trywrlock Returns: true Returns: false failed. check errno function try_lock [1/2] \u00b6 bool coro :: section :: try_lock () noexcept function unlock [1/2] \u00b6 void coro :: section :: unlock () noexcept See also: pthread_rwlock_unlock function unlock [1/2] \u00b6 void coro :: section :: unlock () noexcept function ~section [1/2] \u00b6 coro :: section ::~ section () noexcept See also: pthread_rwlock_destroy function ~section [1/2] \u00b6 coro :: section ::~ section () noexcept The documentation for this class was generated from the following file modules/system/pthread.cpp","title":"Class coro::section"},{"location":"classcoro_1_1section/#class-corosection","text":"Class List > coro > section Standard lockable with win32 criticial section. Inherits the following classes: CRITICAL_SECTION","title":"Class coro::section"},{"location":"classcoro_1_1section/#public-functions","text":"Type Name void lock () noexcept void lock () noexcept section & operator= (const section &) = delete section & operator= ( section &&) = delete section () noexcept section (const section &) = delete section ( section &&) = delete section () noexcept bool try_lock () noexcept bool try_lock () noexcept void unlock () noexcept void unlock () noexcept ~section () noexcept ~section () noexcept","title":"Public Functions"},{"location":"classcoro_1_1section/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1section/#function-lock-12","text":"void coro :: section :: lock () noexcept Note: pthread_mutex_ returned EINVAL for lock operation. replaced to rwlock See also: pthread_rwlock_wrlock","title":"function lock [1/2]"},{"location":"classcoro_1_1section/#function-lock-12_1","text":"void coro :: section :: lock () noexcept","title":"function lock [1/2]"},{"location":"classcoro_1_1section/#function-operator","text":"section & coro :: section :: operator = ( const section & ) = delete","title":"function operator="},{"location":"classcoro_1_1section/#function-operator_1","text":"section & coro :: section :: operator = ( section && ) = delete","title":"function operator="},{"location":"classcoro_1_1section/#function-section-16","text":"coro :: section :: section () noexcept See also: pthread_rwlock_init","title":"function section [1/6]"},{"location":"classcoro_1_1section/#function-section-26","text":"coro :: section :: section ( const section & ) = delete","title":"function section [2/6]"},{"location":"classcoro_1_1section/#function-section-36","text":"coro :: section :: section ( section && ) = delete","title":"function section [3/6]"},{"location":"classcoro_1_1section/#function-section-16_1","text":"coro :: section :: section () noexcept","title":"function section [1/6]"},{"location":"classcoro_1_1section/#function-try_lock-12","text":"bool coro :: section :: try_lock () noexcept possible errors are ... * EBUSY * EINVAL * EDEADLK See also: pthread_rwlock_trywrlock Returns: true Returns: false failed. check errno","title":"function try_lock [1/2]"},{"location":"classcoro_1_1section/#function-try_lock-12_1","text":"bool coro :: section :: try_lock () noexcept","title":"function try_lock [1/2]"},{"location":"classcoro_1_1section/#function-unlock-12","text":"void coro :: section :: unlock () noexcept See also: pthread_rwlock_unlock","title":"function unlock [1/2]"},{"location":"classcoro_1_1section/#function-unlock-12_1","text":"void coro :: section :: unlock () noexcept","title":"function unlock [1/2]"},{"location":"classcoro_1_1section/#function-section-12","text":"coro :: section ::~ section () noexcept See also: pthread_rwlock_destroy","title":"function ~section [1/2]"},{"location":"classcoro_1_1section/#function-section-12_1","text":"coro :: section ::~ section () noexcept The documentation for this class was generated from the following file modules/system/pthread.cpp","title":"function ~section [1/2]"},{"location":"classcoro_1_1set__or__cancel/","text":"Class coro::set_or_cancel \u00b6 Class List > coro > set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. More... #include <windows.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const uint32_t await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept set_or_cancel (void * target) noexcept uint32_t unregister () noexcept cancel the event waiting ~set_or_cancel () noexcept Detailed Description \u00b6 It uses INFINITE wait. So its user must sure one of SetEvent(hEvent) or sc.unregister() happens after co_await . Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool coro :: set_or_cancel :: await_ready () noexcept const function await_resume \u00b6 inline uint32_t coro :: set_or_cancel :: await_resume () noexcept function await_suspend \u00b6 inline void coro :: set_or_cancel :: await_suspend ( coroutine_handle < void > coro ) noexcept function set_or_cancel [3/3] \u00b6 explicit coro :: set_or_cancel :: set_or_cancel ( void * target ) noexcept function unregister \u00b6 uint32_t coro :: set_or_cancel :: unregister () noexcept Returns: uint32_t See also: https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-unregisterwait function ~set_or_cancel \u00b6 coro :: set_or_cancel ::~ set_or_cancel () noexcept The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"Class coro::set\\_or\\_cancel"},{"location":"classcoro_1_1set__or__cancel/#class-coroset_or_cancel","text":"Class List > coro > set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. More... #include <windows.h>","title":"Class coro::set_or_cancel"},{"location":"classcoro_1_1set__or__cancel/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const uint32_t await_resume () noexcept void await_suspend ( coroutine_handle < void > coro) noexcept set_or_cancel (void * target) noexcept uint32_t unregister () noexcept cancel the event waiting ~set_or_cancel () noexcept","title":"Public Functions"},{"location":"classcoro_1_1set__or__cancel/#detailed-description","text":"It uses INFINITE wait. So its user must sure one of SetEvent(hEvent) or sc.unregister() happens after co_await .","title":"Detailed Description"},{"location":"classcoro_1_1set__or__cancel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classcoro_1_1set__or__cancel/#function-await_ready","text":"inline constexpr bool coro :: set_or_cancel :: await_ready () noexcept const","title":"function await_ready"},{"location":"classcoro_1_1set__or__cancel/#function-await_resume","text":"inline uint32_t coro :: set_or_cancel :: await_resume () noexcept","title":"function await_resume"},{"location":"classcoro_1_1set__or__cancel/#function-await_suspend","text":"inline void coro :: set_or_cancel :: await_suspend ( coroutine_handle < void > coro ) noexcept","title":"function await_suspend"},{"location":"classcoro_1_1set__or__cancel/#function-set_or_cancel-33","text":"explicit coro :: set_or_cancel :: set_or_cancel ( void * target ) noexcept","title":"function set_or_cancel [3/3]"},{"location":"classcoro_1_1set__or__cancel/#function-unregister","text":"uint32_t coro :: set_or_cancel :: unregister () noexcept Returns: uint32_t See also: https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-unregisterwait","title":"function unregister"},{"location":"classcoro_1_1set__or__cancel/#function-set_or_cancel","text":"coro :: set_or_cancel ::~ set_or_cancel () noexcept The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"function ~set_or_cancel"},{"location":"classes/","text":"Class Index \u00b6 b \u00b6 bypass_mutex ( coro ) c \u00b6 channel ( coro ) channel_peeker ( coro ) channel_reader ( coro ) channel_writer ( coro ) continue_on_apc ( coro ) continue_on_thread_pool ( coro ) coroutine_handle ( std::experimental ) coroutine_handle< noop_coroutine_promise > ( std::experimental ) coroutine_handle< void > ( std::experimental ) clang_frame_prefix coroutine_traits ( std::experimental ) coroutine_traits< void, P... > ( std::experimental ) e \u00b6 enumerable ( coro ) epoll_owner ( coro ) event ( coro ) f \u00b6 frame_t ( coro ) g \u00b6 gcc_frame_prefix i \u00b6 iterator ( coro::enumerable ) io_recv ( coro ) io_recv_from ( coro ) io_send ( coro ) io_send_to ( coro ) io_work_t ( coro ) k \u00b6 kqueue_owner ( coro ) l \u00b6 list ( coro::internal ) m \u00b6 msvc_frame_prefix n \u00b6 noop_coroutine_promise ( std::experimental ) p \u00b6 promise_type ( coro::enumerable ) promise_type ( coro::frame_t ) promise_aa ( coro ) promise_an ( coro ) promise_na ( coro ) promise_nn ( coro ) pthread_detacher_t ( coro ) promise_type ( coro::pthread_detacher_t ) pthread_joiner_t ( coro ) promise_type ( coro::pthread_joiner_t ) pthread_knower_t ( coro ) pthread_spawn_promise ( coro ) pthread_spawner_t ( coro ) promise_type ( std::experimental::coroutine_traits< void, P... > ) s \u00b6 section ( coro ) set_or_cancel ( coro ) suspend_always ( std::experimental ) suspend_never ( std::experimental )","title":"Classes"},{"location":"classes/#class-index","text":"","title":"Class Index"},{"location":"classes/#b","text":"bypass_mutex ( coro )","title":"b"},{"location":"classes/#c","text":"channel ( coro ) channel_peeker ( coro ) channel_reader ( coro ) channel_writer ( coro ) continue_on_apc ( coro ) continue_on_thread_pool ( coro ) coroutine_handle ( std::experimental ) coroutine_handle< noop_coroutine_promise > ( std::experimental ) coroutine_handle< void > ( std::experimental ) clang_frame_prefix coroutine_traits ( std::experimental ) coroutine_traits< void, P... > ( std::experimental )","title":"c"},{"location":"classes/#e","text":"enumerable ( coro ) epoll_owner ( coro ) event ( coro )","title":"e"},{"location":"classes/#f","text":"frame_t ( coro )","title":"f"},{"location":"classes/#g","text":"gcc_frame_prefix","title":"g"},{"location":"classes/#i","text":"iterator ( coro::enumerable ) io_recv ( coro ) io_recv_from ( coro ) io_send ( coro ) io_send_to ( coro ) io_work_t ( coro )","title":"i"},{"location":"classes/#k","text":"kqueue_owner ( coro )","title":"k"},{"location":"classes/#l","text":"list ( coro::internal )","title":"l"},{"location":"classes/#m","text":"msvc_frame_prefix","title":"m"},{"location":"classes/#n","text":"noop_coroutine_promise ( std::experimental )","title":"n"},{"location":"classes/#p","text":"promise_type ( coro::enumerable ) promise_type ( coro::frame_t ) promise_aa ( coro ) promise_an ( coro ) promise_na ( coro ) promise_nn ( coro ) pthread_detacher_t ( coro ) promise_type ( coro::pthread_detacher_t ) pthread_joiner_t ( coro ) promise_type ( coro::pthread_joiner_t ) pthread_knower_t ( coro ) pthread_spawn_promise ( coro ) pthread_spawner_t ( coro ) promise_type ( std::experimental::coroutine_traits< void, P... > )","title":"p"},{"location":"classes/#s","text":"section ( coro ) set_or_cancel ( coro ) suspend_always ( std::experimental ) suspend_never ( std::experimental )","title":"s"},{"location":"classstd_1_1experimental_1_1coroutine__handle/","text":"Class std::experimental::coroutine_handle \u00b6 template <typename PromiseType> Class List > std > experimental > coroutine_handle #include <frame.h> Public Types \u00b6 Type Name typedef PromiseType promise_type Public Functions \u00b6 Type Name coroutine_handle & operator= (nullptr_t) noexcept auto promise () noexcept const auto promise () noexcept Public Static Functions \u00b6 Type Name coroutine_handle from_address (void * addr) noexcept coroutine_handle from_promise ( promise_type & prom) noexcept Public Types Documentation \u00b6 typedef promise_type \u00b6 using std :: experimental :: coroutine_handle < PromiseType >:: promise_type = PromiseType ; Public Functions Documentation \u00b6 function operator= \u00b6 inline coroutine_handle & std :: experimental :: coroutine_handle :: operator = ( nullptr_t ) noexcept function promise [1/2] \u00b6 inline auto std :: experimental :: coroutine_handle :: promise () noexcept const function promise [2/2] \u00b6 inline auto std :: experimental :: coroutine_handle :: promise () noexcept Public Static Functions Documentation \u00b6 function from_address \u00b6 static inline coroutine_handle std :: experimental :: coroutine_handle :: from_address ( void * addr ) noexcept function from_promise \u00b6 static inline coroutine_handle std :: experimental :: coroutine_handle :: from_promise ( promise_type & prom ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::coroutine\\_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#class-stdexperimentalcoroutine_handle","text":"template <typename PromiseType> Class List > std > experimental > coroutine_handle #include <frame.h>","title":"Class std::experimental::coroutine_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-types","text":"Type Name typedef PromiseType promise_type","title":"Public Types"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-functions","text":"Type Name coroutine_handle & operator= (nullptr_t) noexcept auto promise () noexcept const auto promise () noexcept","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-static-functions","text":"Type Name coroutine_handle from_address (void * addr) noexcept coroutine_handle from_promise ( promise_type & prom) noexcept","title":"Public Static Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#typedef-promise_type","text":"using std :: experimental :: coroutine_handle < PromiseType >:: promise_type = PromiseType ;","title":"typedef promise_type"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-operator","text":"inline coroutine_handle & std :: experimental :: coroutine_handle :: operator = ( nullptr_t ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-promise-12","text":"inline auto std :: experimental :: coroutine_handle :: promise () noexcept const","title":"function promise [1/2]"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-promise-22","text":"inline auto std :: experimental :: coroutine_handle :: promise () noexcept","title":"function promise [2/2]"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-from_address","text":"static inline coroutine_handle std :: experimental :: coroutine_handle :: from_address ( void * addr ) noexcept","title":"function from_address"},{"location":"classstd_1_1experimental_1_1coroutine__handle/#function-from_promise","text":"static inline coroutine_handle std :: experimental :: coroutine_handle :: from_promise ( promise_type & prom ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function from_promise"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/","text":"Class std::experimental::coroutine_handle< noop_coroutine_promise > \u00b6 template <> Class List > std > experimental > coroutine_handle< noop_coroutine_promise > #include <frame.h> Inherits the following classes: std::experimental::coroutine_handle< void > Public Types inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name union prefix_t Public Attributes \u00b6 Type Name this prefix v = = &p Public Attributes inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name prefix_t prefix Public Functions \u00b6 Type Name constexpr void * address () noexcept const coroutine_handle () noexcept constexpr void destroy () noexcept const constexpr bool done () noexcept const constexpr operator bool () noexcept const constexpr void operator() () noexcept const noop_coroutine_promise & promise () noexcept const constexpr void resume () noexcept const Public Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept Public Static Functions inherited from std::experimental::coroutine_handle< void > \u00b6 See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept Public Attributes Documentation \u00b6 variable v \u00b6 this prefix std :: experimental :: coroutine_handle < noop_coroutine_promise >:: v ; Public Functions Documentation \u00b6 function address \u00b6 inline constexpr void * std :: experimental :: coroutine_handle < noop_coroutine_promise >:: address () noexcept const function coroutine_handle \u00b6 inline std :: experimental :: coroutine_handle < noop_coroutine_promise >:: coroutine_handle () noexcept function destroy \u00b6 inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: destroy () noexcept const function done \u00b6 inline constexpr bool std :: experimental :: coroutine_handle < noop_coroutine_promise >:: done () noexcept const function operator bool \u00b6 inline explicit constexpr std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator bool () noexcept const function operator() \u00b6 inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator () () noexcept const function promise \u00b6 inline noop_coroutine_promise & std :: experimental :: coroutine_handle < noop_coroutine_promise >:: promise () noexcept const function resume \u00b6 inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: resume () noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::coroutine\\_handle&lt; noop\\_coroutine\\_promise &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#class-stdexperimentalcoroutine_handle-noop_coroutine_promise","text":"template <> Class List > std > experimental > coroutine_handle< noop_coroutine_promise > #include <frame.h> Inherits the following classes: std::experimental::coroutine_handle< void >","title":"Class std::experimental::coroutine_handle&lt; noop_coroutine_promise &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-types-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name union prefix_t","title":"Public Types inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-attributes","text":"Type Name this prefix v = = &p","title":"Public Attributes"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-attributes-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name prefix_t prefix","title":"Public Attributes inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-functions","text":"Type Name constexpr void * address () noexcept const coroutine_handle () noexcept constexpr void destroy () noexcept const constexpr bool done () noexcept const constexpr operator bool () noexcept const constexpr void operator() () noexcept const noop_coroutine_promise & promise () noexcept const constexpr void resume () noexcept const","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept","title":"Public Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-static-functions-inherited-from-stdexperimentalcoroutine_handle-void","text":"See std::experimental::coroutine_handle< void > Type Name coroutine_handle from_address (void * addr) noexcept","title":"Public Static Functions inherited from std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#variable-v","text":"this prefix std :: experimental :: coroutine_handle < noop_coroutine_promise >:: v ;","title":"variable v"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-address","text":"inline constexpr void * std :: experimental :: coroutine_handle < noop_coroutine_promise >:: address () noexcept const","title":"function address"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-coroutine_handle","text":"inline std :: experimental :: coroutine_handle < noop_coroutine_promise >:: coroutine_handle () noexcept","title":"function coroutine_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-destroy","text":"inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: destroy () noexcept const","title":"function destroy"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-done","text":"inline constexpr bool std :: experimental :: coroutine_handle < noop_coroutine_promise >:: done () noexcept const","title":"function done"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-operator-bool","text":"inline explicit constexpr std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator bool () noexcept const","title":"function operator bool"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-operator","text":"inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: operator () () noexcept const","title":"function operator()"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-promise","text":"inline noop_coroutine_promise & std :: experimental :: coroutine_handle < noop_coroutine_promise >:: promise () noexcept const","title":"function promise"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01noop__coroutine__promise_01_4/#function-resume","text":"inline constexpr void std :: experimental :: coroutine_handle < noop_coroutine_promise >:: resume () noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function resume"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/","text":"Class std::experimental::coroutine_handle< void > \u00b6 template <> Class List > std > experimental > coroutine_handle< void > #include <frame.h> Inherited by the following classes: coro::frame_t , std::experimental::coroutine_handle< noop_coroutine_promise > Public Types \u00b6 Type Name union prefix_t Public Attributes \u00b6 Type Name prefix_t prefix Public Functions \u00b6 Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept Public Static Functions \u00b6 Type Name coroutine_handle from_address (void * addr) noexcept Public Types Documentation \u00b6 union prefix_t \u00b6 Public Attributes Documentation \u00b6 variable prefix \u00b6 prefix_t std :: experimental :: coroutine_handle < void >:: prefix ; Public Functions Documentation \u00b6 function address \u00b6 inline constexpr void * std :: experimental :: coroutine_handle < void >:: address () noexcept const function coroutine_handle [1/4] \u00b6 std :: experimental :: coroutine_handle < void >:: coroutine_handle () noexcept function coroutine_handle [2/4] \u00b6 std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle const & ) noexcept function coroutine_handle [3/4] \u00b6 std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle && rhs ) noexcept function coroutine_handle [4/4] \u00b6 inline std :: experimental :: coroutine_handle < void >:: coroutine_handle ( std :: nullptr_t ) noexcept function destroy \u00b6 inline void std :: experimental :: coroutine_handle < void >:: destroy () noexcept function done \u00b6 inline bool std :: experimental :: coroutine_handle < void >:: done () noexcept const function operator bool \u00b6 inline explicit std :: experimental :: coroutine_handle < void >:: operator bool () noexcept const function operator= \u00b6 coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle const & ) noexcept function operator= \u00b6 coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle && rhs ) noexcept function operator= \u00b6 inline coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( nullptr_t ) noexcept function resume \u00b6 inline void std :: experimental :: coroutine_handle < void >:: resume () noexcept function ~coroutine_handle \u00b6 std :: experimental :: coroutine_handle < void >::~ coroutine_handle () noexcept Public Static Functions Documentation \u00b6 function from_address \u00b6 static inline coroutine_handle std :: experimental :: coroutine_handle < void >:: from_address ( void * addr ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::coroutine\\_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#class-stdexperimentalcoroutine_handle-void","text":"template <> Class List > std > experimental > coroutine_handle< void > #include <frame.h> Inherited by the following classes: coro::frame_t , std::experimental::coroutine_handle< noop_coroutine_promise >","title":"Class std::experimental::coroutine_handle&lt; void &gt;"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-types","text":"Type Name union prefix_t","title":"Public Types"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-attributes","text":"Type Name prefix_t prefix","title":"Public Attributes"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-functions","text":"Type Name constexpr void * address () noexcept const coroutine_handle () noexcept coroutine_handle ( coroutine_handle const &) noexcept coroutine_handle ( coroutine_handle && rhs) noexcept coroutine_handle (std::nullptr_t) noexcept void destroy () noexcept bool done () noexcept const operator bool () noexcept const coroutine_handle & operator= ( coroutine_handle const &) noexcept coroutine_handle & operator= ( coroutine_handle && rhs) noexcept coroutine_handle & operator= (nullptr_t) noexcept void resume () noexcept ~coroutine_handle () noexcept","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-static-functions","text":"Type Name coroutine_handle from_address (void * addr) noexcept","title":"Public Static Functions"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#union-prefix_t","text":"","title":"union prefix_t"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#variable-prefix","text":"prefix_t std :: experimental :: coroutine_handle < void >:: prefix ;","title":"variable prefix"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-address","text":"inline constexpr void * std :: experimental :: coroutine_handle < void >:: address () noexcept const","title":"function address"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine_handle-14","text":"std :: experimental :: coroutine_handle < void >:: coroutine_handle () noexcept","title":"function coroutine_handle [1/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine_handle-24","text":"std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle const & ) noexcept","title":"function coroutine_handle [2/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine_handle-34","text":"std :: experimental :: coroutine_handle < void >:: coroutine_handle ( coroutine_handle && rhs ) noexcept","title":"function coroutine_handle [3/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine_handle-44","text":"inline std :: experimental :: coroutine_handle < void >:: coroutine_handle ( std :: nullptr_t ) noexcept","title":"function coroutine_handle [4/4]"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-destroy","text":"inline void std :: experimental :: coroutine_handle < void >:: destroy () noexcept","title":"function destroy"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-done","text":"inline bool std :: experimental :: coroutine_handle < void >:: done () noexcept const","title":"function done"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator-bool","text":"inline explicit std :: experimental :: coroutine_handle < void >:: operator bool () noexcept const","title":"function operator bool"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator","text":"coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle const & ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator_1","text":"coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( coroutine_handle && rhs ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-operator_2","text":"inline coroutine_handle & std :: experimental :: coroutine_handle < void >:: operator = ( nullptr_t ) noexcept","title":"function operator="},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-resume","text":"inline void std :: experimental :: coroutine_handle < void >:: resume () noexcept","title":"function resume"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-coroutine_handle","text":"std :: experimental :: coroutine_handle < void >::~ coroutine_handle () noexcept","title":"function ~coroutine_handle"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"classstd_1_1experimental_1_1coroutine__handle_3_01void_01_4/#function-from_address","text":"static inline coroutine_handle std :: experimental :: coroutine_handle < void >:: from_address ( void * addr ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function from_address"},{"location":"classstd_1_1experimental_1_1suspend__always/","text":"Class std::experimental::suspend_always \u00b6 Class List > std > experimental > suspend_always #include <frame.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool std :: experimental :: suspend_always :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void std :: experimental :: suspend_always :: await_resume () noexcept const function await_suspend \u00b6 inline void std :: experimental :: suspend_always :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::suspend\\_always"},{"location":"classstd_1_1experimental_1_1suspend__always/#class-stdexperimentalsuspend_always","text":"Class List > std > experimental > suspend_always #include <frame.h>","title":"Class std::experimental::suspend_always"},{"location":"classstd_1_1experimental_1_1suspend__always/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1suspend__always/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1suspend__always/#function-await_ready","text":"inline constexpr bool std :: experimental :: suspend_always :: await_ready () noexcept const","title":"function await_ready"},{"location":"classstd_1_1experimental_1_1suspend__always/#function-await_resume","text":"inline constexpr void std :: experimental :: suspend_always :: await_resume () noexcept const","title":"function await_resume"},{"location":"classstd_1_1experimental_1_1suspend__always/#function-await_suspend","text":"inline void std :: experimental :: suspend_always :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function await_suspend"},{"location":"classstd_1_1experimental_1_1suspend__never/","text":"Class std::experimental::suspend_never \u00b6 Class List > std > experimental > suspend_never #include <frame.h> Public Functions \u00b6 Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const Public Functions Documentation \u00b6 function await_ready \u00b6 inline constexpr bool std :: experimental :: suspend_never :: await_ready () noexcept const function await_resume \u00b6 inline constexpr void std :: experimental :: suspend_never :: await_resume () noexcept const function await_suspend \u00b6 inline void std :: experimental :: suspend_never :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Class std::experimental::suspend\\_never"},{"location":"classstd_1_1experimental_1_1suspend__never/#class-stdexperimentalsuspend_never","text":"Class List > std > experimental > suspend_never #include <frame.h>","title":"Class std::experimental::suspend_never"},{"location":"classstd_1_1experimental_1_1suspend__never/#public-functions","text":"Type Name constexpr bool await_ready () noexcept const constexpr void await_resume () noexcept const void await_suspend ( coroutine_handle < void >) noexcept const","title":"Public Functions"},{"location":"classstd_1_1experimental_1_1suspend__never/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classstd_1_1experimental_1_1suspend__never/#function-await_ready","text":"inline constexpr bool std :: experimental :: suspend_never :: await_ready () noexcept const","title":"function await_ready"},{"location":"classstd_1_1experimental_1_1suspend__never/#function-await_resume","text":"inline constexpr void std :: experimental :: suspend_never :: await_resume () noexcept const","title":"function await_resume"},{"location":"classstd_1_1experimental_1_1suspend__never/#function-await_suspend","text":"inline void std :: experimental :: suspend_never :: await_suspend ( coroutine_handle < void > ) noexcept const The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function await_suspend"},{"location":"darwin_8cpp/","text":"File darwin.cpp \u00b6 File List > modules > system > darwin.cpp Go to the source code of this file. #include <coroutine/frame.h> #include <coroutine/unix.h> #include <coroutine/return.h> #include \"internal/yield.hpp\" The documentation for this class was generated from the following file modules/system/darwin.cpp","title":"File darwin.cpp"},{"location":"darwin_8cpp/#file-darwincpp","text":"File List > modules > system > darwin.cpp Go to the source code of this file. #include <coroutine/frame.h> #include <coroutine/unix.h> #include <coroutine/return.h> #include \"internal/yield.hpp\" The documentation for this class was generated from the following file modules/system/darwin.cpp","title":"File darwin.cpp"},{"location":"darwin_8cpp_source/","text":"File darwin.cpp \u00b6 File List > modules > system > darwin.cpp Go to the documentation of this file. // expect the following headers are available // clang-format off #include <coroutine/frame.h> #include <coroutine/unix.h> #include <coroutine/return.h> #include \"internal/yield.hpp\" // clang-format on #if defined(__clang__) #else // we must error for the compilation. // however, this section will be left blank // to allow possible a clang-compatible one #endif // in-use functions static_assert ( __has_builtin ( __builtin_coro_done )); static_assert ( __has_builtin ( __builtin_coro_resume )); static_assert ( __has_builtin ( __builtin_coro_destroy )); static_assert ( __has_builtin ( __builtin_coro_promise )); // known functions static_assert ( __has_builtin ( __builtin_coro_size )); static_assert ( __has_builtin ( __builtin_coro_frame )); static_assert ( __has_builtin ( __builtin_coro_free )); static_assert ( __has_builtin ( __builtin_coro_id )); static_assert ( __has_builtin ( __builtin_coro_begin )); static_assert ( __has_builtin ( __builtin_coro_end )); static_assert ( __has_builtin ( __builtin_coro_suspend )); static_assert ( __has_builtin ( __builtin_coro_param ));","title":"File darwin.cpp"},{"location":"darwin_8cpp_source/#file-darwincpp","text":"File List > modules > system > darwin.cpp Go to the documentation of this file. // expect the following headers are available // clang-format off #include <coroutine/frame.h> #include <coroutine/unix.h> #include <coroutine/return.h> #include \"internal/yield.hpp\" // clang-format on #if defined(__clang__) #else // we must error for the compilation. // however, this section will be left blank // to allow possible a clang-compatible one #endif // in-use functions static_assert ( __has_builtin ( __builtin_coro_done )); static_assert ( __has_builtin ( __builtin_coro_resume )); static_assert ( __has_builtin ( __builtin_coro_destroy )); static_assert ( __has_builtin ( __builtin_coro_promise )); // known functions static_assert ( __has_builtin ( __builtin_coro_size )); static_assert ( __has_builtin ( __builtin_coro_frame )); static_assert ( __has_builtin ( __builtin_coro_free )); static_assert ( __has_builtin ( __builtin_coro_id )); static_assert ( __has_builtin ( __builtin_coro_begin )); static_assert ( __has_builtin ( __builtin_coro_end )); static_assert ( __has_builtin ( __builtin_coro_suspend )); static_assert ( __has_builtin ( __builtin_coro_param ));","title":"File darwin.cpp"},{"location":"dir_1a14cfa05288f960dad150e6e316c4bb/","text":"Dir interface/internal \u00b6 File List > interface > internal Files \u00b6 Type Name file yield.hpp enumerable is simply a copy of generator in VC++ The documentation for this class was generated from the following file interface/internal/","title":"Dir interface/internal"},{"location":"dir_1a14cfa05288f960dad150e6e316c4bb/#dir-interfaceinternal","text":"File List > interface > internal","title":"Dir interface/internal"},{"location":"dir_1a14cfa05288f960dad150e6e316c4bb/#files","text":"Type Name file yield.hpp enumerable is simply a copy of generator in VC++ The documentation for this class was generated from the following file interface/internal/","title":"Files"},{"location":"dir_826aeabe2439c2b66ff3bb7c0dad7853/","text":"Dir modules/system \u00b6 File List > modules > system Files \u00b6 Type Name file darwin.cpp file kqueue.cpp file libmain.cpp file linux.cpp file pthread.cpp file windows.cpp The documentation for this class was generated from the following file modules/system/","title":"Dir modules/system"},{"location":"dir_826aeabe2439c2b66ff3bb7c0dad7853/#dir-modulessystem","text":"File List > modules > system","title":"Dir modules/system"},{"location":"dir_826aeabe2439c2b66ff3bb7c0dad7853/#files","text":"Type Name file darwin.cpp file kqueue.cpp file libmain.cpp file linux.cpp file pthread.cpp file windows.cpp The documentation for this class was generated from the following file modules/system/","title":"Files"},{"location":"dir_923c80758d00fd62f29a99e232049d19/","text":"Dir modules/net \u00b6 File List > modules > net Files \u00b6 Type Name file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp The documentation for this class was generated from the following file modules/net/","title":"Dir modules/net"},{"location":"dir_923c80758d00fd62f29a99e232049d19/#dir-modulesnet","text":"File List > modules > net","title":"Dir modules/net"},{"location":"dir_923c80758d00fd62f29a99e232049d19/#files","text":"Type Name file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp The documentation for this class was generated from the following file modules/net/","title":"Files"},{"location":"dir_9b61234ab8cba81e3caae75634773f62/","text":"Dir interface/coroutine \u00b6 File List > coroutine Files \u00b6 Type Name file channel.hpp C++ Coroutines based channel. It's a simplified form of the channel in The Go Language. file frame.h file linux.h file net.h Async I/O operation support with system socket functions. file pthread.h file return.h Utility to define return types for coroutine. file unix.h file windows.h The documentation for this class was generated from the following file interface/coroutine/","title":"Dir interface/coroutine"},{"location":"dir_9b61234ab8cba81e3caae75634773f62/#dir-interfacecoroutine","text":"File List > coroutine","title":"Dir interface/coroutine"},{"location":"dir_9b61234ab8cba81e3caae75634773f62/#files","text":"Type Name file channel.hpp C++ Coroutines based channel. It's a simplified form of the channel in The Go Language. file frame.h file linux.h file net.h Async I/O operation support with system socket functions. file pthread.h file return.h Utility to define return types for coroutine. file unix.h file windows.h The documentation for this class was generated from the following file interface/coroutine/","title":"Files"},{"location":"dir_b31d54d5631803016a26f28213a41162/","text":"Dir interface \u00b6 File List > interface Directories \u00b6 Type Name dir coroutine dir internal The documentation for this class was generated from the following file interface/","title":"Dir interface"},{"location":"dir_b31d54d5631803016a26f28213a41162/#dir-interface","text":"File List > interface","title":"Dir interface"},{"location":"dir_b31d54d5631803016a26f28213a41162/#directories","text":"Type Name dir coroutine dir internal The documentation for this class was generated from the following file interface/","title":"Directories"},{"location":"dir_e05d7e2b1ecd646af5bb94391405f3b5/","text":"Dir modules \u00b6 File List > modules Directories \u00b6 Type Name dir net dir system The documentation for this class was generated from the following file modules/","title":"Dir modules"},{"location":"dir_e05d7e2b1ecd646af5bb94391405f3b5/#dir-modules","text":"File List > modules","title":"Dir modules"},{"location":"dir_e05d7e2b1ecd646af5bb94391405f3b5/#directories","text":"Type Name dir net dir system The documentation for this class was generated from the following file modules/","title":"Directories"},{"location":"files/","text":"File List \u00b6 Here is a list of all files with brief descriptions: dir interface dir coroutine file channel.hpp C++ Coroutines based channel. It's a simplified form of the channel in The Go Language. file frame.h file linux.h file net.h Async I/O operation support with system socket functions. file pthread.h file return.h Utility to define return types for coroutine. file unix.h file windows.h dir internal file yield.hpp enumerable is simply a copy of generator in VC++ dir modules dir net file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp dir system file darwin.cpp file kqueue.cpp file libmain.cpp file linux.cpp file pthread.cpp file windows.cpp","title":"Files"},{"location":"files/#file-list","text":"Here is a list of all files with brief descriptions: dir interface dir coroutine file channel.hpp C++ Coroutines based channel. It's a simplified form of the channel in The Go Language. file frame.h file linux.h file net.h Async I/O operation support with system socket functions. file pthread.h file return.h Utility to define return types for coroutine. file unix.h file windows.h dir internal file yield.hpp enumerable is simply a copy of generator in VC++ dir modules dir net file io_darwin.cpp file io_linux.cpp file io_windows.cpp file resolver.cpp dir system file darwin.cpp file kqueue.cpp file libmain.cpp file linux.cpp file pthread.cpp file windows.cpp","title":"File List"},{"location":"frame_8h/","text":"File frame.h \u00b6 File List > coroutine > frame.h Go to the source code of this file. #include <cstddef> #include <cstdint> #include <type_traits> Namespaces \u00b6 Type Name namespace std namespace experimental Classes \u00b6 Type Name struct clang_frame_prefix struct gcc_frame_prefix struct msvc_frame_prefix class coroutine_handle <PromiseType> class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never Public Types \u00b6 Type Name union prefix_t Public Attributes \u00b6 Type Name constexpr auto aligned_size_v = = ((sizeof(T) + 16u - 1u) & ~(16u - 1u)) Public Functions \u00b6 Type Name void __builtin_coro_destroy (void *) bool __builtin_coro_done (void *) void __builtin_coro_resume (void *) void _coro_destroy (void *) size_t _coro_done (void *) bool _coro_finished (const msvc_frame_prefix *) noexcept size_t _coro_resume (void *) Macros \u00b6 Type Name define COROUTINE_PORTABLE_FRAME_H Public Types Documentation \u00b6 union prefix_t \u00b6 Public Attributes Documentation \u00b6 variable aligned_size_v \u00b6 constexpr auto aligned_size_v ; Public Functions Documentation \u00b6 function __builtin_coro_destroy \u00b6 void __builtin_coro_destroy ( void * ) function __builtin_coro_done \u00b6 bool __builtin_coro_done ( void * ) function __builtin_coro_resume \u00b6 void __builtin_coro_resume ( void * ) function _coro_destroy \u00b6 void _coro_destroy ( void * ) function _coro_done \u00b6 size_t _coro_done ( void * ) function _coro_finished \u00b6 bool _coro_finished ( const msvc_frame_prefix * ) noexcept function _coro_resume \u00b6 size_t _coro_resume ( void * ) Macro Definition Documentation \u00b6 define COROUTINE_PORTABLE_FRAME_H \u00b6 #define COROUTINE_PORTABLE_FRAME_H The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"File frame.h"},{"location":"frame_8h/#file-frameh","text":"File List > coroutine > frame.h Go to the source code of this file. #include <cstddef> #include <cstdint> #include <type_traits>","title":"File frame.h"},{"location":"frame_8h/#namespaces","text":"Type Name namespace std namespace experimental","title":"Namespaces"},{"location":"frame_8h/#classes","text":"Type Name struct clang_frame_prefix struct gcc_frame_prefix struct msvc_frame_prefix class coroutine_handle <PromiseType> class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct noop_coroutine_promise class suspend_always class suspend_never","title":"Classes"},{"location":"frame_8h/#public-types","text":"Type Name union prefix_t","title":"Public Types"},{"location":"frame_8h/#public-attributes","text":"Type Name constexpr auto aligned_size_v = = ((sizeof(T) + 16u - 1u) & ~(16u - 1u))","title":"Public Attributes"},{"location":"frame_8h/#public-functions","text":"Type Name void __builtin_coro_destroy (void *) bool __builtin_coro_done (void *) void __builtin_coro_resume (void *) void _coro_destroy (void *) size_t _coro_done (void *) bool _coro_finished (const msvc_frame_prefix *) noexcept size_t _coro_resume (void *)","title":"Public Functions"},{"location":"frame_8h/#macros","text":"Type Name define COROUTINE_PORTABLE_FRAME_H","title":"Macros"},{"location":"frame_8h/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"frame_8h/#union-prefix_t","text":"","title":"union prefix_t"},{"location":"frame_8h/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"frame_8h/#variable-aligned_size_v","text":"constexpr auto aligned_size_v ;","title":"variable aligned_size_v"},{"location":"frame_8h/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"frame_8h/#function-__builtin_coro_destroy","text":"void __builtin_coro_destroy ( void * )","title":"function __builtin_coro_destroy"},{"location":"frame_8h/#function-__builtin_coro_done","text":"bool __builtin_coro_done ( void * )","title":"function __builtin_coro_done"},{"location":"frame_8h/#function-__builtin_coro_resume","text":"void __builtin_coro_resume ( void * )","title":"function __builtin_coro_resume"},{"location":"frame_8h/#function-_coro_destroy","text":"void _coro_destroy ( void * )","title":"function _coro_destroy"},{"location":"frame_8h/#function-_coro_done","text":"size_t _coro_done ( void * )","title":"function _coro_done"},{"location":"frame_8h/#function-_coro_finished","text":"bool _coro_finished ( const msvc_frame_prefix * ) noexcept","title":"function _coro_finished"},{"location":"frame_8h/#function-_coro_resume","text":"size_t _coro_resume ( void * )","title":"function _coro_resume"},{"location":"frame_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"frame_8h/#define-coroutine_portable_frame_h","text":"#define COROUTINE_PORTABLE_FRAME_H The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"define COROUTINE_PORTABLE_FRAME_H"},{"location":"frame_8h_source/","text":"File frame.h \u00b6 File List > coroutine > frame.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // Header to adjust the difference of coroutine frame between compilers // // Reference // <experimental/resumable> from Microsoft VC++ (since 2017 Feb.) // <experimental/coroutine> from LLVM libcxx (since 6.0) // https://github.com/iains/gcc-cxx-coroutines // #pragma once #include <cstddef> #include <cstdint> #if defined(__clang__) && defined(_MSC_VER) // use this header // // case: clang-cl, VC++ // In this case, override <experimental/resumable>. // Since msvc and clang++ uses differnet frame layout, // VC++ won't fit clang-cl's code generation. // see the implementation below // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #elif defined(USE_PORTABLE_COROUTINE_HANDLE) // use this header // // case: clang-cl, VC++ // case: msvc, VC++ // case: clang, libc++ // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #else // use default header // // case: msvc, VC++ // case: clang, libc++ // It is safe to use vendor's header. // by defining macro variable, user can prevent template redefinition // #if __has_include(<coroutine>) // C++ 20 standard #include <coroutine> #elif __has_include(<experimental/coroutine>) // C++ 17 experimetal #include <experimental/coroutine> // We don't need to use this portable one. // Disable the implementation below and use the default #define COROUTINE_PORTABLE_FRAME_H #endif #endif // <coroutine> header #if defined(__clang__) static constexpr auto is_clang = true ; static constexpr auto is_msvc = ! is_clang ; static constexpr auto is_gcc = ! is_clang ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(_MSC_VER) static constexpr auto is_msvc = true ; static constexpr auto is_clang = ! is_msvc ; static constexpr auto is_gcc = ! is_msvc ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(__GNUC__) static constexpr auto is_gcc = true ; static constexpr auto is_msvc = ! is_gcc ; static constexpr auto is_clang = ! is_gcc ; // gcc-10 failes when __cdecl is used. declare it without convention using procedure_t = void ( * )( void * ); #else #error \"unexpected compiler. please contact the author\" #endif template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16u - 1u ) & ~ ( 16u - 1u )); // - Note // MSVC coroutine frame's prefix // Reference <experimental/resumable> for the detail // - Layout // +------------+------------------+--------------------+ // | Promise(?) | Frame Prefix(16) | Local variables(?) | // +------------+------------------+--------------------+ struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); // - Note // Clang coroutine frame's prefix // - Layout // +------------------+------------+---+--------------------+ // | Frame Prefix(16) | Promise(?) | ? | Local variables(?) | // +------------------+------------+---+--------------------+ struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 ); // - Note // GCC coroutine frame's prefix // - Layout // Unknown struct gcc_frame_prefix final { void * _unknown1 ; void * _unknown2 ; }; static_assert ( aligned_size_v < gcc_frame_prefix > == 16 ); #ifndef COROUTINE_PORTABLE_FRAME_H #define COROUTINE_PORTABLE_FRAME_H #pragma warning(push, 4) #pragma warning(disable : 4455 4494 4577 4619 4643 4702 4984 4988) #pragma warning(disable : 26490 26481 26476 26429 26409) #include <type_traits> // Alternative of `_coro_done` of msvc for this library. // It is renamed to avoid redefinition bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; // // intrinsic: MSVC // extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // // intrinsic: Clang/GCC // extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); // void* __builtin_coro_promise(void* ptr, int align, bool p); namespace std { namespace experimental { // template <typename R, class = void> // struct coroutine_traits_sfinae {}; // // template <typename R> // struct coroutine_traits_sfinae<R, void_t<typename R::promise_type>> { // using promise_type = typename R::promise_type; // }; // traits to enforce `promise_type`, without sfinae consideration. template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; template < typename PromiseType = void > class coroutine_handle ; template <> class coroutine_handle < void > { public : // This type is exposed // to provide more information for the frame and // to prepare for future adaptation. (especially for gcc family) union prefix_t { void * v {}; msvc_frame_prefix * m ; clang_frame_prefix * c ; gcc_frame_prefix * g ; }; static_assert ( sizeof ( prefix_t ) == sizeof ( void * )); prefix_t prefix ; public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept : prefix { nullptr } { } coroutine_handle & operator = ( nullptr_t ) noexcept { prefix . v = nullptr ; return * this ; } explicit operator bool () const noexcept { return prefix . v != nullptr ; } void resume () noexcept ( false ) { if constexpr ( is_msvc ) { _coro_resume ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_resume ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_resume ( prefix . g ); } } void destroy () noexcept { if constexpr ( is_msvc ) { _coro_destroy ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_destroy ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_destroy ( prefix . g ); } } bool done () const noexcept { if constexpr ( is_msvc ) { return _coro_finished ( prefix . m ); } else if constexpr ( is_clang ) { return __builtin_coro_done ( prefix . c ); } else if constexpr ( is_gcc ) { return __builtin_coro_done ( prefix . g ); } else { return false ; } } public : constexpr void * address () const noexcept { return prefix . v ; } static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } }; template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; private : static promise_type * from_frame ( prefix_t addr ) noexcept { if constexpr ( is_clang ) { // calculate the location of the frame's prefix auto * prefix = addr . c ; // for clang, promise is placed just after frame prefix // so this line works like `__builtin_coro_promise`, auto * promise = reinterpret_cast < promise_type *> ( prefix + 1 ); return promise ; } else if constexpr ( is_msvc ) { auto * ptr = reinterpret_cast < char *> ( addr . m ); // for msvc, promise is placed before frame prefix auto * promise = reinterpret_cast < promise_type *> ( ptr - aligned_size_v < promise_type > ); return promise ; } else if constexpr ( is_gcc ) { void * ptr = __builtin_coro_promise ( addr . g , __alignof ( promise_type ), false ); return reinterpret_cast < promise_type *> ( ptr ); } // !!! crash !!! return nullptr ; } public : using coroutine_handle < void >:: coroutine_handle ; coroutine_handle & operator = ( nullptr_t ) noexcept { this -> prefix . v = nullptr ; return * this ; } auto promise () const noexcept -> const promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } auto promise () noexcept -> promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } public : static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } static coroutine_handle from_promise ( promise_type & prom ) noexcept { promise_type * promise = & prom ; // calculate the location of the coroutine frame prefix if constexpr ( is_clang ) { void * prefix = reinterpret_cast < char *> ( promise ) - sizeof ( clang_frame_prefix ); return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_msvc ) { void * prefix = reinterpret_cast < char *> ( promise ) + aligned_size_v < promise_type > ; return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_gcc ) { void * prefix = __builtin_coro_promise ( reinterpret_cast < char *> ( & prom ), __alignof ( promise_type ), true ); return coroutine_handle :: from_address ( prefix ); } return coroutine_handle {}; } }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); inline bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () == rhs . address (); } inline bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs == rhs ); } inline bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () < rhs . address (); } inline bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } inline bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs > rhs ); } inline bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } struct noop_coroutine_promise {}; using noop_coroutine_handle = coroutine_handle < noop_coroutine_promise > ; template <> class coroutine_handle < noop_coroutine_promise > : public coroutine_handle < void > { public : coroutine_handle () noexcept : coroutine_handle < void > {} { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) this -> prefix . v = __builtin_coro_noop (); #else auto & p = this -> promise (); this -> prefix . v = & p ; #endif } public : constexpr explicit operator bool () const noexcept { return true ; } constexpr bool done () const noexcept { return false ; } constexpr void operator ()() const noexcept { return ; } constexpr void resume () const noexcept { return ; } constexpr void destroy () const noexcept { return ; } noop_coroutine_promise & promise () const noexcept { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) return * static_cast < noop_coroutine_promise *> ( __builtin_coro_promise ( this -> prefix . v , __alignof ( noop_coroutine_promise ), false )); #else static noop_coroutine_promise p {}; return p ; #endif } constexpr void * address () const noexcept { return this -> prefix . v ; } }; inline noop_coroutine_handle noop_coroutine () noexcept { return {}; } class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function won't be invoked } }; class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function will ignore the given handle } }; } // namespace experimental } // namespace std #if defined(__clang__) // // Note // VC++ header expects msvc intrinsics. Redirect them to Clang intrinsics. // If the project uses libc++ header files, this code won't be a problem // because they wont't be used // Reference // https://clang.llvm.org/docs/LanguageExtensions.html#c-coroutines-support-builtins // https://llvm.org/docs/Coroutines.html#example // inline bool _coro_finished ( msvc_frame_prefix * m ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed auto * c = reinterpret_cast < clang_frame_prefix *> ( m ); return __builtin_coro_done ( c ) ? 1 : 0 ; } inline size_t _coro_resume ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_resume ( c ); return 0 ; } inline void _coro_destroy ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_destroy ( c ); } #elif defined(_MSC_VER) inline bool _coro_finished ( const msvc_frame_prefix * prefix ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed return prefix -> index == 0 ; } namespace std :: experimental { // Helper traits for MSVC's coroutine compilation. // The original code is in <experimental/resumable> template < typename _Ret , typename ... _Ts > struct _Resumable_helper_traits { using promise_type = typename coroutine_traits < _Ret , _Ts ... >:: promise_type ; using handle_type = coroutine_handle < promise_type > ; static promise_type * _Promise_from_frame ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); return & prom ; } static handle_type _Handle_from_frame ( void * _Addr ) noexcept { auto * p = _Promise_from_frame ( _Addr ); return handle_type :: from_promise ( * p ); } static void _Set_exception ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); prom -> set_exception ( std :: current_exception ()); } static void _ConstructPromise ( void * addr , void * func , int _HeapElision ) noexcept ( false ) { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); prefix -> factivate = static_cast < procedure_t > ( func ); uint32_t * ptr = reinterpret_cast < uint32_t *> ( reinterpret_cast < uintptr_t > ( prefix ) + sizeof ( void * )); * ptr = 2 + ( _HeapElision ? 0 : 0x10000 ); auto * prom = _Promise_from_frame ( prefix ); :: new ( prom ) promise_type (); } static void _DestructPromise ( void * addr ) noexcept { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); _Promise_from_frame ( prefix ) ->~ promise_type (); } }; } // namespace std::experimental #elif defined(__GNUC__) inline bool is_suspended ( gcc_frame_prefix * g ) noexcept { return __builtin_coro_is_suspended ( g ); } #endif // __clang__ || _MSC_VER || __GNUC__ #pragma warning(pop) #endif // COROUTINE_PORTABLE_FRAME_H","title":"File frame.h"},{"location":"frame_8h_source/#file-frameh","text":"File List > coroutine > frame.h Go to the documentation of this file. // // Author : github.com/luncliff (luncliff@gmail.com) // License : CC BY 4.0 // // Note // Header to adjust the difference of coroutine frame between compilers // // Reference // <experimental/resumable> from Microsoft VC++ (since 2017 Feb.) // <experimental/coroutine> from LLVM libcxx (since 6.0) // https://github.com/iains/gcc-cxx-coroutines // #pragma once #include <cstddef> #include <cstdint> #if defined(__clang__) && defined(_MSC_VER) // use this header // // case: clang-cl, VC++ // In this case, override <experimental/resumable>. // Since msvc and clang++ uses differnet frame layout, // VC++ won't fit clang-cl's code generation. // see the implementation below // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #elif defined(USE_PORTABLE_COROUTINE_HANDLE) // use this header // // case: clang-cl, VC++ // case: msvc, VC++ // case: clang, libc++ // #if defined(_EXPERIMENTAL_RESUMABLE_) static_assert ( false , \"This header replaces <experimental/coroutine>\" \" for clang-cl/VC++. Please remove previous includes.\" ); #endif // supporess later includes #define _EXPERIMENTAL_RESUMABLE_ #else // use default header // // case: msvc, VC++ // case: clang, libc++ // It is safe to use vendor's header. // by defining macro variable, user can prevent template redefinition // #if __has_include(<coroutine>) // C++ 20 standard #include <coroutine> #elif __has_include(<experimental/coroutine>) // C++ 17 experimetal #include <experimental/coroutine> // We don't need to use this portable one. // Disable the implementation below and use the default #define COROUTINE_PORTABLE_FRAME_H #endif #endif // <coroutine> header #if defined(__clang__) static constexpr auto is_clang = true ; static constexpr auto is_msvc = ! is_clang ; static constexpr auto is_gcc = ! is_clang ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(_MSC_VER) static constexpr auto is_msvc = true ; static constexpr auto is_clang = ! is_msvc ; static constexpr auto is_gcc = ! is_msvc ; using procedure_t = void ( __cdecl * )( void * ); #elif defined(__GNUC__) static constexpr auto is_gcc = true ; static constexpr auto is_msvc = ! is_gcc ; static constexpr auto is_clang = ! is_gcc ; // gcc-10 failes when __cdecl is used. declare it without convention using procedure_t = void ( * )( void * ); #else #error \"unexpected compiler. please contact the author\" #endif template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16u - 1u ) & ~ ( 16u - 1u )); // - Note // MSVC coroutine frame's prefix // Reference <experimental/resumable> for the detail // - Layout // +------------+------------------+--------------------+ // | Promise(?) | Frame Prefix(16) | Local variables(?) | // +------------+------------------+--------------------+ struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); // - Note // Clang coroutine frame's prefix // - Layout // +------------------+------------+---+--------------------+ // | Frame Prefix(16) | Promise(?) | ? | Local variables(?) | // +------------------+------------+---+--------------------+ struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 ); // - Note // GCC coroutine frame's prefix // - Layout // Unknown struct gcc_frame_prefix final { void * _unknown1 ; void * _unknown2 ; }; static_assert ( aligned_size_v < gcc_frame_prefix > == 16 ); #ifndef COROUTINE_PORTABLE_FRAME_H #define COROUTINE_PORTABLE_FRAME_H #pragma warning(push, 4) #pragma warning(disable : 4455 4494 4577 4619 4643 4702 4984 4988) #pragma warning(disable : 26490 26481 26476 26429 26409) #include <type_traits> // Alternative of `_coro_done` of msvc for this library. // It is renamed to avoid redefinition bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; // // intrinsic: MSVC // extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // // intrinsic: Clang/GCC // extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); // void* __builtin_coro_promise(void* ptr, int align, bool p); namespace std { namespace experimental { // template <typename R, class = void> // struct coroutine_traits_sfinae {}; // // template <typename R> // struct coroutine_traits_sfinae<R, void_t<typename R::promise_type>> { // using promise_type = typename R::promise_type; // }; // traits to enforce `promise_type`, without sfinae consideration. template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; template < typename PromiseType = void > class coroutine_handle ; template <> class coroutine_handle < void > { public : // This type is exposed // to provide more information for the frame and // to prepare for future adaptation. (especially for gcc family) union prefix_t { void * v {}; msvc_frame_prefix * m ; clang_frame_prefix * c ; gcc_frame_prefix * g ; }; static_assert ( sizeof ( prefix_t ) == sizeof ( void * )); prefix_t prefix ; public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept : prefix { nullptr } { } coroutine_handle & operator = ( nullptr_t ) noexcept { prefix . v = nullptr ; return * this ; } explicit operator bool () const noexcept { return prefix . v != nullptr ; } void resume () noexcept ( false ) { if constexpr ( is_msvc ) { _coro_resume ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_resume ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_resume ( prefix . g ); } } void destroy () noexcept { if constexpr ( is_msvc ) { _coro_destroy ( prefix . m ); } else if constexpr ( is_clang ) { __builtin_coro_destroy ( prefix . c ); } else if constexpr ( is_gcc ) { __builtin_coro_destroy ( prefix . g ); } } bool done () const noexcept { if constexpr ( is_msvc ) { return _coro_finished ( prefix . m ); } else if constexpr ( is_clang ) { return __builtin_coro_done ( prefix . c ); } else if constexpr ( is_gcc ) { return __builtin_coro_done ( prefix . g ); } else { return false ; } } public : constexpr void * address () const noexcept { return prefix . v ; } static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } }; template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; private : static promise_type * from_frame ( prefix_t addr ) noexcept { if constexpr ( is_clang ) { // calculate the location of the frame's prefix auto * prefix = addr . c ; // for clang, promise is placed just after frame prefix // so this line works like `__builtin_coro_promise`, auto * promise = reinterpret_cast < promise_type *> ( prefix + 1 ); return promise ; } else if constexpr ( is_msvc ) { auto * ptr = reinterpret_cast < char *> ( addr . m ); // for msvc, promise is placed before frame prefix auto * promise = reinterpret_cast < promise_type *> ( ptr - aligned_size_v < promise_type > ); return promise ; } else if constexpr ( is_gcc ) { void * ptr = __builtin_coro_promise ( addr . g , __alignof ( promise_type ), false ); return reinterpret_cast < promise_type *> ( ptr ); } // !!! crash !!! return nullptr ; } public : using coroutine_handle < void >:: coroutine_handle ; coroutine_handle & operator = ( nullptr_t ) noexcept { this -> prefix . v = nullptr ; return * this ; } auto promise () const noexcept -> const promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } auto promise () noexcept -> promise_type & { promise_type * p = from_frame ( prefix ); return * p ; } public : static coroutine_handle from_address ( void * addr ) noexcept { coroutine_handle rh {}; rh . prefix . v = addr ; return rh ; } static coroutine_handle from_promise ( promise_type & prom ) noexcept { promise_type * promise = & prom ; // calculate the location of the coroutine frame prefix if constexpr ( is_clang ) { void * prefix = reinterpret_cast < char *> ( promise ) - sizeof ( clang_frame_prefix ); return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_msvc ) { void * prefix = reinterpret_cast < char *> ( promise ) + aligned_size_v < promise_type > ; return coroutine_handle :: from_address ( prefix ); } else if constexpr ( is_gcc ) { void * prefix = __builtin_coro_promise ( reinterpret_cast < char *> ( & prom ), __alignof ( promise_type ), true ); return coroutine_handle :: from_address ( prefix ); } return coroutine_handle {}; } }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); inline bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () == rhs . address (); } inline bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs == rhs ); } inline bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return lhs . address () < rhs . address (); } inline bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } inline bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs > rhs ); } inline bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept { return ! ( lhs < rhs ); } struct noop_coroutine_promise {}; using noop_coroutine_handle = coroutine_handle < noop_coroutine_promise > ; template <> class coroutine_handle < noop_coroutine_promise > : public coroutine_handle < void > { public : coroutine_handle () noexcept : coroutine_handle < void > {} { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) this -> prefix . v = __builtin_coro_noop (); #else auto & p = this -> promise (); this -> prefix . v = & p ; #endif } public : constexpr explicit operator bool () const noexcept { return true ; } constexpr bool done () const noexcept { return false ; } constexpr void operator ()() const noexcept { return ; } constexpr void resume () const noexcept { return ; } constexpr void destroy () const noexcept { return ; } noop_coroutine_promise & promise () const noexcept { #if defined(__clang__) && __has_builtin(__builtin_coro_noop) return * static_cast < noop_coroutine_promise *> ( __builtin_coro_promise ( this -> prefix . v , __alignof ( noop_coroutine_promise ), false )); #else static noop_coroutine_promise p {}; return p ; #endif } constexpr void * address () const noexcept { return this -> prefix . v ; } }; inline noop_coroutine_handle noop_coroutine () noexcept { return {}; } class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function won't be invoked } }; class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // This function will ignore the given handle } }; } // namespace experimental } // namespace std #if defined(__clang__) // // Note // VC++ header expects msvc intrinsics. Redirect them to Clang intrinsics. // If the project uses libc++ header files, this code won't be a problem // because they wont't be used // Reference // https://clang.llvm.org/docs/LanguageExtensions.html#c-coroutines-support-builtins // https://llvm.org/docs/Coroutines.html#example // inline bool _coro_finished ( msvc_frame_prefix * m ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed auto * c = reinterpret_cast < clang_frame_prefix *> ( m ); return __builtin_coro_done ( c ) ? 1 : 0 ; } inline size_t _coro_resume ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_resume ( c ); return 0 ; } inline void _coro_destroy ( void * addr ) { auto * c = reinterpret_cast < clang_frame_prefix *> ( addr ); __builtin_coro_destroy ( c ); } #elif defined(_MSC_VER) inline bool _coro_finished ( const msvc_frame_prefix * prefix ) noexcept { // expect: coroutine == suspended // expect: coroutine != destroyed return prefix -> index == 0 ; } namespace std :: experimental { // Helper traits for MSVC's coroutine compilation. // The original code is in <experimental/resumable> template < typename _Ret , typename ... _Ts > struct _Resumable_helper_traits { using promise_type = typename coroutine_traits < _Ret , _Ts ... >:: promise_type ; using handle_type = coroutine_handle < promise_type > ; static promise_type * _Promise_from_frame ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); return & prom ; } static handle_type _Handle_from_frame ( void * _Addr ) noexcept { auto * p = _Promise_from_frame ( _Addr ); return handle_type :: from_promise ( * p ); } static void _Set_exception ( void * addr ) noexcept { auto & prom = handle_type :: from_address ( addr ). promise (); prom -> set_exception ( std :: current_exception ()); } static void _ConstructPromise ( void * addr , void * func , int _HeapElision ) noexcept ( false ) { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); prefix -> factivate = static_cast < procedure_t > ( func ); uint32_t * ptr = reinterpret_cast < uint32_t *> ( reinterpret_cast < uintptr_t > ( prefix ) + sizeof ( void * )); * ptr = 2 + ( _HeapElision ? 0 : 0x10000 ); auto * prom = _Promise_from_frame ( prefix ); :: new ( prom ) promise_type (); } static void _DestructPromise ( void * addr ) noexcept { auto prefix = static_cast < msvc_frame_prefix *> ( addr ); _Promise_from_frame ( prefix ) ->~ promise_type (); } }; } // namespace std::experimental #elif defined(__GNUC__) inline bool is_suspended ( gcc_frame_prefix * g ) noexcept { return __builtin_coro_is_suspended ( g ); } #endif // __clang__ || _MSC_VER || __GNUC__ #pragma warning(pop) #endif // COROUTINE_PORTABLE_FRAME_H","title":"File frame.h"},{"location":"functions/","text":"Functions \u00b6 _ \u00b6 __builtin_coro_destroy ( frame.h ) __builtin_coro_done ( frame.h ) __builtin_coro_resume ( frame.h ) _coro_destroy ( frame.h ) _coro_done ( frame.h ) _coro_finished ( frame.h ) _coro_resume ( frame.h )","title":"Functions"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"functions/#_","text":"__builtin_coro_destroy ( frame.h ) __builtin_coro_done ( frame.h ) __builtin_coro_resume ( frame.h ) _coro_destroy ( frame.h ) _coro_done ( frame.h ) _coro_finished ( frame.h ) _coro_resume ( frame.h )","title":"_"},{"location":"group__BSD/","text":"Group BSD \u00b6 Modules > BSD Classes \u00b6 Type Name class coro::kqueue_owner RAII wrapping for kqueue file descriptor.","title":"Group BSD"},{"location":"group__BSD/#group-bsd","text":"Modules > BSD","title":"Group BSD"},{"location":"group__BSD/#classes","text":"Type Name class coro::kqueue_owner RAII wrapping for kqueue file descriptor.","title":"Classes"},{"location":"group__Linux/","text":"Group Linux \u00b6 Modules > Linux Classes \u00b6 Type Name class coro::epoll_owner RAII wrapping for epoll file descriptor. class coro::event RAII + stateful eventfd __ Public Functions \u00b6 Type Name auto coro::wait_in ( epoll_owner & ep, event & efd) Bind the given event ( eventfd ) to epoll_owner (Epoll) Public Functions Documentation \u00b6 function wait_in \u00b6 auto coro :: wait_in ( epoll_owner & ep , event & efd ) Parameters: ep epoll_owner efd event See also: event Returns: awaitable struct for the binding","title":"Group Linux"},{"location":"group__Linux/#group-linux","text":"Modules > Linux","title":"Group Linux"},{"location":"group__Linux/#classes","text":"Type Name class coro::epoll_owner RAII wrapping for epoll file descriptor. class coro::event RAII + stateful eventfd __","title":"Classes"},{"location":"group__Linux/#public-functions","text":"Type Name auto coro::wait_in ( epoll_owner & ep, event & efd) Bind the given event ( eventfd ) to epoll_owner (Epoll)","title":"Public Functions"},{"location":"group__Linux/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"group__Linux/#function-wait_in","text":"auto coro :: wait_in ( epoll_owner & ep , event & efd ) Parameters: ep epoll_owner efd event See also: event Returns: awaitable struct for the binding","title":"function wait_in"},{"location":"group__NetResolve/","text":"Group NetResolve \u00b6 Modules > NetResolve More... Public Functions \u00b6 Type Name uint32_t coro::get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in > output) noexcept Thin wrapper of getaddrinfo for IPv4. uint32_t coro::get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in6 > output) noexcept Thin wrapper of getaddrinfo for IPv6. uint32_t coro::get_name (const sockaddr_in & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST uint32_t coro::get_name (const sockaddr_in6 & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST Detailed Description \u00b6 Name resolution utilities Public Functions Documentation \u00b6 function get_address \u00b6 uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror function get_address \u00b6 uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror function get_name \u00b6 uint32_t coro :: get_name ( const sockaddr_in & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo function get_name \u00b6 uint32_t coro :: get_name ( const sockaddr_in6 & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"Group NetResolve"},{"location":"group__NetResolve/#group-netresolve","text":"Modules > NetResolve More...","title":"Group NetResolve"},{"location":"group__NetResolve/#public-functions","text":"Type Name uint32_t coro::get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in > output) noexcept Thin wrapper of getaddrinfo for IPv4. uint32_t coro::get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in6 > output) noexcept Thin wrapper of getaddrinfo for IPv6. uint32_t coro::get_name (const sockaddr_in & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST uint32_t coro::get_name (const sockaddr_in6 & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST","title":"Public Functions"},{"location":"group__NetResolve/#detailed-description","text":"Name resolution utilities","title":"Detailed Description"},{"location":"group__NetResolve/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"group__NetResolve/#function-get_address","text":"uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror","title":"function get_address"},{"location":"group__NetResolve/#function-get_address_1","text":"uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror","title":"function get_address"},{"location":"group__NetResolve/#function-get_name","text":"uint32_t coro :: get_name ( const sockaddr_in & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"function get_name"},{"location":"group__NetResolve/#function-get_name_1","text":"uint32_t coro :: get_name ( const sockaddr_in6 & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"function get_name"},{"location":"group__NetWork/","text":"Group NetWork \u00b6 Modules > NetWork More... Classes \u00b6 Type Name class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. Public Types \u00b6 Type Name typedef gsl::span< std::byte > coro::io_buffer_t This is simply a view to storage. Be aware that it doesn't have ownership. Public Functions \u00b6 Type Name auto coro::recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto coro::recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto coro::recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_recv awaitable with the given parameters. auto coro::send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_send awaitable with the given parameters. auto coro::send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. auto coro::send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. Detailed Description \u00b6 Helper types to apply co_await for socket operations Public Types Documentation \u00b6 typedef io_buffer_t \u00b6 using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ; Public Functions Documentation \u00b6 function recv_from \u00b6 auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from & function recv_from \u00b6 auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from & function recv_stream \u00b6 auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_recv & function send_stream \u00b6 auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_send & function send_to \u00b6 auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to & function send_to \u00b6 auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"Group NetWork"},{"location":"group__NetWork/#group-network","text":"Modules > NetWork More...","title":"Group NetWork"},{"location":"group__NetWork/#classes","text":"Type Name class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle.","title":"Classes"},{"location":"group__NetWork/#public-types","text":"Type Name typedef gsl::span< std::byte > coro::io_buffer_t This is simply a view to storage. Be aware that it doesn't have ownership.","title":"Public Types"},{"location":"group__NetWork/#public-functions","text":"Type Name auto coro::recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto coro::recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto coro::recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_recv awaitable with the given parameters. auto coro::send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_send awaitable with the given parameters. auto coro::send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. auto coro::send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters.","title":"Public Functions"},{"location":"group__NetWork/#detailed-description","text":"Helper types to apply co_await for socket operations","title":"Detailed Description"},{"location":"group__NetWork/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"group__NetWork/#typedef-io_buffer_t","text":"using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ;","title":"typedef io_buffer_t"},{"location":"group__NetWork/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"group__NetWork/#function-recv_from","text":"auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from &","title":"function recv_from"},{"location":"group__NetWork/#function-recv_from_1","text":"auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from &","title":"function recv_from"},{"location":"group__NetWork/#function-recv_stream","text":"auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_recv &","title":"function recv_stream"},{"location":"group__NetWork/#function-send_stream","text":"auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_send &","title":"function send_stream"},{"location":"group__NetWork/#function-send_to","text":"auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"function send_to"},{"location":"group__NetWork/#function-send_to_1","text":"auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"function send_to"},{"location":"group__POSIX/","text":"Group POSIX \u00b6 Modules > POSIX More... Classes \u00b6 Type Name class coro::pthread_detacher_t Special return type that wraps pthread_detach __ class coro::pthread_joiner_t Special return type that wraps pthread_join __ class coro::pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class coro::pthread_spawn_promise allows pthread_attr_t* for co_await operator class coro::pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. Detailed Description \u00b6 Helpers to apply co_await for thread object/operations","title":"Group POSIX"},{"location":"group__POSIX/#group-posix","text":"Modules > POSIX More...","title":"Group POSIX"},{"location":"group__POSIX/#classes","text":"Type Name class coro::pthread_detacher_t Special return type that wraps pthread_detach __ class coro::pthread_joiner_t Special return type that wraps pthread_join __ class coro::pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class coro::pthread_spawn_promise allows pthread_attr_t* for co_await operator class coro::pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it.","title":"Classes"},{"location":"group__POSIX/#detailed-description","text":"Helpers to apply co_await for thread object/operations","title":"Detailed Description"},{"location":"group__Return/","text":"Group Return \u00b6 Modules > Return More... Classes \u00b6 Type Name class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class coro::promise_aa class coro::promise_an class coro::promise_na class coro::promise_nn Detailed Description \u00b6 Types for easier coroutine promise/return type definition.","title":"Group Return"},{"location":"group__Return/#group-return","text":"Modules > Return More...","title":"Group Return"},{"location":"group__Return/#classes","text":"Type Name class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class coro::promise_aa class coro::promise_an class coro::promise_na class coro::promise_nn","title":"Classes"},{"location":"group__Return/#detailed-description","text":"Types for easier coroutine promise/return type definition.","title":"Detailed Description"},{"location":"group__Windows/","text":"Group Windows \u00b6 Modules > Windows More... Classes \u00b6 Type Name class coro::continue_on_apc Move into the designated thread's APC queue and continue the routine. class coro::continue_on_thread_pool Move into the win32 thread pool and continue the routine. class coro::set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. Detailed Description \u00b6 Most of the implementation use Win32 thread pool.","title":"Group Windows"},{"location":"group__Windows/#group-windows","text":"Modules > Windows More...","title":"Group Windows"},{"location":"group__Windows/#classes","text":"Type Name class coro::continue_on_apc Move into the designated thread's APC queue and continue the routine. class coro::continue_on_thread_pool Move into the win32 thread pool and continue the routine. class coro::set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body.","title":"Classes"},{"location":"group__Windows/#detailed-description","text":"Most of the implementation use Win32 thread pool.","title":"Detailed Description"},{"location":"group__channel/","text":"Group channel \u00b6 Modules > channel More... Classes \u00b6 Type Name class coro::channel <T, M> C++ Coroutines based channel. class coro::channel_peeker <typename T, typename M> Extension of channel_reader for subroutines. class coro::channel_reader <typename T, typename M> Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class coro::channel_writer <typename T, typename M> Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . Public Functions \u00b6 Type Name void coro::select ( channel < T, M > & ch, Fn && fn) noexcept void coro::select (Ch & ch, Fn && fn, Args &&... args) noexcept Public Static Functions \u00b6 Type Name void * coro::internal::poison () noexcept Returns a non-null address that leads access violation. Detailed Description \u00b6 Note: The implementation of channel heavily rely on friend relationship. The design may make the template code ugly, but is necessary because of 2 behaviors. channel is a synchronizes 2 awaitable types, channel_reader and channel_writer . Those reader/writer exchanges their information before their resume of each other. If user code can become mess because of such relationship, it is strongly recommended to hide channel internally and open their own interfaces. Public Functions Documentation \u00b6 function select \u00b6 template < typename T typename T , typename M typename M , typename Fn typename Fn > void coro :: select ( channel < T , M > & ch , Fn && fn ) noexcept Note: If the channel is readable, acquire the value and invoke the function See also: channel_peeker function select \u00b6 template < typename ... Args , typename Ch typename Ch , typename Fn typename Fn > void coro :: select ( Ch & ch , Fn && fn , Args && ... args ) noexcept Note: For each pair, peeks a channel and invoke the function with the value if the peek was successful. See also: test/channel_select_type.cpp Public Static Functions Documentation \u00b6 function poison \u00b6 static void * internal :: poison () noexcept Note: Notice that reinterpret_cast is not constexpr for some compiler. Returns: void* non-null address","title":"Group channel"},{"location":"group__channel/#group-channel","text":"Modules > channel More...","title":"Group channel"},{"location":"group__channel/#classes","text":"Type Name class coro::channel <T, M> C++ Coroutines based channel. class coro::channel_peeker <typename T, typename M> Extension of channel_reader for subroutines. class coro::channel_reader <typename T, typename M> Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class coro::channel_writer <typename T, typename M> Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader .","title":"Classes"},{"location":"group__channel/#public-functions","text":"Type Name void coro::select ( channel < T, M > & ch, Fn && fn) noexcept void coro::select (Ch & ch, Fn && fn, Args &&... args) noexcept","title":"Public Functions"},{"location":"group__channel/#public-static-functions","text":"Type Name void * coro::internal::poison () noexcept Returns a non-null address that leads access violation.","title":"Public Static Functions"},{"location":"group__channel/#detailed-description","text":"Note: The implementation of channel heavily rely on friend relationship. The design may make the template code ugly, but is necessary because of 2 behaviors. channel is a synchronizes 2 awaitable types, channel_reader and channel_writer . Those reader/writer exchanges their information before their resume of each other. If user code can become mess because of such relationship, it is strongly recommended to hide channel internally and open their own interfaces.","title":"Detailed Description"},{"location":"group__channel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"group__channel/#function-select","text":"template < typename T typename T , typename M typename M , typename Fn typename Fn > void coro :: select ( channel < T , M > & ch , Fn && fn ) noexcept Note: If the channel is readable, acquire the value and invoke the function See also: channel_peeker","title":"function select"},{"location":"group__channel/#function-select_1","text":"template < typename ... Args , typename Ch typename Ch , typename Fn typename Fn > void coro :: select ( Ch & ch , Fn && fn , Args && ... args ) noexcept Note: For each pair, peeks a channel and invoke the function with the value if the peek was successful. See also: test/channel_select_type.cpp","title":"function select"},{"location":"group__channel/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"group__channel/#function-poison","text":"static void * internal :: poison () noexcept Note: Notice that reinterpret_cast is not constexpr for some compiler. Returns: void* non-null address","title":"function poison"},{"location":"hierarchy/","text":"Class Hierarchy \u00b6 This inheritance list is sorted roughly, but not completely, alphabetically: class coro::internal::list Linked list without allocation. class coro::channel_reader Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class coro::channel_peeker Extension of channel_reader for subroutines. class coro::channel_writer Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class coro::continue_on_apc Move into the designated thread's APC queue and continue the routine. class coro::continue_on_thread_pool Move into the win32 thread pool and continue the routine. class coro::enumerable class coro::enumerable::iterator class coro::promise_aa class coro::enumerable::promise_type class coro::epoll_owner RAII wrapping for epoll file descriptor. class coro::event RAII + stateful eventfd __ class std::experimental::coroutine_handle< void > class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class std::experimental::coroutine_handle< noop_coroutine_promise > class coro::promise_na class coro::frame_t::promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __ class coro::kqueue_owner RAII wrapping for kqueue file descriptor. class coro::promise_an class coro::promise_nn class coro::pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class coro::pthread_detacher_t Special return type that wraps pthread_detach __ class coro::pthread_joiner_t Special return type that wraps pthread_join __ class coro::pthread_spawn_promise allows pthread_attr_t* for co_await operator class coro::pthread_detacher_t::promise_type class coro::pthread_joiner_t::promise_type class coro::pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class coro::set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. class std::experimental::coroutine_handle class std::experimental::suspend_always class std::experimental::suspend_never struct clang_frame_prefix struct coro::bypass_mutex Lockable without lock operation. struct gcc_frame_prefix struct msvc_frame_prefix struct std::experimental::coroutine_traits struct std::experimental::coroutine_traits< void, P... > Allow void return of the coroutine. struct std::experimental::coroutine_traits< void, P... >::promise_type struct std::experimental::noop_coroutine_promise class io_control_block class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class CRITICAL_SECTION class coro::section Standard lockable with win32 criticial section.","title":"Class Hierarchy"},{"location":"hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class coro::internal::list Linked list without allocation. class coro::channel_reader Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class coro::channel_peeker Extension of channel_reader for subroutines. class coro::channel_writer Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class coro::continue_on_apc Move into the designated thread's APC queue and continue the routine. class coro::continue_on_thread_pool Move into the win32 thread pool and continue the routine. class coro::enumerable class coro::enumerable::iterator class coro::promise_aa class coro::enumerable::promise_type class coro::epoll_owner RAII wrapping for epoll file descriptor. class coro::event RAII + stateful eventfd __ class std::experimental::coroutine_handle< void > class coro::frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class std::experimental::coroutine_handle< noop_coroutine_promise > class coro::promise_na class coro::frame_t::promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __ class coro::kqueue_owner RAII wrapping for kqueue file descriptor. class coro::promise_an class coro::promise_nn class coro::pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class coro::pthread_detacher_t Special return type that wraps pthread_detach __ class coro::pthread_joiner_t Special return type that wraps pthread_join __ class coro::pthread_spawn_promise allows pthread_attr_t* for co_await operator class coro::pthread_detacher_t::promise_type class coro::pthread_joiner_t::promise_type class coro::pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class coro::set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. class std::experimental::coroutine_handle class std::experimental::suspend_always class std::experimental::suspend_never struct clang_frame_prefix struct coro::bypass_mutex Lockable without lock operation. struct gcc_frame_prefix struct msvc_frame_prefix struct std::experimental::coroutine_traits struct std::experimental::coroutine_traits< void, P... > Allow void return of the coroutine. struct std::experimental::coroutine_traits< void, P... >::promise_type struct std::experimental::noop_coroutine_promise class io_control_block class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class coro::io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class coro::io_recv Awaitable type to perform recv I/O request. class coro::io_recv_from Awaitable type to perform recvfrom I/O request. class coro::io_send Awaitable type to perform send I/O request. class coro::io_send_to Awaitable type to perform sendto I/O request. class CRITICAL_SECTION class coro::section Standard lockable with win32 criticial section.","title":"Class Hierarchy"},{"location":"io__darwin_8cpp/","text":"File io_darwin.cpp \u00b6 File List > modules > net > io_darwin.cpp Go to the source code of this file. #include <chrono> #include <coroutine/net.h> #include <coroutine/unix.h> Namespaces \u00b6 Type Name namespace coro namespace chrono The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"File io\\_darwin.cpp"},{"location":"io__darwin_8cpp/#file-io_darwincpp","text":"File List > modules > net > io_darwin.cpp Go to the source code of this file. #include <chrono> #include <coroutine/net.h> #include <coroutine/unix.h>","title":"File io_darwin.cpp"},{"location":"io__darwin_8cpp/#namespaces","text":"Type Name namespace coro namespace chrono The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"Namespaces"},{"location":"io__darwin_8cpp_source/","text":"File io_darwin.cpp \u00b6 File List > modules > net > io_darwin.cpp Go to the documentation of this file. #include <chrono> #include <coroutine/net.h> #include <coroutine/unix.h> static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { kqueue_owner netkq {}; using net_callback_t = void ( * )( void * ctx , coroutine_handle < void > coro ); void poll_net_tasks ( const timespec & wait_time , // net_callback_t callback , void * ctx ) noexcept ( false ) { constexpr auto buf_size = 30u ; auto buf = make_unique < kevent64_s [] > ( buf_size ); const auto count = netkq . events ( wait_time , { buf . get (), buf_size }); for ( auto i = count ; i < count ; ++ i ) { auto * work = reinterpret_cast < io_work_t *> ( buf [ i ]. udata ); callback ( ctx , work -> task ); } } void resume_net_task ( void * , coroutine_handle < void > coro ) noexcept ( false ) { return coro . resume (); } void poll_net_tasks ( uint64_t nano ) noexcept ( false ) { auto timeout = nanoseconds { nano }; const auto sec = duration_cast < seconds > ( timeout ); const timespec wait_time { . tv_sec = sec . count (), . tv_nsec = ( timeout - sec ). count (), }; return poll_net_tasks ( wait_time , resume_net_task , nullptr ); } bool io_work_t :: ready () const noexcept { const auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; // it is possible to pass `rh` for the user data, // but will pass this object to support // receiving some values from `wait_io_tasks` req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); errc = sz < 0 ? errno : 0 ; return sz ; } auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io\\_darwin.cpp"},{"location":"io__darwin_8cpp_source/#file-io_darwincpp","text":"File List > modules > net > io_darwin.cpp Go to the documentation of this file. #include <chrono> #include <coroutine/net.h> #include <coroutine/unix.h> static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { kqueue_owner netkq {}; using net_callback_t = void ( * )( void * ctx , coroutine_handle < void > coro ); void poll_net_tasks ( const timespec & wait_time , // net_callback_t callback , void * ctx ) noexcept ( false ) { constexpr auto buf_size = 30u ; auto buf = make_unique < kevent64_s [] > ( buf_size ); const auto count = netkq . events ( wait_time , { buf . get (), buf_size }); for ( auto i = count ; i < count ; ++ i ) { auto * work = reinterpret_cast < io_work_t *> ( buf [ i ]. udata ); callback ( ctx , work -> task ); } } void resume_net_task ( void * , coroutine_handle < void > coro ) noexcept ( false ) { return coro . resume (); } void poll_net_tasks ( uint64_t nano ) noexcept ( false ) { auto timeout = nanoseconds { nano }; const auto sec = duration_cast < seconds > ( timeout ); const timespec wait_time { . tv_sec = sec . count (), . tv_nsec = ( timeout - sec ). count (), }; return poll_net_tasks ( wait_time , resume_net_task , nullptr ); } bool io_work_t :: ready () const noexcept { const auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; // it is possible to pass `rh` for the user data, // but will pass this object to support // receiving some values from `wait_io_tasks` req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); errc = sz < 0 ? errno : 0 ; return sz ; } auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( coroutine_handle < void > rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // system operation kevent64_s req {}; req . ident = this -> handle ; req . filter = EVFILT_READ ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); netkq . change ( req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io_darwin.cpp"},{"location":"io__linux_8cpp/","text":"File io_linux.cpp \u00b6 File List > modules > net > io_linux.cpp Go to the source code of this file. #include <chrono> #include <coroutine/linux.h> #include <coroutine/net.h> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_linux.cpp","title":"File io\\_linux.cpp"},{"location":"io__linux_8cpp/#file-io_linuxcpp","text":"File List > modules > net > io_linux.cpp Go to the source code of this file. #include <chrono> #include <coroutine/linux.h> #include <coroutine/net.h>","title":"File io_linux.cpp"},{"location":"io__linux_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/net/io_linux.cpp","title":"Namespaces"},{"location":"io__linux_8cpp_source/","text":"File io_linux.cpp \u00b6 File List > modules > net > io_linux.cpp Go to the documentation of this file. #include <chrono> #include <coroutine/linux.h> #include <coroutine/net.h> static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { epoll_owner iep {}, oep {}; // inbound, outbound void poll_net_tasks ( uint64_t nano ) noexcept ( false ) { const auto half_time = duration_cast < milliseconds > ( nanoseconds { nano } / 2 ); // event buffer for this poll constexpr auto buf_sz = 30u ; auto buf = make_unique < epoll_event [] > ( buf_sz ); // resume inbound coroutines auto count = iep . wait ( half_time . count (), { buf . get (), buf_sz }); for ( auto i = 0u ; i < count ; ++ i ) if ( auto coro = coroutine_handle < void >:: from_address ( buf [ i ]. data . ptr )) coro . resume (); // resume outbound coroutines count = oep . wait ( half_time . count (), { buf . get (), buf_sz }); for ( auto i = 0u ; i < count ; ++ i ) if ( auto coro = coroutine_handle < void >:: from_address ( buf [ i ]. data . ptr )) coro . resume (); } bool io_work_t :: ready () const noexcept { auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); oep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); iep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); oep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); iep . try_add ( sd , req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io\\_linux.cpp"},{"location":"io__linux_8cpp_source/#file-io_linuxcpp","text":"File List > modules > net > io_linux.cpp Go to the documentation of this file. #include <chrono> #include <coroutine/linux.h> #include <coroutine/net.h> static_assert ( sizeof ( ssize_t ) <= sizeof ( int64_t )); using namespace std ; using namespace std :: chrono ; namespace coro { epoll_owner iep {}, oep {}; // inbound, outbound void poll_net_tasks ( uint64_t nano ) noexcept ( false ) { const auto half_time = duration_cast < milliseconds > ( nanoseconds { nano } / 2 ); // event buffer for this poll constexpr auto buf_sz = 30u ; auto buf = make_unique < epoll_event [] > ( buf_sz ); // resume inbound coroutines auto count = iep . wait ( half_time . count (), { buf . get (), buf_sz }); for ( auto i = 0u ; i < count ; ++ i ) if ( auto coro = coroutine_handle < void >:: from_address ( buf [ i ]. data . ptr )) coro . resume (); // resume outbound coroutines count = oep . wait ( half_time . count (), { buf . get (), buf_sz }); for ( auto i = 0u ; i < count ; ++ i ) if ( auto coro = coroutine_handle < void >:: from_address ( buf [ i ]. data . ptr )) coro . resume (); } bool io_work_t :: ready () const noexcept { auto sd = this -> handle ; // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return gsl :: narrow_cast < uint32_t > ( this -> internal ); } auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . handle = sd ; work . ptr = const_cast < sockaddr_in6 *> ( addressof ( remote )); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_send_to *> ( addressof ( work )); } void io_send_to :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); oep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send_to :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = sendto ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addrlen ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . handle = sd ; work . ptr = addressof ( remote ); work . internal_high = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } void io_recv_from :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); iep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_recv_from :: resume () noexcept { auto sd = this -> handle ; auto addr = reinterpret_cast < sockaddr *> ( this -> ptr ); auto addrlen = static_cast < socklen_t > ( this -> internal_high ); auto & errc = this -> internal ; auto sz = recvfrom ( sd , buffer . data (), buffer . size_bytes (), // 0 , addr , addressof ( addrlen )); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } void io_send :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLOUT | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); oep . try_add ( sd , req ); // throws if epoll_ctl fails } int64_t io_send :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . handle = sd ; work . internal = flag ; work . buffer = buffer ; return * reinterpret_cast < io_recv *> ( addressof ( work )); } void io_recv :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { auto sd = this -> handle ; auto & errc = this -> internal ; errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = coro . address (); iep . try_add ( sd , req ); } int64_t io_recv :: resume () noexcept { auto sd = this -> handle ; auto flag = this -> internal ; auto & errc = this -> internal ; const auto sz = recv ( sd , buffer . data (), buffer . size_bytes (), flag ); // update error code upon i/o failure errc = sz < 0 ? errno : 0 ; return sz ; } } // namespace coro","title":"File io_linux.cpp"},{"location":"io__windows_8cpp/","text":"File io_windows.cpp \u00b6 File List > modules > net > io_windows.cpp Go to the source code of this file. #include <cassert> #include <coroutine/net.h> Namespaces \u00b6 Type Name namespace coro namespace gsl The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"File io\\_windows.cpp"},{"location":"io__windows_8cpp/#file-io_windowscpp","text":"File List > modules > net > io_windows.cpp Go to the source code of this file. #include <cassert> #include <coroutine/net.h>","title":"File io_windows.cpp"},{"location":"io__windows_8cpp/#namespaces","text":"Type Name namespace coro namespace gsl The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"Namespaces"},{"location":"io__windows_8cpp_source/","text":"File io_windows.cpp \u00b6 File List > modules > net > io_windows.cpp Go to the documentation of this file. #include <cassert> #include <coroutine/net.h> using namespace std ; using namespace gsl ; namespace coro { //void wait_net_tasks(enumerable<coroutine_handle<void>>& tasks, // chrono::nanoseconds) noexcept(false) { // // windows implementation rely on callback. // // So there is noting to yield ... // tasks = enumerable<coroutine_handle<void>>{}; // // Just comsume some items in this thread's APC queue // SleepEx(0, true); //} bool is_async_pending ( int ec ) noexcept { switch ( ec ) { case WSAEWOULDBLOCK : case EWOULDBLOCK : case EINPROGRESS : case ERROR_IO_PENDING : return true ; default : return false ; } } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .6 ) void CALLBACK on_io_done ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); // Mostly, `Internal` and `InternalHigh` holds exactly same value with the parameters. // So these assignments are redundant. Here, we are just making sure of it. work -> Internal = errc ; // -> return of `work.error()` work -> InternalHigh = sz ; // -> return of `work.resume()` assert ( static_cast < bool > ( work -> task )); work -> task . resume (); } bool io_work_t :: ready () const noexcept { return false ; // always trigger `await_suspend` in Windows API } uint32_t get_io_error ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < uint32_t > ( target -> Internal ); } int64_t get_io_length ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < int64_t > ( target -> InternalHigh ); } // see also: `on_io_done` uint32_t io_work_t :: error () const noexcept { return get_io_error ( this ); } // zero memory the `OVERLAPPED` part in the `io_work_t` auto zero_overlapped ( io_control_block * work ) noexcept -> io_control_block * { * work = OVERLAPPED {}; return work ; } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .4 ) // for clang, this is not constexpr function. auto make_wsa_buf ( io_buffer_t v ) noexcept -> WSABUF { WSABUF buf {}; // expect NRVO buf . buf = reinterpret_cast < char *> ( v . data ()); buf . len = gsl :: narrow_cast < ULONG > ( v . size_bytes ()); return buf ; } // ensure we are x64 static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in6 *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send_to :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASendTo ( sd , bufs , 1 , nullptr , flag , // addr , addrlen , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASendTo\" }; } } int64_t io_send_to :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv_from :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecvFrom ( sd , bufs , 1 , nullptr , & flag , // addr , & addrlen , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecvFrom\" }; } } int64_t io_recv_from :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_send` return * reinterpret_cast < io_send *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASend ( sd , bufs , 1 , nullptr , flag , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASend\" }; } } int64_t io_send :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_recv` return * reinterpret_cast < io_recv *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecv ( sd , bufs , 1 , nullptr , & flag , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecv\" }; } } int64_t io_recv :: resume () noexcept { return get_io_length ( this ); } } // namespace coro","title":"File io\\_windows.cpp"},{"location":"io__windows_8cpp_source/#file-io_windowscpp","text":"File List > modules > net > io_windows.cpp Go to the documentation of this file. #include <cassert> #include <coroutine/net.h> using namespace std ; using namespace gsl ; namespace coro { //void wait_net_tasks(enumerable<coroutine_handle<void>>& tasks, // chrono::nanoseconds) noexcept(false) { // // windows implementation rely on callback. // // So there is noting to yield ... // tasks = enumerable<coroutine_handle<void>>{}; // // Just comsume some items in this thread's APC queue // SleepEx(0, true); //} bool is_async_pending ( int ec ) noexcept { switch ( ec ) { case WSAEWOULDBLOCK : case EWOULDBLOCK : case EINPROGRESS : case ERROR_IO_PENDING : return true ; default : return false ; } } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .6 ) void CALLBACK on_io_done ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); // Mostly, `Internal` and `InternalHigh` holds exactly same value with the parameters. // So these assignments are redundant. Here, we are just making sure of it. work -> Internal = errc ; // -> return of `work.error()` work -> InternalHigh = sz ; // -> return of `work.resume()` assert ( static_cast < bool > ( work -> task )); work -> task . resume (); } bool io_work_t :: ready () const noexcept { return false ; // always trigger `await_suspend` in Windows API } uint32_t get_io_error ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < uint32_t > ( target -> Internal ); } int64_t get_io_length ( const OVERLAPPED * target ) noexcept { return gsl :: narrow_cast < int64_t > ( target -> InternalHigh ); } // see also: `on_io_done` uint32_t io_work_t :: error () const noexcept { return get_io_error ( this ); } // zero memory the `OVERLAPPED` part in the `io_work_t` auto zero_overlapped ( io_control_block * work ) noexcept -> io_control_block * { * work = OVERLAPPED {}; return work ; } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( f .4 ) // for clang, this is not constexpr function. auto make_wsa_buf ( io_buffer_t v ) noexcept -> WSABUF { WSABUF buf {}; // expect NRVO buf . buf = reinterpret_cast < char *> ( v . data ()); buf . len = gsl :: narrow_cast < ULONG > ( v . size_bytes ()); return buf ; } // ensure we are x64 static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in6 *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( type .3 ) auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( const_cast < sockaddr_in *> ( addressof ( remote ))); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_send_to` return * reinterpret_cast < io_send_to *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send_to :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASendTo ( sd , bufs , 1 , nullptr , flag , // addr , addrlen , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASendTo\" }; } } int64_t io_send_to :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in6 ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . Pointer = reinterpret_cast < sockaddr *> ( addressof ( remote )); work . buffer = buffer ; work . Internal = DWORD { 0 }; // flag work . InternalHigh = sizeof ( sockaddr_in ); // `co_await` operator will use reference to `io_recv_from` return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv_from :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto addr = reinterpret_cast < sockaddr *> ( Pointer ); auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecvFrom ( sd , bufs , 1 , nullptr , & flag , // addr , & addrlen , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecvFrom\" }; } } int64_t io_recv_from :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_send` return * reinterpret_cast < io_send *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_send :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); const auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSASend ( sd , bufs , 1 , nullptr , flag , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSASend\" }; } } int64_t io_send :: resume () noexcept { return get_io_length ( this ); } GSL_SUPPRESS ( type .1 ) auto recv_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & { work . hEvent = reinterpret_cast < HANDLE > ( sd ); work . buffer = buffer ; work . Internal = flag ; // `co_await` operator will use reference to `io_recv` return * reinterpret_cast < io_recv *> ( addressof ( work )); } GSL_SUPPRESS ( type .1 ) GSL_SUPPRESS ( bounds .3 ) void io_recv :: suspend ( coroutine_handle < void > t ) noexcept ( false ) { task = t ; // coroutine will be resumed in overlapped callback const auto sd = reinterpret_cast < SOCKET > ( hEvent ); auto flag = gsl :: narrow_cast < DWORD > ( Internal ); WSABUF bufs [ 1 ] = { make_wsa_buf ( buffer )}; if ( :: WSARecv ( sd , bufs , 1 , nullptr , & flag , // zero_overlapped ( this ), on_io_done ) == NO_ERROR ) return ; if ( const auto ec = WSAGetLastError ()) { if ( is_async_pending ( ec )) return ; throw system_error { ec , system_category (), \"WSARecv\" }; } } int64_t io_recv :: resume () noexcept { return get_io_length ( this ); } } // namespace coro","title":"File io_windows.cpp"},{"location":"kqueue_8cpp/","text":"File kqueue.cpp \u00b6 File List > modules > system > kqueue.cpp Go to the source code of this file. #include <coroutine/unix.h> #include <system_error> #include <unistd.h> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/system/kqueue.cpp","title":"File kqueue.cpp"},{"location":"kqueue_8cpp/#file-kqueuecpp","text":"File List > modules > system > kqueue.cpp Go to the source code of this file. #include <coroutine/unix.h> #include <system_error> #include <unistd.h>","title":"File kqueue.cpp"},{"location":"kqueue_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/system/kqueue.cpp","title":"Namespaces"},{"location":"kqueue_8cpp_source/","text":"File kqueue.cpp \u00b6 File List > modules > system > kqueue.cpp Go to the documentation of this file. #include <coroutine/unix.h> #include <system_error> #include <unistd.h> namespace coro { kqueue_owner :: kqueue_owner () noexcept ( false ) : kqfd { kqueue ()} { if ( kqfd < 0 ) throw system_error { errno , system_category (), \"kqueue\" }; } kqueue_owner ::~ kqueue_owner () noexcept { close ( kqfd ); } void kqueue_owner :: change ( kevent64_s & req ) noexcept ( false ) { // attach the event config auto ec = kevent64 ( kqfd , & req , 1 , nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } ptrdiff_t kqueue_owner :: events ( const timespec & ts , gsl :: span < kevent64_s > events ) noexcept ( false ) { // wait for events ... auto count = kevent64 ( kqfd , nullptr , 0 , // events . data (), events . size (), // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; return static_cast < ptrdiff_t > ( count ); } } // namespace coro","title":"File kqueue.cpp"},{"location":"kqueue_8cpp_source/#file-kqueuecpp","text":"File List > modules > system > kqueue.cpp Go to the documentation of this file. #include <coroutine/unix.h> #include <system_error> #include <unistd.h> namespace coro { kqueue_owner :: kqueue_owner () noexcept ( false ) : kqfd { kqueue ()} { if ( kqfd < 0 ) throw system_error { errno , system_category (), \"kqueue\" }; } kqueue_owner ::~ kqueue_owner () noexcept { close ( kqfd ); } void kqueue_owner :: change ( kevent64_s & req ) noexcept ( false ) { // attach the event config auto ec = kevent64 ( kqfd , & req , 1 , nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } ptrdiff_t kqueue_owner :: events ( const timespec & ts , gsl :: span < kevent64_s > events ) noexcept ( false ) { // wait for events ... auto count = kevent64 ( kqfd , nullptr , 0 , // events . data (), events . size (), // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; return static_cast < ptrdiff_t > ( count ); } } // namespace coro","title":"File kqueue.cpp"},{"location":"libmain_8cpp/","text":"File libmain.cpp \u00b6 File List > modules > system > libmain.cpp Go to the source code of this file. Macros \u00b6 Type Name define EPILOGUE __attribute__((destructor)) define PROLOGUE __attribute__((constructor)) Macro Definition Documentation \u00b6 define EPILOGUE \u00b6 #define EPILOGUE __attribute__((destructor)) define PROLOGUE \u00b6 #define PROLOGUE __attribute__((constructor)) Author: github.com/luncliff ( luncliff@gmail.com ) The documentation for this class was generated from the following file modules/system/libmain.cpp","title":"File libmain.cpp"},{"location":"libmain_8cpp/#file-libmaincpp","text":"File List > modules > system > libmain.cpp Go to the source code of this file.","title":"File libmain.cpp"},{"location":"libmain_8cpp/#macros","text":"Type Name define EPILOGUE __attribute__((destructor)) define PROLOGUE __attribute__((constructor))","title":"Macros"},{"location":"libmain_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"libmain_8cpp/#define-epilogue","text":"#define EPILOGUE __attribute__((destructor))","title":"define EPILOGUE"},{"location":"libmain_8cpp/#define-prologue","text":"#define PROLOGUE __attribute__((constructor)) Author: github.com/luncliff ( luncliff@gmail.com ) The documentation for this class was generated from the following file modules/system/libmain.cpp","title":"define PROLOGUE"},{"location":"libmain_8cpp_source/","text":"File libmain.cpp \u00b6 File List > modules > system > libmain.cpp Go to the documentation of this file. #ifdef _WIN32 #define PROLOGUE #define EPILOGUE #else #define PROLOGUE __attribute__((constructor)) #define EPILOGUE __attribute__((destructor)) #endif #ifdef _WIN32 #include <Windows.h> // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx BOOL WINAPI DllMain ( HINSTANCE , DWORD , LPVOID ) noexcept { return TRUE ; } #endif","title":"File libmain.cpp"},{"location":"libmain_8cpp_source/#file-libmaincpp","text":"File List > modules > system > libmain.cpp Go to the documentation of this file. #ifdef _WIN32 #define PROLOGUE #define EPILOGUE #else #define PROLOGUE __attribute__((constructor)) #define EPILOGUE __attribute__((destructor)) #endif #ifdef _WIN32 #include <Windows.h> // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx BOOL WINAPI DllMain ( HINSTANCE , DWORD , LPVOID ) noexcept { return TRUE ; } #endif","title":"File libmain.cpp"},{"location":"linux_8cpp/","text":"File linux.cpp \u00b6 File List > modules > system > linux.cpp Go to the source code of this file. #include <coroutine/linux.h> #include <fcntl.h> #include <sys/eventfd.h> #include <unistd.h> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/system/linux.cpp","title":"File linux.cpp"},{"location":"linux_8cpp/#file-linuxcpp","text":"File List > modules > system > linux.cpp Go to the source code of this file. #include <coroutine/linux.h> #include <fcntl.h> #include <sys/eventfd.h> #include <unistd.h>","title":"File linux.cpp"},{"location":"linux_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/system/linux.cpp","title":"Namespaces"},{"location":"linux_8cpp_source/","text":"File linux.cpp \u00b6 File List > modules > system > linux.cpp Go to the documentation of this file. #include <coroutine/linux.h> #include <fcntl.h> #include <sys/eventfd.h> #include <unistd.h> using namespace std ; namespace coro { epoll_owner :: epoll_owner () noexcept ( false ) : epfd { epoll_create1 ( EPOLL_CLOEXEC )} { if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } epoll_owner ::~ epoll_owner () noexcept { close ( epfd ); } void epoll_owner :: try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl(EPOLL_CTL_ADD|EPOLL_CTL_MODE)\" }; } void epoll_owner :: remove ( uint64_t fd ) { epoll_event req {}; // just prevent non-null input const auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl(EPOLL_CTL_DEL)\" }; } ptrdiff_t epoll_owner :: wait ( uint32_t wait_ms , gsl :: span < epoll_event > output ) noexcept ( false ) { auto count = epoll_wait ( epfd , output . data (), output . size (), wait_ms ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; return count ; } // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) noexcept { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) noexcept { return static_cast < int64_t > ( ~ emask & state ); } void notify_event ( int64_t efd ) noexcept ( false ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd if ( write ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"write\" }; } void consume_event ( int64_t efd ) noexcept ( false ) { if ( read ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"read\" }; } event :: event () noexcept ( false ) : state {} { const auto fd = :: eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () noexcept { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } uint64_t event :: fd () const noexcept { return get_eventfd ( state ); } bool event :: is_set () const noexcept { return is_signaled ( state ); } void event :: set () noexcept ( false ) { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); notify_event ( fd ); // if it didn't throwed state = emask | static_cast < uint64_t > ( fd ); // it's signaled state from now } void event :: reset () noexcept ( false ) { const auto fd = get_eventfd ( state ); // if already signaled. nothing to do... if ( is_signaled ( state )) consume_event ( fd ); // make unsignaled state this -> state = static_cast < uint64_t > ( fd ); } } // namespace coro","title":"File linux.cpp"},{"location":"linux_8cpp_source/#file-linuxcpp","text":"File List > modules > system > linux.cpp Go to the documentation of this file. #include <coroutine/linux.h> #include <fcntl.h> #include <sys/eventfd.h> #include <unistd.h> using namespace std ; namespace coro { epoll_owner :: epoll_owner () noexcept ( false ) : epfd { epoll_create1 ( EPOLL_CLOEXEC )} { if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } epoll_owner ::~ epoll_owner () noexcept { close ( epfd ); } void epoll_owner :: try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl(EPOLL_CTL_ADD|EPOLL_CTL_MODE)\" }; } void epoll_owner :: remove ( uint64_t fd ) { epoll_event req {}; // just prevent non-null input const auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl(EPOLL_CTL_DEL)\" }; } ptrdiff_t epoll_owner :: wait ( uint32_t wait_ms , gsl :: span < epoll_event > output ) noexcept ( false ) { auto count = epoll_wait ( epfd , output . data (), output . size (), wait_ms ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; return count ; } // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) noexcept { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) noexcept { return static_cast < int64_t > ( ~ emask & state ); } void notify_event ( int64_t efd ) noexcept ( false ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd if ( write ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"write\" }; } void consume_event ( int64_t efd ) noexcept ( false ) { if ( read ( efd , & efd , sizeof ( efd )) == - 1 ) throw system_error { errno , system_category (), \"read\" }; } event :: event () noexcept ( false ) : state {} { const auto fd = :: eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () noexcept { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } uint64_t event :: fd () const noexcept { return get_eventfd ( state ); } bool event :: is_set () const noexcept { return is_signaled ( state ); } void event :: set () noexcept ( false ) { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); notify_event ( fd ); // if it didn't throwed state = emask | static_cast < uint64_t > ( fd ); // it's signaled state from now } void event :: reset () noexcept ( false ) { const auto fd = get_eventfd ( state ); // if already signaled. nothing to do... if ( is_signaled ( state )) consume_event ( fd ); // make unsignaled state this -> state = static_cast < uint64_t > ( fd ); } } // namespace coro","title":"File linux.cpp"},{"location":"linux_8h/","text":"File linux.h \u00b6 File List > coroutine > linux.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/epoll.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"File linux.h"},{"location":"linux_8h/#file-linuxh","text":"File List > coroutine > linux.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/epoll.h>","title":"File linux.h"},{"location":"linux_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"linux_8h/#classes","text":"Type Name class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __","title":"Classes"},{"location":"linux_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/linux.h","title":"Detailed Description"},{"location":"linux_8h_source/","text":"File linux.h \u00b6 File List > coroutine > linux.h Go to the documentation of this file. #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if not(defined(__linux__)) #error \"expect Linux platform for this file\" #endif #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/epoll.h> // for Linux epoll namespace coro { using namespace std ; using namespace std :: experimental ; class epoll_owner final { int64_t epfd ; public : epoll_owner () noexcept ( false ); ~ epoll_owner () noexcept ; epoll_owner ( const epoll_owner & ) = delete ; epoll_owner ( epoll_owner && ) = delete ; epoll_owner & operator = ( const epoll_owner & ) = delete ; epoll_owner & operator = ( epoll_owner && ) = delete ; public : void try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ); void remove ( uint64_t fd ); ptrdiff_t wait ( uint32_t wait_ms , gsl :: span < epoll_event > list ) noexcept ( false ); public : [[ nodiscard ]] auto submit ( int64_t fd , epoll_event & req ) noexcept { class awaiter final : public suspend_always { epoll_owner & ep ; int64_t fd ; epoll_event & req ; public : constexpr awaiter ( epoll_owner & _ep , int64_t _fd , epoll_event & _req ) : ep { _ep }, fd { _fd }, req { _req } { } public : void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( req . data . ptr == nullptr ) req . data . ptr = coro . address (); return ep . try_add ( fd , req ); } }; return awaiter { * this , fd , req }; } }; class event final { uint64_t state ; public : event () noexcept ( false ); ~ event () noexcept ; event ( const event & ) = delete ; event ( event && ) = delete ; event & operator = ( const event & ) = delete ; event & operator = ( event && ) = delete ; uint64_t fd () const noexcept ; bool is_set () const noexcept ; void set () noexcept ( false ); void reset () noexcept ( false ); }; auto wait_in ( epoll_owner & ep , event & efd ) { class awaiter : epoll_event { epoll_owner & ep ; event & efd ; public : awaiter ( epoll_owner & _ep , event & _efd ) noexcept : epoll_event {}, ep { _ep }, efd { _efd } { this -> events = EPOLLET | EPOLLIN | EPOLLONESHOT ; } bool await_ready () const noexcept { return efd . is_set (); } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { this -> data . ptr = coro . address (); return ep . try_add ( efd . fd (), * this ); } void await_resume () noexcept { return efd . reset (); } }; return awaiter { ep , efd }; } } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File linux.h"},{"location":"linux_8h_source/#file-linuxh","text":"File List > coroutine > linux.h Go to the documentation of this file. #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if not(defined(__linux__)) #error \"expect Linux platform for this file\" #endif #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/epoll.h> // for Linux epoll namespace coro { using namespace std ; using namespace std :: experimental ; class epoll_owner final { int64_t epfd ; public : epoll_owner () noexcept ( false ); ~ epoll_owner () noexcept ; epoll_owner ( const epoll_owner & ) = delete ; epoll_owner ( epoll_owner && ) = delete ; epoll_owner & operator = ( const epoll_owner & ) = delete ; epoll_owner & operator = ( epoll_owner && ) = delete ; public : void try_add ( uint64_t fd , epoll_event & req ) noexcept ( false ); void remove ( uint64_t fd ); ptrdiff_t wait ( uint32_t wait_ms , gsl :: span < epoll_event > list ) noexcept ( false ); public : [[ nodiscard ]] auto submit ( int64_t fd , epoll_event & req ) noexcept { class awaiter final : public suspend_always { epoll_owner & ep ; int64_t fd ; epoll_event & req ; public : constexpr awaiter ( epoll_owner & _ep , int64_t _fd , epoll_event & _req ) : ep { _ep }, fd { _fd }, req { _req } { } public : void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( req . data . ptr == nullptr ) req . data . ptr = coro . address (); return ep . try_add ( fd , req ); } }; return awaiter { * this , fd , req }; } }; class event final { uint64_t state ; public : event () noexcept ( false ); ~ event () noexcept ; event ( const event & ) = delete ; event ( event && ) = delete ; event & operator = ( const event & ) = delete ; event & operator = ( event && ) = delete ; uint64_t fd () const noexcept ; bool is_set () const noexcept ; void set () noexcept ( false ); void reset () noexcept ( false ); }; auto wait_in ( epoll_owner & ep , event & efd ) { class awaiter : epoll_event { epoll_owner & ep ; event & efd ; public : awaiter ( epoll_owner & _ep , event & _efd ) noexcept : epoll_event {}, ep { _ep }, efd { _efd } { this -> events = EPOLLET | EPOLLIN | EPOLLONESHOT ; } bool await_ready () const noexcept { return efd . is_set (); } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { this -> data . ptr = coro . address (); return ep . try_add ( efd . fd (), * this ); } void await_resume () noexcept { return efd . reset (); } }; return awaiter { ep , efd }; } } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File linux.h"},{"location":"macros/","text":"Macros \u00b6 c \u00b6 COROUTINE_PORTABLE_FRAME_H ( frame.h ) COROUTINE_NET_IO_H ( net.h ) COROUTINE_PROMISE_AND_RETURN_TYPES_H ( return.h ) COROUTINE_SYSTEM_WRAPPER_H ( windows.h ) e \u00b6 EPILOGUE ( libmain.cpp ) l \u00b6 LUNCLIFF_COROUTINE_CHANNEL_HPP ( channel.hpp ) p \u00b6 PROLOGUE ( libmain.cpp )","title":"Macros"},{"location":"macros/#macros","text":"","title":"Macros"},{"location":"macros/#c","text":"COROUTINE_PORTABLE_FRAME_H ( frame.h ) COROUTINE_NET_IO_H ( net.h ) COROUTINE_PROMISE_AND_RETURN_TYPES_H ( return.h ) COROUTINE_SYSTEM_WRAPPER_H ( windows.h )","title":"c"},{"location":"macros/#e","text":"EPILOGUE ( libmain.cpp )","title":"e"},{"location":"macros/#l","text":"LUNCLIFF_COROUTINE_CHANNEL_HPP ( channel.hpp )","title":"l"},{"location":"macros/#p","text":"PROLOGUE ( libmain.cpp )","title":"p"},{"location":"modules/","text":"Modules \u00b6 Here is a list of all modules: BSD Linux NetResolve NetWork POSIX Return Windows Channel","title":"Groups"},{"location":"modules/#modules","text":"Here is a list of all modules: BSD Linux NetResolve NetWork POSIX Return Windows Channel","title":"Modules"},{"location":"namespace_member_enums/","text":"Namespace Member Enums \u00b6","title":"Namespace Member Enums"},{"location":"namespace_member_enums/#namespace-member-enums","text":"","title":"Namespace Member Enums"},{"location":"namespace_member_functions/","text":"Namespace Member Functions \u00b6 c \u00b6 consume_event ( coro ) g \u00b6 GSL_SUPPRESS ( coro ) get_address ( coro ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro ) i \u00b6 is_async_pending ( coro ) is_signaled ( coro ) n \u00b6 notify_event ( coro ) noop_coroutine ( std::experimental ) o \u00b6 on_io_done ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental ) p \u00b6 poison ( coro::internal ) poll_net_tasks ( coro ) r \u00b6 recv_from ( coro ) recv_stream ( coro ) resume_net_task ( coro ) s \u00b6 select ( coro ) send_stream ( coro ) send_to ( coro ) w \u00b6 wait_event_on_thread_pool ( coro ) wait_in ( coro ) z \u00b6 zero_overlapped ( coro )","title":"Namespace Member Functions"},{"location":"namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"namespace_member_functions/#c","text":"consume_event ( coro )","title":"c"},{"location":"namespace_member_functions/#g","text":"GSL_SUPPRESS ( coro ) get_address ( coro ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro )","title":"g"},{"location":"namespace_member_functions/#i","text":"is_async_pending ( coro ) is_signaled ( coro )","title":"i"},{"location":"namespace_member_functions/#n","text":"notify_event ( coro ) noop_coroutine ( std::experimental )","title":"n"},{"location":"namespace_member_functions/#o","text":"on_io_done ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental )","title":"o"},{"location":"namespace_member_functions/#p","text":"poison ( coro::internal ) poll_net_tasks ( coro )","title":"p"},{"location":"namespace_member_functions/#r","text":"recv_from ( coro ) recv_stream ( coro ) resume_net_task ( coro )","title":"r"},{"location":"namespace_member_functions/#s","text":"select ( coro ) send_stream ( coro ) send_to ( coro )","title":"s"},{"location":"namespace_member_functions/#w","text":"wait_event_on_thread_pool ( coro ) wait_in ( coro )","title":"w"},{"location":"namespace_member_functions/#z","text":"zero_overlapped ( coro )","title":"z"},{"location":"namespace_member_typedefs/","text":"Namespace Member Typedefs \u00b6 c \u00b6 coroutine_traits ( std ) i \u00b6 io_buffer_t ( coro ) n \u00b6 net_callback_t ( coro ) noop_coroutine_handle ( std::experimental )","title":"Namespace Member Typedefs"},{"location":"namespace_member_typedefs/#namespace-member-typedefs","text":"","title":"Namespace Member Typedefs"},{"location":"namespace_member_typedefs/#c","text":"coroutine_traits ( std )","title":"c"},{"location":"namespace_member_typedefs/#i","text":"io_buffer_t ( coro )","title":"i"},{"location":"namespace_member_typedefs/#n","text":"net_callback_t ( coro ) noop_coroutine_handle ( std::experimental )","title":"n"},{"location":"namespace_member_variables/","text":"Namespace Member Variables \u00b6 e \u00b6 emask ( coro ) i \u00b6 iep ( coro ) n \u00b6 netkq ( coro ) o \u00b6 oep ( coro )","title":"Namespace Member Variables"},{"location":"namespace_member_variables/#namespace-member-variables","text":"","title":"Namespace Member Variables"},{"location":"namespace_member_variables/#e","text":"emask ( coro )","title":"e"},{"location":"namespace_member_variables/#i","text":"iep ( coro )","title":"i"},{"location":"namespace_member_variables/#n","text":"netkq ( coro )","title":"n"},{"location":"namespace_member_variables/#o","text":"oep ( coro )","title":"o"},{"location":"namespace_members/","text":"Namespace Members \u00b6 c \u00b6 consume_event ( coro ) coroutine_traits ( std ) e \u00b6 emask ( coro ) g \u00b6 GSL_SUPPRESS ( coro ) get_address ( coro ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro ) i \u00b6 iep ( coro ) io_buffer_t ( coro ) is_async_pending ( coro ) is_signaled ( coro ) n \u00b6 net_callback_t ( coro ) netkq ( coro ) notify_event ( coro ) noop_coroutine ( std::experimental ) noop_coroutine_handle ( std::experimental ) o \u00b6 oep ( coro ) on_io_done ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental ) p \u00b6 poison ( coro::internal ) poll_net_tasks ( coro ) r \u00b6 recv_from ( coro ) recv_stream ( coro ) resume_net_task ( coro ) s \u00b6 select ( coro ) send_stream ( coro ) send_to ( coro ) w \u00b6 wait_event_on_thread_pool ( coro ) wait_in ( coro ) z \u00b6 zero_overlapped ( coro )","title":"Namespace Members"},{"location":"namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"namespace_members/#c","text":"consume_event ( coro ) coroutine_traits ( std )","title":"c"},{"location":"namespace_members/#e","text":"emask ( coro )","title":"e"},{"location":"namespace_members/#g","text":"GSL_SUPPRESS ( coro ) get_address ( coro ) get_eventfd ( coro ) get_io_error ( coro ) get_io_length ( coro ) get_name ( coro )","title":"g"},{"location":"namespace_members/#i","text":"iep ( coro ) io_buffer_t ( coro ) is_async_pending ( coro ) is_signaled ( coro )","title":"i"},{"location":"namespace_members/#n","text":"net_callback_t ( coro ) netkq ( coro ) notify_event ( coro ) noop_coroutine ( std::experimental ) noop_coroutine_handle ( std::experimental )","title":"n"},{"location":"namespace_members/#o","text":"oep ( coro ) on_io_done ( coro ) operator!= ( std::experimental ) operator< ( std::experimental ) operator<= ( std::experimental ) operator== ( std::experimental ) operator> ( std::experimental ) operator>= ( std::experimental )","title":"o"},{"location":"namespace_members/#p","text":"poison ( coro::internal ) poll_net_tasks ( coro )","title":"p"},{"location":"namespace_members/#r","text":"recv_from ( coro ) recv_stream ( coro ) resume_net_task ( coro )","title":"r"},{"location":"namespace_members/#s","text":"select ( coro ) send_stream ( coro ) send_to ( coro )","title":"s"},{"location":"namespace_members/#w","text":"wait_event_on_thread_pool ( coro ) wait_in ( coro )","title":"w"},{"location":"namespace_members/#z","text":"zero_overlapped ( coro )","title":"z"},{"location":"namespacecoro/","text":"Namespace coro \u00b6 Class List > coro More... Namespaces \u00b6 Type Name namespace internal Classes \u00b6 Type Name struct bypass_mutex Lockable without lock operation. class channel <T, M> C++ Coroutines based channel. class channel_peeker <typename T, typename M> Extension of channel_reader for subroutines. class channel_reader <typename T, typename M> Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class channel_writer <typename T, typename M> Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class enumerable <typename T> class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class kqueue_owner RAII wrapping for kqueue file descriptor. class promise_aa class promise_an class promise_na class promise_nn class pthread_detacher_t Special return type that wraps pthread_detach __ class pthread_joiner_t Special return type that wraps pthread_join __ class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class section Standard lockable with win32 criticial section. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. Public Types \u00b6 Type Name typedef gsl::span< std::byte > io_buffer_t This is simply a view to storage. Be aware that it doesn't have ownership. typedef void(*)(void *ctx, coroutine_handle < void > coro) net_callback_t Public Attributes \u00b6 Type Name constexpr uint64_t emask = = 1ULL << 63 epoll_owner iep = {} kqueue_owner netkq = {} epoll_owner oep = {} Public Functions \u00b6 Type Name GSL_SUPPRESS (f. 4) noexcept void consume_event (int64_t efd) noexcept uint32_t get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in > output) noexcept Thin wrapper of getaddrinfo for IPv4. uint32_t get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in6 > output) noexcept Thin wrapper of getaddrinfo for IPv6. auto get_address (addrinfo * list) noexcept auto get_address (addrinfo * list, sockaddr_in addr) noexcept auto get_address (addrinfo * list, sockaddr_in6 addr) noexcept int64_t get_eventfd (uint64_t state) noexcept uint32_t get_io_error (const OVERLAPPED * target) noexcept int64_t get_io_length (const OVERLAPPED * target) noexcept uint32_t get_name (const sockaddr_in & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST uint32_t get_name (const sockaddr_in6 & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST bool is_async_pending (int ec) noexcept bool is_signaled (uint64_t state) noexcept void notify_event (int64_t efd) noexcept void CALLBACK on_io_done (DWORD errc, DWORD sz, LPWSAOVERLAPPED pover, DWORD flags) noexcept void poll_net_tasks (const timespec & wait_time, net_callback_t callback, void * ctx) noexcept void poll_net_tasks (uint64_t nano) noexcept auto recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_recv awaitable with the given parameters. void resume_net_task (void *, coroutine_handle < void > coro) noexcept void select ( channel < T, M > & ch, Fn && fn) noexcept void select (Ch & ch, Fn && fn, Args &&... args) noexcept auto send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_send awaitable with the given parameters. auto send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. auto send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. void __stdcall wait_event_on_thread_pool (PVOID ctx, BOOLEAN timedout) auto wait_in ( epoll_owner & ep, event & efd) Bind the given event ( eventfd ) to epoll_owner (Epoll) auto zero_overlapped (io_control_block * work) noexcept Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Public Types Documentation \u00b6 typedef io_buffer_t \u00b6 using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ; typedef net_callback_t \u00b6 using coro :: net_callback_t = typedef void ( * )( void * ctx , coroutine_handle < void > coro ); Public Attributes Documentation \u00b6 variable emask \u00b6 constexpr uint64_t coro :: emask ; variable iep \u00b6 epoll_owner coro :: iep ; variable netkq \u00b6 kqueue_owner coro :: netkq ; variable oep \u00b6 epoll_owner coro :: oep ; Public Functions Documentation \u00b6 function GSL_SUPPRESS \u00b6 coro :: GSL_SUPPRESS ( f . 4 ) noexcept function consume_event \u00b6 void coro :: consume_event ( int64_t efd ) noexcept function get_address \u00b6 uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror function get_address \u00b6 uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror function get_address \u00b6 auto coro :: get_address ( addrinfo * list ) noexcept function get_address \u00b6 auto coro :: get_address ( addrinfo * list , sockaddr_in addr ) noexcept function get_address \u00b6 auto coro :: get_address ( addrinfo * list , sockaddr_in6 addr ) noexcept function get_eventfd \u00b6 int64_t coro :: get_eventfd ( uint64_t state ) noexcept function get_io_error \u00b6 uint32_t coro :: get_io_error ( const OVERLAPPED * target ) noexcept function get_io_length \u00b6 int64_t coro :: get_io_length ( const OVERLAPPED * target ) noexcept function get_name \u00b6 uint32_t coro :: get_name ( const sockaddr_in & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo function get_name \u00b6 uint32_t coro :: get_name ( const sockaddr_in6 & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo function is_async_pending \u00b6 bool coro :: is_async_pending ( int ec ) noexcept function is_signaled \u00b6 bool coro :: is_signaled ( uint64_t state ) noexcept function notify_event \u00b6 void coro :: notify_event ( int64_t efd ) noexcept function on_io_done \u00b6 void CALLBACK coro :: on_io_done ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept function poll_net_tasks \u00b6 void coro :: poll_net_tasks ( const timespec & wait_time , net_callback_t callback , void * ctx ) noexcept function poll_net_tasks \u00b6 void coro :: poll_net_tasks ( uint64_t nano ) noexcept function recv_from \u00b6 auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from & function recv_from \u00b6 auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from & function recv_stream \u00b6 auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_recv & function resume_net_task \u00b6 void coro :: resume_net_task ( void * , coroutine_handle < void > coro ) noexcept function select \u00b6 template < typename T typename T , typename M typename M , typename Fn typename Fn > void coro :: select ( channel < T , M > & ch , Fn && fn ) noexcept Note: If the channel is readable, acquire the value and invoke the function See also: channel_peeker function select \u00b6 template < typename ... Args , typename Ch typename Ch , typename Fn typename Fn > void coro :: select ( Ch & ch , Fn && fn , Args && ... args ) noexcept Note: For each pair, peeks a channel and invoke the function with the value if the peek was successful. See also: test/channel_select_type.cpp function send_stream \u00b6 auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_send & function send_to \u00b6 auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to & function send_to \u00b6 auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to & function wait_event_on_thread_pool \u00b6 void __stdcall coro :: wait_event_on_thread_pool ( PVOID ctx , BOOLEAN timedout ) function wait_in \u00b6 auto coro :: wait_in ( epoll_owner & ep , event & efd ) Parameters: ep epoll_owner efd event See also: event Returns: awaitable struct for the binding function zero_overlapped \u00b6 auto coro :: zero_overlapped ( io_control_block * work ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Namespace coro"},{"location":"namespacecoro/#namespace-coro","text":"Class List > coro More...","title":"Namespace coro"},{"location":"namespacecoro/#namespaces","text":"Type Name namespace internal","title":"Namespaces"},{"location":"namespacecoro/#classes","text":"Type Name struct bypass_mutex Lockable without lock operation. class channel <T, M> C++ Coroutines based channel. class channel_peeker <typename T, typename M> Extension of channel_reader for subroutines. class channel_reader <typename T, typename M> Awaitable type for channel 's read operation. It moves the value from writer coroutine's frame to reader coroutine's frame. class channel_writer <typename T, typename M> Awaitable for channel 's write operation. It exposes a reference to the value for channel_reader . class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class enumerable <typename T> class epoll_owner RAII wrapping for epoll file descriptor. class event RAII + stateful eventfd __ class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. class kqueue_owner RAII wrapping for kqueue file descriptor. class promise_aa class promise_an class promise_na class promise_nn class pthread_detacher_t Special return type that wraps pthread_detach __ class pthread_joiner_t Special return type that wraps pthread_join __ class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. class section Standard lockable with win32 criticial section. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body.","title":"Classes"},{"location":"namespacecoro/#public-types","text":"Type Name typedef gsl::span< std::byte > io_buffer_t This is simply a view to storage. Be aware that it doesn't have ownership. typedef void(*)(void *ctx, coroutine_handle < void > coro) net_callback_t","title":"Public Types"},{"location":"namespacecoro/#public-attributes","text":"Type Name constexpr uint64_t emask = = 1ULL << 63 epoll_owner iep = {} kqueue_owner netkq = {} epoll_owner oep = {}","title":"Public Attributes"},{"location":"namespacecoro/#public-functions","text":"Type Name GSL_SUPPRESS (f. 4) noexcept void consume_event (int64_t efd) noexcept uint32_t get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in > output) noexcept Thin wrapper of getaddrinfo for IPv4. uint32_t get_address (const addrinfo & hint, gsl::czstring<> host, gsl::czstring<> serv, gsl::span< sockaddr_in6 > output) noexcept Thin wrapper of getaddrinfo for IPv6. auto get_address (addrinfo * list) noexcept auto get_address (addrinfo * list, sockaddr_in addr) noexcept auto get_address (addrinfo * list, sockaddr_in6 addr) noexcept int64_t get_eventfd (uint64_t state) noexcept uint32_t get_io_error (const OVERLAPPED * target) noexcept int64_t get_io_length (const OVERLAPPED * target) noexcept uint32_t get_name (const sockaddr_in & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST uint32_t get_name (const sockaddr_in6 & addr, gsl::zstring< NI_MAXHOST > name, gsl::zstring< NI_MAXSERV > serv, int32_t flags=NI_NUMERICHOST bool is_async_pending (int ec) noexcept bool is_signaled (uint64_t state) noexcept void notify_event (int64_t efd) noexcept void CALLBACK on_io_done (DWORD errc, DWORD sz, LPWSAOVERLAPPED pover, DWORD flags) noexcept void poll_net_tasks (const timespec & wait_time, net_callback_t callback, void * ctx) noexcept void poll_net_tasks (uint64_t nano) noexcept auto recv_from (uint64_t sd, sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto recv_from (uint64_t sd, sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_recv_from awaitable with the given parameters. auto recv_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_recv awaitable with the given parameters. void resume_net_task (void *, coroutine_handle < void > coro) noexcept void select ( channel < T, M > & ch, Fn && fn) noexcept void select (Ch & ch, Fn && fn, Args &&... args) noexcept auto send_stream (uint64_t sd, io_buffer_t buf, uint32_t flag, io_work_t & work) noexcept Constructs io_send awaitable with the given parameters. auto send_to (uint64_t sd, const sockaddr_in & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. auto send_to (uint64_t sd, const sockaddr_in6 & remote, io_buffer_t buf, io_work_t & work) noexcept Constructs io_send_to awaitable with the given parameters. void __stdcall wait_event_on_thread_pool (PVOID ctx, BOOLEAN timedout) auto wait_in ( epoll_owner & ep, event & efd) Bind the given event ( eventfd ) to epoll_owner (Epoll) auto zero_overlapped (io_control_block * work) noexcept","title":"Public Functions"},{"location":"namespacecoro/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com )","title":"Detailed Description"},{"location":"namespacecoro/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"namespacecoro/#typedef-io_buffer_t","text":"using coro :: io_buffer_t = typedef gsl :: span < std :: byte > ;","title":"typedef io_buffer_t"},{"location":"namespacecoro/#typedef-net_callback_t","text":"using coro :: net_callback_t = typedef void ( * )( void * ctx , coroutine_handle < void > coro );","title":"typedef net_callback_t"},{"location":"namespacecoro/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"namespacecoro/#variable-emask","text":"constexpr uint64_t coro :: emask ;","title":"variable emask"},{"location":"namespacecoro/#variable-iep","text":"epoll_owner coro :: iep ;","title":"variable iep"},{"location":"namespacecoro/#variable-netkq","text":"kqueue_owner coro :: netkq ;","title":"variable netkq"},{"location":"namespacecoro/#variable-oep","text":"epoll_owner coro :: oep ;","title":"variable oep"},{"location":"namespacecoro/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"namespacecoro/#function-gsl_suppress","text":"coro :: GSL_SUPPRESS ( f . 4 ) noexcept","title":"function GSL_SUPPRESS"},{"location":"namespacecoro/#function-consume_event","text":"void coro :: consume_event ( int64_t efd ) noexcept","title":"function consume_event"},{"location":"namespacecoro/#function-get_address","text":"uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror","title":"function get_address"},{"location":"namespacecoro/#function-get_address_1","text":"uint32_t coro :: get_address ( const addrinfo & hint , gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept Parameters: hint host serv output Returns: uint32_t Error code from the getaddrinfo that can be the argument of gai_strerror See also: getaddrinfo See also: gai_strerror","title":"function get_address"},{"location":"namespacecoro/#function-get_address_2","text":"auto coro :: get_address ( addrinfo * list ) noexcept","title":"function get_address"},{"location":"namespacecoro/#function-get_address_3","text":"auto coro :: get_address ( addrinfo * list , sockaddr_in addr ) noexcept","title":"function get_address"},{"location":"namespacecoro/#function-get_address_4","text":"auto coro :: get_address ( addrinfo * list , sockaddr_in6 addr ) noexcept","title":"function get_address"},{"location":"namespacecoro/#function-get_eventfd","text":"int64_t coro :: get_eventfd ( uint64_t state ) noexcept","title":"function get_eventfd"},{"location":"namespacecoro/#function-get_io_error","text":"uint32_t coro :: get_io_error ( const OVERLAPPED * target ) noexcept","title":"function get_io_error"},{"location":"namespacecoro/#function-get_io_length","text":"int64_t coro :: get_io_length ( const OVERLAPPED * target ) noexcept","title":"function get_io_length"},{"location":"namespacecoro/#function-get_name","text":"uint32_t coro :: get_name ( const sockaddr_in & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"function get_name"},{"location":"namespacecoro/#function-get_name_1","text":"uint32_t coro :: get_name ( const sockaddr_in6 & addr , gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept Parameters: addr name serv can be nullptr flags Returns: uint32_t EAI_AGAIN ... See also: getnameinfo","title":"function get_name"},{"location":"namespacecoro/#function-is_async_pending","text":"bool coro :: is_async_pending ( int ec ) noexcept","title":"function is_async_pending"},{"location":"namespacecoro/#function-is_signaled","text":"bool coro :: is_signaled ( uint64_t state ) noexcept","title":"function is_signaled"},{"location":"namespacecoro/#function-notify_event","text":"void coro :: notify_event ( int64_t efd ) noexcept","title":"function notify_event"},{"location":"namespacecoro/#function-on_io_done","text":"void CALLBACK coro :: on_io_done ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept","title":"function on_io_done"},{"location":"namespacecoro/#function-poll_net_tasks","text":"void coro :: poll_net_tasks ( const timespec & wait_time , net_callback_t callback , void * ctx ) noexcept","title":"function poll_net_tasks"},{"location":"namespacecoro/#function-poll_net_tasks_1","text":"void coro :: poll_net_tasks ( uint64_t nano ) noexcept","title":"function poll_net_tasks"},{"location":"namespacecoro/#function-recv_from","text":"auto coro :: recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from &","title":"function recv_from"},{"location":"namespacecoro/#function-recv_from_1","text":"auto coro :: recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_recv_from &","title":"function recv_from"},{"location":"namespacecoro/#function-recv_stream","text":"auto coro :: recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_recv &","title":"function recv_stream"},{"location":"namespacecoro/#function-resume_net_task","text":"void coro :: resume_net_task ( void * , coroutine_handle < void > coro ) noexcept","title":"function resume_net_task"},{"location":"namespacecoro/#function-select","text":"template < typename T typename T , typename M typename M , typename Fn typename Fn > void coro :: select ( channel < T , M > & ch , Fn && fn ) noexcept Note: If the channel is readable, acquire the value and invoke the function See also: channel_peeker","title":"function select"},{"location":"namespacecoro/#function-select_1","text":"template < typename ... Args , typename Ch typename Ch , typename Fn typename Fn > void coro :: select ( Ch & ch , Fn && fn , Args && ... args ) noexcept Note: For each pair, peeks a channel and invoke the function with the value if the peek was successful. See also: test/channel_select_type.cpp","title":"function select"},{"location":"namespacecoro/#function-send_stream","text":"auto coro :: send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept Parameters: sd buf flag work Returns: io_send &","title":"function send_stream"},{"location":"namespacecoro/#function-send_to","text":"auto coro :: send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"function send_to"},{"location":"namespacecoro/#function-send_to_1","text":"auto coro :: send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept Parameters: sd remote buf work Returns: io_send_to &","title":"function send_to"},{"location":"namespacecoro/#function-wait_event_on_thread_pool","text":"void __stdcall coro :: wait_event_on_thread_pool ( PVOID ctx , BOOLEAN timedout )","title":"function wait_event_on_thread_pool"},{"location":"namespacecoro/#function-wait_in","text":"auto coro :: wait_in ( epoll_owner & ep , event & efd ) Parameters: ep epoll_owner efd event See also: event Returns: awaitable struct for the binding","title":"function wait_in"},{"location":"namespacecoro/#function-zero_overlapped","text":"auto coro :: zero_overlapped ( io_control_block * work ) noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function zero_overlapped"},{"location":"namespacecoro_1_1internal/","text":"Namespace coro::internal \u00b6 Class List > coro > internal Classes \u00b6 Type Name class list <T> Linked list without allocation. Public Static Functions \u00b6 Type Name void * poison () noexcept Returns a non-null address that leads access violation. Public Static Functions Documentation \u00b6 function poison \u00b6 static void * coro :: internal :: poison () noexcept Note: Notice that reinterpret_cast is not constexpr for some compiler. Returns: void* non-null address The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Namespace coro::internal"},{"location":"namespacecoro_1_1internal/#namespace-corointernal","text":"Class List > coro > internal","title":"Namespace coro::internal"},{"location":"namespacecoro_1_1internal/#classes","text":"Type Name class list <T> Linked list without allocation.","title":"Classes"},{"location":"namespacecoro_1_1internal/#public-static-functions","text":"Type Name void * poison () noexcept Returns a non-null address that leads access violation.","title":"Public Static Functions"},{"location":"namespacecoro_1_1internal/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"namespacecoro_1_1internal/#function-poison","text":"static void * coro :: internal :: poison () noexcept Note: Notice that reinterpret_cast is not constexpr for some compiler. Returns: void* non-null address The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function poison"},{"location":"namespacegsl/","text":"Namespace gsl \u00b6 Class List > gsl The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"Namespace gsl"},{"location":"namespacegsl/#namespace-gsl","text":"Class List > gsl The documentation for this class was generated from the following file modules/net/io_windows.cpp","title":"Namespace gsl"},{"location":"namespaces/","text":"Namespace List \u00b6 Here is a list of all namespaces with brief descriptions: namespace coro namespace internal namespace gsl namespace std namespace experimental namespace chrono","title":"Namespaces"},{"location":"namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace coro namespace internal namespace gsl namespace std namespace experimental namespace chrono","title":"Namespace List"},{"location":"namespacestd/","text":"Namespace std \u00b6 Class List > std Namespaces \u00b6 Type Name namespace experimental Public Types \u00b6 Type Name typedef std::experimental::coroutine_traits < Ret, Param... > coroutine_traits Public Types Documentation \u00b6 typedef coroutine_traits \u00b6 using std :: coroutine_traits = typedef std :: experimental :: coroutine_traits < Ret , Param ... > ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Namespace std"},{"location":"namespacestd/#namespace-std","text":"Class List > std","title":"Namespace std"},{"location":"namespacestd/#namespaces","text":"Type Name namespace experimental","title":"Namespaces"},{"location":"namespacestd/#public-types","text":"Type Name typedef std::experimental::coroutine_traits < Ret, Param... > coroutine_traits","title":"Public Types"},{"location":"namespacestd/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"namespacestd/#typedef-coroutine_traits","text":"using std :: coroutine_traits = typedef std :: experimental :: coroutine_traits < Ret , Param ... > ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"typedef coroutine_traits"},{"location":"namespacestd_1_1chrono/","text":"Namespace std::chrono \u00b6 Class List > chrono The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"Namespace std::chrono"},{"location":"namespacestd_1_1chrono/#namespace-stdchrono","text":"Class List > chrono The documentation for this class was generated from the following file modules/net/io_darwin.cpp","title":"Namespace std::chrono"},{"location":"namespacestd_1_1experimental/","text":"Namespace std::experimental \u00b6 Class List > std > experimental Classes \u00b6 Type Name class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct coroutine_traits< void, P... > <P> Allow void return of the coroutine. struct noop_coroutine_promise class suspend_always class suspend_never Public Types \u00b6 Type Name typedef coroutine_handle < noop_coroutine_promise > noop_coroutine_handle Public Functions \u00b6 Type Name noop_coroutine_handle noop_coroutine () noexcept bool operator!= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator< (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator<= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator== (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator> (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator>= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept Public Types Documentation \u00b6 typedef noop_coroutine_handle \u00b6 using std :: experimental :: noop_coroutine_handle = typedef coroutine_handle < noop_coroutine_promise > ; Public Functions Documentation \u00b6 function noop_coroutine \u00b6 inline noop_coroutine_handle std :: experimental :: noop_coroutine () noexcept function operator!= \u00b6 inline bool std :: experimental :: operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator< \u00b6 inline bool std :: experimental :: operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator<= \u00b6 inline bool std :: experimental :: operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator== \u00b6 inline bool std :: experimental :: operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator> \u00b6 inline bool std :: experimental :: operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept function operator>= \u00b6 inline bool std :: experimental :: operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Namespace std::experimental"},{"location":"namespacestd_1_1experimental/#namespace-stdexperimental","text":"Class List > std > experimental","title":"Namespace std::experimental"},{"location":"namespacestd_1_1experimental/#classes","text":"Type Name class coroutine_handle <PromiseType> class coroutine_handle< noop_coroutine_promise > <> class coroutine_handle< void > <> struct coroutine_traits <typename ReturnType, Args> struct coroutine_traits< void, P... > <P> Allow void return of the coroutine. struct noop_coroutine_promise class suspend_always class suspend_never","title":"Classes"},{"location":"namespacestd_1_1experimental/#public-types","text":"Type Name typedef coroutine_handle < noop_coroutine_promise > noop_coroutine_handle","title":"Public Types"},{"location":"namespacestd_1_1experimental/#public-functions","text":"Type Name noop_coroutine_handle noop_coroutine () noexcept bool operator!= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator< (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator<= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator== (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator> (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept bool operator>= (const coroutine_handle < void > lhs, const coroutine_handle < void > rhs) noexcept","title":"Public Functions"},{"location":"namespacestd_1_1experimental/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"namespacestd_1_1experimental/#typedef-noop_coroutine_handle","text":"using std :: experimental :: noop_coroutine_handle = typedef coroutine_handle < noop_coroutine_promise > ;","title":"typedef noop_coroutine_handle"},{"location":"namespacestd_1_1experimental/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"namespacestd_1_1experimental/#function-noop_coroutine","text":"inline noop_coroutine_handle std :: experimental :: noop_coroutine () noexcept","title":"function noop_coroutine"},{"location":"namespacestd_1_1experimental/#function-operator","text":"inline bool std :: experimental :: operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator!="},{"location":"namespacestd_1_1experimental/#function-operator_1","text":"inline bool std :: experimental :: operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator&lt;"},{"location":"namespacestd_1_1experimental/#function-operator_2","text":"inline bool std :: experimental :: operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator&lt;="},{"location":"namespacestd_1_1experimental/#function-operator_3","text":"inline bool std :: experimental :: operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator=="},{"location":"namespacestd_1_1experimental/#function-operator_4","text":"inline bool std :: experimental :: operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept","title":"function operator&gt;"},{"location":"namespacestd_1_1experimental/#function-operator_5","text":"inline bool std :: experimental :: operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"function operator&gt;="},{"location":"net_8h/","text":"File net.h \u00b6 File List > coroutine > net.h Go to the source code of this file. Async I/O operation support with system socket functions. More... #include <coroutine/return.h> #include <gsl/gsl> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle. Macros \u00b6 Type Name define COROUTINE_NET_IO_H Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 Macro Definition Documentation \u00b6 define COROUTINE_NET_IO_H \u00b6 #define COROUTINE_NET_IO_H The documentation for this class was generated from the following file interface/coroutine/net.h","title":"File net.h"},{"location":"net_8h/#file-neth","text":"File List > coroutine > net.h Go to the source code of this file. Async I/O operation support with system socket functions. More... #include <coroutine/return.h> #include <gsl/gsl>","title":"File net.h"},{"location":"net_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"net_8h/#classes","text":"Type Name class io_recv Awaitable type to perform recv I/O request. class io_recv_from Awaitable type to perform recvfrom I/O request. class io_send Awaitable type to perform send I/O request. class io_send_to Awaitable type to perform sendto I/O request. class io_work_t A struct to describe \"1 I/O request\" to system API. When I/O request is submitted, an I/O task becomes 1 coroutine handle.","title":"Classes"},{"location":"net_8h/#macros","text":"Type Name define COROUTINE_NET_IO_H","title":"Macros"},{"location":"net_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0","title":"Detailed Description"},{"location":"net_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"net_8h/#define-coroutine_net_io_h","text":"#define COROUTINE_NET_IO_H The documentation for this class was generated from the following file interface/coroutine/net.h","title":"define COROUTINE_NET_IO_H"},{"location":"net_8h_source/","text":"File net.h \u00b6 File List > coroutine > net.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_NET_IO_H #define COROUTINE_NET_IO_H #include <coroutine/return.h> #include <gsl/gsl> #if __has_include(<WinSock2.h>) // use winsock #include <WS2tcpip.h> #include <WinSock2.h> #include <ws2def.h> static constexpr bool is_winsock = true ; static constexpr bool is_netinet = false ; using io_control_block = OVERLAPPED ; #elif __has_include(<netinet/in.h>) // use netinet #include <fcntl.h> #include <netdb.h> #include <netinet/in.h> #include <netinet/tcp.h> #include <sys/socket.h> #include <unistd.h> static constexpr bool is_winsock = false ; static constexpr bool is_netinet = true ; struct io_control_block { uint64_t internal ; // uint32_t errc, int32_t flag uint64_t internal_high ; // int64_t len, socklen_t addrlen union { struct { int32_t offset ; int32_t offset_high ; }; void * ptr ; // sockaddr* addr; }; int64_t handle ; // int64_t sd; }; #endif // winsock || netinet namespace coro { using namespace std ; using namespace std :: experimental ; using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); class io_work_t : public io_control_block { public : coroutine_handle < void > task {}; io_buffer_t buffer {}; protected : bool ready () const noexcept ; public : uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 56 ); class io_send_to final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); class io_recv_from final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); class io_send final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); class io_recv final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_send_to & ; auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_send_to & ; auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_recv_from & ; auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_recv_from & ; auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & ; auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & ; #if defined(__APPLE__) || defined(__UNIX__) || defined(__linux__) void poll_net_tasks ( uint64_t nano ) noexcept ( false ); #endif uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept ; uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept ; uint32_t get_name ( const sockaddr_in & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; uint32_t get_name ( const sockaddr_in6 & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; } // namespace coro #endif // COROUTINE_NET_IO_H","title":"File net.h"},{"location":"net_8h_source/#file-neth","text":"File List > coroutine > net.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_NET_IO_H #define COROUTINE_NET_IO_H #include <coroutine/return.h> #include <gsl/gsl> #if __has_include(<WinSock2.h>) // use winsock #include <WS2tcpip.h> #include <WinSock2.h> #include <ws2def.h> static constexpr bool is_winsock = true ; static constexpr bool is_netinet = false ; using io_control_block = OVERLAPPED ; #elif __has_include(<netinet/in.h>) // use netinet #include <fcntl.h> #include <netdb.h> #include <netinet/in.h> #include <netinet/tcp.h> #include <sys/socket.h> #include <unistd.h> static constexpr bool is_winsock = false ; static constexpr bool is_netinet = true ; struct io_control_block { uint64_t internal ; // uint32_t errc, int32_t flag uint64_t internal_high ; // int64_t len, socklen_t addrlen union { struct { int32_t offset ; int32_t offset_high ; }; void * ptr ; // sockaddr* addr; }; int64_t handle ; // int64_t sd; }; #endif // winsock || netinet namespace coro { using namespace std ; using namespace std :: experimental ; using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); class io_work_t : public io_control_block { public : coroutine_handle < void > task {}; io_buffer_t buffer {}; protected : bool ready () const noexcept ; public : uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 56 ); class io_send_to final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); class io_recv_from final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); class io_send final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); class io_recv final : public io_work_t { private : void suspend ( coroutine_handle < void > t ) noexcept ( false ); int64_t resume () noexcept ; public : bool await_ready () const noexcept { return this -> ready (); } void await_suspend ( coroutine_handle < void > t ) noexcept ( false ) { return this -> suspend ( t ); } int64_t await_resume () noexcept { return this -> resume (); } }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); auto send_to ( uint64_t sd , const sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_send_to & ; auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_send_to & ; auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_recv_from & ; auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , io_work_t & work ) noexcept ( false ) -> io_recv_from & ; auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & ; auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_recv & ; #if defined(__APPLE__) || defined(__UNIX__) || defined(__linux__) void poll_net_tasks ( uint64_t nano ) noexcept ( false ); #endif uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept ; uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept ; uint32_t get_name ( const sockaddr_in & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; uint32_t get_name ( const sockaddr_in6 & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags = NI_NUMERICHOST | NI_NUMERICSERV ) noexcept ; } // namespace coro #endif // COROUTINE_NET_IO_H","title":"File net.h"},{"location":"pages/","text":"Related Pages \u00b6 Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"pages/#related-pages","text":"Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"pthread_8cpp/","text":"File pthread.cpp \u00b6 File List > modules > system > pthread.cpp Go to the source code of this file. #include <coroutine/pthread.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class section Standard lockable with win32 criticial section. The documentation for this class was generated from the following file modules/system/pthread.cpp","title":"File pthread.cpp"},{"location":"pthread_8cpp/#file-pthreadcpp","text":"File List > modules > system > pthread.cpp Go to the source code of this file. #include <coroutine/pthread.h>","title":"File pthread.cpp"},{"location":"pthread_8cpp/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"pthread_8cpp/#classes","text":"Type Name class section Standard lockable with win32 criticial section. The documentation for this class was generated from the following file modules/system/pthread.cpp","title":"Classes"},{"location":"pthread_8cpp_source/","text":"File pthread.cpp \u00b6 File List > modules > system > pthread.cpp Go to the documentation of this file. #include <coroutine/pthread.h> namespace coro { void * pthread_spawner_t :: pthread_resume ( void * ptr ) noexcept ( false ) { // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } void pthread_spawner_t :: resume_on_pthread ( coroutine_handle < void > rh ) // noexcept ( false ) { if ( auto ec = pthread_create ( this -> tid , this -> attr , // pthread_resume , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_joiner_t :: try_join () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; void * ptr {}; // we must acquire `tid` before the destruction if ( auto ec = pthread_join ( tid , & ptr )) { throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )) { frame . destroy (); } } pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_detacher_t :: try_detach () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; if ( auto ec = pthread_detach ( tid )) { throw system_error { ec , system_category (), \"pthread_join\" }; } } class section final { private : pthread_rwlock_t rwlock ; public : section () noexcept ( false ); ~ section () noexcept ; section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; bool try_lock () noexcept ; void lock () noexcept ( false ); void unlock () noexcept ( false ); }; section :: section () noexcept ( false ) : rwlock {} { if ( auto ec = pthread_rwlock_init ( & rwlock , nullptr )) throw system_error { ec , system_category (), \"pthread_rwlock_init\" }; } section ::~ section () noexcept { try { if ( auto ec = pthread_rwlock_destroy ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_destroy\" }; } catch ( const system_error & e ) { perror ( e . what ()); } catch (...) { perror ( \"Unknown exception in section dtor\" ); } } bool section :: try_lock () noexcept { auto ec = pthread_rwlock_trywrlock ( & rwlock ); return ec == 0 ; } void section :: lock () noexcept ( false ) { if ( auto ec = pthread_rwlock_wrlock ( & rwlock )) // EINVAL ? throw system_error { ec , system_category (), \"pthread_rwlock_wrlock\" }; } void section :: unlock () noexcept ( false ) { if ( auto ec = pthread_rwlock_unlock ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_unlock\" }; } } // namespace coro","title":"File pthread.cpp"},{"location":"pthread_8cpp_source/#file-pthreadcpp","text":"File List > modules > system > pthread.cpp Go to the documentation of this file. #include <coroutine/pthread.h> namespace coro { void * pthread_spawner_t :: pthread_resume ( void * ptr ) noexcept ( false ) { // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } void pthread_spawner_t :: resume_on_pthread ( coroutine_handle < void > rh ) // noexcept ( false ) { if ( auto ec = pthread_create ( this -> tid , this -> attr , // pthread_resume , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } pthread_joiner_t :: pthread_joiner_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_joiner_t :: try_join () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; void * ptr {}; // we must acquire `tid` before the destruction if ( auto ec = pthread_join ( tid , & ptr )) { throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )) { frame . destroy (); } } pthread_detacher_t :: pthread_detacher_t ( promise_type * p ) noexcept ( false ) : pthread_knower_t { p } { if ( p == nullptr ) throw invalid_argument { \"nullptr for promise_type*\" }; } void pthread_detacher_t :: try_detach () noexcept ( false ) { pthread_t tid = * this ; if ( tid == pthread_t {}) // spawned no threads. nothing to do return ; if ( auto ec = pthread_detach ( tid )) { throw system_error { ec , system_category (), \"pthread_join\" }; } } class section final { private : pthread_rwlock_t rwlock ; public : section () noexcept ( false ); ~ section () noexcept ; section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; bool try_lock () noexcept ; void lock () noexcept ( false ); void unlock () noexcept ( false ); }; section :: section () noexcept ( false ) : rwlock {} { if ( auto ec = pthread_rwlock_init ( & rwlock , nullptr )) throw system_error { ec , system_category (), \"pthread_rwlock_init\" }; } section ::~ section () noexcept { try { if ( auto ec = pthread_rwlock_destroy ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_destroy\" }; } catch ( const system_error & e ) { perror ( e . what ()); } catch (...) { perror ( \"Unknown exception in section dtor\" ); } } bool section :: try_lock () noexcept { auto ec = pthread_rwlock_trywrlock ( & rwlock ); return ec == 0 ; } void section :: lock () noexcept ( false ) { if ( auto ec = pthread_rwlock_wrlock ( & rwlock )) // EINVAL ? throw system_error { ec , system_category (), \"pthread_rwlock_wrlock\" }; } void section :: unlock () noexcept ( false ) { if ( auto ec = pthread_rwlock_unlock ( & rwlock )) throw system_error { ec , system_category (), \"pthread_rwlock_unlock\" }; } } // namespace coro","title":"File pthread.cpp"},{"location":"pthread_8h/","text":"File pthread.h \u00b6 File List > coroutine > pthread.h Go to the source code of this file. More... #include <pthread.h> #include <system_error> #include <coroutine/frame.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class pthread_detacher_t Special return type that wraps pthread_detach __ class promise_type class pthread_joiner_t Special return type that wraps pthread_join __ class promise_type class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it. Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"File pthread.h"},{"location":"pthread_8h/#file-pthreadh","text":"File List > coroutine > pthread.h Go to the source code of this file. More... #include <pthread.h> #include <system_error> #include <coroutine/frame.h>","title":"File pthread.h"},{"location":"pthread_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"pthread_8h/#classes","text":"Type Name class pthread_detacher_t Special return type that wraps pthread_detach __ class promise_type class pthread_joiner_t Special return type that wraps pthread_join __ class promise_type class pthread_knower_t A proxy to pthread_spawn_promise The type must ensure the promise contains a valid pthread_t when it is constructed. class pthread_spawn_promise allows pthread_attr_t* for co_await operator class pthread_spawner_t Creates a new POSIX Thread and resume the given coroutine handle on it.","title":"Classes"},{"location":"pthread_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/pthread.h","title":"Detailed Description"},{"location":"pthread_8h_source/","text":"File pthread.h \u00b6 File List > coroutine > pthread.h Go to the documentation of this file. #ifndef COROUTINE_PTHREAD_UTILITY_H #define COROUTINE_PTHREAD_UTILITY_H #if not __has_include(<pthread.h>) #error \"expect <pthread.h> for this file\" #endif #include <pthread.h> #include <system_error> #include <coroutine/frame.h> namespace coro { using namespace std ; using namespace std :: experimental ; class pthread_spawner_t { void resume_on_pthread ( coroutine_handle < void > coro ) noexcept ( false ); static void * pthread_resume ( void * ptr ) noexcept ( false ); public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return resume_on_pthread ( coro ); } public : pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr } { } ~ pthread_spawner_t () noexcept = default ; private : pthread_t * const tid ; const pthread_attr_t * const attr ; }; class pthread_spawn_promise { public : pthread_t tid {}; public : auto initial_suspend () noexcept { return suspend_never {}; } void unhandled_exception () noexcept ( false ) { throw ; } auto await_transform ( const pthread_attr_t * attr ) noexcept ( false ) { if ( tid ) // already created. throw logic_error { \"pthread's spawn must be used once\" }; // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; class pthread_knower_t { public : operator pthread_t () const noexcept { return promise -> tid ; } protected : explicit pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept : promise { _promise } { } protected : pthread_spawn_promise * promise ; }; class pthread_joiner_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : auto final_suspend () noexcept { return suspend_always {}; } void return_void () noexcept { // we already returns coroutine's frame. // so `co_return` can't have its operand } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : void try_join () noexcept ( false ); public : ~ pthread_joiner_t () noexcept ( false ) { this -> try_join (); } pthread_joiner_t ( promise_type * p ) noexcept ( false ); }; class pthread_detacher_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : // detacher doesn't care about the coroutine frame's life cycle // it does nothing after `co_return` auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : void try_detach () noexcept ( false ); public : ~ pthread_detacher_t () noexcept ( false ) { this -> try_detach (); } pthread_detacher_t ( promise_type * p ) noexcept ( false ); }; } // namespace coro #endif // COROUTINE_PTHREAD_UTILITY_H","title":"File pthread.h"},{"location":"pthread_8h_source/#file-pthreadh","text":"File List > coroutine > pthread.h Go to the documentation of this file. #ifndef COROUTINE_PTHREAD_UTILITY_H #define COROUTINE_PTHREAD_UTILITY_H #if not __has_include(<pthread.h>) #error \"expect <pthread.h> for this file\" #endif #include <pthread.h> #include <system_error> #include <coroutine/frame.h> namespace coro { using namespace std ; using namespace std :: experimental ; class pthread_spawner_t { void resume_on_pthread ( coroutine_handle < void > coro ) noexcept ( false ); static void * pthread_resume ( void * ptr ) noexcept ( false ); public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return resume_on_pthread ( coro ); } public : pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr } { } ~ pthread_spawner_t () noexcept = default ; private : pthread_t * const tid ; const pthread_attr_t * const attr ; }; class pthread_spawn_promise { public : pthread_t tid {}; public : auto initial_suspend () noexcept { return suspend_never {}; } void unhandled_exception () noexcept ( false ) { throw ; } auto await_transform ( const pthread_attr_t * attr ) noexcept ( false ) { if ( tid ) // already created. throw logic_error { \"pthread's spawn must be used once\" }; // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; class pthread_knower_t { public : operator pthread_t () const noexcept { return promise -> tid ; } protected : explicit pthread_knower_t ( pthread_spawn_promise * _promise ) noexcept : promise { _promise } { } protected : pthread_spawn_promise * promise ; }; class pthread_joiner_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : auto final_suspend () noexcept { return suspend_always {}; } void return_void () noexcept { // we already returns coroutine's frame. // so `co_return` can't have its operand } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : void try_join () noexcept ( false ); public : ~ pthread_joiner_t () noexcept ( false ) { this -> try_join (); } pthread_joiner_t ( promise_type * p ) noexcept ( false ); }; class pthread_detacher_t final : public pthread_knower_t { public : class promise_type final : public pthread_spawn_promise { public : // detacher doesn't care about the coroutine frame's life cycle // it does nothing after `co_return` auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { } auto get_return_object () noexcept -> promise_type * { return this ; } }; private : void try_detach () noexcept ( false ); public : ~ pthread_detacher_t () noexcept ( false ) { this -> try_detach (); } pthread_detacher_t ( promise_type * p ) noexcept ( false ); }; } // namespace coro #endif // COROUTINE_PTHREAD_UTILITY_H","title":"File pthread.h"},{"location":"resolver_8cpp/","text":"File resolver.cpp \u00b6 File List > modules > net > resolver.cpp Go to the source code of this file. #include <coroutine/net.h> #include <internal/yield.hpp> Namespaces \u00b6 Type Name namespace coro The documentation for this class was generated from the following file modules/net/resolver.cpp","title":"File resolver.cpp"},{"location":"resolver_8cpp/#file-resolvercpp","text":"File List > modules > net > resolver.cpp Go to the source code of this file. #include <coroutine/net.h> #include <internal/yield.hpp>","title":"File resolver.cpp"},{"location":"resolver_8cpp/#namespaces","text":"Type Name namespace coro The documentation for this class was generated from the following file modules/net/resolver.cpp","title":"Namespaces"},{"location":"resolver_8cpp_source/","text":"File resolver.cpp \u00b6 File List > modules > net > resolver.cpp Go to the documentation of this file. #include <coroutine/net.h> #include <internal/yield.hpp> using namespace std ; namespace coro { GSL_SUPPRESS ( type .1 ) uint32_t get_name ( const sockaddr_in & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } GSL_SUPPRESS ( type .1 ) uint32_t get_name ( const sockaddr_in6 & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in6 ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } auto get_address ( addrinfo * list ) noexcept -> enumerable < sockaddr *> { auto on_return = gsl :: finally ([ list ]() noexcept { // RAII clean up for the assigned addrinfo :: freeaddrinfo ( list ); }); for ( addrinfo * it = list ; it != nullptr ; it = it -> ai_next ) { co_yield it -> ai_addr ; } } auto get_address ( addrinfo * list , sockaddr_in addr ) noexcept -> enumerable < sockaddr_in > { for ( sockaddr * item : get_address ( list )) { const auto * ptr = reinterpret_cast < sockaddr_in *> ( item ); addr = * ptr ; co_yield addr ; } } auto get_address ( addrinfo * list , sockaddr_in6 addr ) noexcept -> enumerable < sockaddr_in6 > { for ( sockaddr * item : get_address ( list )) { const auto * ptr = reinterpret_cast < sockaddr_in6 *> ( item ); addr = * ptr ; co_yield addr ; } } uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( host , serv , // & hint , & list )) return ec ; // std::system_error{ec, system_category(), ::gai_strerror(ec)}; auto i = 0u ; for ( auto addr : get_address ( list , sockaddr_in {})) { output [ i ++ ] = addr ; if ( i == output . size ()) break ; } return 0 ; } uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( host , serv , // & hint , & list )) return ec ; auto i = 0u ; for ( auto addr : get_address ( list , sockaddr_in6 {})) { output [ i ++ ] = addr ; if ( i == output . size ()) break ; } return 0 ; } } // namespace coro","title":"File resolver.cpp"},{"location":"resolver_8cpp_source/#file-resolvercpp","text":"File List > modules > net > resolver.cpp Go to the documentation of this file. #include <coroutine/net.h> #include <internal/yield.hpp> using namespace std ; namespace coro { GSL_SUPPRESS ( type .1 ) uint32_t get_name ( const sockaddr_in & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } GSL_SUPPRESS ( type .1 ) uint32_t get_name ( const sockaddr_in6 & addr , // gsl :: zstring < NI_MAXHOST > name , gsl :: zstring < NI_MAXSERV > serv , int32_t flags ) noexcept { const auto * ptr = reinterpret_cast < const sockaddr *> ( addressof ( addr )); return :: getnameinfo ( ptr , sizeof ( sockaddr_in6 ), // name , NI_MAXHOST , // serv , ( serv == nullptr ) ? 0 : NI_MAXSERV , // flags ); } auto get_address ( addrinfo * list ) noexcept -> enumerable < sockaddr *> { auto on_return = gsl :: finally ([ list ]() noexcept { // RAII clean up for the assigned addrinfo :: freeaddrinfo ( list ); }); for ( addrinfo * it = list ; it != nullptr ; it = it -> ai_next ) { co_yield it -> ai_addr ; } } auto get_address ( addrinfo * list , sockaddr_in addr ) noexcept -> enumerable < sockaddr_in > { for ( sockaddr * item : get_address ( list )) { const auto * ptr = reinterpret_cast < sockaddr_in *> ( item ); addr = * ptr ; co_yield addr ; } } auto get_address ( addrinfo * list , sockaddr_in6 addr ) noexcept -> enumerable < sockaddr_in6 > { for ( sockaddr * item : get_address ( list )) { const auto * ptr = reinterpret_cast < sockaddr_in6 *> ( item ); addr = * ptr ; co_yield addr ; } } uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in > output ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( host , serv , // & hint , & list )) return ec ; // std::system_error{ec, system_category(), ::gai_strerror(ec)}; auto i = 0u ; for ( auto addr : get_address ( list , sockaddr_in {})) { output [ i ++ ] = addr ; if ( i == output . size ()) break ; } return 0 ; } uint32_t get_address ( const addrinfo & hint , // gsl :: czstring <> host , gsl :: czstring <> serv , gsl :: span < sockaddr_in6 > output ) noexcept { addrinfo * list = nullptr ; if ( const auto ec = :: getaddrinfo ( host , serv , // & hint , & list )) return ec ; auto i = 0u ; for ( auto addr : get_address ( list , sockaddr_in6 {})) { output [ i ++ ] = addr ; if ( i == output . size ()) break ; } return 0 ; } } // namespace coro","title":"File resolver.cpp"},{"location":"return_8h/","text":"File return.h \u00b6 File List > coroutine > return.h Go to the source code of this file. Utility to define return types for coroutine. More... #include <type_traits> #include <coroutine/frame.h> Namespaces \u00b6 Type Name namespace coro namespace std namespace experimental Classes \u00b6 Type Name class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __ class promise_aa class promise_an class promise_na class promise_nn struct coroutine_traits< void, P... > <P> Allow void return of the coroutine. struct promise_type Macros \u00b6 Type Name define COROUTINE_PROMISE_AND_RETURN_TYPES_H Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/ Macro Definition Documentation \u00b6 define COROUTINE_PROMISE_AND_RETURN_TYPES_H \u00b6 #define COROUTINE_PROMISE_AND_RETURN_TYPES_H The documentation for this class was generated from the following file interface/coroutine/return.h","title":"File return.h"},{"location":"return_8h/#file-returnh","text":"File List > coroutine > return.h Go to the source code of this file. Utility to define return types for coroutine. More... #include <type_traits> #include <coroutine/frame.h>","title":"File return.h"},{"location":"return_8h/#namespaces","text":"Type Name namespace coro namespace std namespace experimental","title":"Namespaces"},{"location":"return_8h/#classes","text":"Type Name class frame_t A type to acquire coroutine_handle<void> from anonymous coroutine's return. class promise_type Acquire coroutine_handle<void> from current object and expose it through get_return_object __ class promise_aa class promise_an class promise_na class promise_nn struct coroutine_traits< void, P... > <P> Allow void return of the coroutine. struct promise_type","title":"Classes"},{"location":"return_8h/#macros","text":"Type Name define COROUTINE_PROMISE_AND_RETURN_TYPES_H","title":"Macros"},{"location":"return_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/","title":"Detailed Description"},{"location":"return_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"return_8h/#define-coroutine_promise_and_return_types_h","text":"#define COROUTINE_PROMISE_AND_RETURN_TYPES_H The documentation for this class was generated from the following file interface/coroutine/return.h","title":"define COROUTINE_PROMISE_AND_RETURN_TYPES_H"},{"location":"return_8h_source/","text":"File return.h \u00b6 File List > coroutine > return.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_PROMISE_AND_RETURN_TYPES_H #define COROUTINE_PROMISE_AND_RETURN_TYPES_H #include <type_traits> #include <coroutine/frame.h> namespace coro { #if __has_include(<coroutine>) // C++ 20 using namespace std ; #elif __has_include(<experimental/coroutine>) // C++ 17 using namespace std ; using namespace std :: experimental ; #endif class promise_nn { public : suspend_never initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } }; class promise_na { public : suspend_never initial_suspend () noexcept { return {}; } suspend_always final_suspend () noexcept { return {}; } }; class promise_an { public : suspend_always initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } }; class promise_aa { public : suspend_always initial_suspend () noexcept { return {}; } suspend_always final_suspend () noexcept { return {}; } }; class frame_t final : public coroutine_handle < void > { public : class promise_type final : public promise_na { public : void unhandled_exception () noexcept ( false ) { throw ; } void return_void () noexcept { } frame_t get_return_object () noexcept { frame_t frame {}; coroutine_handle < void >& ref = frame ; ref = coroutine_handle < promise_type >:: from_promise ( * this ); return frame ; } }; }; #if defined(__cpp_concepts) template < typename T , typename R = void > concept awaitable = requires ( T a , coroutine_handle < void > h ) { { a . await_ready () } -> bool ; { a . await_suspend ( h ) } -> void ; { a . await_resume () } -> R ; }; template < typename P > concept promise_requirement_basic = requires ( P p ) { { p . initial_suspend () } -> awaitable ; { p . final_suspend () } -> awaitable ; { p . unhandled_exception () } -> void ; }; #endif } // namespace coro namespace std { namespace experimental { template < typename ... P > struct coroutine_traits < void , P ... > { struct promise_type final { suspend_never initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } void unhandled_exception () noexcept ( false ) { throw ; } void return_void () noexcept { } void get_return_object () noexcept { } }; }; } // namespace experimental template < typename Ret , typename ... Param > using coroutine_traits = std :: experimental :: coroutine_traits < Ret , Param ... > ; } // namespace std #endif // COROUTINE_PROMISE_AND_RETURN_TYPES_H","title":"File return.h"},{"location":"return_8h_source/#file-returnh","text":"File List > coroutine > return.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_PROMISE_AND_RETURN_TYPES_H #define COROUTINE_PROMISE_AND_RETURN_TYPES_H #include <type_traits> #include <coroutine/frame.h> namespace coro { #if __has_include(<coroutine>) // C++ 20 using namespace std ; #elif __has_include(<experimental/coroutine>) // C++ 17 using namespace std ; using namespace std :: experimental ; #endif class promise_nn { public : suspend_never initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } }; class promise_na { public : suspend_never initial_suspend () noexcept { return {}; } suspend_always final_suspend () noexcept { return {}; } }; class promise_an { public : suspend_always initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } }; class promise_aa { public : suspend_always initial_suspend () noexcept { return {}; } suspend_always final_suspend () noexcept { return {}; } }; class frame_t final : public coroutine_handle < void > { public : class promise_type final : public promise_na { public : void unhandled_exception () noexcept ( false ) { throw ; } void return_void () noexcept { } frame_t get_return_object () noexcept { frame_t frame {}; coroutine_handle < void >& ref = frame ; ref = coroutine_handle < promise_type >:: from_promise ( * this ); return frame ; } }; }; #if defined(__cpp_concepts) template < typename T , typename R = void > concept awaitable = requires ( T a , coroutine_handle < void > h ) { { a . await_ready () } -> bool ; { a . await_suspend ( h ) } -> void ; { a . await_resume () } -> R ; }; template < typename P > concept promise_requirement_basic = requires ( P p ) { { p . initial_suspend () } -> awaitable ; { p . final_suspend () } -> awaitable ; { p . unhandled_exception () } -> void ; }; #endif } // namespace coro namespace std { namespace experimental { template < typename ... P > struct coroutine_traits < void , P ... > { struct promise_type final { suspend_never initial_suspend () noexcept { return {}; } suspend_never final_suspend () noexcept { return {}; } void unhandled_exception () noexcept ( false ) { throw ; } void return_void () noexcept { } void get_return_object () noexcept { } }; }; } // namespace experimental template < typename Ret , typename ... Param > using coroutine_traits = std :: experimental :: coroutine_traits < Ret , Param ... > ; } // namespace std #endif // COROUTINE_PROMISE_AND_RETURN_TYPES_H","title":"File return.h"},{"location":"structclang__frame__prefix/","text":"Struct clang_frame_prefix \u00b6 Class List > clang_frame_prefix #include <frame.h> Public Attributes \u00b6 Type Name procedure_t factivate procedure_t fdestroy Public Attributes Documentation \u00b6 variable factivate \u00b6 procedure_t clang_frame_prefix :: factivate ; variable fdestroy \u00b6 procedure_t clang_frame_prefix :: fdestroy ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct clang\\_frame\\_prefix"},{"location":"structclang__frame__prefix/#struct-clang_frame_prefix","text":"Class List > clang_frame_prefix #include <frame.h>","title":"Struct clang_frame_prefix"},{"location":"structclang__frame__prefix/#public-attributes","text":"Type Name procedure_t factivate procedure_t fdestroy","title":"Public Attributes"},{"location":"structclang__frame__prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structclang__frame__prefix/#variable-factivate","text":"procedure_t clang_frame_prefix :: factivate ;","title":"variable factivate"},{"location":"structclang__frame__prefix/#variable-fdestroy","text":"procedure_t clang_frame_prefix :: fdestroy ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable fdestroy"},{"location":"structcoro_1_1bypass__mutex/","text":"Struct coro::bypass_mutex \u00b6 Class List > coro > bypass_mutex Lockable without lock operation. More... #include <channel.hpp> Public Functions \u00b6 Type Name constexpr void lock () noexcept Do nothing since this is 'bypass' lock. constexpr bool try_lock () noexcept constexpr void unlock () noexcept Do nothing since it didn't locked something. Detailed Description \u00b6 Note: channel uses lockable whenever read/write is requested. If its object is used without race condition, such lock operation can be skipped. Use this bypass lockable for such cases. Public Functions Documentation \u00b6 function lock \u00b6 inline constexpr void coro :: bypass_mutex :: lock () noexcept function try_lock \u00b6 inline constexpr bool coro :: bypass_mutex :: try_lock () noexcept function unlock \u00b6 inline constexpr void coro :: bypass_mutex :: unlock () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"Struct coro::bypass\\_mutex"},{"location":"structcoro_1_1bypass__mutex/#struct-corobypass_mutex","text":"Class List > coro > bypass_mutex Lockable without lock operation. More... #include <channel.hpp>","title":"Struct coro::bypass_mutex"},{"location":"structcoro_1_1bypass__mutex/#public-functions","text":"Type Name constexpr void lock () noexcept Do nothing since this is 'bypass' lock. constexpr bool try_lock () noexcept constexpr void unlock () noexcept Do nothing since it didn't locked something.","title":"Public Functions"},{"location":"structcoro_1_1bypass__mutex/#detailed-description","text":"Note: channel uses lockable whenever read/write is requested. If its object is used without race condition, such lock operation can be skipped. Use this bypass lockable for such cases.","title":"Detailed Description"},{"location":"structcoro_1_1bypass__mutex/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structcoro_1_1bypass__mutex/#function-lock","text":"inline constexpr void coro :: bypass_mutex :: lock () noexcept","title":"function lock"},{"location":"structcoro_1_1bypass__mutex/#function-try_lock","text":"inline constexpr bool coro :: bypass_mutex :: try_lock () noexcept","title":"function try_lock"},{"location":"structcoro_1_1bypass__mutex/#function-unlock","text":"inline constexpr void coro :: bypass_mutex :: unlock () noexcept The documentation for this class was generated from the following file interface/coroutine/channel.hpp","title":"function unlock"},{"location":"structgcc__frame__prefix/","text":"Struct gcc_frame_prefix \u00b6 Class List > gcc_frame_prefix #include <frame.h> Public Attributes \u00b6 Type Name void * _unknown1 void * _unknown2 Public Attributes Documentation \u00b6 variable _unknown1 \u00b6 void * gcc_frame_prefix :: _unknown1 ; variable _unknown2 \u00b6 void * gcc_frame_prefix :: _unknown2 ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct gcc\\_frame\\_prefix"},{"location":"structgcc__frame__prefix/#struct-gcc_frame_prefix","text":"Class List > gcc_frame_prefix #include <frame.h>","title":"Struct gcc_frame_prefix"},{"location":"structgcc__frame__prefix/#public-attributes","text":"Type Name void * _unknown1 void * _unknown2","title":"Public Attributes"},{"location":"structgcc__frame__prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structgcc__frame__prefix/#variable-_unknown1","text":"void * gcc_frame_prefix :: _unknown1 ;","title":"variable _unknown1"},{"location":"structgcc__frame__prefix/#variable-_unknown2","text":"void * gcc_frame_prefix :: _unknown2 ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable _unknown2"},{"location":"structmsvc__frame__prefix/","text":"Struct msvc_frame_prefix \u00b6 Class List > msvc_frame_prefix #include <frame.h> Public Attributes \u00b6 Type Name procedure_t factivate uint16_t flag uint16_t index Public Attributes Documentation \u00b6 variable factivate \u00b6 procedure_t msvc_frame_prefix :: factivate ; variable flag \u00b6 uint16_t msvc_frame_prefix :: flag ; variable index \u00b6 uint16_t msvc_frame_prefix :: index ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct msvc\\_frame\\_prefix"},{"location":"structmsvc__frame__prefix/#struct-msvc_frame_prefix","text":"Class List > msvc_frame_prefix #include <frame.h>","title":"Struct msvc_frame_prefix"},{"location":"structmsvc__frame__prefix/#public-attributes","text":"Type Name procedure_t factivate uint16_t flag uint16_t index","title":"Public Attributes"},{"location":"structmsvc__frame__prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structmsvc__frame__prefix/#variable-factivate","text":"procedure_t msvc_frame_prefix :: factivate ;","title":"variable factivate"},{"location":"structmsvc__frame__prefix/#variable-flag","text":"uint16_t msvc_frame_prefix :: flag ;","title":"variable flag"},{"location":"structmsvc__frame__prefix/#variable-index","text":"uint16_t msvc_frame_prefix :: index ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable index"},{"location":"structstd_1_1experimental_1_1coroutine__traits/","text":"Struct std::experimental::coroutine_traits \u00b6 template <typename ReturnType typename ReturnType, typename... Args> Class List > std > experimental > coroutine_traits #include <frame.h> Public Types \u00b6 Type Name typedef typename ReturnType::promise_type promise_type Public Types Documentation \u00b6 typedef promise_type \u00b6 using std :: experimental :: coroutine_traits < ReturnType , Args >:: promise_type = typename ReturnType :: promise_type ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct std::experimental::coroutine\\_traits"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#struct-stdexperimentalcoroutine_traits","text":"template <typename ReturnType typename ReturnType, typename... Args> Class List > std > experimental > coroutine_traits #include <frame.h>","title":"Struct std::experimental::coroutine_traits"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#public-types","text":"Type Name typedef typename ReturnType::promise_type promise_type","title":"Public Types"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"structstd_1_1experimental_1_1coroutine__traits/#typedef-promise_type","text":"using std :: experimental :: coroutine_traits < ReturnType , Args >:: promise_type = typename ReturnType :: promise_type ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"typedef promise_type"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4/","text":"Struct std::experimental::coroutine_traits< void, P... > \u00b6 template <typename... P> Class List > std > experimental > coroutine_traits< void, P... > Allow void return of the coroutine. More... #include <return.h> Classes \u00b6 Type Name struct promise_type Detailed Description \u00b6 Template parameters: P input parameter types of the coroutine's signature The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Struct std::experimental::coroutine\\_traits&lt; void, P... &gt;"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4/#struct-stdexperimentalcoroutine_traits-void-p","text":"template <typename... P> Class List > std > experimental > coroutine_traits< void, P... > Allow void return of the coroutine. More... #include <return.h>","title":"Struct std::experimental::coroutine_traits&lt; void, P... &gt;"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4/#classes","text":"Type Name struct promise_type","title":"Classes"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4/#detailed-description","text":"Template parameters: P input parameter types of the coroutine's signature The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Detailed Description"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4_1_1promise__type/","text":"Struct std::experimental::coroutine_traits< void, P... >::promise_type \u00b6 Class List > std > experimental > coroutine_traits< void, P... > > promise_type #include <return.h> Public Functions \u00b6 Type Name suspend_never final_suspend () noexcept void get_return_object () noexcept Since this is template specialization for void , the return type is fixed to void __ suspend_never initial_suspend () noexcept void return_void () noexcept Since this is template specialization for void , the return type is fixed to void __ void unhandled_exception () noexcept Public Functions Documentation \u00b6 function final_suspend \u00b6 inline suspend_never std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: final_suspend () noexcept function get_return_object \u00b6 inline void std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: get_return_object () noexcept function initial_suspend \u00b6 inline suspend_never std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: initial_suspend () noexcept function return_void \u00b6 inline void std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: return_void () noexcept function unhandled_exception \u00b6 inline void std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"Struct std::experimental::coroutine\\_traits&lt; void, P... &gt;::promise\\_type"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4_1_1promise__type/#struct-stdexperimentalcoroutine_traits-void-p-promise_type","text":"Class List > std > experimental > coroutine_traits< void, P... > > promise_type #include <return.h>","title":"Struct std::experimental::coroutine_traits&lt; void, P... &gt;::promise_type"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4_1_1promise__type/#public-functions","text":"Type Name suspend_never final_suspend () noexcept void get_return_object () noexcept Since this is template specialization for void , the return type is fixed to void __ suspend_never initial_suspend () noexcept void return_void () noexcept Since this is template specialization for void , the return type is fixed to void __ void unhandled_exception () noexcept","title":"Public Functions"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4_1_1promise__type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4_1_1promise__type/#function-final_suspend","text":"inline suspend_never std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: final_suspend () noexcept","title":"function final_suspend"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4_1_1promise__type/#function-get_return_object","text":"inline void std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: get_return_object () noexcept","title":"function get_return_object"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4_1_1promise__type/#function-initial_suspend","text":"inline suspend_never std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: initial_suspend () noexcept","title":"function initial_suspend"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4_1_1promise__type/#function-return_void","text":"inline void std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: return_void () noexcept","title":"function return_void"},{"location":"structstd_1_1experimental_1_1coroutine__traits_3_01void_00_01P_8_8_8_01_4_1_1promise__type/#function-unhandled_exception","text":"inline void std :: experimental :: coroutine_traits < void , P ... >:: promise_type :: unhandled_exception () noexcept The documentation for this class was generated from the following file interface/coroutine/return.h","title":"function unhandled_exception"},{"location":"structstd_1_1experimental_1_1noop__coroutine__promise/","text":"Struct std::experimental::noop_coroutine_promise \u00b6 Class List > std > experimental > noop_coroutine_promise #include <frame.h> The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct std::experimental::noop\\_coroutine\\_promise"},{"location":"structstd_1_1experimental_1_1noop__coroutine__promise/#struct-stdexperimentalnoop_coroutine_promise","text":"Class List > std > experimental > noop_coroutine_promise #include <frame.h> The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Struct std::experimental::noop_coroutine_promise"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/","text":"Union std::experimental::coroutine_handle< void >::prefix_t \u00b6 Class List > std > experimental > coroutine_handle< void > > prefix_t #include <frame.h> Public Attributes \u00b6 Type Name clang_frame_prefix * c gcc_frame_prefix * g msvc_frame_prefix * m void * v = {} Public Attributes Documentation \u00b6 variable c \u00b6 clang_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: c ; variable g \u00b6 gcc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: g ; variable m \u00b6 msvc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: m ; variable v \u00b6 void * std :: experimental :: coroutine_handle < void >:: prefix_t :: v ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"Union std::experimental::coroutine\\_handle&lt; void &gt;::prefix\\_t"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#union-stdexperimentalcoroutine_handle-void-prefix_t","text":"Class List > std > experimental > coroutine_handle< void > > prefix_t #include <frame.h>","title":"Union std::experimental::coroutine_handle&lt; void &gt;::prefix_t"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#public-attributes","text":"Type Name clang_frame_prefix * c gcc_frame_prefix * g msvc_frame_prefix * m void * v = {}","title":"Public Attributes"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-c","text":"clang_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: c ;","title":"variable c"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-g","text":"gcc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: g ;","title":"variable g"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-m","text":"msvc_frame_prefix * std :: experimental :: coroutine_handle < void >:: prefix_t :: m ;","title":"variable m"},{"location":"unionstd_1_1experimental_1_1coroutine__handle_3_01void_01_4_1_1prefix__t/#variable-v","text":"void * std :: experimental :: coroutine_handle < void >:: prefix_t :: v ; The documentation for this class was generated from the following file interface/coroutine/frame.h","title":"variable v"},{"location":"unix_8h/","text":"File unix.h \u00b6 File List > coroutine > unix.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/event.h> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class kqueue_owner RAII wrapping for kqueue file descriptor. Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/unix.h","title":"File unix.h"},{"location":"unix_8h/#file-unixh","text":"File List > coroutine > unix.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/event.h>","title":"File unix.h"},{"location":"unix_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"unix_8h/#classes","text":"Type Name class kqueue_owner RAII wrapping for kqueue file descriptor.","title":"Classes"},{"location":"unix_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/coroutine/unix.h","title":"Detailed Description"},{"location":"unix_8h_source/","text":"File unix.h \u00b6 File List > coroutine > unix.h Go to the documentation of this file. #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if not(defined(unix) or defined(__APPLE__) or defined(__FreeBSD__)) #error \"expect UNIX platform for this file\" #endif #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/event.h> // for BSD kqueue namespace coro { using namespace std ; using namespace std :: experimental ; class kqueue_owner final { int64_t kqfd ; public : kqueue_owner () noexcept ( false ); ~ kqueue_owner () noexcept ; kqueue_owner ( const kqueue_owner & ) = delete ; kqueue_owner ( kqueue_owner && ) = delete ; kqueue_owner & operator = ( const kqueue_owner & ) = delete ; kqueue_owner & operator = ( kqueue_owner && ) = delete ; public : void change ( kevent64_s & req ) noexcept ( false ); ptrdiff_t events ( const timespec & wait_time , gsl :: span < kevent64_s > list ) noexcept ( false ); public : [[ nodiscard ]] auto submit ( kevent64_s & req ) noexcept { class awaiter final : public suspend_always { kqueue_owner & kq ; kevent64_s & req ; public : constexpr awaiter ( kqueue_owner & _kq , kevent64_s & _req ) : kq { _kq }, req { _req } { } public : void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( req . udata == 0 ) req . udata = reinterpret_cast < uint64_t > ( coro . address ()); return kq . change ( req ); } }; return awaiter { * this , req }; } }; } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File unix.h"},{"location":"unix_8h_source/#file-unixh","text":"File List > coroutine > unix.h Go to the documentation of this file. #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if not(defined(unix) or defined(__APPLE__) or defined(__FreeBSD__)) #error \"expect UNIX platform for this file\" #endif #include <coroutine/frame.h> #include <gsl/gsl> #include <sys/event.h> // for BSD kqueue namespace coro { using namespace std ; using namespace std :: experimental ; class kqueue_owner final { int64_t kqfd ; public : kqueue_owner () noexcept ( false ); ~ kqueue_owner () noexcept ; kqueue_owner ( const kqueue_owner & ) = delete ; kqueue_owner ( kqueue_owner && ) = delete ; kqueue_owner & operator = ( const kqueue_owner & ) = delete ; kqueue_owner & operator = ( kqueue_owner && ) = delete ; public : void change ( kevent64_s & req ) noexcept ( false ); ptrdiff_t events ( const timespec & wait_time , gsl :: span < kevent64_s > list ) noexcept ( false ); public : [[ nodiscard ]] auto submit ( kevent64_s & req ) noexcept { class awaiter final : public suspend_always { kqueue_owner & kq ; kevent64_s & req ; public : constexpr awaiter ( kqueue_owner & _kq , kevent64_s & _req ) : kq { _kq }, req { _req } { } public : void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( req . udata == 0 ) req . udata = reinterpret_cast < uint64_t > ( coro . address ()); return kq . change ( req ); } }; return awaiter { * this , req }; } }; } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File unix.h"},{"location":"variables/","text":"Variables \u00b6 a \u00b6 aligned_size_v ( frame.h )","title":"Variables"},{"location":"variables/#variables","text":"","title":"Variables"},{"location":"variables/#a","text":"aligned_size_v ( frame.h )","title":"a"},{"location":"windows_8cpp/","text":"File windows.cpp \u00b6 File List > modules > system > windows.cpp Go to the source code of this file. #include <Windows.h> #include <TlHelp32.h> #include <threadpoolapiset.h> #include <synchapi.h> #include <coroutine/windows.h> #include <gsl/gsl> #include <cassert> #include <system_error> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class section Standard lockable with win32 criticial section. The documentation for this class was generated from the following file modules/system/windows.cpp","title":"File windows.cpp"},{"location":"windows_8cpp/#file-windowscpp","text":"File List > modules > system > windows.cpp Go to the source code of this file. #include <Windows.h> #include <TlHelp32.h> #include <threadpoolapiset.h> #include <synchapi.h> #include <coroutine/windows.h> #include <gsl/gsl> #include <cassert> #include <system_error>","title":"File windows.cpp"},{"location":"windows_8cpp/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"windows_8cpp/#classes","text":"Type Name class section Standard lockable with win32 criticial section. The documentation for this class was generated from the following file modules/system/windows.cpp","title":"Classes"},{"location":"windows_8cpp_source/","text":"File windows.cpp \u00b6 File List > modules > system > windows.cpp Go to the documentation of this file. // clang-format off #include <Windows.h> #include <TlHelp32.h> #include <threadpoolapiset.h> #include <synchapi.h> // Windows Concurrency Runtime's event is not alertible. //#include <concrt.h> // clang-format on #include <coroutine/windows.h> #include <gsl/gsl> #include <cassert> #include <system_error> using namespace std ; using namespace gsl ; namespace coro { static_assert ( is_move_assignable_v < set_or_cancel > == false ); static_assert ( is_move_constructible_v < set_or_cancel > == false ); static_assert ( is_copy_assignable_v < set_or_cancel > == false ); static_assert ( is_copy_constructible_v < set_or_cancel > == false ); GSL_SUPPRESS ( con .4 ) void __stdcall wait_event_on_thread_pool ( PVOID ctx , BOOLEAN timedout ) { UNREFERENCED_PARAMETER ( timedout ); auto coro = coroutine_handle < void >:: from_address ( ctx ); assert ( coro . done () == false ); coro . resume (); } set_or_cancel :: set_or_cancel ( HANDLE target_event ) noexcept ( false ) : hobject { target_event } { // wait object is used as a storage for the event handle // until it is going to suspend } set_or_cancel ::~ set_or_cancel () noexcept { UnregisterWait ( hobject ); } auto set_or_cancel :: unregister () noexcept -> uint32_t { UnregisterWait ( hobject ); const auto ec = GetLastError (); if ( ec == ERROR_IO_PENDING ) { // this is expected since we are using INFINITE timeout return NO_ERROR ; } return ec ; } void set_or_cancel :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // since this point, wo becomes a handle for the request // this is one-shot event. so use infinite timeout if ( RegisterWaitForSingleObject ( addressof ( hobject ), hobject , wait_event_on_thread_pool , coro . address (), INFINITE , WT_EXECUTEONLYONCE ) == FALSE ) { throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"RegisterWaitForSingleObject\" }; } } // auto get_threads_of(DWORD pid) noexcept(false) -> enumerable<DWORD> { // // for current process // auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // if (snapshot == INVALID_HANDLE_VALUE) // co_return; // auto on_return = gsl::finally([=]() noexcept { CloseHandle(snapshot); }); // THREADENTRY32 entry{}; // entry.dwSize = sizeof(THREADENTRY32); // for (Thread32First(snapshot, &entry); Thread32Next(snapshot, &entry);) { // // filter other process's threads // if (entry.th32OwnerProcessID != pid) // co_yield entry.th32ThreadID; // entry.dwSize = sizeof(THREADENTRY32); // } // } GSL_SUPPRESS ( con .4 ) void continue_on_thread_pool :: resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , // PVOID ctx , PTP_WORK work ) { if ( auto coro = coroutine_handle < void >:: from_address ( ctx )) if ( coro . done () == false ) coro . resume (); :: CloseThreadpoolWork ( work ); // one-time work item } auto continue_on_thread_pool :: create_and_submit_work ( coroutine_handle < void > coro ) noexcept -> uint32_t { // just make sure no data loss in `static_cast` static_assert ( sizeof ( uint32_t ) == sizeof ( DWORD )); auto work = :: CreateThreadpoolWork ( resume_on_thread_pool , // coro . address (), nullptr ); if ( work == nullptr ) return GetLastError (); SubmitThreadpoolWork ( work ); return S_OK ; } GSL_SUPPRESS ( type .1 ) void continue_on_apc :: resume_on_apc ( ULONG_PTR param ) { auto ptr = reinterpret_cast < void *> ( param ); if ( auto coro = coroutine_handle < void >:: from_address ( ptr )) coro . resume (); } GSL_SUPPRESS ( type .1 ) auto continue_on_apc :: queue_user_apc ( coroutine_handle < void > coro ) noexcept -> uint32_t { const auto param = reinterpret_cast < ULONG_PTR > ( coro . address ()); if ( QueueUserAPC ( resume_on_apc , this -> thread , param ) == 0 ) return GetLastError (); return S_OK ; } class section final : CRITICAL_SECTION { section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; public : section () noexcept ( false ); ~ section () noexcept ; bool try_lock () noexcept ; void lock () noexcept ( false ); void unlock () noexcept ( false ); }; section :: section () noexcept ( false ) { InitializeCriticalSectionAndSpinCount ( this , 0600 ); } section ::~ section () noexcept { DeleteCriticalSection ( this ); } bool section :: try_lock () noexcept { return TryEnterCriticalSection ( this ); } void section :: lock () noexcept ( false ) { EnterCriticalSection ( this ); } void section :: unlock () noexcept ( false ) { LeaveCriticalSection ( this ); } } // namespace coro","title":"File windows.cpp"},{"location":"windows_8cpp_source/#file-windowscpp","text":"File List > modules > system > windows.cpp Go to the documentation of this file. // clang-format off #include <Windows.h> #include <TlHelp32.h> #include <threadpoolapiset.h> #include <synchapi.h> // Windows Concurrency Runtime's event is not alertible. //#include <concrt.h> // clang-format on #include <coroutine/windows.h> #include <gsl/gsl> #include <cassert> #include <system_error> using namespace std ; using namespace gsl ; namespace coro { static_assert ( is_move_assignable_v < set_or_cancel > == false ); static_assert ( is_move_constructible_v < set_or_cancel > == false ); static_assert ( is_copy_assignable_v < set_or_cancel > == false ); static_assert ( is_copy_constructible_v < set_or_cancel > == false ); GSL_SUPPRESS ( con .4 ) void __stdcall wait_event_on_thread_pool ( PVOID ctx , BOOLEAN timedout ) { UNREFERENCED_PARAMETER ( timedout ); auto coro = coroutine_handle < void >:: from_address ( ctx ); assert ( coro . done () == false ); coro . resume (); } set_or_cancel :: set_or_cancel ( HANDLE target_event ) noexcept ( false ) : hobject { target_event } { // wait object is used as a storage for the event handle // until it is going to suspend } set_or_cancel ::~ set_or_cancel () noexcept { UnregisterWait ( hobject ); } auto set_or_cancel :: unregister () noexcept -> uint32_t { UnregisterWait ( hobject ); const auto ec = GetLastError (); if ( ec == ERROR_IO_PENDING ) { // this is expected since we are using INFINITE timeout return NO_ERROR ; } return ec ; } void set_or_cancel :: suspend ( coroutine_handle < void > coro ) noexcept ( false ) { // since this point, wo becomes a handle for the request // this is one-shot event. so use infinite timeout if ( RegisterWaitForSingleObject ( addressof ( hobject ), hobject , wait_event_on_thread_pool , coro . address (), INFINITE , WT_EXECUTEONLYONCE ) == FALSE ) { throw system_error { gsl :: narrow_cast < int > ( GetLastError ()), system_category (), \"RegisterWaitForSingleObject\" }; } } // auto get_threads_of(DWORD pid) noexcept(false) -> enumerable<DWORD> { // // for current process // auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // if (snapshot == INVALID_HANDLE_VALUE) // co_return; // auto on_return = gsl::finally([=]() noexcept { CloseHandle(snapshot); }); // THREADENTRY32 entry{}; // entry.dwSize = sizeof(THREADENTRY32); // for (Thread32First(snapshot, &entry); Thread32Next(snapshot, &entry);) { // // filter other process's threads // if (entry.th32OwnerProcessID != pid) // co_yield entry.th32ThreadID; // entry.dwSize = sizeof(THREADENTRY32); // } // } GSL_SUPPRESS ( con .4 ) void continue_on_thread_pool :: resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , // PVOID ctx , PTP_WORK work ) { if ( auto coro = coroutine_handle < void >:: from_address ( ctx )) if ( coro . done () == false ) coro . resume (); :: CloseThreadpoolWork ( work ); // one-time work item } auto continue_on_thread_pool :: create_and_submit_work ( coroutine_handle < void > coro ) noexcept -> uint32_t { // just make sure no data loss in `static_cast` static_assert ( sizeof ( uint32_t ) == sizeof ( DWORD )); auto work = :: CreateThreadpoolWork ( resume_on_thread_pool , // coro . address (), nullptr ); if ( work == nullptr ) return GetLastError (); SubmitThreadpoolWork ( work ); return S_OK ; } GSL_SUPPRESS ( type .1 ) void continue_on_apc :: resume_on_apc ( ULONG_PTR param ) { auto ptr = reinterpret_cast < void *> ( param ); if ( auto coro = coroutine_handle < void >:: from_address ( ptr )) coro . resume (); } GSL_SUPPRESS ( type .1 ) auto continue_on_apc :: queue_user_apc ( coroutine_handle < void > coro ) noexcept -> uint32_t { const auto param = reinterpret_cast < ULONG_PTR > ( coro . address ()); if ( QueueUserAPC ( resume_on_apc , this -> thread , param ) == 0 ) return GetLastError (); return S_OK ; } class section final : CRITICAL_SECTION { section ( const section & ) = delete ; section ( section && ) = delete ; section & operator = ( const section & ) = delete ; section & operator = ( section && ) = delete ; public : section () noexcept ( false ); ~ section () noexcept ; bool try_lock () noexcept ; void lock () noexcept ( false ); void unlock () noexcept ( false ); }; section :: section () noexcept ( false ) { InitializeCriticalSectionAndSpinCount ( this , 0600 ); } section ::~ section () noexcept { DeleteCriticalSection ( this ); } bool section :: try_lock () noexcept { return TryEnterCriticalSection ( this ); } void section :: lock () noexcept ( false ) { EnterCriticalSection ( this ); } void section :: unlock () noexcept ( false ) { LeaveCriticalSection ( this ); } } // namespace coro","title":"File windows.cpp"},{"location":"windows_8h/","text":"File windows.h \u00b6 File List > coroutine > windows.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <system_error> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body. Macros \u00b6 Type Name define COROUTINE_SYSTEM_WRAPPER_H Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 Macro Definition Documentation \u00b6 define COROUTINE_SYSTEM_WRAPPER_H \u00b6 #define COROUTINE_SYSTEM_WRAPPER_H The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"File windows.h"},{"location":"windows_8h/#file-windowsh","text":"File List > coroutine > windows.h Go to the source code of this file. More... #include <coroutine/frame.h> #include <system_error>","title":"File windows.h"},{"location":"windows_8h/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"windows_8h/#classes","text":"Type Name class continue_on_apc Move into the designated thread's APC queue and continue the routine. class continue_on_thread_pool Move into the win32 thread pool and continue the routine. class set_or_cancel Awaitable event type over Win32 thread pool Its object can be co_await ed only once. The purpose of such design is to encourage use of short functions rather than containing multiple objects in the function's body.","title":"Classes"},{"location":"windows_8h/#macros","text":"Type Name define COROUTINE_SYSTEM_WRAPPER_H","title":"Macros"},{"location":"windows_8h/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0","title":"Detailed Description"},{"location":"windows_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"windows_8h/#define-coroutine_system_wrapper_h","text":"#define COROUTINE_SYSTEM_WRAPPER_H The documentation for this class was generated from the following file interface/coroutine/windows.h","title":"define COROUTINE_SYSTEM_WRAPPER_H"},{"location":"windows_8h_source/","text":"File windows.h \u00b6 File List > coroutine > windows.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if __has_include(<Windows.h>) #include <Windows.h> #else #error \"expect Windows platform for this file\" #endif #include <coroutine/frame.h> #include <system_error> namespace coro { using namespace std ; using namespace std :: experimental ; class set_or_cancel final { void * hobject ; set_or_cancel ( const set_or_cancel & ) = delete ; set_or_cancel ( set_or_cancel && ) = delete ; set_or_cancel & operator = ( const set_or_cancel & ) = delete ; set_or_cancel & operator = ( set_or_cancel && ) = delete ; public : explicit set_or_cancel ( void * target ) noexcept ( false ); ~ set_or_cancel () noexcept ; private : void suspend ( coroutine_handle < void > ) noexcept ( false ); public : uint32_t unregister () noexcept ; constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return suspend ( coro ); } uint32_t await_resume () noexcept { return unregister (); } }; class continue_on_thread_pool final { static void __stdcall resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); uint32_t create_and_submit_work ( coroutine_handle < void > ) noexcept ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { // nothing to do for this implementation } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = create_and_submit_work ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; class continue_on_apc final { static void __stdcall resume_on_apc ( ULONG_PTR ); uint32_t queue_user_apc ( coroutine_handle < void > ) noexcept ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = queue_user_apc ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"QueueUserAPC\" }; } public : explicit continue_on_apc ( HANDLE hThread ) noexcept : thread { hThread } { } private : HANDLE thread ; }; } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File windows.h"},{"location":"windows_8h_source/#file-windowsh","text":"File List > coroutine > windows.h Go to the documentation of this file. #pragma once #ifndef COROUTINE_SYSTEM_WRAPPER_H #define COROUTINE_SYSTEM_WRAPPER_H #if __has_include(<Windows.h>) #include <Windows.h> #else #error \"expect Windows platform for this file\" #endif #include <coroutine/frame.h> #include <system_error> namespace coro { using namespace std ; using namespace std :: experimental ; class set_or_cancel final { void * hobject ; set_or_cancel ( const set_or_cancel & ) = delete ; set_or_cancel ( set_or_cancel && ) = delete ; set_or_cancel & operator = ( const set_or_cancel & ) = delete ; set_or_cancel & operator = ( set_or_cancel && ) = delete ; public : explicit set_or_cancel ( void * target ) noexcept ( false ); ~ set_or_cancel () noexcept ; private : void suspend ( coroutine_handle < void > ) noexcept ( false ); public : uint32_t unregister () noexcept ; constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { return suspend ( coro ); } uint32_t await_resume () noexcept { return unregister (); } }; class continue_on_thread_pool final { static void __stdcall resume_on_thread_pool ( PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); uint32_t create_and_submit_work ( coroutine_handle < void > ) noexcept ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { // nothing to do for this implementation } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = create_and_submit_work ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; class continue_on_apc final { static void __stdcall resume_on_apc ( ULONG_PTR ); uint32_t queue_user_apc ( coroutine_handle < void > ) noexcept ; public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () noexcept { } void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = queue_user_apc ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"QueueUserAPC\" }; } public : explicit continue_on_apc ( HANDLE hThread ) noexcept : thread { hThread } { } private : HANDLE thread ; }; } // namespace coro #endif // COROUTINE_SYSTEM_WRAPPER_H","title":"File windows.h"},{"location":"yield_8hpp/","text":"File yield.hpp \u00b6 File List > interface > internal > yield.hpp Go to the source code of this file. enumerable is simply a copy of generator in VC++ More... #include <coroutine/return.h> #include <iterator> Namespaces \u00b6 Type Name namespace coro Classes \u00b6 Type Name class enumerable <typename T> class iterator class promise_type Detailed Description \u00b6 Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"File yield.hpp"},{"location":"yield_8hpp/#file-yieldhpp","text":"File List > interface > internal > yield.hpp Go to the source code of this file. enumerable is simply a copy of generator in VC++ More... #include <coroutine/return.h> #include <iterator>","title":"File yield.hpp"},{"location":"yield_8hpp/#namespaces","text":"Type Name namespace coro","title":"Namespaces"},{"location":"yield_8hpp/#classes","text":"Type Name class enumerable <typename T> class iterator class promise_type","title":"Classes"},{"location":"yield_8hpp/#detailed-description","text":"Author: github.com/luncliff ( luncliff@gmail.com ) Copyright: CC BY 4.0 The documentation for this class was generated from the following file interface/internal/yield.hpp","title":"Detailed Description"},{"location":"yield_8hpp_source/","text":"File yield.hpp \u00b6 File List > interface > internal > yield.hpp Go to the documentation of this file. #ifndef COROUTINE_YIELD_HPP #define COROUTINE_YIELD_HPP #include <coroutine/return.h> #include <iterator> namespace coro { using namespace std :: experimental ; // <experimental/generator> from the VC++ template < typename T > class enumerable { public : class promise_type ; class iterator ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; private : coroutine_handle < promise_type > coro {}; public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( enumerable && rhs ) noexcept : coro { rhs . coro } { rhs . coro = nullptr ; } enumerable & operator = ( enumerable && rhs ) noexcept { std :: swap ( coro , rhs . coro ); return * this ; } enumerable () noexcept = default ; enumerable ( promise_type * ptr ) noexcept : coro { coroutine_handle < promise_type >:: from_promise ( * ptr )} { } ~ enumerable () noexcept { // enumerable will destroy the frame. // promise/iterator are free from those ownership if ( coro ) coro . destroy (); } public : iterator begin () noexcept ( false ) { if ( coro ) // resumeable? { coro . resume (); if ( coro . done ()) // finished? return iterator { nullptr }; } return iterator { coro }; } iterator end () noexcept { return iterator { nullptr }; } public : class promise_type final : public promise_aa { friend class iterator ; friend class enumerable ; pointer current = nullptr ; public : promise_type * get_return_object () noexcept { // enumerable will create coroutine handle from the address return this ; } void unhandled_exception () noexcept ( false ) { throw ; } // `co_yield` expression. for reference auto yield_value ( reference ref ) noexcept { current = std :: addressof ( ref ); return suspend_always {}; } // `co_yield` expression. for r-value auto yield_value ( value_type && v ) noexcept { return yield_value ( v ); } // `co_return` expression void return_void () noexcept { // no more access to value current = nullptr ; } }; class iterator final { public : using iterator_category = std :: forward_iterator_tag ; using difference_type = ptrdiff_t ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; public : coroutine_handle < promise_type > coro ; public : // `enumerable::end()` explicit iterator ( std :: nullptr_t ) noexcept : coro { nullptr } { } // `enumerable::begin()` explicit iterator ( coroutine_handle < promise_type > handle ) noexcept : coro { handle } { } public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ) { coro . resume (); if ( coro . done ()) // enumerable will destroy coro = nullptr ; // the frame later... return * this ; } pointer operator -> () noexcept { pointer ptr = coro . promise (). current ; return ptr ; } reference operator * () noexcept { return * ( this -> operator -> ()); } bool operator == ( const iterator & rhs ) const noexcept { return this -> coro == rhs . coro ; } bool operator != ( const iterator & rhs ) const noexcept { return ! ( * this == rhs ); } }; }; } // namespace coro #endif // COROUTINE_YIELD_HPP","title":"File yield.hpp"},{"location":"yield_8hpp_source/#file-yieldhpp","text":"File List > interface > internal > yield.hpp Go to the documentation of this file. #ifndef COROUTINE_YIELD_HPP #define COROUTINE_YIELD_HPP #include <coroutine/return.h> #include <iterator> namespace coro { using namespace std :: experimental ; // <experimental/generator> from the VC++ template < typename T > class enumerable { public : class promise_type ; class iterator ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; private : coroutine_handle < promise_type > coro {}; public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( enumerable && rhs ) noexcept : coro { rhs . coro } { rhs . coro = nullptr ; } enumerable & operator = ( enumerable && rhs ) noexcept { std :: swap ( coro , rhs . coro ); return * this ; } enumerable () noexcept = default ; enumerable ( promise_type * ptr ) noexcept : coro { coroutine_handle < promise_type >:: from_promise ( * ptr )} { } ~ enumerable () noexcept { // enumerable will destroy the frame. // promise/iterator are free from those ownership if ( coro ) coro . destroy (); } public : iterator begin () noexcept ( false ) { if ( coro ) // resumeable? { coro . resume (); if ( coro . done ()) // finished? return iterator { nullptr }; } return iterator { coro }; } iterator end () noexcept { return iterator { nullptr }; } public : class promise_type final : public promise_aa { friend class iterator ; friend class enumerable ; pointer current = nullptr ; public : promise_type * get_return_object () noexcept { // enumerable will create coroutine handle from the address return this ; } void unhandled_exception () noexcept ( false ) { throw ; } // `co_yield` expression. for reference auto yield_value ( reference ref ) noexcept { current = std :: addressof ( ref ); return suspend_always {}; } // `co_yield` expression. for r-value auto yield_value ( value_type && v ) noexcept { return yield_value ( v ); } // `co_return` expression void return_void () noexcept { // no more access to value current = nullptr ; } }; class iterator final { public : using iterator_category = std :: forward_iterator_tag ; using difference_type = ptrdiff_t ; using value_type = T ; using reference = value_type & ; using pointer = value_type * ; public : coroutine_handle < promise_type > coro ; public : // `enumerable::end()` explicit iterator ( std :: nullptr_t ) noexcept : coro { nullptr } { } // `enumerable::begin()` explicit iterator ( coroutine_handle < promise_type > handle ) noexcept : coro { handle } { } public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ) { coro . resume (); if ( coro . done ()) // enumerable will destroy coro = nullptr ; // the frame later... return * this ; } pointer operator -> () noexcept { pointer ptr = coro . promise (). current ; return ptr ; } reference operator * () noexcept { return * ( this -> operator -> ()); } bool operator == ( const iterator & rhs ) const noexcept { return this -> coro == rhs . coro ; } bool operator != ( const iterator & rhs ) const noexcept { return ! ( * this == rhs ); } }; }; } // namespace coro #endif // COROUTINE_YIELD_HPP","title":"File yield.hpp"}]}